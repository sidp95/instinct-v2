import { D as getCore, h as getSessionKeys, v as assertDefined } from "./constants-hy8OYHwt.esm.js";
import { i as bufferToHex, r as consumeMfaToken, t as isMfaRequiredForAction } from "./isMfaRequiredForAction-BgevGq0s.esm.js";

//#region src/modules/mfa/consumeMfaTokenIfRequiredForAction/consumeMfaTokenIfRequiredForAction.ts
const consumeMfaTokenIfRequiredForAction = async ({ mfaAction }, client) => {
	if (!await isMfaRequiredForAction({ mfaAction }, client)) return;
	return consumeMfaToken(client);
};

//#endregion
//#region src/utils/p256Sign/p256Sign.ts
const p256Sign = async ({ privateKeyJwk, message }) => {
	const privateKey = await crypto.subtle.importKey("jwk", privateKeyJwk, {
		name: "ECDSA",
		namedCurve: "P-256"
	}, false, ["sign"]);
	return bufferToHex(await crypto.subtle.sign({
		hash: "SHA-256",
		name: "ECDSA"
	}, privateKey, new TextEncoder().encode(message)));
};

//#endregion
//#region src/modules/sessionKeys/generateSessionSignature/generateSessionSignature.ts
const generateSessionSignature = async ({ sessionId }, client) => {
	const sessionKeys = getSessionKeys(client);
	assertDefined(sessionKeys, "Session keys not found");
	const { privateKeyJwk } = sessionKeys;
	return { signature: await p256Sign({
		message: sessionId,
		privateKeyJwk
	}) };
};

//#endregion
//#region src/modules/sessionKeys/getSignedSessionId/getSignedSessionId.ts
const getSignedSessionId = async (client) => {
	const sessionId = getCore(client).state.get().user?.sessionId;
	assertDefined(sessionId, "Session ID is required");
	const { signature } = await generateSessionSignature({ sessionId }, client);
	assertDefined(signature, "Signed session ID is required");
	return { signature };
};

//#endregion
export { consumeMfaTokenIfRequiredForAction as n, getSignedSessionId as t };
//# sourceMappingURL=getSignedSessionId-BhFfSHeA.esm.js.map