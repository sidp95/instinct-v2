import { AuthStorageEnum, Configuration, SDKApi } from "@dynamic-labs/sdk-api-core";
import { Buffer as Buffer$1 } from "buffer";

//#region package.json
var name = "@dynamic-labs-sdk/client";
var version = "0.4.0";
var dependencies = {
	"@dynamic-labs-sdk/assert-package-version": "workspace:*",
	"@dynamic-labs-wallet/browser-wallet-client": "0.0.250",
	"@dynamic-labs/sdk-api-core": "0.0.860",
	"@simplewebauthn/browser": "13.1.0",
	"buffer": "6.0.3",
	"eventemitter3": "5.0.1",
	"zod": "4.0.5"
};

//#endregion
//#region src/client/core/getCore/getCore.ts
const getCore = (client) => {
	return client.__core;
};

//#endregion
//#region src/errors/base/BaseError.ts
const getDetails = ({ details, cause }) => {
	if (cause instanceof BaseError) return cause.details;
	if (cause?.message) return cause.message;
	return details;
};
/**
* Formats the error message with all available information
*/
const formatMessage = ({ shortMessage, details, docsUrl, metaMessages }) => {
	return [
		shortMessage,
		"",
		...metaMessages ? [...metaMessages, ""] : [],
		...docsUrl ? [`Docs: ${docsUrl}`] : [],
		...details ? [`Details: ${details}`] : [],
		`Version: ${version}`,
		`Timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}`
	].join("\n");
};
/**
* Base error class that provides structured error handling with detailed information
*/
var BaseError = class BaseError extends Error {
	/** The error unique code */
	code;
	details;
	formattedMessage;
	name = "BaseError";
	cause;
	constructor(args) {
		const details = getDetails(args);
		const formattedMessage = formatMessage({
			...args,
			details
		});
		super(args.shortMessage ?? formattedMessage, args.cause ? { cause: args.cause } : void 0);
		this.formattedMessage = formattedMessage;
		this.details = details;
		this.name = args.name ?? this.name;
		this.cause = args.cause ?? this.cause;
		this.code = args.code;
	}
	/**
	* Walks the cause chain of the error and returns the root error
	*/
	walk() {
		const cause = this.cause;
		if (cause instanceof BaseError) return cause.walk();
		return cause;
	}
	toString() {
		return this.formattedMessage;
	}
};

//#endregion
//#region src/errors/ClientNotFoundError.ts
var ClientNotFoundError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "client_not_found_error",
			docsUrl: null,
			name: "ClientNotFoundError",
			shortMessage: "No Dynamic client has been created yet. Make sure you have called createDynamicClient() first."
		});
	}
};

//#endregion
//#region src/client/defaultClient/defaultClient.ts
let defaultClient = null;
let numOfInitializedClients = 0;
/**
* Returns the DynamicClient instance that was initialized with createDynamicClient.
*
* If more than one instance of DynamicClient was initialized, you should not use this function.
* Instead, you should pass the client instance you stored to the function that needs it.
*/
const getDefaultClient = () => {
	if (!defaultClient) throw new ClientNotFoundError();
	if (numOfInitializedClients > 1) getCore(defaultClient).logger.debug("Multiple instances of DynamicClient found. If you are only using one client (recommended), make sure you are not calling \"createDynamicClient\" multiple times. If you are using multiple clients, make sure you are passing which client to use as the last param of all Dynamic functions.");
	return defaultClient;
};
const setDefaultClient = (client) => {
	defaultClient = client;
	numOfInitializedClients++;
};

//#endregion
//#region src/modules/apiClient/constants.ts
const DYNAMIC_API_VERSION_HEADER = "x-dyn-api-version";
const DYNAMIC_REQUEST_ID_HEADER = "x-dyn-request-id";
const DYNAMIC_SDK_VERSION_HEADER = "x-dyn-version";
const MFA_TOKEN_HEADER = "x-mfa-auth-token";
const SESSION_PUBLIC_KEY_HEADER = "x-dyn-session-public-key";
const DYNAMIC_SDK_API_VERSION = dependencies["@dynamic-labs/sdk-api-core"];
const CLIENT_SDK_NAME = "ClientSDK";

//#endregion
//#region src/utils/randomString/randomString.ts
const randomString = (length) => {
	const CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	let result = "";
	for (let i = length; i > 0; --i) result += CHARS[Math.floor(Math.random() * 64)];
	return result;
};

//#endregion
//#region src/errors/ValueMustBeDefinedError.ts
var ValueMustBeDefinedError = class extends BaseError {
	constructor(message) {
		super({
			cause: null,
			code: "value_must_be_defined_error",
			docsUrl: null,
			name: "ValueMustBeDefined",
			shortMessage: message
		});
	}
};

//#endregion
//#region src/utils/assertDefined/assertDefined.ts
/**
* Asserts that a value is not null or undefined, throwing an error if it is.
* This function acts as a type guard, narrowing the type to exclude null and undefined.
*
* @template T - The type of the value being checked
* @param value - The value to check for null or undefined
* @param message - The error message to throw if the value is null or undefined
* @throws Throws an error with the provided message if value is null or undefined
* @example
* ```typescript
* const maybeString: string | null = getValue();
* assertDefined(maybeString, 'String value is required');
* // maybeString is now typed as string (null is excluded)
* ```
*/
function assertDefined(value, message) {
	if (value === null || value === void 0) throw new ValueMustBeDefinedError(message);
}

//#endregion
//#region src/modules/projectSettings/isCookieEnabled/isCookieEnabled.ts
/**
* Returns true if the client is using Dynamic cookies or a BYO JWT cookie.
*/
const isCookieEnabled = (client) => {
	assertDefined(client.projectSettings, "Project settings are not defined");
	const securitySettings = client.projectSettings.security;
	if (!securitySettings) return false;
	const dynamicCookiesEnabled = (securitySettings.auth?.storage || []).includes(AuthStorageEnum.Cookie);
	const byoJwtCookieEnabled = Boolean(securitySettings.externalAuth?.cookieName);
	return dynamicCookiesEnabled || byoJwtCookieEnabled;
};

//#endregion
//#region src/utils/getBuffer/getBuffer.ts
const getBuffer = () => typeof Buffer !== "undefined" ? Buffer : Buffer$1;

//#endregion
//#region src/modules/sessionKeys/getSessionKeys/getSessionKeys.ts
const getSessionKeys = (client) => {
	const core = getCore(client);
	const encodedKeys = core.state.get().sessionKeys;
	if (!encodedKeys) return;
	try {
		return JSON.parse(getBuffer().from(encodedKeys, "base64").toString());
	} catch (error) {
		core.logger.error("Error decoding session keys", error);
		return;
	}
};

//#endregion
//#region src/errors/APIError/APIError.ts
var APIError = class APIError extends BaseError {
	status;
	constructor(message, code, status) {
		super({
			cause: null,
			code,
			docsUrl: null,
			name: "APIError",
			shortMessage: message
		});
		this.status = status;
	}
	static async fromResponse(response) {
		try {
			const errorBody = await response.clone().json();
			if (errorBody && "error" in errorBody && typeof errorBody.error === "string") {
				const errorCode = "code" in errorBody && typeof errorBody.code === "string" ? errorBody.code : "unknown_error";
				return new APIError(errorBody.error, errorCode, response.status);
			}
			return null;
		} catch {
			return null;
		}
	}
};

//#endregion
//#region src/errors/InvalidExternalAuthError.ts
var InvalidExternalAuthError = class extends BaseError {
	constructor({ cause }) {
		super({
			cause,
			code: "invalid_external_auth_error",
			docsUrl: "https://www.dynamic.xyz/docs/external-auth/third-party-auth-overview",
			name: "InvalidExternalAuthError",
			shortMessage: "Error authenticating with external JWT"
		});
	}
};

//#endregion
//#region src/errors/LinkCredentialError.ts
var LinkCredentialError = class extends BaseError {
	constructor({ cause }) {
		super({
			cause,
			code: "link_credential_error",
			docsUrl: null,
			name: "LinkCredentialError",
			shortMessage: "The credential you are trying to link is associated with another account and cannot be reassigned."
		});
	}
};

//#endregion
//#region src/errors/MfaInvalidOtpError.ts
var MfaInvalidOtpError = class extends BaseError {
	constructor({ cause }) {
		super({
			cause,
			code: "mfa_invalid_otp_error",
			docsUrl: null,
			name: "MfaInvalidOtpError",
			shortMessage: "Invalid OTP"
		});
	}
};

//#endregion
//#region src/errors/MfaRateLimitedError.ts
var MfaRateLimitedError = class extends BaseError {
	constructor({ cause }) {
		super({
			cause,
			code: "mfa_rate_limited_error",
			docsUrl: null,
			name: "MfaRateLimitedError",
			shortMessage: "Rate limited"
		});
	}
};

//#endregion
//#region src/errors/SandboxMaximumThresholdReachedError.ts
var SandboxMaximumThresholdReachedError = class extends BaseError {
	constructor({ cause }) {
		super({
			cause,
			code: "sandbox_maximum_threshold_reached_error",
			docsUrl: "https://www.dynamic.xyz/docs/developer-dashboard/sandbox-vs-live#sandbox-vs-live",
			name: "SandboxMaximumThresholdReachedError",
			shortMessage: "Your sandbox environment has reached the maximum MAU. Please use a live environment for production traffic."
		});
	}
};

//#endregion
//#region src/modules/apiClient/utils/clientErrorMapper/clientErrorMapper.ts
/**
* Default error mapper for the client that handles common API error codes.
*
* This mapper transforms specific API error codes into more specific error types:
* - `mfa_invalid_code` → `MfaInvalidOtpError`
* - `mfa_rate_limited` → `MfaRateLimitedError`
*
* @param error - The error to be mapped
* @returns A transformed error if the error code matches a known pattern, or null if no transformation is needed
*
* @example
* ```typescript
* // This will be automatically applied to all API errors
* const apiClient = createApiClient({}, client);
*
* // The clientErrorMapper will automatically convert mfa_invalid_code errors
* // to MfaInvalidOtpError instances
* ```
*/
const clientErrorMapper = (error) => {
	if (error instanceof APIError) {
		if (error.code === "mfa_invalid_code") return new MfaInvalidOtpError({ cause: error });
		if (error.code === "mfa_rate_limited") return new MfaRateLimitedError({ cause: error });
		if (error.code === "invalid_external_auth") return new InvalidExternalAuthError({ cause: error });
		if (error.code === "sandbox_maximum_threshold_reached") return new SandboxMaximumThresholdReachedError({ cause: error });
		if (error.code === "merge_accounts_invalid" || error.code === "reassign_wallet_error") return new LinkCredentialError({ cause: error });
	}
	return null;
};

//#endregion
//#region src/modules/apiClient/utils/convertToApiErrorMiddleware/convertToApiErrorMiddleware.ts
/**
* Creates middleware that converts HTTP error responses to APIError instances
* and optionally applies custom error mappers to transform them into specific error types.
*
* @param options.errorMappers - Array of error mappers to apply to API errors
* @returns A middleware function that handles error conversion and mapping
*/
const createConvertToApiErrorMiddleware = ({ errorMappers = [] }) => ({ post: async (context) => {
	if (context.response.status >= 400) {
		const apiError = await APIError.fromResponse(context.response);
		if (apiError) {
			let errorToThrow = apiError;
			for (const mapper of errorMappers) {
				const newError = mapper(apiError);
				if (newError) {
					errorToThrow = newError;
					break;
				}
			}
			throw errorToThrow;
		}
	}
	return context.response;
} });

//#endregion
//#region src/modules/apiClient/createApiClient.ts
/**
* Returns a new instance of the SDK API client.
*
* This is not meant for storing, as it is very light we can create it whenever needed.
*/
const createApiClient = (options = {}, client) => {
	const core = getCore(client);
	const coreState = core.state.get();
	const settings = {
		basePath: core.apiBaseUrl,
		headers: {
			"Content-Type": "application/json",
			[DYNAMIC_API_VERSION_HEADER]: `API/${DYNAMIC_SDK_API_VERSION}`,
			[DYNAMIC_REQUEST_ID_HEADER]: randomString(50),
			[DYNAMIC_SDK_VERSION_HEADER]: `${CLIENT_SDK_NAME}/${version}`,
			...core.getApiHeaders(),
			...options.headers
		}
	};
	if (client.token) settings.headers.Authorization = `Bearer ${client.token}`;
	if (client.projectSettings && isCookieEnabled(client)) settings.credentials = "include";
	if (options.includeMfaToken && coreState.mfaToken) settings.headers[MFA_TOKEN_HEADER] = coreState.mfaToken;
	const sessionPublicKey = getSessionKeys(client)?.publicKey;
	const isSessionPublicKeyHeaderPresent = settings.headers[SESSION_PUBLIC_KEY_HEADER] !== void 0;
	if (sessionPublicKey && !isSessionPublicKeyHeaderPresent) settings.headers[SESSION_PUBLIC_KEY_HEADER] = sessionPublicKey;
	return new SDKApi(new Configuration({
		...settings,
		fetchApi: core.fetch,
		middleware: [createConvertToApiErrorMiddleware({ errorMappers: [...options.errorMappers || [], clientErrorMapper] })]
	}));
};

//#endregion
//#region src/modules/wallets/constants.ts
const CHAINS_INFO_MAP = {
	ALGO: {
		apiChainName: "algo",
		blockchainName: "Algorand",
		verifiedCredentialChainName: "algorand"
	},
	APTOS: {
		apiChainName: "aptos",
		blockchainName: "Aptos",
		verifiedCredentialChainName: "aptos"
	},
	BTC: {
		apiChainName: "bitcoin",
		blockchainName: "Bitcoin",
		verifiedCredentialChainName: "bip122"
	},
	COSMOS: {
		apiChainName: "cosmos",
		blockchainName: "Cosmos",
		verifiedCredentialChainName: "cosmos"
	},
	ECLIPSE: {
		apiChainName: "eclipse",
		blockchainName: "Eclipse",
		verifiedCredentialChainName: "eclipse"
	},
	EVM: {
		apiChainName: "evm",
		blockchainName: "Ethereum",
		verifiedCredentialChainName: "eip155"
	},
	FLOW: {
		apiChainName: "flow",
		blockchainName: "Flow",
		verifiedCredentialChainName: "flow"
	},
	SOL: {
		apiChainName: "solana",
		blockchainName: "Solana",
		verifiedCredentialChainName: "solana",
		waasChainNameOverride: "SVM"
	},
	SPARK: {
		apiChainName: "spark",
		blockchainName: "Spark",
		verifiedCredentialChainName: "spark"
	},
	STARK: {
		apiChainName: "starknet",
		blockchainName: "Starknet",
		verifiedCredentialChainName: "starknet"
	},
	STELLAR: {
		apiChainName: "stellar",
		blockchainName: "Stellar",
		verifiedCredentialChainName: "stellar"
	},
	SUI: {
		apiChainName: "sui",
		blockchainName: "Sui",
		verifiedCredentialChainName: "sui"
	},
	TON: {
		apiChainName: "ton",
		blockchainName: "TON",
		verifiedCredentialChainName: "ton"
	},
	TRON: {
		apiChainName: "tron",
		blockchainName: "Tron",
		verifiedCredentialChainName: "tron"
	}
};

//#endregion
//#region src/utils/getChainFromVerifiedCredentialChain/getChainFromVerifiedCredentialChain.ts
const getChainFromVerifiedCredentialChain = (verifiedCredentialChain) => {
	const chain = Object.keys(CHAINS_INFO_MAP).find((chain$1) => CHAINS_INFO_MAP[chain$1].verifiedCredentialChainName === verifiedCredentialChain);
	assertDefined(chain, `Unknown chain: ${verifiedCredentialChain}`);
	return chain;
};

//#endregion
//#region src/constants.ts
const SDK_API_CORE_VERSION = dependencies["@dynamic-labs/sdk-api-core"];
const DYNAMIC_ICONIC_SPRITE_URL = "https://iconic.dynamic-static-assets.com/icons/sprite.svg";

//#endregion
//#region src/modules/waas/constants.ts
const DEFAULT_WAAS_BASE_API_URL = "https://app.dynamicauth.com";
const DEFAULT_WAAS_BASE_MPC_RELAY_API_URL = "https://relay.dynamicauth.com";
const DYNAMIC_WAAS_METADATA = {
	displayName: "Dynamic WaaS",
	icon: `${DYNAMIC_ICONIC_SPRITE_URL}#dynamicwaas`,
	normalizedWalletName: "dynamicwaas"
};

//#endregion
export { getDefaultClient as C, getCore as D, BaseError as E, name as O, DYNAMIC_SDK_API_VERSION as S, ClientNotFoundError as T, isCookieEnabled as _, SDK_API_CORE_VERSION as a, randomString as b, createApiClient as c, MfaInvalidOtpError as d, LinkCredentialError as f, getBuffer as g, getSessionKeys as h, DYNAMIC_ICONIC_SPRITE_URL as i, version as k, SandboxMaximumThresholdReachedError as l, APIError as m, DEFAULT_WAAS_BASE_MPC_RELAY_API_URL as n, getChainFromVerifiedCredentialChain as o, InvalidExternalAuthError as p, DYNAMIC_WAAS_METADATA as r, CHAINS_INFO_MAP as s, DEFAULT_WAAS_BASE_API_URL as t, MfaRateLimitedError as u, assertDefined as v, setDefaultClient as w, CLIENT_SDK_NAME as x, ValueMustBeDefinedError as y };
//# sourceMappingURL=constants-hy8OYHwt.esm.js.map