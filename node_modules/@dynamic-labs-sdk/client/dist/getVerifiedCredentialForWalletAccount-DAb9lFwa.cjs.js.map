{"version":3,"file":"getVerifiedCredentialForWalletAccount-DAb9lFwa.cjs.js","names":["getDefaultClient","getCore","BaseError","WalletProviderEnum","getCore","getChainFromVerifiedCredentialChain","getChainFromVerifiedCredentialChain","walletAccountsMap: Map<string, WalletAccount>","JwtVerifiedCredentialFormatEnum","getDefaultClient","getCore","BaseError","getCore","getCore","DYNAMIC_WAAS_METADATA","DYNAMIC_WAAS_METADATA","WalletProviderEnum","DYNAMIC_WAAS_METADATA","getCore","newState: Partial<DynamicCoreState>","isCookieEnabled","walletProvider"],"sources":["../src/utils/setCookie/setCookie.ts","../src/modules/clientEvents/clientEvents.ts","../src/errors/InvalidWalletProviderKeyError.ts","../src/modules/wallets/walletProvider/splitWalletProviderKey/splitWalletProviderKey.ts","../src/modules/wallets/utils/normalizeAddress/normalizeAddress.ts","../src/modules/wallets/utils/formatWalletAccountId/formatWalletAccountId.ts","../src/modules/wallets/utils/convertUnverifiedWalletAccountToWalletAccount/convertUnverifiedWalletAccountToWalletAccount.ts","../src/modules/wallets/utils/normalizeWalletNameWithChain/normalizeWalletNameWithChain.ts","../src/modules/wallets/utils/formatWalletProviderKey/formatWalletProviderKey.ts","../src/modules/wallets/walletProvider/walletProviderKeyMap/getWalletProviderKeyFromVerifiedCredential/getWalletProviderKeyFromVerifiedCredential.ts","../src/modules/wallets/utils/convertVerifiedCredentialToWalletAccount/convertVerifiedCredentialToWalletAccount.ts","../src/modules/wallets/getWalletAccounts/getWalletAccountsFromState/getWalletAccountsFromState.ts","../src/modules/wallets/getWalletAccounts/getWalletAccounts.ts","../src/errors/NoWalletProviderFoundError.ts","../src/services/runtimeServices/createRuntimeServiceAccessKey/createRuntimeServiceAccessKey.ts","../src/modules/wallets/walletProviderRegistry/createWalletProviderRegistry/createWalletProviderRegistry.ts","../src/modules/wallets/walletProviderRegistry/getWalletProviderRegistry/getWalletProviderRegistry.ts","../src/modules/wallets/walletProviderRegistry/walletProviderRegistry.types.ts","../src/modules/wallets/utils/getWalletProviderFromWalletAccount/getWalletProviderFromWalletAccount.ts","../src/modules/auth/consts.ts","../src/modules/wallets/emitWalletAccountsChangedEvent/emitWalletAccountsChangedEvent.ts","../src/modules/auth/updateAuthFromVerifyResponse/checkAndRaiseWalletAccountsChangedEvent/checkAndRaiseWalletAccountsChangedEvent.ts","../src/modules/wallets/getWalletProviders/getWalletProviders.ts","../src/modules/waas/isWaasWalletProvider/isWaasWalletProvider.ts","../src/modules/waas/findWaasWalletProviderByChain/findWaasWalletProviderByChain.ts","../src/modules/waas/isWaasWalletAccount/isWaasWalletAccount.ts","../src/modules/waas/restoreUserSharesForAllWalletAccounts/restoreUserSharesForAllWalletAccounts.ts","../src/modules/auth/updateAuthFromVerifyResponse/updateAuthFromVerifyResponse.ts","../src/modules/wallets/getWalletProviderByKey/getWalletProviderByKey.ts","../src/modules/wallets/utils/getVerifiedCredentialForWalletAccount/getVerifiedCredentialForWalletAccount.ts"],"sourcesContent":["/**\n * Sefelly sets the cookie in the browser.\n */\nexport const setCookie = (cookie: string) => {\n  // eslint-disable-next-line no-restricted-globals\n  document.cookie = cookie;\n};\n","import { getCore } from '../../client/core/getCore';\nimport { getDefaultClient } from '../../client/defaultClient';\nimport type { DynamicClient } from '../../client/types';\nimport type {\n  DynamicEvents,\n  EmitEventParams,\n  OffEventParams,\n  OnEventParams,\n  OnceEventParams,\n} from './clientEvents.types';\n\n/**\n * Adds an event listener for Dynamic client events.\n *\n * This function allows you to listen for various events emitted by the Dynamic client,\n * such as authentication state changes, wallet connections, and more.\n *\n * @param params.event - The event name to listen for.\n * @param params.listener - The callback function to execute when the event is fired.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A function that can be called to remove the listener.\n */\nexport const onEvent = <E extends keyof DynamicEvents>(\n  { event, listener }: OnEventParams<E>,\n  client = getDefaultClient()\n) => {\n  const { eventEmitter } = getCore(client);\n\n  eventEmitter.on(event, listener);\n\n  return () => {\n    eventEmitter.off(event, listener);\n  };\n};\n\n/**\n * Removes an event listener from Dynamic client events.\n *\n * This function unsubscribes a previously registered event listener\n * from the specified Dynamic client event.\n *\n * @param params.event - The event name to remove the listener from.\n * @param params.listener - The callback function to remove.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n */\nexport const offEvent = <E extends keyof DynamicEvents>(\n  { event, listener }: OffEventParams<E>,\n  client = getDefaultClient()\n) => {\n  const { eventEmitter } = getCore(client);\n\n  eventEmitter.off(event, listener);\n};\n\n/**\n * Adds a one-time event listener for Dynamic client events.\n *\n * This function listens for an event that will automatically remove itself\n * after being triggered once.\n *\n * @param params.event - The event name to listen for.\n * @param params.listener - The callback function to execute when the event is fired.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A function that can be called to remove the listener before it fires.\n */\nexport const onceEvent = <E extends keyof DynamicEvents>(\n  { event, listener }: OnceEventParams<E>,\n  client = getDefaultClient()\n) => {\n  const { eventEmitter } = getCore(client);\n\n  eventEmitter.once(event, listener);\n\n  return () => {\n    eventEmitter.off(event, listener);\n  };\n};\n\n/**\n * Emits a Dynamic client event.\n *\n * This function triggers an event that will be received by all registered\n * listeners for the specified event type.\n *\n * @param params.event - The event name to emit.\n * @param params.args - The arguments to pass to event listeners.\n * @param client - The Dynamic client instance.\n */\nexport const emitEvent = <E extends keyof DynamicEvents>(\n  { event, args }: EmitEventParams<E>,\n  client: DynamicClient\n) => {\n  const { eventEmitter } = getCore(client);\n\n  eventEmitter.emit(event, args);\n};\n","import { BaseError } from './base';\n\nexport class InvalidWalletProviderKeyError extends BaseError {\n  constructor(value: string) {\n    super({\n      cause: null,\n      code: 'invalid_wallet_provider_key',\n      docsUrl: null,\n      name: 'InvalidWalletProviderKeyError',\n      shortMessage: `Invalid wallet provider key: ${value}. Key must be in the format of <normalizedWalletNameWithChain>:<walletProviderType>[:<suffix>]`,\n    });\n  }\n}\n","import { WalletProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { InvalidWalletProviderKeyError } from '../../../../errors/InvalidWalletProviderKeyError';\n\ntype SplitWalletProviderKeyResult = {\n  normalizedWalletNameWithChain: string;\n  suffix: string | undefined;\n  walletProviderType: WalletProviderEnum;\n};\n\nexport const splitWalletProviderKey = (\n  walletProviderKey: string\n): SplitWalletProviderKeyResult => {\n  const [normalizedWalletNameWithChain, walletProviderType, suffix, ...rest] =\n    walletProviderKey.split(':');\n\n  if (\n    !normalizedWalletNameWithChain ||\n    !Object.values(WalletProviderEnum).includes(\n      walletProviderType as WalletProviderEnum\n    ) ||\n    rest.length > 0\n  ) {\n    throw new InvalidWalletProviderKeyError(walletProviderKey);\n  }\n\n  return {\n    normalizedWalletNameWithChain,\n    suffix,\n    walletProviderType: walletProviderType as WalletProviderEnum,\n  };\n};\n","import type { Chain } from '../../../chain';\n\nexport const normalizeAddress = (address: string, chain: Chain) => {\n  let normalizedAddress = address;\n\n  if (normalizedAddress?.startsWith('0x')) {\n    normalizedAddress = normalizedAddress.slice(2);\n  }\n\n  /**\n   * These are standard from CAIP-2: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md\n   * see also: https://github.com/ChainAgnostic/namespaces\n   * note: no standard namespace currently exists for flow\n   */\n  const chainsThatRequireLowercaseAddress: Chain[] = ['EVM', 'FLOW'];\n\n  normalizedAddress = chainsThatRequireLowercaseAddress.includes(chain)\n    ? normalizedAddress?.toLowerCase()\n    : normalizedAddress;\n\n  return normalizedAddress;\n};\n","import type { Chain } from '../../../chain';\nimport { splitWalletProviderKey } from '../../walletProvider/splitWalletProviderKey';\nimport { normalizeAddress } from '../normalizeAddress';\n\ntype CreateWalletAccountIdParams = {\n  address: string;\n  chain: Chain;\n  walletProviderKey: string;\n};\n\nexport const formatWalletAccountId = ({\n  address,\n  chain,\n  walletProviderKey,\n}: CreateWalletAccountIdParams): string => {\n  const { normalizedWalletNameWithChain } =\n    splitWalletProviderKey(walletProviderKey);\n\n  const normalizedAddress = normalizeAddress(address, chain);\n\n  return `${normalizedWalletNameWithChain}:${normalizedAddress}`;\n};\n","import type { UnverifiedWalletAccount } from '../../unverifiedWalletAccounts';\nimport type { WalletAccount } from '../../walletAccount';\nimport { formatWalletAccountId } from '../formatWalletAccountId';\n\ntype ConvertUnverifiedWalletAccountToWalletAccountParams = {\n  unverifiedWalletAccount: UnverifiedWalletAccount;\n};\n\nexport const convertUnverifiedWalletAccountToWalletAccount = ({\n  unverifiedWalletAccount,\n}: ConvertUnverifiedWalletAccountToWalletAccountParams): WalletAccount => ({\n  address: unverifiedWalletAccount.address,\n  addressesWithTypes: unverifiedWalletAccount.addressesWithTypes,\n  chain: unverifiedWalletAccount.chain,\n  id: formatWalletAccountId({\n    address: unverifiedWalletAccount.address,\n    chain: unverifiedWalletAccount.chain,\n    walletProviderKey: unverifiedWalletAccount.walletProviderKey,\n  }),\n  lastSelectedAt: unverifiedWalletAccount.lastSelectedAt,\n  verifiedCredentialId: null,\n  walletProviderKey: unverifiedWalletAccount.walletProviderKey,\n});\n","import type { Chain } from '../../../chain';\n\ntype NormalizeWalletNameWithChainParams = {\n  chain: Chain;\n  displayName: string;\n};\n\n/**\n * Format the raw wallet name and chain to get the value we can use for\n * verified credentials' `walletName` field.\n */\nexport const normalizeWalletNameWithChain = ({\n  displayName,\n  chain,\n}: NormalizeWalletNameWithChainParams): string => {\n  const sanitizedWalletName = displayName\n    .replace(/[^a-zA-Z0-9]/g, '')\n    .toLowerCase();\n\n  const chainLowered = chain.toLocaleLowerCase();\n\n  if (sanitizedWalletName.endsWith(chainLowered)) {\n    return sanitizedWalletName;\n  }\n\n  return `${sanitizedWalletName}${chainLowered}`;\n};\n","import type { WalletProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport type { Chain } from '../../../chain';\nimport { normalizeWalletNameWithChain } from '../normalizeWalletNameWithChain';\n\ntype FormatWalletProviderKeyParams = {\n  chain: Chain;\n  displayName: string;\n  suffix?: string;\n  walletProviderType: WalletProviderEnum;\n};\n\n/**\n * Assembles the wallet provider key from the wallet name, chain, and wallet provider type.\n *\n * The suffix is optional and can be used to add a uniquely identifying string to the key, which\n * might be necessary for some wallet providers (like Wallet Connect).\n *\n * IMPORTANT: Do NOT add a suffix unless absolutely necessary, as it will cause the wallet account\n * to not be able to find its wallet provider when connecting to a new device (it won't be possible\n * to determine the full key just from the Verified Credential data).\n */\nexport const formatWalletProviderKey = ({\n  suffix,\n  chain,\n  displayName,\n  walletProviderType,\n}: FormatWalletProviderKeyParams) => {\n  const normalizedNameWithChain = normalizeWalletNameWithChain({\n    chain,\n    displayName,\n  });\n\n  return `${normalizedNameWithChain}:${walletProviderType}${\n    suffix ? `:${suffix}` : ''\n  }`;\n};\n","import type { JwtVerifiedCredential } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../../client/types';\nimport { assertDefined } from '../../../../../utils/assertDefined';\nimport { getChainFromVerifiedCredentialChain } from '../../../../../utils/getChainFromVerifiedCredentialChain';\nimport { formatWalletProviderKey } from '../../../utils/formatWalletProviderKey';\n\ntype GetWalletProviderKeyFromVerifiedCredentialParams = {\n  verifiedCredential: JwtVerifiedCredential;\n};\n\nexport const getWalletProviderKeyFromVerifiedCredential = (\n  { verifiedCredential }: GetWalletProviderKeyFromVerifiedCredentialParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  const { walletProviderKeyMap } = core.state.get();\n\n  const storedWalletProviderKey = walletProviderKeyMap[verifiedCredential.id];\n\n  if (storedWalletProviderKey) {\n    return { walletProviderKey: storedWalletProviderKey };\n  }\n\n  /**\n   * We fallback to comprising the wallet provider key from walletName and walletProvider.\n   *\n   * Some wallet provider types (like Wallet Connect) also use a special suffix for their wallet provider\n   * keys, so this won't be enough for them.\n   * Therefore, for those specific wallet providers, the wallet account will remain without a wallet provider\n   * and will require reconnection.\n   * Read walletProvider.types.ts for more info.\n   */\n  assertDefined(\n    verifiedCredential.walletName,\n    `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletName`\n  );\n\n  assertDefined(\n    verifiedCredential.walletProvider,\n    `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletProvider`\n  );\n\n  assertDefined(\n    verifiedCredential.chain,\n    `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing chain`\n  );\n\n  /**\n   * Historically, walletNames did not include the chain name as a suffix.\n   * This piece of logic simply ensures we normalize any legacy walletNames to conform.\n   */\n  const chain = getChainFromVerifiedCredentialChain(verifiedCredential.chain);\n\n  const walletProviderKey = formatWalletProviderKey({\n    chain,\n    displayName: verifiedCredential.walletName,\n    walletProviderType: verifiedCredential.walletProvider,\n  });\n\n  return { walletProviderKey };\n};\n","import type { JwtVerifiedCredential } from '@dynamic-labs/sdk-api-core';\n\nimport type { DynamicClient } from '../../../../client/types';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport { getChainFromVerifiedCredentialChain } from '../../../../utils/getChainFromVerifiedCredentialChain';\nimport type { WalletAccount } from '../../walletAccount';\nimport { getWalletProviderKeyFromVerifiedCredential } from '../../walletProvider/walletProviderKeyMap/getWalletProviderKeyFromVerifiedCredential';\nimport { formatWalletAccountId } from '../formatWalletAccountId';\n\ntype ConvertVerifiedCredentialToWalletAccountParams = {\n  verifiedCredential: JwtVerifiedCredential;\n};\n\nexport const convertVerifiedCredentialToWalletAccount = (\n  { verifiedCredential }: ConvertVerifiedCredentialToWalletAccountParams,\n  client: DynamicClient\n): WalletAccount => {\n  assertDefined(\n    verifiedCredential.address,\n    'Missing address in verified credential'\n  );\n  assertDefined(\n    verifiedCredential.chain,\n    'Missing chain in verified credential'\n  );\n\n  const chain = getChainFromVerifiedCredentialChain(verifiedCredential.chain);\n\n  const { walletProviderKey } = getWalletProviderKeyFromVerifiedCredential(\n    {\n      verifiedCredential,\n    },\n    client\n  );\n\n  const walletAccountId = formatWalletAccountId({\n    address: verifiedCredential.address,\n    chain,\n    walletProviderKey,\n  });\n\n  return {\n    address: verifiedCredential.address,\n    addressesWithTypes: verifiedCredential.walletAdditionalAddresses,\n    chain,\n    id: walletAccountId,\n    lastSelectedAt: verifiedCredential.lastSelectedAt ?? null,\n    verifiedCredentialId: verifiedCredential.id,\n    walletProviderKey,\n  };\n};\n","import type { SdkUser } from '@dynamic-labs/sdk-api-core';\nimport { JwtVerifiedCredentialFormatEnum } from '@dynamic-labs/sdk-api-core';\n\nimport type { DynamicClient } from '../../../../client/types';\nimport type { UnverifiedWalletAccount } from '../../unverifiedWalletAccounts';\nimport { convertUnverifiedWalletAccountToWalletAccount } from '../../utils/convertUnverifiedWalletAccountToWalletAccount';\nimport { convertVerifiedCredentialToWalletAccount } from '../../utils/convertVerifiedCredentialToWalletAccount';\nimport type { WalletAccount } from '../../walletAccount';\n\ntype GetWalletAccountsFromStateParams = {\n  unverifiedWalletAccounts: UnverifiedWalletAccount[];\n  user: SdkUser | null;\n};\n\nexport const getWalletAccountsFromState = (\n  { unverifiedWalletAccounts, user }: GetWalletAccountsFromStateParams,\n  client: DynamicClient\n): WalletAccount[] => {\n  const walletAccountsMap: Map<string, WalletAccount> = new Map();\n\n  /**\n   * Handle the unverified wallet accounts before the user verified credentials\n   * so the later verified wallet accounts can override the unverified wallet accounts\n   */\n  unverifiedWalletAccounts.forEach((unverifiedWalletAccount) => {\n    const walletAccount = convertUnverifiedWalletAccountToWalletAccount({\n      unverifiedWalletAccount,\n    });\n\n    walletAccountsMap.set(walletAccount.id, walletAccount);\n  });\n\n  /**\n   * Handle user verified credentials\n   */\n  const verifiedCredentials = user?.verifiedCredentials ?? [];\n\n  verifiedCredentials\n    .filter(\n      (verified) =>\n        verified.format === JwtVerifiedCredentialFormatEnum.Blockchain\n    )\n    .forEach((verifiedWalletAccount) => {\n      const walletAccount = convertVerifiedCredentialToWalletAccount(\n        {\n          verifiedCredential: verifiedWalletAccount,\n        },\n        client\n      );\n\n      walletAccountsMap.set(walletAccount.id, walletAccount);\n    });\n\n  return Array.from(walletAccountsMap.values());\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport type { WalletAccount } from '../walletAccount';\nimport { getWalletAccountsFromState } from './getWalletAccountsFromState';\n\n/**\n * Retrieves all wallet accounts associated with the current session.\n *\n * This function returns both verified and unverified wallet accounts,\n * combining data from user credentials and local unverified accounts.\n * You can differentiate between verified and unverified wallet accounts by\n * checking the `verifiedCredentialId` property.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns An array of wallet accounts associated with the session.\n */\nexport const getWalletAccounts = (\n  client = getDefaultClient()\n): WalletAccount[] => {\n  const core = getCore(client);\n  const { unverifiedWalletAccounts, user } = core.state.get();\n\n  return getWalletAccountsFromState({ unverifiedWalletAccounts, user }, client);\n};\n","import { BaseError } from './base';\n\ntype NoWalletProviderFoundErrorParams = {\n  walletProviderKey: string;\n};\n\nexport class NoWalletProviderFoundError extends BaseError {\n  constructor({ walletProviderKey }: NoWalletProviderFoundErrorParams) {\n    super({\n      cause: null,\n      code: 'no_wallet_provider_found_error',\n      docsUrl: null,\n      name: 'NoWalletProviderFoundError',\n      shortMessage: `No wallet provider found with key: ${walletProviderKey}`,\n    });\n  }\n}\n","import type { DynamicClient } from '../../../client/types/DynamicClient';\nimport { getCore } from '../../../client/core/getCore';\n\n/**\n * Creates a service accessor function that manages service instantiation and caching.\n * The returned function will either retrieve an existing service from the registry or\n * create a new one using the provided builder function.\n *\n * @template - The type of service to be created/accessed\n * @param key - Unique identifier for the service in the registry\n * @param builder - Function that creates the service instance when called with a DynamicClient\n */\nexport const createRuntimeServiceAccessKey =\n  <T>(key: string, builder: (client: DynamicClient) => T) =>\n  (client: DynamicClient): T => {\n    const { runtimeServices } = getCore(client);\n\n    const currentService = runtimeServices.getByKey<T>(key);\n\n    if (currentService) {\n      return currentService;\n    }\n\n    const service = builder(client);\n\n    runtimeServices.register(key, service);\n\n    return service;\n  };\n","import type { DynamicClient } from '../../../../client/types';\nimport { emitEvent } from '../../../clientEvents';\nimport type { WalletProvider } from '../../walletProvider/walletProvider.types';\nimport type { WalletProviderRegistry } from '../walletProviderRegistry.types';\n\n/**\n * Creates a new wallet provider registry that manages wallet providers with priority-based registration.\n *\n * @returns The wallet provider registry instance\n *\n * @example\n * ```typescript\n * const registry = createWalletProviderRegistry();\n *\n * registry.register({\n *   priority: WalletProviderPriority.WALLET_SDK,\n *   walletProvider: myWalletProvider\n * });\n *\n * const provider = registry.getByKey('my-wallet-key');\n * const providers = registry.listProviders();\n * ```\n */\nexport const createWalletProviderRegistry = (\n  client: DynamicClient\n): WalletProviderRegistry => {\n  const registry = new Map<\n    string,\n    { priority: number; walletProvider: WalletProvider }\n  >();\n\n  return {\n    getByKey: (key) => registry.get(key)?.walletProvider,\n    listProviders: () =>\n      Array.from(registry.values()).map((v) => v.walletProvider),\n    register: (args) => {\n      const existingEntry = registry.get(args.walletProvider.key);\n\n      if (existingEntry) {\n        if (existingEntry.priority < args.priority) {\n          registry.set(args.walletProvider.key, args);\n\n          emitEvent(\n            {\n              args: { walletProviderKey: args.walletProvider.key },\n              event: 'walletProviderChanged',\n            },\n            client\n          );\n        }\n      } else {\n        registry.set(args.walletProvider.key, args);\n\n        emitEvent(\n          {\n            args: { walletProvider: args.walletProvider },\n            event: 'walletProviderRegistered',\n          },\n          client\n        );\n\n        emitEvent(\n          {\n            args: { walletProviderKey: args.walletProvider.key },\n            event: 'walletProviderChanged',\n          },\n          client\n        );\n      }\n    },\n    unregister: (key) => {\n      registry.delete(key);\n\n      emitEvent(\n        {\n          args: { walletProviderKey: key },\n          event: 'walletProviderUnregistered',\n        },\n        client\n      );\n    },\n  };\n};\n","import { createRuntimeServiceAccessKey } from '../../../../services/runtimeServices';\nimport { createWalletProviderRegistry } from '../createWalletProviderRegistry';\n\n/**\n * This function provides access to a shared instance of the wallet provider registry.\n *\n * It ensures that the same registry instance is used throughout the client to maintaining\n * consistency of registered wallet providers across different parts of the codebase.\n *\n * @returns The wallet provider registry instance\n *\n * @example\n * ```typescript\n * // Get the registry instance\n * const registry = getWalletProviderRegistry();\n *\n * // Register a wallet provider\n * registry.register({\n *   priority: WalletProviderPriority.WALLET_SDK,\n *   walletProvider: myWalletProvider\n * });\n *\n * // Retrieve a specific provider\n * const provider = registry.getByKey('metamaskevm');\n * ```\n */\nexport const getWalletProviderRegistry = createRuntimeServiceAccessKey(\n  'walletProviderRegistry',\n  (client) => createWalletProviderRegistry(client)\n);\n","import type { WalletProvider } from '../walletProvider/walletProvider.types';\n\nexport enum WalletProviderPriority {\n  /**\n   * Highest priority should be used by wallet providers that implement\n   * the most reliable wallet integration.\n   * example: The SDK provided by the wallet provider.\n   */\n  WALLET_SDK = 100,\n  /**\n   * Medium priority should be used by wallet providers that implement\n   * a wallet integration via some reliable standard.\n   * example: A wallet provider that uses EIP6963 announcement.\n   */\n  WALLET_SELF_ANNOUNCEMENT_STANDARD = 50,\n  /**\n   * Low priority should be used by wallet providers that implement\n   * a wallet integration on a less reliable standard.\n   * example: A wallet provider that uses window.ethereum, where the\n   * window key can be overridden by other extensions.\n   */\n  WINDOW_INJECT = 20,\n}\n\nexport type WalletProviderRegistry = {\n  /**\n   * Retrieves a wallet provider by its key.\n   * @param key - The key of the wallet provider.\n   * @returns The wallet provider.\n   */\n  getByKey: (key: string) => WalletProvider | undefined;\n  /**\n   * Retrieves all wallet providers.\n   * @returns The wallet providers.\n   */\n  listProviders: () => WalletProvider[];\n  /**\n   * Registers a wallet provider.\n   * @param args - The arguments for the wallet provider.\n   */\n  register: (args: {\n    priority: WalletProviderPriority;\n    walletProvider: WalletProvider;\n  }) => void;\n  /**\n   * Unregisters a wallet provider.\n   * @param key - The key of the wallet provider.\n   */\n  unregister: (key: string) => void;\n};\n","import type { DynamicClient } from '../../../../client/types';\nimport { NoWalletProviderFoundError } from '../../../../errors/NoWalletProviderFoundError';\nimport type { WalletAccount } from '../../walletAccount';\nimport { getWalletProviderRegistry } from '../../walletProviderRegistry';\n\ntype GetWalletProviderFromWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\nexport const getWalletProviderFromWalletAccount = (\n  { walletAccount }: GetWalletProviderFromWalletAccountParams,\n  client: DynamicClient\n) => {\n  const walletProviderRegistry = getWalletProviderRegistry(client);\n\n  const walletProvider = walletProviderRegistry.getByKey(\n    walletAccount.walletProviderKey\n  );\n\n  if (!walletProvider) {\n    throw new NoWalletProviderFoundError({\n      walletProviderKey: walletAccount.walletProviderKey,\n    });\n  }\n\n  return walletProvider;\n};\n","export const DYNAMIC_AUTH_COOKIE_NAME = 'DYNAMIC_JWT_TOKEN';\n","import type { DynamicClient } from '../../../client/types';\nimport { emitEvent } from '../../clientEvents';\nimport { getWalletAccounts } from '../getWalletAccounts';\n\n/**\n * Emits the `walletAccountsChanged` event.\n */\nexport const emitWalletAccountsChangedEvent = (client: DynamicClient): void => {\n  const walletAccounts = getWalletAccounts(client);\n\n  emitEvent(\n    {\n      args: { walletAccounts },\n      event: 'walletAccountsChanged',\n    },\n    client\n  );\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { emitWalletAccountsChangedEvent } from '../../../wallets/emitWalletAccountsChangedEvent';\nimport { getWalletAccountsFromState } from '../../../wallets/getWalletAccounts/getWalletAccountsFromState';\n\ntype CheckAndRaiseWalletAccountsChangedEventParams = {\n  previousState: Readonly<DynamicCoreState>;\n};\n\nexport const checkAndRaiseWalletAccountsChangedEvent = (\n  { previousState }: CheckAndRaiseWalletAccountsChangedEventParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  const walletAccountsHashBefore = getWalletAccountsHash(previousState, client);\n\n  const walletAccountsHashAfter = getWalletAccountsHash(\n    core.state.get(),\n    client\n  );\n\n  if (walletAccountsHashBefore !== walletAccountsHashAfter) {\n    emitWalletAccountsChangedEvent(client);\n  }\n};\n\nconst getWalletAccountsHash = (\n  state: Readonly<DynamicCoreState>,\n  client: DynamicClient\n) =>\n  getWalletAccountsFromState(state, client)\n    .map((walletAccount) => JSON.stringify(walletAccount))\n    .sort()\n    .join('-');\n","import type { DynamicClient } from '../../../client/types';\nimport { getWalletProviderRegistry } from '../walletProviderRegistry';\n\n/**\n * Get all available wallet providers to interact with internally.\n */\nexport const getWalletProviders = (client: DynamicClient) => {\n  const walletProviderRegistry = getWalletProviderRegistry(client);\n\n  return walletProviderRegistry.listProviders();\n};\n","import type { WalletProvider } from '../../wallets/walletProvider';\nimport { DYNAMIC_WAAS_METADATA } from '../constants';\nimport type { WaasWalletProvider } from '../waas.types';\n\nexport const isWaasWalletProvider = (\n  walletProvider: WalletProvider\n): walletProvider is WaasWalletProvider => {\n  return walletProvider.key.includes(\n    DYNAMIC_WAAS_METADATA.normalizedWalletName\n  );\n};\n","import { WalletProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport type { DynamicClient } from '../../../client/types/DynamicClient';\nimport type { Chain } from '../../chain';\nimport { getWalletProviders } from '../../wallets/getWalletProviders';\nimport { formatWalletProviderKey } from '../../wallets/utils/formatWalletProviderKey';\nimport { DYNAMIC_WAAS_METADATA } from '../constants';\nimport { isWaasWalletProvider } from '../isWaasWalletProvider';\nimport type { WaasWalletProvider } from '../waas.types';\n\ntype FindWaasWalletProviderByChainParams = {\n  chain: Chain;\n};\n\nexport const findWaasWalletProviderByChain = (\n  { chain }: FindWaasWalletProviderByChainParams,\n  client: DynamicClient\n): WaasWalletProvider | null => {\n  const providers = getWalletProviders(client);\n\n  const waasProviderKey = formatWalletProviderKey({\n    chain,\n    displayName: DYNAMIC_WAAS_METADATA.displayName,\n    walletProviderType: WalletProviderEnum.EmbeddedWallet,\n  });\n\n  const waasProvider = providers.find(\n    (provider) => provider.key === waasProviderKey && provider.chain === chain\n  );\n\n  if (!waasProvider || !isWaasWalletProvider(waasProvider)) {\n    return null;\n  }\n\n  return waasProvider;\n};\n","import type { WalletAccount } from '../../wallets/walletAccount';\nimport { DYNAMIC_WAAS_METADATA } from '../constants';\n\ntype IsWaasWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * This function determines whether the provided wallet account is a Dynamic\n * WaaS wallet account.\n *\n * @param params.walletAccount - The wallet account to check.\n * @returns True if the wallet account is a WaaS wallet account, false otherwise.\n */\nexport const isWaasWalletAccount = ({\n  walletAccount,\n}: IsWaasWalletAccountParams): boolean => {\n  return walletAccount.walletProviderKey.includes(\n    DYNAMIC_WAAS_METADATA.normalizedWalletName\n  );\n};\n","import type { DynamicClient } from '../../../client/types';\nimport { getWalletAccounts } from '../../wallets/getWalletAccounts';\nimport { findWaasWalletProviderByChain } from '../findWaasWalletProviderByChain';\nimport { isWaasWalletAccount } from '../isWaasWalletAccount';\n\nexport const restoreUserSharesForAllWalletAccounts = async (\n  client: DynamicClient\n) => {\n  const walletAccounts = getWalletAccounts(client);\n\n  const waasWalletAccounts = walletAccounts.filter((walletAccount) =>\n    isWaasWalletAccount({ walletAccount })\n  );\n\n  await Promise.all(\n    waasWalletAccounts.map(async (walletAccount) => {\n      const provider = findWaasWalletProviderByChain(\n        { chain: walletAccount.chain },\n        client\n      );\n\n      /**\n       * The environment might not have the embedded wallet extensions installed.\n       * In that case there is no provider for the chain and we can skip restoring the user share.\n       */\n      if (!provider) return;\n\n      return provider.restoreUserShareForWalletAccount({ walletAccount });\n    })\n  );\n};\n","import type { VerifyResponse } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport type { DynamicCoreState } from '../../../client/core/types';\nimport type { DynamicClient } from '../../../client/types';\nimport { setCookie } from '../../../utils/setCookie';\nimport { isCookieEnabled } from '../../projectSettings/isCookieEnabled';\nimport { restoreUserSharesForAllWalletAccounts } from '../../waas/restoreUserSharesForAllWalletAccounts';\nimport { DYNAMIC_AUTH_COOKIE_NAME } from '../consts';\nimport { checkAndRaiseWalletAccountsChangedEvent } from './checkAndRaiseWalletAccountsChangedEvent';\n\ntype UpdateAuthFromVerifyResponseParams = {\n  response: VerifyResponse;\n};\n\nexport const updateAuthFromVerifyResponse = (\n  { response }: UpdateAuthFromVerifyResponseParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  const previousState = { ...core.state.get() };\n\n  const { user, minifiedJwt, jwt, expiresAt, mfaToken } = response;\n\n  // Expires at is in seconds, so we need to convert it to milliseconds\n  const sessionExpiresAt = new Date(expiresAt * 1000);\n\n  const newState: Partial<DynamicCoreState> = {\n    legacyToken: jwt ?? null,\n    sessionExpiresAt: sessionExpiresAt,\n    token: minifiedJwt ?? null,\n    user,\n  };\n\n  // only override the mfaToken if a new one is provided in the response\n  if (mfaToken) {\n    newState.mfaToken = mfaToken;\n  }\n\n  core.state.set(newState);\n\n  /**\n   * For customers using a sandbox environment with cookies enabled, we need to set the cookie\n   * programmatically because Redcoast won't set the cookie via headers. We set the cookie programmatically\n   * so customers can access the cookie from document.cookie consistently between sandbox and live environments.\n   */\n  if (minifiedJwt && isCookieEnabled(client)) {\n    const expireDate = sessionExpiresAt.toUTCString();\n\n    setCookie(\n      `${DYNAMIC_AUTH_COOKIE_NAME}=${minifiedJwt}; expires=${expireDate}; path=/; SameSite=Lax`\n    );\n  }\n\n  checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);\n\n  // if the user is logging in, we should restore user shares\n  // for all wallet accounts for performance reasons\n  const isUserLoggingIn = !previousState.user && Boolean(newState.user);\n  if (isUserLoggingIn) {\n    void restoreUserSharesForAllWalletAccounts(client);\n  }\n};\n","import type { DynamicClient } from '../../../client/types';\nimport { NoWalletProviderFoundError } from '../../../errors/NoWalletProviderFoundError';\nimport { getWalletProviders } from '../getWalletProviders';\n\ntype GetWalletProviderByKeyParams = {\n  walletProviderKey: string;\n};\n\nexport const getWalletProviderByKey = (\n  { walletProviderKey }: GetWalletProviderByKeyParams,\n  client: DynamicClient\n) => {\n  const walletProviders = getWalletProviders(client);\n\n  const walletProvider = walletProviders.find(\n    (walletProvider) => walletProvider.key === walletProviderKey\n  );\n\n  if (!walletProvider) {\n    throw new NoWalletProviderFoundError({ walletProviderKey });\n  }\n\n  return walletProvider;\n};\n","import type { DynamicClient } from '../../../../client/types/DynamicClient';\nimport type { WalletAccount } from '../../walletAccount';\n\ntype GetVerifiedCredentialForWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\nexport const getVerifiedCredentialForWalletAccount = (\n  { walletAccount }: GetVerifiedCredentialForWalletAccountParams,\n  client: DynamicClient\n) => {\n  return client.user?.verifiedCredentials.find(\n    (vc) => vc.id === walletAccount.verifiedCredentialId\n  );\n};\n"],"mappings":"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"}