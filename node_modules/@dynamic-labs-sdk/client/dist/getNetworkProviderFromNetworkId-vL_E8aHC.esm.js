import { C as getDefaultClient, D as getCore, E as BaseError, c as createApiClient, s as CHAINS_INFO_MAP, v as assertDefined } from "./constants-hy8OYHwt.esm.js";
import { f as getWalletProviderFromWalletAccount, h as createRuntimeServiceAccessKey, l as checkAndRaiseWalletAccountsChangedEvent, y as normalizeWalletNameWithChain } from "./getVerifiedCredentialForWalletAccount-c_lbXWMG.esm.js";
import { AuthModeEnum } from "@dynamic-labs/sdk-api-core";
import { EventEmitter } from "eventemitter3";

//#region src/utils/isEqualShallow/isEqualShallow.ts
/**
* Shallow compare two objects.
*
* Source: https://github.com/pmndrs/zustand/blob/main/src/vanilla/shallow.ts
*/
const isEqualShallow = (objA, objB) => {
	if (Object.is(objA, objB)) return true;
	if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return objA === objB;
	if (objA instanceof Map && objB instanceof Map) {
		if (objA.size !== objB.size) return false;
		for (const [key, value] of objA) if (!Object.is(value, objB.get(key))) return false;
		return true;
	}
	if (objA instanceof Set && objB instanceof Set) {
		if (objA.size !== objB.size) return false;
		for (const value of objA) if (!objB.has(value)) return false;
		return true;
	}
	const keysA = Object.keys(objA);
	if (keysA.length !== Object.keys(objB).length) return false;
	for (const keyA of keysA) if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) return false;
	if (objA.constructor !== objB.constructor) return false;
	return true;
};

//#endregion
//#region src/utils/observable/subscribeWithSelector/subscribeWithSelector.ts
/**
* Allows subscribing to a slice of the state.
* The slice is a computation of the states.
*
* The callback will only be called when the slice has changed.
* Change is determined by shallow comparison.
*
* Returns a function to unsubscribe the callback.
*/
const subscribeWithSelector = (observable, selector) => (callback) => {
	let lastSlice = selector(observable.get());
	return observable.subscribe((value) => {
		const nextSlice = selector(value);
		if (isEqualShallow(nextSlice, lastSlice)) return;
		lastSlice = nextSlice;
		callback(nextSlice);
	});
};

//#endregion
//#region src/services/storage/createLocalStorageAdapter/createLocalStorageAdapter.ts
/**
* Creates a localStorage adapter
*/
const createLocalStorageAdapter = () => ({
	getItem: async (key) => localStorage.getItem(key),
	removeItem: async (key) => localStorage.removeItem(key),
	setItem: async (key, value) => localStorage.setItem(key, value)
});

//#endregion
//#region src/errors/InvalidStorageSet.ts
var InvalidStorageSet = class extends BaseError {
	constructor({ key, value }) {
		super({
			cause: null,
			code: "invalid_storage_set",
			docsUrl: null,
			metaMessages: [`key: ${key}`, value],
			name: "InvalidStorageSet",
			shortMessage: "Tried to store a value that does not match the schema"
		});
	}
};

//#endregion
//#region src/services/storage/createStorage/formatForStorage/isValidDateISOString/isValidDateISOString.ts
/**
* Returns whether the given string is a valid ISO date string.
*
* Does not support timezone offsets.
*/
const isValidDateISOString = (value) => {
	const date = new Date(value);
	return !isNaN(date.getTime()) && date.toISOString() === value;
};

//#endregion
//#region src/services/storage/createStorage/formatForStorage/storageFormat.ts
const DATE_PREFIX = "__DATE__";
const formatForStorage = (value) => {
	const item = { value };
	return JSON.stringify(item, (_, entry) => {
		if (isValidDateISOString(entry)) return `${DATE_PREFIX}${entry}`;
		return entry;
	});
};
const parseFromStorage = (value) => {
	try {
		return JSON.parse(value, (_, entry) => {
			if (typeof entry === "string" && entry.startsWith(DATE_PREFIX)) return new Date(entry.slice(8));
			return entry;
		});
	} catch (error) {
		return null;
	}
};

//#endregion
//#region src/services/storage/createStorage/createStorage.ts
/**
* Creates a Storage service to interact with storage adapter
*/
const createStorage = ({ prefix = "", storageAdapter }) => {
	const getPrefixedKey = (key) => prefix ? `${prefix}_${key}` : key;
	return {
		getItem: async (storageKeySchema) => {
			const rawItem = await storageAdapter.getItem(getPrefixedKey(storageKeySchema.key));
			const parsedItem = rawItem ? parseFromStorage(rawItem) : null;
			/**
			* The item saved to localStorage may be malformed.
			* In this case, we remove it and return null.
			*/
			if (parsedItem !== null) {
				const parsed = storageKeySchema.schema.safeParse(parsedItem.value);
				if (parsed.success) return parsed.data;
			}
			/**
			* The item saved to localStorage may be malformed.
			* In this case, we remove it and return null.
			*/
			await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));
			return null;
		},
		removeItem: async (storageKeySchema) => {
			await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));
		},
		setItem: async (storageKeySchema, value) => {
			const parsed = storageKeySchema.schema.safeParse(value);
			if (!parsed.success) throw new InvalidStorageSet({
				key: storageKeySchema.key,
				value: JSON.stringify(value)
			});
			const item = formatForStorage(parsed.data);
			await storageAdapter.setItem(getPrefixedKey(storageKeySchema.key), item);
		}
	};
};

//#endregion
//#region src/services/storage/createStorageKeySchema/createStorageKeySchema.ts
const createStorageKeySchema = (params) => {
	return params;
};

//#endregion
//#region src/modules/initializeClient/consts.ts
const REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY = "refresh-user-state-from-cookie";
const INITIALIZE_STORAGE_SYNC_TRACKER_KEY = "initialize-storage-sync";
const FETCH_PROJECT_SETTINGS_TRACKER_KEY = "fetch-project-settings";
const GENERATE_SESSION_KEYS_TRACKER_KEY = "generate-session-keys";

//#endregion
//#region src/utils/deferredPromise/createDeferredPromise.ts
const createDeferredPromise = () => {
	let resolve;
	let reject;
	return {
		promise: new Promise((_resolve, _reject) => {
			resolve = _resolve;
			reject = _reject;
		}),
		reject: (reason) => reject?.(reason),
		resolve: (value) => resolve?.(value)
	};
};

//#endregion
//#region src/errors/CannotTrackError.ts
var CannotTrackError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "cannot_track_error",
			docsUrl: null,
			name: "CannotTrackError",
			shortMessage: "All track calls must be performed in the same node tick"
		});
	}
};

//#endregion
//#region src/services/logger/createLogger/createLogger.ts
/**
* Log levels and their corresponding numeric values
*/
const LOG_LEVELS = {
	debug: 0,
	error: 3,
	info: 1,
	warn: 2
};
const defaultConsole = console;
/**
* Creates a logger instance with configurable log level and event emission capabilities.
* @returns A logger instance with debug, info, warn, and error methods
*/
const createLogger = (options = {}) => {
	const eventEmitter = new EventEmitter();
	const minLevel = options.level ?? "warn";
	const shouldLog = (level) => {
		return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];
	};
	const formatMessage = (level, message) => {
		return `[${(/* @__PURE__ */ new Date()).toISOString()}] ${level.toUpperCase()}: ${message}`;
	};
	const log = (level, consoleMethod, message, ...args) => {
		eventEmitter.emit("log", level, message, ...args);
		if (!shouldLog(level)) return;
		consoleMethod(formatMessage(level, message), ...args);
	};
	return {
		debug: (message, ...args) => log("debug", defaultConsole.debug, message, ...args),
		error: (message, ...args) => log("error", defaultConsole.error, message, ...args),
		info: (message, ...args) => log("info", defaultConsole.info, message, ...args),
		off: eventEmitter.off.bind(eventEmitter),
		on: eventEmitter.on.bind(eventEmitter),
		warn: (message, ...args) => log("warn", defaultConsole.warn, message, ...args)
	};
};

//#endregion
//#region src/errors/NoNetworkProvidersError.ts
var NoNetworkProvidersError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "no_network_providers",
			docsUrl: null,
			name: "NoNetworkProvidersError",
			shortMessage: "No networks were registered in the client"
		});
	}
};

//#endregion
//#region src/errors/WalletAlreadyLinkedToAnotherUserError.ts
var WalletAlreadyLinkedToAnotherUserError = class extends BaseError {
	constructor({ cause }) {
		super({
			cause,
			code: "wallet_already_linked_to_another_user_error",
			docsUrl: null,
			name: "WalletAlreadyLinkedToAnotherUserError",
			shortMessage: "This wallet is already linked to another user"
		});
	}
};

//#endregion
//#region src/modules/captcha/isCaptchaRequired/isCaptchaRequired.ts
const isCaptchaRequired = (client = getDefaultClient()) => {
	const projectSettings = client.projectSettings;
	assertDefined(projectSettings, "Project settings are not available");
	return projectSettings.security.hCaptcha?.enabled ?? false;
};

//#endregion
//#region src/modules/captcha/consumeCaptchaToken/consumeCaptchaToken.ts
/**
* Retrieves the current captcha token from the client state and sets it to null.
*/
const consumeCaptchaToken = (client) => {
	const core = getCore(client);
	const captchaToken = core.state.get().captchaToken;
	if (isCaptchaRequired(client)) assertDefined(captchaToken, "Captcha token is required");
	core.state.set({ captchaToken: null });
	return captchaToken ?? void 0;
};

//#endregion
//#region src/modules/captcha/setCaptchaToken/setCaptchaToken.ts
/**
* Sets the given captcha token in the client state.
*
* @param params.captchaToken - The captcha token to set.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
*/
const setCaptchaToken = ({ captchaToken }, client = getDefaultClient()) => {
	getCore(client).state.set({ captchaToken });
};

//#endregion
//#region src/modules/extension/hasExtension/hasExtension.ts
/**
* Checks if a specific extension has been applied to the Dynamic client.
*
* Extensions add optional features to the Dynamic SDK,
* such as EVM, Solana, or other chain support.
*
* @param params.extensionKey - The unique key identifying the extension to check for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns True if the extension is applied, false otherwise.
*/
const hasExtension = ({ extensionKey }, client = getDefaultClient()) => {
	return getCore(client).extensions.has(extensionKey);
};

//#endregion
//#region src/modules/auth/createVisit/createVisit.ts
const createVisit = async ({ walletAccount, authMode = AuthModeEnum.Only }, client) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	try {
		const walletName = normalizeWalletNameWithChain({
			chain: walletProvider.chain,
			displayName: walletProvider.metadata.displayName
		});
		const connectRequest = {
			address: walletAccount.address,
			authMode,
			chain: walletProvider.chain,
			provider: walletProvider.walletProviderType,
			walletName
		};
		await apiClient.createVisit({
			connectRequest,
			environmentId: core.environmentId
		});
	} catch (error) {
		core.logger.error("Error creating visit", { error });
	}
};

//#endregion
//#region src/modules/wallets/unverifiedWalletAccounts/setUnverifiedWalletAccounts/setUnverifiedWalletAccounts.ts
/**
* Updates the unverified wallet account in the client state.
* This will add new wallet accounts and override those with matching ids,
* but will leave other preexisting wallet accounts unchanged.
*/
const setUnverifiedWalletAccounts = ({ unverifiedWalletAccountsToUpdate }, client) => {
	if (unverifiedWalletAccountsToUpdate.length === 0) return;
	const core = getCore(client);
	const unverifiedWalletAccountsToUpdateIds = unverifiedWalletAccountsToUpdate.map(({ id }) => id);
	const filteredUnverifiedWalletAccounts = core.state.get().unverifiedWalletAccounts.filter((unverifiedWalletAccount) => !unverifiedWalletAccountsToUpdateIds.includes(unverifiedWalletAccount.id));
	core.state.set({ unverifiedWalletAccounts: [...filteredUnverifiedWalletAccounts, ...unverifiedWalletAccountsToUpdate] });
};

//#endregion
//#region src/modules/wallets/utils/formatSignInMessage/formatSignInMessage.ts
/**
* Formats a sign in message to prove ownership of an address.
*/
const formatSignInMessage = async ({ domain, blockchainName, address, uri, chainId, nonce, issuedAt, requestId, statement, resources }) => {
	const prefix = [`${domain} wants you to sign in with your ${blockchainName} account:`, address].join("\n");
	const prefixWithStatementGap = statement ? "\n\n" : "\n";
	const prefixWithStatement = `${[prefix, statement].join(prefixWithStatementGap)}\n`;
	const suffixFields = [];
	suffixFields.push(`URI: ${uri}`);
	suffixFields.push("Version: 1");
	if (chainId) suffixFields.push(`Chain ID: ${chainId}`);
	suffixFields.push(`Nonce: ${nonce}`);
	if (issuedAt) suffixFields.push(`Issued At: ${issuedAt}`);
	if (requestId) suffixFields.push(`Request ID: ${requestId}`);
	if (resources?.length) suffixFields.push(`Resources:${resources.map((resource) => "\n- " + resource).join()}`);
	return [prefixWithStatement, suffixFields.join("\n")].join("\n");
};

//#endregion
//#region src/modules/wallets/utils/getSignInMessage/createSignInMessageStatement/createSignInMessageStatement.ts
const createSignInMessageStatement = (client) => {
	const appName = getCore(client).metadata?.name ?? client.projectSettings?.general.displayName;
	return `Welcome to ${appName}. Signing is the only way we can truly know that you are the owner of the wallet you are connecting. Signing is a safe, gas-less transaction that does not in any way give ${appName} permission to perform any transactions with your wallet.`;
};

//#endregion
//#region src/modules/wallets/unverifiedWalletAccounts/removeUnverifiedWalletAccount/removeUnverifiedWalletAccount.ts
/**
* Removes an unverified wallet account from the client's state.
*/
const removeUnverifiedWalletAccount = ({ unverifiedWalletAccount }, client) => {
	const core = getCore(client);
	const previousState = core.state.get();
	const { unverifiedWalletAccounts } = core.state.get();
	const filteredUnverifiedWalletAccounts = unverifiedWalletAccounts.filter((account) => account.id !== unverifiedWalletAccount.id);
	core.state.set({ unverifiedWalletAccounts: filteredUnverifiedWalletAccounts });
	/**
	* We check before raising because the wallet account we are removing might still
	* be present in wallet accounts due to having been moved to verified credentials.
	*/
	checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);
};

//#endregion
//#region src/utils/isError/isError.ts
/**
* Check if the given value is an Error object
*/
const isError = (error) => error instanceof Error;

//#endregion
//#region src/utils/isErrorWithCode/isErrorWithCode.ts
/**
* Check if the given value is an Error object with a specific code
*/
const isErrorWithCode = (error, code) => {
	if (!isError(error)) return false;
	return "code" in error && error.code === code;
};

//#endregion
//#region src/modules/wallets/verifyMessageSignatureOwnership/verifyMessageSignatureOwnership.ts
/**
* Verifies a signed message by calling either the verifyLink, verifyTransfer or verify API function,
* depending on whether the user is signing in, linking or transferring a wallet.
*
* Does NOT call updateAuthFromVerifyResponse, it should be called from the return of this function.
*/
const verifyMessageSignatureOwnership = async ({ messageToSign, walletAddress, addressesWithTypes, signature, chain, isTransfer = false, walletDisplayName, walletProviderType }, client) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const walletName = normalizeWalletNameWithChain({
		chain,
		displayName: walletDisplayName
	});
	let verifyApiFunction;
	if (!client.user) verifyApiFunction = apiClient.verify.bind(apiClient);
	else if (isTransfer) verifyApiFunction = apiClient.verifyTransfer.bind(apiClient);
	else verifyApiFunction = apiClient.verifyLink.bind(apiClient);
	try {
		return await verifyApiFunction({
			environmentId: core.environmentId,
			verifyRequest: {
				additionalWalletAddresses: addressesWithTypes?.map((address) => ({
					address: address.address,
					publicKey: address.publicKey,
					type: address.type
				})),
				captchaToken: consumeCaptchaToken(client),
				chain,
				messageToSign,
				publicWalletAddress: walletAddress,
				signedMessage: signature,
				walletName,
				walletProvider: walletProviderType
			}
		});
	} catch (error) {
		if (isErrorWithCode(error, "reassign_wallet_confirm") || isErrorWithCode(error, "merge_accounts_confirmation")) throw new WalletAlreadyLinkedToAnotherUserError({ cause: error });
		throw error;
	}
};

//#endregion
//#region src/modules/wallets/walletProvider/walletProviderKeyMap/updateWalletProviderKeysForVerifiedCredentials/updateWalletProviderKeysForVerifiedCredentials.ts
const updateWalletProviderKeysForVerifiedCredentials = ({ keysToUpdate }, client) => {
	const core = getCore(client);
	core.state.set({ walletProviderKeyMap: {
		...core.state.get().walletProviderKeyMap,
		...keysToUpdate
	} });
};

//#endregion
//#region src/modules/wallets/networks/getSdkChainFromApiChainName/getSdkChainFromApiChainName.ts
/**
* Maps the chain name from the API to the SDK chain name
*/
const getSdkChainFromApiChainName = (chainName) => {
	return Object.keys(CHAINS_INFO_MAP).find((chain) => CHAINS_INFO_MAP[chain].apiChainName === chainName) || null;
};

//#endregion
//#region src/modules/wallets/networks/getNetworksData/getNetworksData.ts
/**
* Retrieves all available network configurations from project settings.
*
* This function returns detailed configuration data for all networks enabled
* in your Dynamic project, including RPC URLs, native currencies, and metadata.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns An array of network configuration data for all enabled networks.
*/
const getNetworksData = (client = getDefaultClient()) => {
	const { state } = getCore(client);
	const { projectSettings } = state.get();
	assertDefined(projectSettings, "projectSettings not found");
	const networks = projectSettings.networks;
	if (!networks) return [];
	return networks.map((network) => {
		if (!network.chainName) return [];
		const chain = getSdkChainFromApiChainName(network.chainName);
		if (!network?.networks?.length || !chain) return [];
		return network.networks.map((networkConfiguration) => ({
			blockExplorerUrls: networkConfiguration.blockExplorerUrls,
			chain,
			cluster: networkConfiguration.cluster,
			displayName: networkConfiguration.vanityName || networkConfiguration.name,
			genesisHash: networkConfiguration.genesisHash,
			iconUrl: networkConfiguration.iconUrls[0],
			nativeCurrency: {
				decimals: networkConfiguration.nativeCurrency.decimals,
				iconUrl: networkConfiguration.nativeCurrency.iconUrl,
				name: networkConfiguration.nativeCurrency.name,
				symbol: networkConfiguration.nativeCurrency.symbol
			},
			networkId: networkConfiguration.networkId,
			rpcUrls: { http: [...networkConfiguration.privateCustomerRpcUrls ?? [], ...networkConfiguration.rpcUrls ?? []] },
			testnet: networkConfiguration.isTestnet ?? false
		}));
	}).flat();
};

//#endregion
//#region src/modules/wallets/networks/networkProviderBuilderRegistry/createNetworkProviderBuilderRegistry/createNetworkProviderBuilderRegistry.ts
const createNetworkProviderBuilderRegistry = () => {
	const registry = /* @__PURE__ */ new Map();
	return {
		get: () => registry,
		register: (networkProviderBuilder) => {
			registry.set(networkProviderBuilder.chain, networkProviderBuilder);
		}
	};
};

//#endregion
//#region src/modules/wallets/networks/networkProviderBuilderRegistry/getNetworkProviderBuilderRegistry/getNetworkProviderBuilderRegistry.ts
const getNetworkProviderBuilderRegistry = createRuntimeServiceAccessKey("networkProviderBuilderRegistry", createNetworkProviderBuilderRegistry);

//#endregion
//#region src/modules/wallets/networks/getNetworkProviders/getNetworkProviders.ts
/**
* Retrieves all registered network providers for enabled chains.
*/
const getNetworkProviders = (client) => {
	const networkProviderBuilderRegistry = getNetworkProviderBuilderRegistry(client);
	const registeredNetworkProviderBuilders = Array.from(networkProviderBuilderRegistry.get().values());
	const networksData = getNetworksData(client);
	return registeredNetworkProviderBuilders.map(({ builder, chain }) => {
		return networksData.filter((networkData) => networkData.chain === chain).map(builder);
	}).flat();
};

//#endregion
//#region src/modules/wallets/networks/getNetworkProviderFromNetworkId/getNetworkProviderFromNetworkId.ts
const getNetworkProviderFromNetworkId = ({ networkId, chain }, client) => {
	const networkProviders = getNetworkProviders(client);
	if (networkProviders.length === 0) throw new NoNetworkProvidersError();
	const networkProvider = networkProviders.find((networkProvider$1) => networkProvider$1.networkId === networkId && networkProvider$1.chain === chain);
	assertDefined(networkProvider, `No network provider found for chain ${chain} with network id ${networkId}`);
	return networkProvider;
};

//#endregion
export { isEqualShallow as A, INITIALIZE_STORAGE_SYNC_TRACKER_KEY as C, InvalidStorageSet as D, createStorage as E, createLocalStorageAdapter as O, GENERATE_SESSION_KEYS_TRACKER_KEY as S, createStorageKeySchema as T, NoNetworkProvidersError as _, updateWalletProviderKeysForVerifiedCredentials as a, createDeferredPromise as b, createSignInMessageStatement as c, createVisit as d, hasExtension as f, WalletAlreadyLinkedToAnotherUserError as g, isCaptchaRequired as h, getNetworksData as i, subscribeWithSelector as k, formatSignInMessage as l, consumeCaptchaToken as m, getNetworkProviders as n, verifyMessageSignatureOwnership as o, setCaptchaToken as p, getNetworkProviderBuilderRegistry as r, removeUnverifiedWalletAccount as s, getNetworkProviderFromNetworkId as t, setUnverifiedWalletAccounts as u, createLogger as v, REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY as w, FETCH_PROJECT_SETTINGS_TRACKER_KEY as x, CannotTrackError as y };
//# sourceMappingURL=getNetworkProviderFromNetworkId-vL_E8aHC.esm.js.map