import { C as getDefaultClient, D as getCore, E as BaseError, O as name, _ as isCookieEnabled, a as SDK_API_CORE_VERSION, b as randomString, c as createApiClient, d as MfaInvalidOtpError, f as LinkCredentialError, g as getBuffer, i as DYNAMIC_ICONIC_SPRITE_URL, k as version, l as SandboxMaximumThresholdReachedError, m as APIError, o as getChainFromVerifiedCredentialChain, p as InvalidExternalAuthError, s as CHAINS_INFO_MAP, u as MfaRateLimitedError, v as assertDefined, w as setDefaultClient, x as CLIENT_SDK_NAME, y as ValueMustBeDefinedError } from "./constants-hy8OYHwt.esm.js";
import { A as isEqualShallow, C as INITIALIZE_STORAGE_SYNC_TRACKER_KEY, E as createStorage, O as createLocalStorageAdapter, S as GENERATE_SESSION_KEYS_TRACKER_KEY, T as createStorageKeySchema, _ as NoNetworkProvidersError, a as updateWalletProviderKeysForVerifiedCredentials, b as createDeferredPromise, c as createSignInMessageStatement, d as createVisit, f as hasExtension, g as WalletAlreadyLinkedToAnotherUserError, h as isCaptchaRequired, i as getNetworksData, k as subscribeWithSelector, l as formatSignInMessage, m as consumeCaptchaToken, o as verifyMessageSignatureOwnership, p as setCaptchaToken, s as removeUnverifiedWalletAccount, t as getNetworkProviderFromNetworkId, u as setUnverifiedWalletAccounts, v as createLogger, w as REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY, x as FETCH_PROJECT_SETTINGS_TRACKER_KEY, y as CannotTrackError } from "./getNetworkProviderFromNetworkId-vL_E8aHC.esm.js";
import { D as onceEvent, E as onEvent, O as setCookie, S as splitWalletProviderKey, T as offEvent, _ as getWalletAccounts, b as formatWalletAccountId, c as getWalletProviders, d as DYNAMIC_AUTH_COOKIE_NAME, f as getWalletProviderFromWalletAccount, g as NoWalletProviderFoundError, i as restoreUserSharesForAllWalletAccounts, l as checkAndRaiseWalletAccountsChangedEvent, n as getWalletProviderByKey, r as updateAuthFromVerifyResponse, t as getVerifiedCredentialForWalletAccount, u as emitWalletAccountsChangedEvent, w as emitEvent, x as normalizeAddress } from "./getVerifiedCredentialForWalletAccount-c_lbXWMG.esm.js";
import { i as bufferToHex, n as getMfaMethods, r as consumeMfaToken, t as isMfaRequiredForAction } from "./isMfaRequiredForAction-BgevGq0s.esm.js";
import { n as refreshAuth, t as NotWaasWalletAccountError } from "./NotWaasWalletAccountError-D0YXdfTu.esm.js";
import { t as InvalidParamError } from "./InvalidParamError-c8UAEGKA.esm.js";
import { assertPackageVersion } from "@dynamic-labs-sdk/assert-package-version";
import { AuthModeEnum, JwtVerifiedCredentialFormatEnum, MFAAction, MfaBackupCodeAcknowledgement, ProviderEnum } from "@dynamic-labs/sdk-api-core";
import * as z from "zod/mini";
import EventEmitter$1, { EventEmitter } from "eventemitter3";
import { browserSupportsWebAuthn, startAuthentication, startRegistration } from "@simplewebauthn/browser";

//#region src/modules/state/raiseStateEvents/events.ts
/**
* Maps the state keys to the event names.
*
* This is mainly to ensure that whenever a new state key is added, the developer
* will have to come to this file and remember to add it here and in the interface.
*/
const stateChangeEvents = {
	initStatus: "initStatusChanged",
	mfaToken: "mfaTokenChanged",
	projectSettings: "projectSettingsChanged",
	sessionExpiresAt: "sessionExpiresAtChanged",
	token: "tokenChanged",
	user: "userChanged"
};

//#endregion
//#region src/utils/retryOnFail/InvalidRetryOnFailCallError.ts
/**
* This error is thrown when the `retryOnFail` function is called with an invalid
* number of retries (i.e. less than 0).
*/
var InvalidRetryOnFailCallError = class extends BaseError {
	constructor(maxRetries) {
		super({
			cause: null,
			code: "invalid_retry_on_fail_call_error",
			docsUrl: null,
			name: "InvalidRetryOnFailCallError",
			shortMessage: `Invalid retries parameter for retryOnFail call: ${maxRetries}`
		});
	}
};

//#endregion
//#region src/utils/retryOnFail/retryOnFail.ts
const retryOnFail = async ({ delay = 0, fn, maxRetries }) => {
	for (let retry = 0; retry <= maxRetries; retry++) try {
		return await fn();
	} catch (error) {
		if (retry >= maxRetries) throw error;
		if (delay > 0) await new Promise((resolve) => setTimeout(resolve, delay));
	}
	/**
	* Reaching this point should never happen and this
	* error is thrown to help us debug the issue.
	*/
	throw new InvalidRetryOnFailCallError(maxRetries);
};

//#endregion
//#region src/modules/auth/isSignedIn/isSignedIn.ts
/**
* Checks if the user is currently signed in to the Dynamic client.
*
* The client is considered to be in a signed in state if a user has
* authenticated or if the client has at least one wallet connected.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns True if the user is signed in, false otherwise.
*/
const isSignedIn = (client = getDefaultClient()) => Boolean(client.user || getWalletAccounts(client).length > 0);

//#endregion
//#region src/modules/projectSettings/fetchProjectSettings/projectSettingsExpirationScheme.ts
/**
* The schema to track the expiration time of the project settings.
*/
const projectSettingsExpirationStorageKeySchema = createStorageKeySchema({
	key: "projectSettingsExpiration",
	schema: z.number()
});

//#endregion
//#region src/modules/projectSettings/fetchProjectSettings/fetchProjectSettings.ts
/**
* Expiration time of the project settings in milliseconds.
*/
const PROJECT_SETTINGS_EXPIRATION_TIME = 1e3 * 60 * 5;
/**
* Fetches and updates the project settings from the API.
*
* This function retrieves the latest project configuration settings
* from Dynamic's servers, including authentication options, enabled chains,
* and security configurations. The settings are cached for performance.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the updated project settings.
*/
const fetchProjectSettings = async (client = getDefaultClient()) => {
	const core = getCore(client);
	const currentExpiration = await core.storage.getItem(projectSettingsExpirationStorageKeySchema);
	if (Boolean(client.projectSettings) && !(currentExpiration && currentExpiration < Date.now()) && isSignedIn(client)) return client.projectSettings;
	const apiClient = createApiClient({}, client);
	core.logger.debug("[fetchProjectSettings] Fetching project settings...");
	const doFetch = async () => apiClient.getEnvironmentSettings({
		environmentId: core.environmentId,
		sdkVersion: `${CLIENT_SDK_NAME}/${core.version}`
	}, { credentials: "omit" });
	const projectSettings = await retryOnFail({
		fn: doFetch,
		maxRetries: 2
	});
	core.state.set({ projectSettings: projectSettings ?? null });
	await core.storage.setItem(projectSettingsExpirationStorageKeySchema, Date.now() + PROJECT_SETTINGS_EXPIRATION_TIME);
	return projectSettings;
};

//#endregion
//#region src/utils/base64UrlDecode/base64UrlDecode.ts
/**
* Takes a base64url-encoded string (e.g. "nMueRPiAm51YXEjRtka8S_8Ura3HaqbmqDqMJCZmvkM")
* and return the corresponding bytes, as an array buffer.
*/
const base64UrlDecode = (s) => {
	s = s?.replace(/-/g, "+").replace(/_/g, "/") || "";
	return Uint8Array.from(atob(s), (c) => c.charCodeAt(0));
};

//#endregion
//#region src/utils/compressRawPublicKey/compressRawPublicKey.ts
/**
* Accepts a public key array buffer, and returns a buffer with the compressed version of the public key
*/
const compressRawPublicKey = (rawPublicKey) => {
	const rawPublicKeyBytes = new Uint8Array(rawPublicKey);
	const len = rawPublicKeyBytes.byteLength;
	const compressedBytes = rawPublicKeyBytes.slice(0, 1 + len >>> 1);
	compressedBytes[0] = 2 | rawPublicKeyBytes[len - 1] & 1;
	return compressedBytes.buffer;
};

//#endregion
//#region src/utils/p256Keygen/p256Keygen.ts
const p256Keygen = async () => {
	const p256Keypair = await crypto.subtle.generateKey({
		name: "ECDSA",
		namedCurve: "P-256"
	}, true, ["sign", "verify"]);
	const rawPublicKey = await crypto.subtle.exportKey("raw", p256Keypair.publicKey);
	const privateKeyJwk = await crypto.subtle.exportKey("jwk", p256Keypair.privateKey);
	const compressedPublicKeyBuffer = compressRawPublicKey(rawPublicKey);
	return {
		private: bufferToHex(base64UrlDecode(privateKeyJwk.d)),
		privateJwk: privateKeyJwk,
		public: bufferToHex(compressedPublicKeyBuffer)
	};
};

//#endregion
//#region src/modules/sessionKeys/generateSessionKeys/generateSessionKeys.ts
const generateSessionKeys = async (client) => {
	const { private: privateKey, public: publicKey, privateJwk: privateKeyJwk } = await p256Keygen();
	const core = getCore(client);
	const stringifiedSessionKeys = JSON.stringify({
		privateKey,
		privateKeyJwk,
		publicKey,
		registered: false
	});
	const encodedSessionKeys = getBuffer().from(stringifiedSessionKeys).toString("base64");
	core.state.set({ sessionKeys: encodedSessionKeys });
	return {
		privateKey,
		privateKeyJwk,
		publicKey
	};
};

//#endregion
//#region src/services/runtimeServices/createRuntimeServices/createRuntimeServices.ts
/**
* Creates a new runtime services instance that manages service registration and retrieval.
*
* @returns A RuntimeServices object with methods to get, register, and unregister services
*/
const createRuntimeServices = () => {
	const registry = /* @__PURE__ */ new Map();
	return {
		getByKey: (key) => registry.get(key),
		register: (key, service) => registry.set(key, service),
		unregister: (key) => registry.delete(key)
	};
};

//#endregion
//#region src/modules/wallets/utils/getAvailableWalletProvidersFromWalletAccounts/getAvailableWalletProvidersFromWalletAccounts.ts
const getAvailableWalletProvidersFromWalletAccounts = (client) => {
	const core = getCore(client);
	const walletProvidersMap = /* @__PURE__ */ new Map();
	getWalletAccounts(client).forEach((walletAccount) => {
		if (walletProvidersMap.has(walletAccount.walletProviderKey)) return;
		try {
			const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
			walletProvidersMap.set(walletAccount.walletProviderKey, walletProvider);
		} catch (error) {
			core.logger.debug("Wallet provider not found for wallet account", {
				error,
				walletAccount: walletAccount.address
			});
		}
	});
	return Array.from(walletProvidersMap.values());
};

//#endregion
//#region src/modules/wallets/disconnectAndTerminateWalletProviders/disconnectAndTerminateWalletProviders.ts
/**
* Disconnect and terminate each wallet provider, if available.
*/
const disconnectAndTerminateWalletProviders = async (client) => {
	const core = getCore(client);
	const walletProviders = getAvailableWalletProvidersFromWalletAccounts(client);
	await Promise.all(walletProviders.map(async (walletProvider) => {
		if (walletProvider.terminate) await walletProvider.terminate();
		if (walletProvider.disconnect) try {
			await walletProvider.disconnect();
		} catch (err) {
			core.logger.error(`Error disconnecting from wallet ${walletProvider.key}`, err);
		}
	}));
};

//#endregion
//#region src/modules/auth/logout/logout.ts
/**
* Logs out the current user and clears all authentication data.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the logout process is complete.
*/
const logout = async (client = getDefaultClient()) => {
	const core = getCore(client);
	core.logger.debug("[logout] Logging out...");
	await disconnectAndTerminateWalletProviders(client);
	if (client.user !== null) {
		const apiClient = createApiClient({}, client);
		try {
			await apiClient.revokeSession({ environmentId: core.environmentId });
		} catch (error) {
			core.logger.error("Failed to revoke session", error);
		}
		/**
		* This deletes the auth cookie if it exists.
		* If the cookie doesn't exist, this sets a new cookie that expires immediately.
		*/
		if (isCookieEnabled(client)) setCookie(`${DYNAMIC_AUTH_COOKIE_NAME}=; Max-Age=-99999999; path=/; SameSite=Lax`);
	}
	core.state.set({
		captchaToken: null,
		legacyToken: null,
		mfaToken: null,
		sessionExpiresAt: null,
		sessionKeys: null,
		token: null,
		unverifiedWalletAccounts: [],
		user: null
	});
	emitEvent({ event: "logout" }, client);
	fetchProjectSettings(client);
	generateSessionKeys(client);
};

//#endregion
//#region src/modules/auth/initializeAuth/setLongTimeout/setLongTimeout.ts
/**
* A replacement for setTimeout that supports delays longer than 2147483647ms (~24.8 days).
*/
const setLongTimeout = (callback, delay) => {
	const MAX_DELAY = 2147483647;
	let timeoutId = null;
	let remaining = delay;
	const run = () => {
		if (remaining <= MAX_DELAY) timeoutId = setTimeout(callback, remaining);
		else timeoutId = setTimeout(() => {
			remaining -= MAX_DELAY;
			run();
		}, MAX_DELAY);
	};
	run();
	return () => {
		if (timeoutId !== null) clearTimeout(timeoutId);
	};
};

//#endregion
//#region src/modules/auth/initializeAuth/initializeAuth.ts
/**
* Sets up a timeout to log out the user when their token expires.
*/
const initializeAuth = (client) => {
	const core = getCore(client);
	let clearExpirationTimeout = null;
	const onChangeExpiration = subscribeWithSelector(core.state, (state) => state.sessionExpiresAt);
	const checkExpiration = () => {
		const expiration = core.state.get().sessionExpiresAt;
		clearExpirationTimeout?.();
		if (!expiration) return;
		const now = /* @__PURE__ */ new Date();
		const timeUntilExpiration = expiration.getTime() - now.getTime();
		if (timeUntilExpiration <= 0) {
			logout(client);
			return;
		}
		clearExpirationTimeout = setLongTimeout(checkExpiration, timeUntilExpiration);
	};
	onChangeExpiration(checkExpiration);
	checkExpiration();
};

//#endregion
//#region src/modules/state/raiseStateEvents/raiseStateEvents.ts
const raiseStateEvents = (client) => {
	getCore(client).state.subscribe((value, previous) => {
		Object.entries(stateChangeEvents).forEach(([key, event]) => {
			if (isEqualShallow(value[key], previous[key])) return;
			emitEvent({
				args: { [key]: value[key] },
				event
			}, client);
		});
	});
};

//#endregion
//#region src/modules/wallets/unverifiedWalletAccounts/schema.ts
const unverifiedWalletAccountSchema = z.object({
	address: z.string(),
	addressesWithTypes: z.optional(z.array(z.object({
		address: z.string(),
		publicKey: z.optional(z.string()),
		type: z.custom((val) => typeof val === "string")
	}))),
	chain: z.custom((val) => typeof val === "string"),
	id: z.string(),
	lastSelectedAt: z.nullable(z.date()),
	walletProviderKey: z.string()
});

//#endregion
//#region src/modules/wallets/walletProvider/walletProviderKeyMap/schema.ts
const walletProviderKeyMapSchema = z.record(z.string(), z.string());

//#endregion
//#region src/modules/storageSync/schema.ts
const stateStorageKeySchema = createStorageKeySchema({
	key: "state",
	schema: z.object({
		apiVersion: z.string(),
		projectSettings: z.custom(),
		unverifiedWalletAccounts: z.array(unverifiedWalletAccountSchema),
		user: z.custom(),
		walletProviderKeyMap: walletProviderKeyMapSchema
	})
});
const sessionStorageKeySchema = createStorageKeySchema({
	key: "session",
	schema: z.object({
		captchaToken: z.nullable(z.string()),
		legacyToken: z.nullable(z.string()),
		mfaToken: z.nullable(z.string()),
		sessionExpiration: z.number(),
		sessionKeys: z.nullable(z.string()),
		token: z.nullable(z.string())
	})
});

//#endregion
//#region src/modules/storageSync/hydrateStateWithStorage/hydrateStateWithStorage.ts
const hydrateStateWithStorage = async (client) => {
	const core = getCore(client);
	const previousState = core.state.get();
	const stateChanges = {};
	const session = await core.storage.getItem(sessionStorageKeySchema);
	const isSessionValid = session?.sessionExpiration && session.sessionExpiration > Date.now();
	if (isSessionValid) {
		stateChanges.token = session.token;
		stateChanges.legacyToken = session.legacyToken;
		stateChanges.sessionExpiresAt = new Date(session.sessionExpiration);
		stateChanges.mfaToken = session.mfaToken;
		stateChanges.captchaToken = session.captchaToken;
		stateChanges.sessionKeys = session.sessionKeys;
	}
	const storedState = await core.storage.getItem(stateStorageKeySchema);
	if (storedState?.apiVersion === SDK_API_CORE_VERSION) {
		stateChanges.unverifiedWalletAccounts = storedState.unverifiedWalletAccounts;
		stateChanges.walletProviderKeyMap = storedState.walletProviderKeyMap;
		if (isSessionValid) stateChanges.user = storedState.user;
		if (isSessionValid || (storedState.unverifiedWalletAccounts ?? []).length > 0) stateChanges.projectSettings = storedState.projectSettings;
	}
	if (Object.keys(stateChanges).length > 0) core.state.set(stateChanges);
	checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);
};

//#endregion
//#region src/modules/storageSync/syncStateWithStorage/syncStateWithStorage.ts
const syncStateWithStorage = (client) => {
	const core = getCore(client);
	core.state.subscribe((state) => {
		if (state.sessionExpiresAt === null) core.storage.removeItem(sessionStorageKeySchema);
		else core.storage.setItem(sessionStorageKeySchema, {
			captchaToken: state.captchaToken,
			legacyToken: state.legacyToken,
			mfaToken: state.mfaToken,
			sessionExpiration: state.sessionExpiresAt.getTime(),
			sessionKeys: state.sessionKeys,
			token: state.token
		});
		core.storage.setItem(stateStorageKeySchema, {
			apiVersion: SDK_API_CORE_VERSION,
			projectSettings: state.projectSettings,
			unverifiedWalletAccounts: state.unverifiedWalletAccounts,
			user: state.user,
			walletProviderKeyMap: state.walletProviderKeyMap
		});
	});
};

//#endregion
//#region src/modules/storageSync/initializeStorageSync.ts
const initializeStorageSync = async (client) => {
	await hydrateStateWithStorage(client);
	syncStateWithStorage(client);
};

//#endregion
//#region src/errors/ClientAlreadyInitializedError.ts
var ClientAlreadyInitializedError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "client_already_initialized_error",
			docsUrl: null,
			name: "ClientAlreadyInitializedError",
			shortMessage: "Client must not be initialized more than once"
		});
	}
};

//#endregion
//#region src/modules/initializeClient/initializeClient.ts
/**
* Initializes the Dynamic client and all its modules and services.
*
* This function orchestrates the initialization of authentication, project settings,
* session keys, and storage sync. It manages the initialization status and handles
* any errors that occur during the process.
*
* You only need to call this function if you are not using `autoInitialize: true` in createDynamicClient.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when initialization is complete.
* @throws ClientAlreadyInitializedError If the client is already initialized.
*/
const initializeClient = async (client = getDefaultClient()) => {
	const core = getCore(client);
	core.logger.debug("[initializeClient] Initializing client. Current init status", core.state.get().initStatus);
	if (core.state.get().initStatus !== "uninitialized") throw new ClientAlreadyInitializedError();
	core.state.set({ initStatus: "in-progress" });
	initializeAuth(client);
	raiseStateEvents(client);
	const initializeStorageSyncPromise = initializeStorageSync(client);
	const fetchProjectSettingsPromise = initializeStorageSyncPromise.then(async () => {
		if (!core.state.get().projectSettings) await fetchProjectSettings(client);
	});
	/**
	* Generate session keys if they don't exist
	*/
	const generateSessionKeysPromise = fetchProjectSettingsPromise.then(async () => {
		if (!core.state.get().sessionKeys) await generateSessionKeys(client);
	});
	/**
	* Refresh user state on initialization when cookie is enabled.
	* This is necessary for supporting multiple subdomain domains.
	*
	* When a user logs in on sub1.example.com, they will have a cookie set. However, when they access
	* sub2.example.com, the cookie will be present but the user state will not be present.
	* We need to fetch the user to access the expiration date of the cookie on the new subdomain.
	*
	* This is also needed in case a user logs in with a new user on sub1.example.com and then accesses
	* sub2.example.com that had the original logged-in user. We need to fetch the user to refresh
	* the user state with the correct logged-in user.
	*/
	const refreshUserStateFromCookiePromise = fetchProjectSettingsPromise.then(async () => {
		/**
		* When cookies are enabled, we need to refresh the user as part of the initialization process
		* to ensure the user is logged in and sync the auth state with the server.
		*
		* This call can fail with a 401 error if the user is not logged in and the SDK should finish its initialization process
		* without throwing an error because that is an expected behavior.
		*/
		if (isCookieEnabled(client)) await refreshAuth(client).catch(async (error) => {
			if (error.status === 401) {
				if (client.user) await logout(client);
			} else throw error;
		});
	});
	core.initTrack.track({
		name: INITIALIZE_STORAGE_SYNC_TRACKER_KEY,
		promise: initializeStorageSyncPromise
	});
	core.initTrack.track({
		name: FETCH_PROJECT_SETTINGS_TRACKER_KEY,
		promise: fetchProjectSettingsPromise
	});
	core.initTrack.track({
		name: GENERATE_SESSION_KEYS_TRACKER_KEY,
		promise: generateSessionKeysPromise
	});
	core.initTrack.track({
		name: REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY,
		promise: refreshUserStateFromCookiePromise
	});
	try {
		await core.initTrack.waitForAll();
		core.state.set({ initStatus: "finished" });
	} catch (error) {
		core.state.set({ initStatus: "failed" });
		throw error;
	}
	if (client.user) restoreUserSharesForAllWalletAccounts(client);
};

//#endregion
//#region src/utils/isServerSideRendering/isServerSideRendering.ts
/**
* Indicates if the code is running in a server-side environment.
*/
const isServerSideRendering = () => typeof window === "undefined";

//#endregion
//#region src/services/asyncTrack/createAsyncTrack.ts
/**
* Creates a tracker that associates names with promises and raises as promises resolve.
*/
const createAsyncTrack = () => {
	/**
	* Whether tracking is enabled.
	* All processes must be tracked on the same node tick.
	*
	* This ensures no process is missed (as it would throw when tracked on a different node tick).
	*/
	let isTrackEnabled = true;
	const eventEmitter = new EventEmitter();
	const allSettledPromise = createDeferredPromise();
	const tracker = /* @__PURE__ */ new Map();
	/**
	* Checks if all processes are initialized and resolves the main promise if they are.
	*/
	const checkIfAllSettled = () => {
		if (!Array.from(tracker.values()).every(({ status }) => status === "resolved")) return;
		allSettledPromise.resolve();
	};
	const track = ({ name: name$1, promise }) => {
		if (!isTrackEnabled) throw new CannotTrackError();
		Promise.resolve().then(() => isTrackEnabled = false);
		tracker.set(name$1, {
			promise,
			status: "pending"
		});
		promise.then(() => {
			tracker.set(name$1, {
				promise,
				status: "resolved"
			});
			eventEmitter.emit("resolved", name$1);
			checkIfAllSettled();
		}).catch((error) => {
			tracker.set(name$1, {
				promise,
				status: "failed"
			});
			eventEmitter.emit("failed", name$1, error);
			allSettledPromise.reject(error);
		});
	};
	const waitForAll = () => allSettledPromise.promise;
	const getTracker = (trackerKey) => tracker.get(trackerKey);
	return {
		getTracker,
		off: eventEmitter.off.bind(eventEmitter),
		on: eventEmitter.on.bind(eventEmitter),
		track,
		waitForAll
	};
};

//#endregion
//#region src/services/eventEmitter/createEventEmitter.ts
const createEventEmitter = () => new EventEmitter$1();

//#endregion
//#region src/errors/UnavailableInServerSideError.ts
var UnavailableInServerSideError = class extends BaseError {
	constructor(unavailableFeature) {
		super({
			cause: null,
			code: "unavailable_in_server_side_error",
			docsUrl: null,
			name: "UnavailableInServerSideError",
			shortMessage: `This function is not available in server-side rendering: ${unavailableFeature}`
		});
	}
};

//#endregion
//#region src/services/fetch/createWebFetch.ts
/**
* Creates a fetch instance that uses the native window.fetch API.
*/
const createWebFetch = () => {
	if (isServerSideRendering()) return () => Promise.reject(new UnavailableInServerSideError("createWebFetch"));
	return window.fetch.bind(window);
};

//#endregion
//#region src/services/navigate/createNavigationHandler/createNavigationHandler.ts
/**
* Creates a navigation handler that uses the native window.location API.
*/
const createNavigationHandler = () => {
	if (isServerSideRendering()) return () => Promise.reject(new UnavailableInServerSideError("createNavigationHandler"));
	return async (url) => {
		window.location.href = url;
	};
};

//#endregion
//#region src/services/openDeeplink/createWebDeeplinkOpener/createWebDeeplinkOpener.ts
/**
* Creates a deeplink opener that uses the native window.open API.
*/
const createWebDeeplinkOpener = () => {
	if (isServerSideRendering()) return () => Promise.reject(new UnavailableInServerSideError("createWebDeeplinkOpener"));
	return async (url) => {
		window.open(url, "_blank");
	};
};

//#endregion
//#region src/services/passkey/createWebPasskeyService/createWebPasskeyService.ts
/**
* Because this is the web implementation of the passkey service, we need to
* import the browser's WebAuthn API directly.
*/
/**
* Create a passkey service that uses the browser's WebAuthn API.
*/
const createWebPasskeyService = () => ({
	authenticate: (options) => startAuthentication(options),
	isSupported: () => browserSupportsWebAuthn(),
	register: (options) => startRegistration(options)
});

//#endregion
//#region src/utils/debouncedMutex/createDebouncedMutex/createDebouncedMutex.ts
const createDebouncedMutex = () => {
	const mutexState = /* @__PURE__ */ new Map();
	return async ({ lockKey, callback, debounceTime = 0 }) => {
		const resolutionPromise = createDeferredPromise();
		if (!mutexState.has(lockKey)) mutexState.set(lockKey, {
			nextCallback: null,
			queuePromise: Promise.resolve(),
			resolutionPromises: [],
			timer: null
		});
		const currentState = mutexState.get(lockKey);
		assertDefined(currentState, `Mutex state for key ${lockKey} not found`);
		currentState.resolutionPromises.push(resolutionPromise);
		if (currentState.timer) clearTimeout(currentState.timer);
		currentState.nextCallback = callback;
		const addCallbackToQueue = async () => {
			currentState.queuePromise = currentState.queuePromise.then(async () => {
				if (!currentState.nextCallback) return;
				const { nextCallback } = currentState;
				currentState.nextCallback = null;
				const promisesToResolve = currentState.resolutionPromises;
				currentState.resolutionPromises = [];
				try {
					await nextCallback();
					promisesToResolve.forEach((resolutionPromise$1) => resolutionPromise$1.resolve());
				} catch (error) {
					promisesToResolve.forEach((resolutionPromise$1) => resolutionPromise$1.reject(error));
				}
			});
		};
		if (debounceTime > 0) currentState.timer = setTimeout(addCallbackToQueue, debounceTime);
		else await addCallbackToQueue();
		return resolutionPromise.promise;
	};
};

//#endregion
//#region src/errors/InvalidStorageValue.ts
var InvalidStorageValue = class extends BaseError {
	constructor(key, value) {
		super({
			cause: null,
			code: "invalid_storage_value",
			docsUrl: null,
			name: "InvalidStorageValue",
			shortMessage: `Tried to store state with a forbidden value. Key: ${key}, Value: ${value}`
		});
	}
};

//#endregion
//#region src/utils/observable/createObservableState/createObservableState.ts
/**
* Creates an observable state object that allows subscribing to immutable state changes.
*
* This function creates a state management system with the following capabilities:
* - Get the current state
* - Update state partially
* - Subscribe to state changes
* - Unsubscribe from state changes
*
* @param getInitialState - A function that returns the initial state object
* @returns An ObservableState object with methods to manage and observe state changes
* @example
* ```typescript
* const state = createObservableState(() => ({
*   count: 0,
*   name: 'John'
* }));
*
* // Subscribe to changes
* const unsubscribe = state.subscribe((current, previous) => {
*   console.log('State changed:', current, 'Previous:', previous);
* });
*
* // Update state
* state.set({ count: 1 });
*
* // Get current state
* const currentState = state.get();
*
* // Unsubscribe when done
* unsubscribe();
* ```
*/
const createObservableState = (getInitialState$1) => {
	const subscribers = /* @__PURE__ */ new Set();
	const notifySubscribers = (value, previous) => {
		subscribers.forEach((callback) => callback(value, previous));
	};
	const subscribe = (callback) => {
		subscribers.add(callback);
		return () => unsubscribe(callback);
	};
	const unsubscribe = (callback) => {
		subscribers.delete(callback);
	};
	let currentState = getInitialState$1();
	const get = () => currentState;
	const set = (partial) => {
		const previous = currentState;
		Object.entries(partial).forEach(([key, value]) => {
			if (value === void 0) throw new InvalidStorageValue(key, value);
		});
		currentState = Object.assign({}, currentState, partial);
		notifySubscribers(currentState, previous);
	};
	return {
		get,
		getInitialState: getInitialState$1,
		set,
		subscribe,
		unsubscribe
	};
};

//#endregion
//#region src/client/consts.ts
/**
* The default API base URL for Dynamic apps in production.
*/
const DEFAULT_API_BASE_URL = "https://app.dynamicauth.com/api/v0";

//#endregion
//#region src/client/core/createCore/getInitialState.ts
/**
* The initial values for the state of the client.
*/
const getInitialState = () => ({
	captchaToken: null,
	initStatus: "uninitialized",
	legacyToken: null,
	mfaToken: null,
	projectSettings: null,
	sessionExpiresAt: null,
	sessionKeys: null,
	token: null,
	unverifiedWalletAccounts: [],
	user: null,
	walletProviderKeyMap: {}
});

//#endregion
//#region src/client/core/createCore/createCore.ts
/**
* Creates a core instance that contains all the services and state of the Dynamic SDK client.
*/
const createCore = (config) => {
	const apiBaseUrl = config.coreConfig?.apiBaseUrl ?? DEFAULT_API_BASE_URL;
	const logger = config.coreConfig?.logger ?? createLogger({ level: config.logLevel });
	const storage = createStorage({
		prefix: `dynamic_${config.environmentId}`,
		storageAdapter: config.coreConfig?.storageAdapter ?? createLocalStorageAdapter()
	});
	const fetch = config.coreConfig?.fetch ?? createWebFetch();
	const openDeeplink = config.coreConfig?.openDeeplink ?? createWebDeeplinkOpener();
	const navigate = config.coreConfig?.navigate ?? createNavigationHandler();
	const state = createObservableState(getInitialState);
	const debouncedMutex = createDebouncedMutex();
	const eventEmitter = createEventEmitter();
	const initTrack = createAsyncTrack();
	const runtimeServices = createRuntimeServices();
	const passkey = config.coreConfig?.passkey ?? createWebPasskeyService();
	return {
		apiBaseUrl,
		debouncedMutex,
		environmentId: config.environmentId,
		eventEmitter,
		extensions: /* @__PURE__ */ new Set(),
		fetch,
		getApiHeaders: config.coreConfig?.getApiHeaders ?? (() => ({})),
		initTrack,
		logger,
		metadata: config.metadata,
		navigate,
		openDeeplink,
		passkey,
		runtimeServices,
		state,
		storage,
		version
	};
};

//#endregion
//#region src/client/createDynamicClient/createDynamicClient.ts
/**
* Creates a new DynamicClient instance.
*
* Notice the `autoInitialize` flag is true by default (unless you're running
* in SSR), so the client will be automatically initialized when created â€” if
* you want to manually initialize the client, you can set the `autoInitialize`
* flag to false and then later call the `initializeClient` function.
*
* Manually calling `initializeClient` also allows you to catch any potential
* errors that may occur during initialization.
*
* @param config - The configuration for the Dynamic client, like the environment ID, app url, etc.
* @returns The Dynamic client instance.
*/
const createDynamicClient = (config) => {
	const core = createCore(config);
	const client = {
		get __core() {
			return core;
		},
		get initStatus() {
			return core.state.get().initStatus;
		},
		get mfaToken() {
			return core.state.get().mfaToken;
		},
		get projectSettings() {
			return core.state.get().projectSettings;
		},
		get sessionExpiresAt() {
			return core.state.get().sessionExpiresAt;
		},
		get token() {
			return core.state.get().token;
		},
		get user() {
			return core.state.get().user;
		}
	};
	const autoInitialize = config.autoInitialize ?? true;
	const shouldAutoInitialize = isServerSideRendering() ? false : autoInitialize;
	core.logger.debug("[createDynamicClient] Creating client...");
	if (shouldAutoInitialize) {
		core.logger.debug("[createDynamicClient] Initializing client...");
		initializeClient(client);
	}
	setDefaultClient(client);
	return client;
};

//#endregion
//#region src/errors/InvalidRedirectStorageStateError.ts
var InvalidRedirectStorageStateError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "invalid_redirect_storage_state_error",
			docsUrl: null,
			name: "InvalidRedirectStorageStateError",
			shortMessage: "The social redirect data found in local storage does not match the expected state. Try connecting again."
		});
	}
};

//#endregion
//#region src/errors/MissingRedirectStorageStateError.ts
var MissingRedirectStorageStateError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "missing_redirect_storage_state_error",
			docsUrl: null,
			name: "MissingRedirectStorageStateError",
			shortMessage: "The social redirect data was not found in local storage. Try connecting again."
		});
	}
};

//#endregion
//#region src/errors/MissingSocialUrlParamError.ts
var MissingSocialUrlParamError = class extends BaseError {
	constructor(param) {
		super({
			cause: null,
			code: "missing_social_url_param_error",
			docsUrl: null,
			name: "MissingSocialParamError",
			shortMessage: `To complete social sign in, the following URL query parameter is required to be set but was not found: ${param}`
		});
	}
};

//#endregion
//#region src/errors/MissingUserVerificationError.ts
var MissingUserVerificationError = class extends BaseError {
	informationToVerify;
	constructor({ informationToVerify, message }) {
		super({
			cause: null,
			code: "missing_user_verification_error",
			docsUrl: null,
			name: "MissingUserVerificationError",
			shortMessage: message ?? `The user is missing verification for ${informationToVerify}. Please verify the user's ${informationToVerify}`
		});
		this.informationToVerify = informationToVerify;
	}
};

//#endregion
//#region src/errors/NetworkAddingUnavailableError.ts
var NetworkAddingUnavailableError = class extends BaseError {
	constructor({ walletProviderKey, originalError, extraMessages }) {
		const cause = originalError instanceof Error ? originalError : null;
		super({
			cause,
			code: "network_adding_unavailable",
			docsUrl: null,
			metaMessages: [`Wallet provider key: ${walletProviderKey}`, ...extraMessages ?? []],
			name: "NetworkAddingUnavailableError",
			shortMessage: `Network adding is not available for this wallet provider. The user should manually add the network in their wallet`
		});
	}
};

//#endregion
//#region src/errors/NetworkNotAddedError.ts
var NetworkNotAddedError = class extends BaseError {
	networkData;
	constructor({ networkData, networkId, originalError, walletProviderKey }) {
		const cause = originalError instanceof Error ? originalError : null;
		super({
			cause,
			code: "network_not_added",
			docsUrl: null,
			metaMessages: [
				`Wallet provider key: ${walletProviderKey}`,
				`Network ID: ${networkId}`,
				"The network is not added to the wallet. If the wallet provider supports adding networks, call the `addNetwork` method before switching.",
				"The network data is available in the error payload as `error.networkData` and can be passed directly to `addNetwork`."
			],
			name: "NetworkNotAddedError",
			shortMessage: `Cannot switch to network ${networkId} because it is not added to the wallet. If the wallet provider supports it, call \`addNetwork\` with the network data from \`error.networkData\` first.`
		});
		this.networkData = networkData;
	}
};

//#endregion
//#region src/errors/NetworkSwitchingUnavailableError.ts
var NetworkSwitchingUnavailableError = class extends BaseError {
	constructor({ walletProviderKey, originalError, extraMessages }) {
		const cause = originalError instanceof Error ? originalError : null;
		super({
			cause,
			code: "network_switching_unavailable",
			docsUrl: null,
			metaMessages: [`Wallet provider key: ${walletProviderKey}`, ...extraMessages ?? []],
			name: "NetworkSwitchingUnavailableError",
			shortMessage: `Network switching is not available at this time. The user should manually switch networks in their wallet`
		});
	}
};

//#endregion
//#region src/errors/NoAddressFoundError.ts
var NoAddressFoundError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "no_address_found_error",
			docsUrl: null,
			name: "NoAddressFoundError",
			shortMessage: "No address is connected to the wallet"
		});
	}
};

//#endregion
//#region src/errors/NoPasskeyCredentialsFoundError.ts
var NoPasskeyCredentialsFoundError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "no_passkey_credentials_found_error",
			docsUrl: null,
			name: "NoPasskeyCredentialsFoundError",
			shortMessage: "No passkey credentials found"
		});
	}
};

//#endregion
//#region src/errors/NoSmartWalletAccountSignerFoundError.ts
var NoSmartWalletAccountSignerFoundError = class extends BaseError {
	constructor(smartWalletAddress) {
		super({
			cause: null,
			code: "no_smart_wallet_account_signer_found_error",
			docsUrl: null,
			name: "NoSmartWalletAccountSignerFoundError",
			shortMessage: `No signer wallet account found for smart wallet account ${smartWalletAddress}`
		});
	}
};

//#endregion
//#region src/errors/NoWebAuthNSupportError.ts
var NoWebAuthNSupportError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "no_webauthn_support_error",
			docsUrl: null,
			name: "NoWebAuthNSupportError",
			shortMessage: "Browser does not support WebAuthn"
		});
	}
};

//#endregion
//#region src/errors/UnrecognizedNetworkError.ts
var UnrecognizedNetworkError = class extends BaseError {
	constructor({ networkId, originalError, walletProviderKey }) {
		const cause = originalError instanceof Error ? originalError : null;
		super({
			cause,
			code: "unrecognized_network",
			docsUrl: null,
			metaMessages: [`Wallet provider key: ${walletProviderKey}`],
			name: "UnrecognizedNetworkError",
			shortMessage: `Attempt to switch to unrecognized network of ID ${networkId}. Please enable this network in your dashboard configuration first.`
		});
	}
};

//#endregion
//#region src/errors/UserNotAuthenticatedError.ts
var UserNotAuthenticatedError = class extends BaseError {
	constructor({ shortMessage } = {}) {
		super({
			cause: null,
			code: "user_not_authenticated_error",
			docsUrl: null,
			name: "UserNotAuthenticatedError",
			shortMessage: shortMessage ?? "User not authenticated"
		});
	}
};

//#endregion
//#region src/errors/UserRejectedError.ts
var UserRejectedError = class extends BaseError {
	constructor({ action }) {
		super({
			cause: null,
			code: "user_rejected",
			docsUrl: null,
			name: "UserRejectedError",
			shortMessage: `User rejected action "${action}"`
		});
	}
};

//#endregion
//#region src/errors/WalletAccountAlreadyVerifiedError.ts
var WalletAccountAlreadyVerifiedError = class extends BaseError {
	constructor(address) {
		super({
			cause: null,
			code: "wallet_account_already_verified_error",
			docsUrl: null,
			name: "WalletAccountAlreadyVerifiedError",
			shortMessage: `Wallet account ${address} is already verified`
		});
	}
};

//#endregion
//#region src/errors/WalletAccountNotSelectedError.ts
var WalletAccountNotSelectedError = class extends BaseError {
	expectedAddress;
	selectedAddress;
	constructor(params) {
		const currentAccountInfo = params.selectedAddress ? ` (currently ${params.selectedAddress})` : "";
		super({
			cause: null,
			code: "wallet_account_not_selected_error",
			docsUrl: null,
			name: "WalletAccountNotSelected",
			shortMessage: `This wallet only supports signing with its selected account${currentAccountInfo}. Please select account ${params.expectedAddress} in your wallet app and try again`
		});
		this.expectedAddress = params.expectedAddress;
		this.selectedAddress = params.selectedAddress;
	}
};

//#endregion
//#region src/errors/WalletProviderMethodUnavailableError.ts
var WalletProviderMethodUnavailableError = class extends BaseError {
	constructor({ methodName, walletProviderKey }) {
		super({
			cause: null,
			code: "wallet_provider_method_unavailable_error",
			docsUrl: null,
			name: "WalletProviderMethodUnavailableError",
			shortMessage: `Wallet provider ${walletProviderKey} does not have ${methodName} available`
		});
	}
};

//#endregion
//#region src/modules/auth/externalAuth/signInWithExternalJwt/signInWithExternalJwt.ts
/**
* Signs in a user using an external JWT token.
*
* This function allows authentication using JWT tokens from external providers,
* enabling integration with custom authentication systems.
*
* @param [params.externalJwt] - Optional external JWT token to authenticate with. Not required when using cookie based auth.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the authentication response from the server.
*/
const signInWithExternalJwt = async ({ externalJwt, sessionPublicKey } = {}, client = getDefaultClient()) => {
	const core = getCore(client);
	const response = await createApiClient({}, client).externalAuthSignin({
		environmentId: core.environmentId,
		externalAuthSigninRequest: {
			jwt: externalJwt,
			sessionPublicKey
		}
	});
	updateAuthFromVerifyResponse({ response }, client);
	return response;
};

//#endregion
//#region src/modules/auth/passkeys/deletePasskey/deletePasskey.ts
/**
* Deletes a passkey for the current user.
*
* @param params.passkeyId - The unique identifier of the passkey to delete.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the passkey is successfully deleted.
*/
const deletePasskey = async ({ passkeyId }, client = getDefaultClient()) => {
	const core = getCore(client);
	await createApiClient({ includeMfaToken: true }, client).deletePasskey({
		deleteUserPasskeyRequest: { passkeyId },
		environmentId: core.environmentId
	});
};

//#endregion
//#region src/modules/auth/passkeys/getPasskeys/getPasskeys.ts
/**
* Retrieves all passkeys associated with the current user.
*
* This function fetches the list of registered passkeys (WebAuthn credentials)
* that the user can use for multi-factor authentication.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an array of the user's registered passkeys.
*/
const getPasskeys = async (client = getDefaultClient()) => {
	const core = getCore(client);
	return (await createApiClient({}, client).getUserPasskeys({ environmentId: core.environmentId })).passkeys;
};

//#endregion
//#region src/modules/auth/passkeys/getPasskeyRegistrationOptions/getPasskeyRegistrationOptions.ts
const getPasskeyRegistrationOptions = async (client) => {
	const core = getCore(client);
	return await createApiClient({}, client).getPasskeyRegistrationOptions({ environmentId: core.environmentId });
};

//#endregion
//#region src/modules/auth/passkeys/serverRegisterPasskey/serverRegisterPasskey.ts
const serverRegisterPasskey = async ({ registration, createMfaToken }, client) => {
	const core = getCore(client);
	return await createApiClient({}, client).registerPasskey({
		environmentId: core.environmentId,
		passkeyRegisterRequest: {
			...registration,
			createMfaToken,
			response: {
				...registration.response,
				clientDataJson: registration.response.clientDataJSON
			}
		}
	});
};

//#endregion
//#region src/modules/auth/passkeys/registerPasskey/registerPasskey.ts
/**
* Registers a new passkey for the current user.
*
* This function creates a new WebAuthn credential that can be used for
* passwordless authentication. The user will be prompted to create a passkey
* using their device's biometric authentication or security key.
*
* @param [params.createMfaToken] - Optional configuration for MFA token creation.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the registration response.
* @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.
*/
const registerPasskey = async ({ createMfaToken } = {}, client = getDefaultClient()) => {
	const core = getCore(client);
	if (!core.passkey.isSupported()) throw new NoWebAuthNSupportError();
	const options = await getPasskeyRegistrationOptions(client);
	const response = await serverRegisterPasskey({
		createMfaToken,
		registration: await core.passkey.register({ optionsJSON: options })
	}, client);
	updateAuthFromVerifyResponse({ response }, client);
	return response;
};

//#endregion
//#region src/modules/auth/passkeys/getPasskeyAuthenticationSignInOptions/getPasskeyAuthenticationSignInOptions.ts
const getPasskeyAuthenticationSignInOptions = async ({ relatedOriginRpId } = {}, client) => {
	const core = getCore(client);
	return await createApiClient({}, client).getPasskeyAuthenticationSigninOptions({
		environmentId: core.environmentId,
		relatedOriginRpId
	});
};

//#endregion
//#region src/modules/auth/passkeys/serverSigninPasskey/serverSigninPasskey.ts
const serverSigninPasskey = async ({ authentication, createMfaToken }, client) => {
	const core = getCore(client);
	return await createApiClient({}, client).signinWithPasskey({
		environmentId: core.environmentId,
		passkeyAuthRequest: {
			...authentication,
			createMfaToken,
			response: {
				...authentication.response,
				clientDataJson: authentication.response.clientDataJSON
			}
		}
	});
};

//#endregion
//#region src/modules/auth/passkeys/signInWithPasskey/signInWithPasskey.ts
/**
* Signs in the user using a registered passkey.
*
* This function authenticates the user with a previously registered WebAuthn
* credential, providing passwordless authentication using biometrics or
* security keys.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the authentication response.
* @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.
*/
const signInWithPasskey = async ({ relatedOriginRpId } = {}, client = getDefaultClient()) => {
	const core = getCore(client);
	if (!core.passkey.isSupported()) throw new NoWebAuthNSupportError();
	const formattedOptions = { ...await getPasskeyAuthenticationSignInOptions({ relatedOriginRpId }, client) };
	const response = await serverSigninPasskey({ authentication: await core.passkey.authenticate({ optionsJSON: formattedOptions }) }, client);
	updateAuthFromVerifyResponse({ response }, client);
	return response;
};

//#endregion
//#region src/modules/auth/social/getUserSocialAccounts/getUserSocialAccounts.ts
/**
* Retrieves all social accounts associated with the current user.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns An array of `SocialAccount` objects associated with the user.
*/
const getUserSocialAccounts = (client = getDefaultClient()) => {
	const { user } = client;
	assertDefined(user, "User is not authenticated");
	return (user.verifiedCredentials.filter((credential) => credential.format === JwtVerifiedCredentialFormatEnum.Oauth) ?? []).map((credential) => ({
		accountId: credential.oauthAccountId ?? void 0,
		displayName: credential.oauthDisplayName ?? void 0,
		emails: credential.oauthEmails ?? [],
		photos: credential.oauthAccountPhotos ?? [],
		provider: credential.oauthProvider,
		username: credential.oauthUsername ?? void 0,
		verifiedCredentialId: credential.id
	}));
};

//#endregion
//#region src/modules/auth/social/removeDynamicOauthParamsFromUrl/removeDynamicOauthParamsFromUrl.ts
const removeDynamicOauthParamsFromUrl = (url) => {
	const urlObject = new URL(url);
	urlObject.searchParams.delete("dynamicOauthState");
	urlObject.searchParams.delete("dynamicOauthCode");
	return urlObject.toString();
};

//#endregion
//#region src/modules/auth/social/oauth/redirectStateStorageSchema/redirectStateStorageSchema.ts
/** The schema to track the state of the OAuth flow. */
const redirectStateStorageKeySchema = createStorageKeySchema({
	key: "redirectState",
	schema: z.object({
		codeVerifier: z.optional(z.string()),
		provider: z.enum(ProviderEnum),
		state: z.string()
	})
});

//#endregion
//#region src/utils/digestSHA256/digestSHA256.ts
const digestSHA256 = (str) => {
	const data = new TextEncoder().encode(str);
	return crypto.subtle.digest("SHA-256", data);
};

//#endregion
//#region src/utils/encodeBase64Url/encodeBase64Url.ts
/**
* Encodes a string to base64url.
*
* @param str - The string to encode as an ArrayBuffer.
* @returns The base64url encoded string.
*/
const encodeBase64Url = (str) => {
	const numberArray = [];
	new Uint8Array(str).forEach((item) => numberArray.push(item));
	return btoa(String.fromCharCode.apply(null, numberArray)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};

//#endregion
//#region src/modules/auth/social/oauth/authenticateWithSocial/buildOAuthUrl/addOAuthUrlParams/addOAuthUrlParams.ts
const APPLE_RESPONSE_MODE = "form_post";
const APPLE_RESPONSE_TYPE = "code id_token";
/** Helper function to add OAuth URL parameters to a given base URL. */
const addOAuthUrlParams = (provider, baseUrl) => {
	assertDefined(provider.clientId, "Client ID not found");
	assertDefined(provider.provider, "Provider type not found");
	assertDefined(provider.redirectUrl, "Redirect URL not found");
	const providerType = provider.provider;
	baseUrl.searchParams.set("client_id", provider.clientId);
	baseUrl.searchParams.set("response_type", "code");
	baseUrl.searchParams.set("redirect_uri", provider.redirectUrl);
	if (providerType === ProviderEnum.Tiktok) {
		baseUrl.searchParams.delete("client_id");
		baseUrl.searchParams.set("client_key", provider.clientId);
	}
	if (providerType === ProviderEnum.Google) baseUrl.searchParams.set("access_type", "offline");
	if (providerType === ProviderEnum.Apple) {
		baseUrl.searchParams.set("response_mode", APPLE_RESPONSE_MODE);
		baseUrl.searchParams.set("response_type", APPLE_RESPONSE_TYPE);
	}
	if (provider.scopes) baseUrl.searchParams.set("scope", provider.scopes);
	return baseUrl;
};

//#endregion
//#region src/modules/auth/social/oauth/authenticateWithSocial/buildOAuthUrl/getOAuthBaseUrl/getOAuthBaseUrl.ts
/** Helper function to build the OAuth base URL for a given provider. */
const getOAuthBaseUrl = (provider) => {
	assertDefined(provider.provider, "Provider type not found");
	const providerType = provider.provider;
	if (providerType === ProviderEnum.Telegram) {
		assertDefined(provider.authorizationUrl, "Telegram authorization URL not found");
		return new URL(provider.authorizationUrl);
	}
	assertDefined(provider.baseAuthUrl, "Base auth URL not found");
	if (providerType === ProviderEnum.Shopify) {
		assertDefined(provider.shopifyStore, "Shopify store value not found in provider");
		const loginBaseUrl = provider.baseAuthUrl.replace("{{shopifyStore}}", provider.shopifyStore);
		return new URL(loginBaseUrl);
	}
	return new URL(provider.baseAuthUrl);
};

//#endregion
//#region src/modules/auth/social/oauth/authenticateWithSocial/buildOAuthUrl/buildOAuthUrl.ts
const providersRequiringPkce = ["twitter", "github"];
/** Helper function to build the OAuth URL for a given provider. */
const buildOAuthUrl = async (core, provider) => {
	const { projectSettings } = core.state.get();
	assertDefined(projectSettings, "Project settings not found");
	assertDefined(projectSettings.providers, "Project providers not found");
	const socialProvider = projectSettings.providers.find((p) => p.provider === provider);
	assertDefined(socialProvider, `Social provider ${provider} not supported`);
	const socialProviderUrl = addOAuthUrlParams(socialProvider, getOAuthBaseUrl(socialProvider));
	const usingPkce = providersRequiringPkce.includes(provider);
	const state = randomString(32);
	const codeVerifier = randomString(43);
	socialProviderUrl.searchParams.set("state", state);
	socialProviderUrl.searchParams.set("response_type", "code");
	if (usingPkce) {
		const digest = await digestSHA256(codeVerifier);
		socialProviderUrl.searchParams.set("code_challenge", encodeBase64Url(digest));
		socialProviderUrl.searchParams.set("code_challenge_method", "S256");
	}
	return {
		codeVerifier: usingPkce ? codeVerifier : void 0,
		state,
		url: socialProviderUrl
	};
};

//#endregion
//#region src/modules/auth/social/oauth/authenticateWithSocial/authenticateWithSocial.ts
/**
* Initiates social authentication by redirecting to the OAuth provider.
*
* This function redirects the user to the specified social provider's
* authorization page to complete OAuth authentication flow.
* After the oauth flow is complete, the user will be redirected back to your app.
* You can then call `detectOAuthRedirect` to check if the user got redirected back to your app due to the oauth flow,
* and finally call `completeSocialAuthentication` to complete the social authentication flow.
*
* @param params.provider - The social provider to authenticate with (e.g., 'google', 'github').
* @param params.redirectUrl - The URL to redirect back to after authentication.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
*/
const authenticateWithSocial = async ({ provider, redirectUrl }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	await core.initTrack.waitForAll();
	const providerType = provider;
	const { url, state, codeVerifier } = await buildOAuthUrl(core, providerType);
	await apiClient.initAuth({
		environmentId: core.environmentId,
		oauthInitAuthRequest: {
			redirectUrl: removeDynamicOauthParamsFromUrl(redirectUrl),
			state
		},
		providerType
	});
	await core.storage.setItem(redirectStateStorageKeySchema, {
		codeVerifier,
		provider: providerType,
		state
	});
	await core.navigate(url.toString());
};

//#endregion
//#region src/modules/auth/social/oauth/completeSocialAuthentication/completeSocialAuthentication.ts
/**
* Completes the social authentication flow after OAuth redirect.
*
* This function processes the OAuth callback URL with authorization codes
* and completes the user authentication with the social provider.
*
* @param params.url - The callback URL containing OAuth response parameters.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the authenticated user or null.
* @throws MissingSocialUrlParamError If required OAuth parameters are missing.
* @throws InvalidRedirectStorageStateError If the stored state doesn't match.
*/
const completeSocialAuthentication = async ({ url }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	await core.initTrack.waitForAll();
	const dynamicOauthState = url.searchParams.get("dynamicOauthState");
	const dynamicOauthCode = url.searchParams.get("dynamicOauthCode");
	if (!dynamicOauthState) throw new MissingSocialUrlParamError("dynamicOauthState");
	if (!dynamicOauthCode) throw new MissingSocialUrlParamError("dynamicOauthCode");
	const storedSocialRedirectState = await core.storage.getItem(redirectStateStorageKeySchema);
	if (!storedSocialRedirectState) throw new MissingRedirectStorageStateError();
	if (storedSocialRedirectState.state !== dynamicOauthState) throw new InvalidRedirectStorageStateError();
	const { provider, codeVerifier } = storedSocialRedirectState;
	await core.storage.removeItem(redirectStateStorageKeySchema);
	let response;
	if (client.user) response = await apiClient.oauthVerify({
		environmentId: core.environmentId,
		oauthRequest: {
			code: dynamicOauthCode,
			codeVerifier,
			state: dynamicOauthState
		},
		providerType: provider
	});
	else response = await apiClient.oauthSignIn({
		environmentId: core.environmentId,
		oauthRequest: {
			captchaToken: consumeCaptchaToken(client),
			code: dynamicOauthCode,
			codeVerifier,
			state: dynamicOauthState
		},
		providerType: provider
	});
	updateAuthFromVerifyResponse({ response }, client);
	return response.user;
};

//#endregion
//#region src/modules/auth/social/oauth/detectOAuthRedirect/detectOAuthRedirect.ts
/**
* Detects if the current URL is an OAuth redirect from a social provider.
*
* This function examines the URL parameters to determine if it contains
* OAuth callback data from a social authentication flow.
*
* @param params.url - The URL to check for OAuth redirect parameters.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to true if the URL is an OAuth redirect, false otherwise.
*/
const detectOAuthRedirect = async ({ url }, client = getDefaultClient()) => {
	const core = getCore(client);
	const dynamicOauthState = url.searchParams.get("dynamicOauthState");
	const dynamicOauthCode = url.searchParams.get("dynamicOauthCode");
	if (!dynamicOauthState || !dynamicOauthCode) return false;
	await core.initTrack.waitForAll();
	const storedSocialRedirectState = await core.storage.getItem(redirectStateStorageKeySchema);
	if (!storedSocialRedirectState || storedSocialRedirectState.state !== dynamicOauthState) return false;
	return true;
};

//#endregion
//#region src/modules/wallets/primaryWalletAccount/getPrimaryWalletAccount/getPrimaryWalletAccount.ts
/**
* Get the primary wallet account.
* The primary wallet account is the one that was last selected by the user.
* This information is stored in both unverified and verified wallet accounts.
* This function consolidates this information to determine which wallet was most recently selected.
*/
const getPrimaryWalletAccount = (client = getDefaultClient()) => {
	const sortedLastSelectedWalletAccounts = getWalletAccounts(client).filter((walletAccount) => Boolean(walletAccount.lastSelectedAt)).sort((a, b) => b.lastSelectedAt.getTime() - a.lastSelectedAt.getTime());
	if (sortedLastSelectedWalletAccounts.length === 0) return null;
	const [primaryWalletAccount] = sortedLastSelectedWalletAccounts;
	return primaryWalletAccount;
};

//#endregion
//#region src/modules/auth/social/oauth/unlinkSocialAccount/unlinkSocialAccount.ts
/**
* Unlinks a social account from the user's account.
*
* @param params.verifiedCredentialId - The verified credential ID of the social account to unlink.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the verify response.
*/
const unlinkSocialAccount = async ({ verifiedCredentialId }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const walletId = getPrimaryWalletAccount(client)?.verifiedCredentialId?.replace("-zerodev", "");
	const response = await apiClient.verifyUnlink({
		environmentId: core.environmentId,
		verifyUnlinkRequest: {
			verifiedCredentialId,
			walletId: walletId ?? void 0
		}
	});
	updateAuthFromVerifyResponse({ response }, client);
	return response;
};

//#endregion
//#region src/modules/balances/getMultichainBalances/getMultichainBalances.ts
/**
* Retrieves token balances across multiple blockchain networks.
*
* This function fetches cryptocurrency and token balances for the user's
* wallet addresses across different chains, networks and addresses specified in the request.
*
* @param params.balanceRequest - The balance request configuration specifying which chains, networks and addresses to query.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the chain balances across multiple networks.
*/
const getMultichainBalances = async ({ balanceRequest }, client = getDefaultClient()) => {
	const core = getCore(client);
	return (await createApiClient({}, client).postMultichainAccountBalances({
		environmentId: core.environmentId,
		multichainAccountBalancesRequest: balanceRequest
	})).chainBalances;
};

//#endregion
//#region src/modules/funding/coinbase/addCoinbaseOnrampOrderEventListener/addCoinbaseOnrampOrderEventListener.ts
/**
* Adds a listener for Coinbase onramp order events.
*
* @param params.listener - The listener function to call when an event is received.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A function to remove the listener.
* @throws {ValueMustBeDefinedError} If the window is not available.
* @docs https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api#events-names
*/
const addCoinbaseOnrampOrderEventListener = ({ listener }, client = getDefaultClient()) => {
	const core = getCore(client);
	if (typeof window === "undefined") throw new ValueMustBeDefinedError("Window is not available to listen for Coinbase onramp order events");
	const handleMessageEvent = (event) => {
		if (event.origin !== "https://pay.coinbase.com") return;
		core.logger.debug("[addCoinbaseOnrampOrderEventListener] pay.coinbase.com event received", { event });
		try {
			const coinbaseOnrampOrderEventData = JSON.parse(event.data);
			if (!coinbaseOnrampOrderEventData.eventName?.startsWith("onramp_api.")) return;
			listener({
				data: coinbaseOnrampOrderEventData.data,
				eventName: coinbaseOnrampOrderEventData.eventName
			});
		} catch (error) {
			core.logger.debug("[addCoinbaseOnrampOrderEventListener] Failed to parse Coinbase onramp order event data", { error });
		}
	};
	window.addEventListener("message", handleMessageEvent);
	return () => {
		window.removeEventListener("message", handleMessageEvent);
	};
};

//#endregion
//#region src/modules/funding/coinbase/getMissingVerificationForCoinbaseOnrampOrder/getMissingVerificationForCoinbaseOnrampOrder.ts
/**
* This function is used to get a list of fields that are missing verification for a Coinbase onramp order
*
* - If the user is missing information for an email or phone number, the field will be returned with the error code MISSING_INFORMATION
* - If the user is missing verification for an email or phone number, the field will be returned with the error code MISSING_VERIFICATION
*   and the existing unverified email or phone number will be included in the data field.
* - If the user's phone number has not been verified in the last 60 days, the field will be returned with the error code VERIFICATION_EXPIRED
*   and the existing phone number will be included in the data field.
*
* @param params.paymentMethod - The payment method that will be used to create the onramp order
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns FieldMissingVerificationForCoinbaseOnramp[] - An array of fields that are missing verification for a Coinbase onramp order
* @throws {InvalidParamError} - If the payment method is not valid
* @throws {ValueMustBeDefinedError} - If the user is not authenticated
*/
const getMissingVerificationForCoinbaseOnrampOrder = ({ paymentMethod }, client = getDefaultClient()) => {
	if (paymentMethod !== "GUEST_CHECKOUT_APPLE_PAY") throw new InvalidParamError(`Invalid payment method: ${paymentMethod}`);
	const { user } = client;
	assertDefined(user, "User is not authenticated");
	const fieldsMissingVerification = [];
	const emailVerifiedCredential = user.verifiedCredentials.find((credential) => credential.format === JwtVerifiedCredentialFormatEnum.Email);
	if (!user.email) fieldsMissingVerification.push({
		errorCode: "MISSING_INFORMATION",
		field: "email"
	});
	else if (!emailVerifiedCredential) fieldsMissingVerification.push({
		data: user.email,
		errorCode: "MISSING_VERIFICATION",
		field: "email"
	});
	const phoneVerifiedCredential = user.verifiedCredentials.find((credential) => credential.format === JwtVerifiedCredentialFormatEnum.PhoneNumber);
	const phoneNumberVerifiedInPast60Days = phoneVerifiedCredential?.verifiedAt && phoneVerifiedCredential.verifiedAt >= /* @__PURE__ */ new Date(Date.now() - 1440 * 60 * 60 * 1e3);
	if (!user.phoneNumber) fieldsMissingVerification.push({
		errorCode: "MISSING_INFORMATION",
		field: "phoneNumber"
	});
	else if (!phoneVerifiedCredential) fieldsMissingVerification.push({
		data: user.phoneNumber,
		errorCode: "MISSING_VERIFICATION",
		field: "phoneNumber"
	});
	else if (!phoneNumberVerifiedInPast60Days) fieldsMissingVerification.push({
		data: user.phoneNumber,
		errorCode: "VERIFICATION_EXPIRED",
		field: "phoneNumber"
	});
	return fieldsMissingVerification;
};

//#endregion
//#region src/modules/funding/coinbase/utils/validateUserCredentialsForCoinbaseOnrampOrder/validateUserCredentialsForCoinbaseOnrampOrder.ts
const validateUserCredentialsForCoinbaseOnrampOrder = (client) => {
	const { user } = client;
	assertDefined(user, "User is not authenticated");
	const fieldsMissingVerification = getMissingVerificationForCoinbaseOnrampOrder({ paymentMethod: "GUEST_CHECKOUT_APPLE_PAY" }, client);
	if (fieldsMissingVerification.find((field) => field.field === "email")) throw new MissingUserVerificationError({
		informationToVerify: "email",
		message: "User must have a verified email to create a Coinbase onramp order"
	});
	const missingPhoneNumberVerification = fieldsMissingVerification.find((field) => field.field === "phoneNumber");
	if (missingPhoneNumberVerification && missingPhoneNumberVerification.errorCode !== "VERIFICATION_EXPIRED") throw new MissingUserVerificationError({
		informationToVerify: "phoneNumber",
		message: "User must have a verified phone number to create a Coinbase onramp order"
	});
	if (missingPhoneNumberVerification && missingPhoneNumberVerification.errorCode === "VERIFICATION_EXPIRED") throw new MissingUserVerificationError({
		informationToVerify: "phoneNumber",
		message: "The user's phone number has not been verified in the last 60 days. Please re-verify the user's phone number"
	});
	return user;
};

//#endregion
//#region src/modules/funding/coinbase/createCoinbaseOnrampOrder/createCoinbaseOnrampOrder.ts
/**
* Creates a Coinbase onramp order
*
* @param orderParams CoinbaseCreateOnrampOrderRequest - The parameters for the onramp order.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns The created order
* @throws {MissingUserVerificationError} If the user is missing verification for email or phone
*/
const createCoinbaseOnrampOrder = async (orderParams, client = getDefaultClient()) => {
	const user = validateUserCredentialsForCoinbaseOnrampOrder(client);
	const core = getCore(client);
	const apiClient = createApiClient({ includeMfaToken: true }, client);
	const { isSandbox, ...restOrderParams } = orderParams;
	const orderResponse = await apiClient.createCoinbaseOnrampOrder({
		coinbaseOnrampOrderCreateRequest: {
			...restOrderParams,
			partnerUserRef: orderParams.partnerUserRef ?? (isSandbox ? `sandbox-${user.id}` : user.id),
			paymentMethod: orderParams.paymentMethod
		},
		environmentId: core.environmentId
	});
	if (!isSandbox || !orderResponse.paymentLink) return orderResponse;
	return {
		...orderResponse,
		paymentLink: {
			...orderResponse.paymentLink,
			url: `${orderResponse.paymentLink.url}&useApplePaySandbox=true`
		}
	};
};

//#endregion
//#region src/modules/funding/coinbase/getCoinbaseBuyUrl/getCoinbaseBuyUrl.ts
/**
* Gets a Coinbase buy URL
*
* @param buyUrlParams CoinbaseOnrampGetBuyUrlRequest - The parameters for the buy URL.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns an object containing the buy URL
*/
const getCoinbaseBuyUrl = async (buyUrlParams, client = getDefaultClient()) => {
	const core = getCore(client);
	return await createApiClient({ includeMfaToken: true }, client).generateCoinbaseOnrampBuyUrl({
		coinbaseOnrampGetBuyUrlRequest: buyUrlParams,
		environmentId: core.environmentId
	});
};

//#endregion
//#region src/modules/funding/cryptoDotCom/createCryptoDotComPayment/createCryptoDotComPayment.ts
/**
* Creates a crypto.com payment
*
* @param paymentParams CryptoDotComPaymentCreateRequest - The parameters for the payment.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns The created payment
*/
const createCryptoDotComPayment = async (paymentParams, client = getDefaultClient()) => {
	const core = getCore(client);
	return await createApiClient({ includeMfaToken: true }, client).createCryptoDotComPayment({
		cryptoDotComPaymentCreateRequest: {
			...paymentParams,
			chain: paymentParams.chain
		},
		environmentId: core.environmentId
	});
};

//#endregion
//#region src/modules/initializeClient/waitForClientInitialized/waitForClientInitialized.ts
/**
* Allows waiting until all modules of the client have been properly initialized
* and are ready for use.
*
* @returns a promise that resolves once the client is fully initialized.
*/
const waitForClientInitialized = async (client = getDefaultClient()) => {
	await getCore(client).initTrack.waitForAll();
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletBookCdnUrl/getWalletBookCdnUrl.ts
/**
* Default CDN URL for the wallet book.
*/
const DEFAULT_WALLET_BOOK_CDN_URL = "https://dynamic-static-assets.com/wallet-book/v1/stable/wallet-book.json";
/**
* Gets the wallet book CDN URL from environment variables with fallback to default.
*
* Checks for environment variables in the following order:
* 1. WALLET_BOOK_CDN_URL
* 2. NEXT_PUBLIC_WALLET_BOOK_CDN_URL
* 4. Default CDN URL
*
* @returns The wallet book CDN URL to use.
*/
const getWalletBookCdnUrl = () => {
	if (typeof process !== "undefined" && process.env) {
		const envVar = process.env.WALLET_BOOK_CDN_URL || process.env.NEXT_PUBLIC_WALLET_BOOK_CDN_URL;
		if (envVar) return envVar;
	}
	return DEFAULT_WALLET_BOOK_CDN_URL;
};

//#endregion
//#region src/modules/legacyWalletBook/fetchLegacyWalletBook/fetchWithTimeout/fetchWithTimeout.ts
/**
* The timeout for each fetch attempt in milliseconds.
*/
const FETCH_TIMEOUT_MS = 3e4;
/**
* Fetches the wallet book from the CDN endpoint with timeout handling.
*
* @param client - The Dynamic client instance.
* @returns A promise that resolves to the wallet book data.
*/
const fetchWithTimeout = async (client) => {
	const controller = new AbortController();
	const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
	const core = getCore(client);
	try {
		const response = await core.fetch(getWalletBookCdnUrl(), { signal: controller.signal });
		if (!response.ok) throw new APIError(`Failed to fetch wallet book: ${response.status} ${response.statusText}`, "wallet_book_fetch_error", response.status);
		return await response.json();
	} finally {
		clearTimeout(timeoutId);
	}
};

//#endregion
//#region src/modules/legacyWalletBook/fetchLegacyWalletBook/walletBookCacheStorageKeySchema.ts
/**
* The schema to store the cached wallet book data.
*/
const walletBookCacheStorageKeySchema = createStorageKeySchema({
	key: "legacyWalletBookCache",
	schema: z.object({
		groups: z.record(z.string(), z.any()),
		wallets: z.record(z.string(), z.any())
	})
});

//#endregion
//#region src/modules/legacyWalletBook/fetchLegacyWalletBook/fetchLegacyWalletBook.ts
/**
* The maximum number of retry attempts.
*/
const MAX_RETRIES = 3;
/**
* The delay between retries in milliseconds.
*/
const RETRY_DELAY_MS = 100;
/**
* Fetches the legacy wallet book from Dynamic's CDN endpoint.
*
* This function implements a two-tier fallback strategy:
* 1. Primary: Fetch from CDN endpoint (with retries)
* 2. Secondary: Use cached version from localStorage if available
*
* @param client - The Dynamic client instance.
* @returns A promise that resolves to the wallet book data.
* @throws If both CDN fetch and cache retrieval fail.
*/
const fetchLegacyWalletBook = async (client) => {
	const core = getCore(client);
	core.logger.debug("[fetchLegacyWalletBook] Fetching wallet book...");
	try {
		const walletBook = await retryOnFail({
			delay: RETRY_DELAY_MS,
			fn: async () => fetchWithTimeout(client),
			maxRetries: MAX_RETRIES
		});
		await core.storage.setItem(walletBookCacheStorageKeySchema, walletBook);
		core.logger.debug("[fetchLegacyWalletBook] Successfully fetched wallet book from CDN");
		return walletBook;
	} catch (error) {
		core.logger.debug("[fetchLegacyWalletBook] Failed to fetch from CDN, trying cache...", error);
		const cachedWalletBook = await core.storage.getItem(walletBookCacheStorageKeySchema);
		if (cachedWalletBook) {
			core.logger.debug("[fetchLegacyWalletBook] Using cached wallet book");
			return cachedWalletBook;
		}
		core.logger.debug("[fetchLegacyWalletBook] Failed to fetch from CDN and no cache available");
		throw error;
	}
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalog/shouldFilterWallet/shouldFilterWallet.ts
/**
* Embedded wallet keys that should be filtered out from the WalletConnect catalog.
* These wallets are not meant to be displayed in wallet selection lists.
*/
const EMBEDDED_WALLET_KEYS = [
	"magicemailotp",
	"magiclink",
	"magicsocial",
	"turnkey",
	"turnkeyhd",
	"zerodev",
	"dynamicwaas",
	"coinbasempc",
	"mpcvault",
	"mpcwallet"
];
/**
* Checks if a wallet should be filtered out from the WalletConnect catalog.
*
* @param walletKey - The wallet key identifier.
* @param wallet - The wallet schema to check.
* @returns True if the wallet should be filtered out, false otherwise.
*/
const shouldFilterWallet = (walletKey, wallet) => {
	if (EMBEDDED_WALLET_KEYS.includes(walletKey)) return true;
	if (!wallet.walletConnect || !wallet.walletConnect.sdks.includes("sign_v2")) return true;
	const hasInjectedConfig = wallet.injectedConfig && wallet.injectedConfig.length > 0;
	const hasMobileLinks = Boolean(wallet.mobile?.androidId || wallet.mobile?.iosId || wallet.mobile?.native || wallet.mobile?.universal);
	const hasDesktopLinks = Boolean(wallet.desktop?.chromeId || wallet.desktop?.edgeId || wallet.desktop?.firefoxId || wallet.desktop?.operaId || wallet.desktop?.safariId || wallet.desktop?.universal);
	if (hasInjectedConfig && !hasMobileLinks && !hasDesktopLinks) return true;
	return false;
};

//#endregion
//#region src/modules/legacyWalletBook/getSpriteUrl/getSpriteUrl.ts
/**
* Gets the sprite URL for a given sprite ID.
*
* @param params.spriteId - The sprite identifier from the wallet book.
* @returns The full URL to the sprite icon
*/
const getSpriteUrl = ({ spriteId }) => `${DYNAMIC_ICONIC_SPRITE_URL}#${spriteId}`;

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalog/transformGroup/transformGroup.ts
/**
* Transforms a wallet group schema into a WalletConnect catalog group.
*/
const transformGroup = ({ group }) => {
	const spriteId = group.brand?.spriteId ?? "";
	return {
		key: group.key,
		name: group.name,
		primaryColor: group.brand?.primaryColor,
		spriteUrl: spriteId ? getSpriteUrl({ spriteId }) : ""
	};
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalog/getChainFromWalletSchema/getChainFromWalletSchema.ts
/**
* Maps wallet book injected config chain identifiers to Chain type.
*/
const INJECTED_CHAIN_TO_CHAIN_MAP = {
	algo: "ALGO",
	aptos: "APTOS",
	bitcoin: "BTC",
	btc: "BTC",
	cosmos: "COSMOS",
	eclipse: "ECLIPSE",
	evm: "EVM",
	flow: "FLOW",
	sol: "SOL",
	spark: "SPARK",
	starknet: "STARK",
	sui: "SUI",
	ton: "TON",
	tron: "TRON"
};
/**
* Extracts the chain prefix from a chain identifier string.
* For example, "eip155:1" -> "eip155", "solana:..." -> "solana"
*/
const extractChainPrefix = ({ chainIdentifier }) => {
	const colonIndex = chainIdentifier.indexOf(":");
	if (colonIndex === -1) return chainIdentifier;
	return chainIdentifier.substring(0, colonIndex);
};
/**
* Maps chain name patterns found in wallet keys to Chain type.
* These are common suffixes or embedded chain identifiers in wallet keys.
*/
const WALLET_KEY_CHAIN_PATTERNS = [
	{
		chain: "SOL",
		pattern: "sol"
	},
	{
		chain: "SOL",
		pattern: "solana"
	},
	{
		chain: "BTC",
		pattern: "btc"
	},
	{
		chain: "BTC",
		pattern: "bitcoin"
	},
	{
		chain: "STARK",
		pattern: "stark"
	},
	{
		chain: "STARK",
		pattern: "starknet"
	},
	{
		chain: "SUI",
		pattern: "sui"
	},
	{
		chain: "APTOS",
		pattern: "aptos"
	},
	{
		chain: "COSMOS",
		pattern: "cosmos"
	},
	{
		chain: "FLOW",
		pattern: "flow"
	},
	{
		chain: "ALGO",
		pattern: "algo"
	},
	{
		chain: "TRON",
		pattern: "tron"
	},
	{
		chain: "TON",
		pattern: "ton"
	},
	{
		chain: "SPARK",
		pattern: "spark"
	},
	{
		chain: "ECLIPSE",
		pattern: "eclipse"
	}
];
/**
* Attempts to extract the chain from a wallet key by looking for embedded chain identifiers.
*
* @param params.walletKey - The wallet key identifier.
* @returns The chain type if found, undefined otherwise.
*/
const getChainFromWalletKey = ({ walletKey }) => {
	const lowerKey = walletKey.toLowerCase();
	for (const { chain, pattern } of WALLET_KEY_CHAIN_PATTERNS) if (lowerKey.includes(pattern)) return chain;
};
/**
* Gets the chain from a wallet book entry.
* Checks injectedConfig first, then falls back to the chains array, then the wallet key.
* If no chain can be determined, defaults to EVM.
*
* @param params.wallet - The wallet schema from the wallet book.
* @param params.walletKey - The wallet key identifier (optional, used as last resort fallback).
* @returns The chain type, defaults to EVM if no chain can be determined.
*/
const getChainFromWalletSchema = ({ wallet, walletKey }) => {
	if (wallet.injectedConfig && wallet.injectedConfig.length > 0) {
		const injectedChain = wallet.injectedConfig[0].chain?.toLowerCase();
		if (injectedChain && INJECTED_CHAIN_TO_CHAIN_MAP[injectedChain]) return INJECTED_CHAIN_TO_CHAIN_MAP[injectedChain];
	}
	if (wallet.chains && wallet.chains.length > 0) {
		const firstChain = wallet.chains[0];
		const chainPrefix = extractChainPrefix({ chainIdentifier: firstChain });
		try {
			return getChainFromVerifiedCredentialChain(chainPrefix);
		} catch {}
	}
	if (walletKey) {
		const chainFromKey = getChainFromWalletKey({ walletKey });
		if (chainFromKey) return chainFromKey;
	}
	return "EVM";
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalog/transformWallet/transformWallet.ts
/**
* Transforms a wallet schema into a WalletConnect catalog wallet entry.
*/
const transformWallet = ({ wallet, walletKey }) => {
	const spriteId = wallet.brand?.spriteId ?? "";
	const androidId = wallet.mobile?.androidId;
	const iosId = wallet.mobile?.iosId;
	return {
		chain: getChainFromWalletSchema({
			wallet,
			walletKey
		}),
		deeplinks: {
			native: wallet.mobile?.native,
			universal: wallet.mobile?.universal
		},
		downloadLinks: {
			androidUrl: androidId ? `https://play.google.com/store/apps/details?id=${androidId}` : void 0,
			iosUrl: iosId ? `https://apps.apple.com/app/${iosId}` : void 0
		},
		groupId: wallet.group,
		name: wallet.name,
		primaryColor: wallet.brand?.primaryColor,
		spriteUrl: spriteId ? getSpriteUrl({ spriteId }) : ""
	};
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalog/transformWalletBook/transformWalletBook.ts
/**
* Transforms the legacy wallet book into a WalletConnect catalog structure.
* Filters out embedded wallets and injected-only wallets.
*/
const transformWalletBook = ({ walletBook }) => {
	const groups = {};
	for (const [groupKey, group] of Object.entries(walletBook.groups)) groups[groupKey] = transformGroup({ group });
	const wallets = {};
	for (const [walletKey, wallet] of Object.entries(walletBook.wallets)) {
		if (shouldFilterWallet(walletKey, wallet)) continue;
		wallets[walletKey] = transformWallet({
			wallet,
			walletKey
		});
	}
	return {
		groups,
		wallets
	};
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalog/getWalletConnectCatalog.ts
/**
* Retrieves the WalletConnect catalog from Dynamic's wallet book.
*
* This function fetches the wallet book and returns a WalletConnect catalog structure
* that can be used for displaying wallet information and performing deep links for mobile wallet connections.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the WalletConnect catalog containing groups and wallets.
* @throws If unable to fetch the wallet book from the API (when both CDN fetch and cache retrieval fail).
*/
const getWalletConnectCatalog = async (client = getDefaultClient()) => {
	return transformWalletBook({ walletBook: await fetchLegacyWalletBook(client) });
};

//#endregion
//#region src/modules/wallets/walletProvider/extractChainFromNormalizedName/extractChainFromNormalizedName.ts
/**
* Extracts the chain from a normalized wallet name with chain suffix.
* The chain is appended in lowercase at the end (e.g., "metamaskevm" -> "EVM").
*
* @param params.normalizedWalletNameWithChain - The normalized wallet name with chain suffix.
* @returns The chain if found, undefined otherwise.
*/
const extractChainFromNormalizedName = ({ normalizedWalletNameWithChain }) => {
	const lowerName = normalizedWalletNameWithChain.toLowerCase();
	const chainSuffixes = Object.keys(CHAINS_INFO_MAP).map((chain) => chain.toLowerCase()).sort((a, b) => b.length - a.length);
	for (const suffix of chainSuffixes) if (lowerName.endsWith(suffix)) return suffix.toUpperCase();
};

//#endregion
//#region src/modules/legacyWalletBook/getWalletConnectCatalogWalletByWalletProviderKey/getWalletConnectCatalogWalletByWalletProviderKey.ts
/**
* Gets the WalletConnect catalog wallet entry for a given wallet provider key.
*
* This function extracts the wallet name and chain from the wallet provider key and matches it
* against the WalletConnect catalog to find the corresponding wallet entry, which includes
* deep link information for mobile wallet connections.
*
* @param params.walletProviderKey - The wallet provider key to get the catalog wallet entry for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the WalletConnect catalog wallet entry, or undefined if not found.
*/
const getWalletConnectCatalogWalletByWalletProviderKey = async ({ walletProviderKey }, client = getDefaultClient()) => {
	const { normalizedWalletNameWithChain } = splitWalletProviderKey(walletProviderKey);
	const chain = extractChainFromNormalizedName({ normalizedWalletNameWithChain });
	if (!chain) return;
	let walletProviderName = normalizedWalletNameWithChain.toLowerCase();
	if (walletProviderName.endsWith(chain.toLowerCase())) walletProviderName = walletProviderName.slice(0, -chain.length);
	walletProviderName = walletProviderName.replace(/wallet/g, "");
	const walletConnectCatalog = await getWalletConnectCatalog(client);
	for (const [walletKey, wallet] of Object.entries(walletConnectCatalog.wallets)) {
		if (wallet.chain !== chain) continue;
		const walletKeyLower = walletKey.toLowerCase();
		const walletNameLower = wallet.name.toLowerCase().replace(/\s+/g, "");
		if (walletKeyLower.includes(walletProviderName) || walletNameLower.includes(walletProviderName)) return wallet;
	}
};

//#endregion
//#region src/modules/user/updateUser/updateUser.ts
/**
* Updates the current user's profile information.
*
* This function allows updating various user fields such as email, name,
* and other profile information. Some updates may require OTP verification,
* like email and phone number.
*
* @param params.userFields - The user fields to update.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to OTP verification details if verification is required, or undefined.
*/
const updateUser = async ({ userFields }, client = getDefaultClient()) => {
	const core = getCore(client);
	const response = await createApiClient({ includeMfaToken: true }, client).updateSelf({
		environmentId: core.environmentId,
		userFields
	});
	updateAuthFromVerifyResponse({ response }, client);
	if (response.emailVerification) return {
		email: response.emailVerification.email,
		verificationUUID: response.emailVerification.verificationUUID
	};
	if (response.smsVerification) return {
		isoCountryCode: response.smsVerification.isoCountryCode,
		phoneCountryCode: response.smsVerification.phoneCountryCode,
		phoneNumber: response.smsVerification.phoneNumber,
		verificationUUID: response.smsVerification.verificationUUID
	};
};

//#endregion
//#region src/modules/mfa/acknowledgeRecoveryCodes/acknowledgeRecoveryCodes.ts
/**
* Acknowledges that the user has viewed and saved their MFA recovery codes.
*
* This function marks the recovery codes as acknowledged, indicating that
* the user has properly backed up their MFA recovery codes for account recovery.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the acknowledgment is complete.
*/
const acknowledgeRecoveryCodes = async (client = getDefaultClient()) => {
	return updateUser({ userFields: { mfaBackupCodeAcknowledgement: MfaBackupCodeAcknowledgement.Complete } }, client);
};

//#endregion
//#region src/modules/mfa/authenticateMfaRecoveryCode/authenticateMfaRecoveryCode.ts
/**
* Authenticates using an MFA recovery code.
*
* This function allows users to bypass normal MFA requirements by using
* one of their backup recovery codes when none of the registered MFA methods are available.
*
* @param params.code - The recovery code to authenticate with.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the MFA authentication response with token.
*/
const authenticateMfaRecoveryCode = async ({ code, createMfaTokenOptions }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	try {
		const response = await apiClient.authMfaRecovery({
			environmentId: core.environmentId,
			mFAAuthRecoveryDevicePostRequest: {
				code,
				createMfaToken: createMfaTokenOptions
			}
		});
		updateAuthFromVerifyResponse({ response }, client);
		emitEvent({
			args: { mfaToken: response.mfaToken },
			event: "mfaCompletionSuccess"
		}, client);
		return response;
	} catch (error) {
		emitEvent({
			args: { error },
			event: "mfaCompletionFailure"
		}, client);
		throw error;
	}
};

//#endregion
//#region src/modules/auth/passkeys/getPasskeyAuthenticationOptions/getPasskeyAuthenticationOptions.ts
const getPasskeyAuthenticationOptions = async ({ relatedOriginRpId } = {}, client) => {
	const core = getCore(client);
	return await createApiClient({}, client).getPasskeyAuthenticationOptions({
		environmentId: core.environmentId,
		relatedOriginRpId
	});
};

//#endregion
//#region src/modules/auth/passkeys/serverAuthenticatePasskey/serverAuthenticatePasskey.ts
const serverAuthenticatePasskey = async ({ authentication, createMfaToken }, client) => {
	const core = getCore(client);
	return await createApiClient({}, client).authenticateMfaPasskeyDevice({
		environmentId: core.environmentId,
		passkeyAuthRequest: {
			...authentication,
			createMfaToken,
			response: {
				...authentication.response,
				clientDataJson: authentication.response.clientDataJSON
			}
		}
	});
};

//#endregion
//#region src/modules/mfa/authenticatePasskeyMFA/authenticatePasskeyMFA.ts
/**
* Authenticates using a passkey for multi-factor authentication.
*
* This function prompts the user to authenticate with their registered
* passkey to complete an MFA challenge and obtain an MFA token.
*
* @param [params.createMfaToken] - Optional configuration for MFA token creation.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the MFA authentication response.
* @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.
* @throws NoPasskeyCredentialsFoundError If no passkey credentials are found.
*/
const authenticatePasskeyMFA = async ({ createMfaToken, relatedOriginRpId } = {}, client = getDefaultClient()) => {
	const core = getCore(client);
	try {
		if (!core.passkey.isSupported()) throw new NoWebAuthNSupportError();
		const options = await getPasskeyAuthenticationOptions({ relatedOriginRpId }, client);
		const allowCredentials = options.allowCredentials?.map((credential) => ({
			...credential,
			type: "public-key"
		}));
		if (!allowCredentials?.length) throw new NoPasskeyCredentialsFoundError();
		const formattedOptions = {
			...options,
			allowCredentials
		};
		const response = await serverAuthenticatePasskey({
			authentication: await core.passkey.authenticate({ optionsJSON: formattedOptions }),
			createMfaToken
		}, client);
		updateAuthFromVerifyResponse({ response }, client);
		emitEvent({
			args: { mfaToken: response.mfaToken },
			event: "mfaCompletionSuccess"
		}, client);
		return response;
	} catch (error) {
		emitEvent({
			args: { error },
			event: "mfaCompletionFailure"
		}, client);
		throw error;
	}
};

//#endregion
//#region src/modules/mfa/authenticateTotpMfaDevice/authenticateTotpMfaDevice.ts
/**
* Authenticates using a TOTP (Time-based One-Time Password) MFA device.
*
* This function validates a TOTP code from an authenticator app and returns
* an MFA token upon successful authentication.
*
* @param params.code - The 6-digit TOTP code from the authenticator app.
* @param [params.deviceId] - The ID of the specific TOTP device to authenticate with.
* @param [params.createMfaTokenOptions] - Optional configuration for MFA token creation.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the MFA authentication response.
*/
const authenticateTotpMfaDevice = async ({ deviceId, code, createMfaTokenOptions }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	try {
		const response = await apiClient.authMfaTotpDevice({
			environmentId: core.environmentId,
			mFAAuthTotpDevicePostRequest: {
				code,
				createMfaToken: createMfaTokenOptions,
				id: deviceId
			}
		});
		updateAuthFromVerifyResponse({ response }, client);
		emitEvent({
			args: {
				deviceId,
				mfaToken: response.mfaToken
			},
			event: "mfaCompletionSuccess"
		}, client);
		return response;
	} catch (error) {
		emitEvent({
			args: {
				deviceId,
				error
			},
			event: "mfaCompletionFailure"
		}, client);
		throw error;
	}
};

//#endregion
//#region src/modules/mfa/createNewMfaRecoveryCodes/createNewMfaRecoveryCodes.ts
/**
* Generates new MFA recovery codes for the current user.
*
* This function creates a fresh set of backup codes that can be used
* to bypass MFA requirements if none of the registered MFA methods are available.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the newly generated recovery codes.
*/
const createNewMfaRecoveryCodes = async (client = getDefaultClient()) => {
	const core = getCore(client);
	return createApiClient({}, client).createNewRecoveryCodes({ environmentId: core.environmentId });
};

//#endregion
//#region src/modules/mfa/deleteMfaDevice/deleteMfaDevice.ts
/**
* Deletes a specific MFA device from the user's account.
*
* This function removes a multi-factor authentication device such as
* a TOTP authenticator from the user's registered devices.
*
* @param params.deviceId - The unique identifier of the MFA device to delete.
* @param params.mfaAuthToken - The MFA authentication token required for device deletion.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the MFA device is successfully deleted.
*/
const deleteMfaDevice = async ({ deviceId, mfaAuthToken }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	assertDefined(deviceId, "deviceId is required");
	assertDefined(mfaAuthToken, "mfaAuthToken is required");
	return apiClient.deleteMfaDevice({
		environmentId: core.environmentId,
		mfaDeviceId: deviceId,
		xMfaAuthToken: mfaAuthToken
	});
};

//#endregion
//#region src/modules/mfa/getMfaDevices/getMfaDevices.ts
/**
* Retrieves all MFA devices registered for the current user.
*
* This function fetches the list of multi-factor authentication devices
* associated with the user's account, such as TOTP authenticators.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an array of the user's registered MFA devices.
*/
const getMfaDevices = async (client = getDefaultClient()) => {
	const core = getCore(client);
	const { devices } = await createApiClient({}, client).getUserMfaDevices({ environmentId: core.environmentId });
	return devices;
};

//#endregion
//#region src/modules/mfa/getMfaRecoveryCodes/getMfaRecoveryCodes.ts
/**
* Retrieves the current MFA recovery codes for the user.
*
* This function fetches the backup codes that can be used to bypass
* MFA requirements if none of the registered MFA methods are available.
* If user doesn't have any recovery codes, it will create them,
* otherwise it will return the existing ones.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the user's MFA recovery codes.
*/
const getMfaRecoveryCodes = async (client = getDefaultClient()) => {
	const core = getCore(client);
	return createApiClient({}, client).getRecoveryCodes({ environmentId: core.environmentId });
};

//#endregion
//#region src/modules/mfa/isPendingRecoveryCodesAcknowledgment/isPendingRecoveryCodesAcknowledgment.ts
/**
* Checks if the user is still pending acknowledgment of their MFA recovery codes.
*
* This function determines whether the user has been presented with recovery
* codes that they have not yet acknowledged as saved or backed up.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns True if recovery codes are pending acknowledgment, false otherwise.
*/
const isPendingRecoveryCodesAcknowledgment = (client = getDefaultClient()) => {
	const user = client.user;
	assertDefined(user, "User not logged in");
	return user.mfaBackupCodeAcknowledgement !== MfaBackupCodeAcknowledgement.Complete;
};

//#endregion
//#region src/modules/mfa/isUserMissingMfaAuth/isUserMissingMfaAuth.ts
/**
* Checks if the user requires additional MFA authentication.
*
* This function determines if the current user session requires
* additional multi-factor authentication to access certain features.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns True if the user needs additional MFA authentication, false otherwise.
*/
const isUserMissingMfaAuth = (client = getDefaultClient()) => {
	const user = client.user;
	assertDefined(user, "User not logged in");
	return Boolean(user.scope?.includes("requiresAdditionalAuth"));
};

//#endregion
//#region src/modules/mfa/registerTotpMfaDevice/registerTotpMfaDevice.ts
/**
* Registers a new TOTP (Time-based One-Time Password) MFA device.
*
* This function initiates the registration of a TOTP authenticator app
* (like Google Authenticator or Authy) for multi-factor authentication.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the TOTP registration response containing setup information,
* like the secret key and the OTP Auth URI.
*/
const registerTotpMfaDevice = async (client = getDefaultClient()) => {
	const core = getCore(client);
	return createApiClient({}, client).registerTotpMfaDevice({ environmentId: core.environmentId });
};

//#endregion
//#region src/modules/mfa/setDefaultMfaDevice/setDefaultMfaDevice.ts
/**
* Sets the default MFA device for the current user.
*
* This function designates a specific MFA TOTP device as the primary method
* for multi-factor authentication challenges.
*
* @param params.deviceId - The unique identifier of the MFA device to set as default.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the default MFA device is successfully set.
*/
const setDefaultMfaDevice = async ({ deviceId }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	assertDefined(deviceId, "deviceId is required");
	return apiClient.updateUserMfaDevice({
		environmentId: core.environmentId,
		mfaDeviceId: deviceId
	});
};

//#endregion
//#region src/modules/otp/sendEmailOTP/sendEmailOTP.ts
/**
* Sends a one-time password (OTP) to the specified email address.
*
* Once you have the OTP code, you should then use `verifyOTP` to verify it and complete the authentication process.
*
* @param params.email - The email address to send the OTP to.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an OTPVerification object containing the email and verification UUID.
*/
const sendEmailOTP = async ({ email }, client = getDefaultClient()) => {
	const core = getCore(client);
	const { verificationUUID } = await createApiClient({}, client).createEmailVerification({
		emailVerificationCreateRequest: {
			captchaToken: consumeCaptchaToken(client),
			email
		},
		environmentId: core.environmentId
	});
	return {
		email,
		verificationUUID
	};
};

//#endregion
//#region src/modules/otp/sendSmsOTP/supportedCountries.ts
const supportedCountries = {
	AC: {
		code: "247",
		name: "Ascension"
	},
	AD: {
		code: "376",
		name: "Andorra"
	},
	AE: {
		code: "971",
		name: "United Arab Emirates"
	},
	AF: {
		code: "93",
		name: "Afghanistan"
	},
	AG: {
		code: "1268",
		name: "Antigua and Barbuda"
	},
	AI: {
		code: "1264",
		name: "Anguilla"
	},
	AL: {
		code: "355",
		name: "Albania"
	},
	AM: {
		code: "374",
		name: "Armenia"
	},
	AO: {
		code: "244",
		name: "Angola"
	},
	AR: {
		code: "54",
		name: "Argentina"
	},
	AS: {
		code: "1684",
		name: "American Samoa"
	},
	AT: {
		code: "43",
		name: "Austria"
	},
	AU: {
		code: "61",
		name: "Australia/Cocos/Christmas Island"
	},
	AW: {
		code: "297",
		name: "Aruba"
	},
	AZ: {
		code: "994",
		name: "Azerbaijan"
	},
	BA: {
		code: "387",
		name: "Bosnia and Herzegovina"
	},
	BB: {
		code: "1246",
		name: "Barbados"
	},
	BD: {
		code: "880",
		name: "Bangladesh"
	},
	BE: {
		code: "32",
		name: "Belgium"
	},
	BF: {
		code: "226",
		name: "Burkina Faso"
	},
	BG: {
		code: "359",
		name: "Bulgaria"
	},
	BH: {
		code: "973",
		name: "Bahrain"
	},
	BI: {
		code: "257",
		name: "Burundi"
	},
	BJ: {
		code: "229",
		name: "Benin"
	},
	BM: {
		code: "1441",
		name: "Bermuda"
	},
	BN: {
		code: "673",
		name: "Brunei"
	},
	BO: {
		code: "591",
		name: "Bolivia"
	},
	BR: {
		code: "55",
		name: "Brazil"
	},
	BS: {
		code: "1242",
		name: "Bahamas"
	},
	BT: {
		code: "975",
		name: "Bhutan"
	},
	BW: {
		code: "267",
		name: "Botswana"
	},
	BY: {
		code: "375",
		name: "Belarus"
	},
	BZ: {
		code: "501",
		name: "Belize"
	},
	CA: {
		code: "1",
		name: "Canada"
	},
	CD: {
		code: "243",
		name: "Congo, Dem Rep"
	},
	CF: {
		code: "236",
		name: "Central Africa"
	},
	CG: {
		code: "242",
		name: "Congo"
	},
	CH: {
		code: "41",
		name: "Switzerland"
	},
	CI: {
		code: "225",
		name: "Ivory Coast"
	},
	CK: {
		code: "682",
		name: "Cook Islands"
	},
	CL: {
		code: "56",
		name: "Chile"
	},
	CM: {
		code: "237",
		name: "Cameroon"
	},
	CN: {
		code: "86",
		name: "China"
	},
	CO: {
		code: "57",
		name: "Colombia"
	},
	CR: {
		code: "506",
		name: "Costa Rica"
	},
	CU: {
		code: "53",
		name: "Cuba"
	},
	CV: {
		code: "238",
		name: "Cape Verde"
	},
	CW: {
		code: "599",
		name: "CuraÃ§ao and Caribbean Netherlands (Bonaire, Sint Eustatius, Sint Maarten, Saba)"
	},
	CY: {
		code: "357",
		name: "Cyprus"
	},
	CZ: {
		code: "420",
		name: "Czech Republic"
	},
	DE: {
		code: "49",
		name: "Germany"
	},
	DJ: {
		code: "253",
		name: "Djibouti"
	},
	DK: {
		code: "45",
		name: "Denmark"
	},
	DM: {
		code: "1767",
		name: "Dominica"
	},
	DO: {
		code: "1829",
		name: "Dominican Republic"
	},
	DZ: {
		code: "213",
		name: "Algeria"
	},
	EC: {
		code: "593",
		name: "Ecuador"
	},
	EE: {
		code: "372",
		name: "Estonia"
	},
	EG: {
		code: "20",
		name: "Egypt"
	},
	ER: {
		code: "291",
		name: "Eritrea"
	},
	ES: {
		code: "34",
		name: "Spain"
	},
	ET: {
		code: "251",
		name: "Ethiopia"
	},
	FI: {
		code: "358",
		name: "Finland/Aland Islands"
	},
	FJ: {
		code: "679",
		name: "Fiji"
	},
	FK: {
		code: "500",
		name: "Falkland Islands"
	},
	FM: {
		code: "691",
		name: "Micronesia"
	},
	FO: {
		code: "298",
		name: "Faroe Islands"
	},
	FR: {
		code: "33",
		name: "France"
	},
	GA: {
		code: "241",
		name: "Gabon"
	},
	GB: {
		code: "44",
		name: "United Kingdom"
	},
	GD: {
		code: "1473",
		name: "Grenada"
	},
	GE: {
		code: "995",
		name: "Georgia"
	},
	GF: {
		code: "594",
		name: "French Guiana"
	},
	GG: {
		code: "44",
		name: "Guernsey/Jersey"
	},
	GH: {
		code: "233",
		name: "Ghana"
	},
	GI: {
		code: "350",
		name: "Gibraltar"
	},
	GL: {
		code: "299",
		name: "Greenland"
	},
	GM: {
		code: "220",
		name: "Gambia"
	},
	GN: {
		code: "224",
		name: "Guinea"
	},
	GP: {
		code: "590",
		name: "Guadeloupe"
	},
	GQ: {
		code: "240",
		name: "Equatorial Guinea"
	},
	GR: {
		code: "30",
		name: "Greece"
	},
	GT: {
		code: "502",
		name: "Guatemala"
	},
	GU: {
		code: "1671",
		name: "Guam"
	},
	GW: {
		code: "245",
		name: "Guinea-Bissau"
	},
	GY: {
		code: "592",
		name: "Guyana"
	},
	HK: {
		code: "852",
		name: "Hong Kong"
	},
	HN: {
		code: "504",
		name: "Honduras"
	},
	HR: {
		code: "385",
		name: "Croatia"
	},
	HT: {
		code: "509",
		name: "Haiti"
	},
	HU: {
		code: "36",
		name: "Hungary"
	},
	IC: {
		code: "3491",
		name: "Canary Islands"
	},
	ID: {
		code: "62",
		name: "Indonesia"
	},
	IE: {
		code: "353",
		name: "Ireland"
	},
	IL: {
		code: "972",
		name: "Israel"
	},
	IM: {
		code: "44",
		name: "Isle of Man"
	},
	IN: {
		code: "91",
		name: "India"
	},
	IQ: {
		code: "964",
		name: "Iraq"
	},
	IR: {
		code: "98",
		name: "Iran"
	},
	IS: {
		code: "354",
		name: "Iceland"
	},
	IT: {
		code: "39",
		name: "Italy"
	},
	JM: {
		code: "1876",
		name: "Jamaica"
	},
	JO: {
		code: "962",
		name: "Jordan"
	},
	JP: {
		code: "81",
		name: "Japan"
	},
	KE: {
		code: "254",
		name: "Kenya"
	},
	KG: {
		code: "996",
		name: "Kyrgyzstan"
	},
	KH: {
		code: "855",
		name: "Cambodia"
	},
	KI: {
		code: "686",
		name: "Kiribati"
	},
	KM: {
		code: "269",
		name: "Comoros"
	},
	KN: {
		code: "1869",
		name: "St Kitts and Nevis"
	},
	KP: {
		code: "850",
		name: "Korea Dem People's Rep"
	},
	KR: {
		code: "82",
		name: "Korea Republic of"
	},
	KW: {
		code: "965",
		name: "Kuwait"
	},
	KY: {
		code: "1345",
		name: "Cayman Islands"
	},
	LA: {
		code: "856",
		name: "Laos PDR"
	},
	LB: {
		code: "961",
		name: "Lebanon"
	},
	LC: {
		code: "1758",
		name: "St Lucia"
	},
	LI: {
		code: "423",
		name: "Liechtenstein"
	},
	LK: {
		code: "94",
		name: "Sri Lanka"
	},
	LR: {
		code: "231",
		name: "Liberia"
	},
	LS: {
		code: "266",
		name: "Lesotho"
	},
	LT: {
		code: "370",
		name: "Lithuania"
	},
	LU: {
		code: "352",
		name: "Luxembourg"
	},
	LV: {
		code: "371",
		name: "Latvia"
	},
	LY: {
		code: "218",
		name: "Libya"
	},
	MA: {
		code: "212",
		name: "Morocco/Western Sahara"
	},
	MC: {
		code: "377",
		name: "Monaco"
	},
	MD: {
		code: "373",
		name: "Moldova"
	},
	ME: {
		code: "382",
		name: "Montenegro"
	},
	MG: {
		code: "261",
		name: "Madagascar"
	},
	MH: {
		code: "692",
		name: "Marshall Islands"
	},
	MK: {
		code: "389",
		name: "Republic of North Macedonia"
	},
	ML: {
		code: "223",
		name: "Mali"
	},
	MM: {
		code: "95",
		name: "Myanmar (Burma)"
	},
	MN: {
		code: "976",
		name: "Mongolia"
	},
	MO: {
		code: "853",
		name: "Macau"
	},
	MP: {
		code: "1670",
		name: "Northern Mariana Islands"
	},
	MQ: {
		code: "596",
		name: "Martinique"
	},
	MR: {
		code: "222",
		name: "Mauritania"
	},
	MS: {
		code: "1664",
		name: "Montserrat"
	},
	MT: {
		code: "356",
		name: "Malta"
	},
	MU: {
		code: "230",
		name: "Mauritius"
	},
	MV: {
		code: "960",
		name: "Maldives"
	},
	MW: {
		code: "265",
		name: "Malawi"
	},
	MX: {
		code: "52",
		name: "Mexico"
	},
	MY: {
		code: "60",
		name: "Malaysia"
	},
	MZ: {
		code: "258",
		name: "Mozambique"
	},
	NA: {
		code: "264",
		name: "Namibia"
	},
	NC: {
		code: "687",
		name: "New Caledonia"
	},
	NE: {
		code: "227",
		name: "Niger"
	},
	NF: {
		code: "672",
		name: "Norfolk Island"
	},
	NG: {
		code: "234",
		name: "Nigeria"
	},
	NI: {
		code: "505",
		name: "Nicaragua"
	},
	NL: {
		code: "31",
		name: "Netherlands"
	},
	NO: {
		code: "47",
		name: "Norway"
	},
	NP: {
		code: "977",
		name: "Nepal"
	},
	NU: {
		code: "683",
		name: "Niue"
	},
	NZ: {
		code: "64",
		name: "New Zealand"
	},
	OM: {
		code: "968",
		name: "Oman"
	},
	PA: {
		code: "507",
		name: "Panama"
	},
	PE: {
		code: "51",
		name: "Peru"
	},
	PF: {
		code: "689",
		name: "French Polynesia"
	},
	PG: {
		code: "675",
		name: "Papua New Guinea"
	},
	PH: {
		code: "63",
		name: "Philippines"
	},
	PK: {
		code: "92",
		name: "Pakistan"
	},
	PL: {
		code: "48",
		name: "Poland"
	},
	PM: {
		code: "508",
		name: "St Pierre and Miquelon"
	},
	PR: {
		code: "1787",
		name: "Puerto Rico"
	},
	PS: {
		code: "970, 972",
		name: "Palestinian Territory"
	},
	PT: {
		code: "351",
		name: "Portugal"
	},
	PW: {
		code: "680",
		name: "Palau"
	},
	PY: {
		code: "595",
		name: "Paraguay"
	},
	QA: {
		code: "974",
		name: "Qatar"
	},
	RE: {
		code: "262",
		name: "Reunion/Mayotte"
	},
	RO: {
		code: "40",
		name: "Romania"
	},
	RS: {
		code: "381",
		name: "Serbia"
	},
	RU: {
		code: "7",
		name: "Russia/Kazakhstan"
	},
	RW: {
		code: "250",
		name: "Rwanda"
	},
	SA: {
		code: "966",
		name: "Saudi Arabia"
	},
	SB: {
		code: "677",
		name: "Solomon Islands"
	},
	SC: {
		code: "248",
		name: "Seychelles"
	},
	SD: {
		code: "249",
		name: "Sudan"
	},
	SE: {
		code: "46",
		name: "Sweden"
	},
	SG: {
		code: "65",
		name: "Singapore"
	},
	SI: {
		code: "386",
		name: "Slovenia"
	},
	SK: {
		code: "421",
		name: "Slovakia"
	},
	SL: {
		code: "232",
		name: "Sierra Leone"
	},
	SM: {
		code: "378",
		name: "San Marino"
	},
	SN: {
		code: "221",
		name: "Senegal"
	},
	SO: {
		code: "252",
		name: "Somalia"
	},
	SR: {
		code: "597",
		name: "Suriname"
	},
	SS: {
		code: "211",
		name: "South Sudan"
	},
	ST: {
		code: "239",
		name: "Sao Tome and Principe"
	},
	SV: {
		code: "503",
		name: "El Salvador"
	},
	SY: {
		code: "963",
		name: "Syria"
	},
	SZ: {
		code: "268",
		name: "Swaziland"
	},
	TC: {
		code: "1649",
		name: "Turks and Caicos Islands"
	},
	TD: {
		code: "235",
		name: "Chad"
	},
	TG: {
		code: "228",
		name: "Togo"
	},
	TH: {
		code: "66",
		name: "Thailand"
	},
	TJ: {
		code: "992",
		name: "Tajikistan"
	},
	TL: {
		code: "670",
		name: "East Timor"
	},
	TM: {
		code: "993",
		name: "Turkmenistan"
	},
	TN: {
		code: "216",
		name: "Tunisia"
	},
	TO: {
		code: "676",
		name: "Tonga"
	},
	TR: {
		code: "90",
		name: "Turkiye"
	},
	TT: {
		code: "1868",
		name: "Trinidad and Tobago"
	},
	TV: {
		code: "688",
		name: "Tuvalu"
	},
	TW: {
		code: "886",
		name: "Taiwan"
	},
	TZ: {
		code: "255",
		name: "Tanzania"
	},
	UA: {
		code: "380",
		name: "Ukraine"
	},
	UG: {
		code: "256",
		name: "Uganda"
	},
	US: {
		code: "1",
		name: "United States"
	},
	UY: {
		code: "598",
		name: "Uruguay"
	},
	UZ: {
		code: "998",
		name: "Uzbekistan"
	},
	VA: {
		code: "379",
		name: "Vatican City"
	},
	VC: {
		code: "1784",
		name: "St Vincent Grenadines"
	},
	VE: {
		code: "58",
		name: "Venezuela"
	},
	VG: {
		code: "1284",
		name: "Virgin Islands, British"
	},
	VI: {
		code: "1340",
		name: "Virgin Islands, U.S."
	},
	VN: {
		code: "84",
		name: "Vietnam"
	},
	VU: {
		code: "678",
		name: "Vanuatu"
	},
	WF: {
		code: "681",
		name: "Wallis and Futuna"
	},
	WS: {
		code: "685",
		name: "Samoa"
	},
	XK: {
		code: "383",
		name: "Kosovo"
	},
	YE: {
		code: "967",
		name: "Yemen"
	},
	ZA: {
		code: "27",
		name: "South Africa"
	},
	ZM: {
		code: "260",
		name: "Zambia"
	},
	ZW: {
		code: "263",
		name: "Zimbabwe"
	}
};

//#endregion
//#region src/modules/otp/sendSmsOTP/sendSmsOTP.ts
/**
* Sends a one-time password (OTP) via SMS to the specified phone number.
*
* @param params.isoCountryCode - The ISO country code for the phone number (e.g., 'US', 'CA', 'GB').
* @param params.phoneNumber - The phone number to send the OTP to.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an OTPVerification object containing the phone details and verification UUID.
*/
const sendSmsOTP = async ({ isoCountryCode, phoneNumber }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const phoneCountryCode = supportedCountries[isoCountryCode].code;
	const { verificationUUID } = await apiClient.createSmsVerification({
		environmentId: core.environmentId,
		smsVerificationCreateRequest: {
			captchaToken: consumeCaptchaToken(client),
			isoCountryCode,
			phoneCountryCode,
			phoneNumber
		}
	});
	return {
		isoCountryCode,
		phoneCountryCode,
		phoneNumber,
		verificationUUID
	};
};

//#endregion
//#region src/modules/otp/verifyOTP/verifyOTPForUserSignIn/verifyOTPForUserSignIn.ts
const verifyOTPForUserSignIn = async ({ otpVerification, verificationToken }, client) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const verifyRequest = {
		verificationToken,
		verificationUUID: otpVerification.verificationUUID
	};
	if (otpVerification.email) return apiClient.signInWithEmailVerification({
		emailVerificationVerifyRequest: verifyRequest,
		environmentId: core.environmentId
	});
	return apiClient.signInWithSmsVerification({
		environmentId: core.environmentId,
		smsVerificationVerifyRequest: verifyRequest
	});
};

//#endregion
//#region src/modules/otp/verifyOTP/verifyOTPForUserUpdate/verifyOTPForUserUpdate.ts
const verifyOTPForUserUpdate = async ({ otpVerification, verificationToken }, client) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const verifyRequest = {
		verificationToken,
		verificationUUID: otpVerification.verificationUUID
	};
	if (otpVerification.email) return apiClient.verifyEmailVerification({
		emailVerificationVerifyRequest: verifyRequest,
		environmentId: core.environmentId
	});
	return apiClient.verifySmsVerification({
		environmentId: core.environmentId,
		smsVerificationVerifyRequest: verifyRequest
	});
};

//#endregion
//#region src/modules/otp/verifyOTP/verifyOTP.ts
/**
* Verifies a one-time password (OTP) for user authentication or updates.
*
* This function validates the OTP code provided by the user and completes
* the verification process for either sign-in or account updates.
*
* @param params.otpVerification - The OTP verification object containing verification details.
* @param params.verificationToken - The token received from the OTP verification process.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the verify response object upon successful verification.
*/
const verifyOTP = async ({ otpVerification, verificationToken }, client = getDefaultClient()) => {
	const response = await (client.user ? verifyOTPForUserUpdate : verifyOTPForUserSignIn)({
		otpVerification,
		verificationToken
	}, client);
	updateAuthFromVerifyResponse({ response }, client);
	return response;
};

//#endregion
//#region src/modules/user/deleteUser/deleteUser.ts
/**
* Deletes the current user's account permanently.
*
* This function performs a hard delete of the user account. Upon successful deletion,
* the user will be automatically logged out and all authentication data will be cleared.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the user account is successfully deleted.
*/
const deleteUser = async (client = getDefaultClient()) => {
	const core = getCore(client);
	await createApiClient({ includeMfaToken: true }, client).hardDeleteUser({ environmentId: core.environmentId });
	await logout(client);
};

//#endregion
//#region src/modules/user/refreshUser/refreshUser.ts
/**
* Refreshes the current user's data from the server.
*
* This function fetches the latest authenticated user information from the backend
* and updates the local user state.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the authenticated user.
*/
const refreshUser = async (client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const previousState = { ...core.state.get() };
	const user = await apiClient.getAuthenticatedUser({ environmentId: core.environmentId });
	core.state.set({ user });
	checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);
	return user;
};

//#endregion
//#region src/modules/wallets/assertWalletAccountSigningAvailability/assertWalletAccountSigningAvailability.ts
/**
* Asserts that a wallet account is available and ready for signing operations.
*
* This function verifies that the specified wallet account is currently
* connected and selected in the wallet app, ensuring it can perform signing operations.
*
* If the wallet account is not available, the user might need to reconnect it or
* change the account in their wallet app to make it active.
*
* @param params.walletAccount - The wallet account to verify signing availability for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves if the wallet is available for signing.
* @throws WalletAccountNotSelectedError If the wallet account is not currently selected.
*/
const assertWalletAccountSigningAvailability = async ({ walletAccount }, client = getDefaultClient()) => {
	const { addresses } = await getWalletProviderFromWalletAccount({ walletAccount }, client).getConnectedAddresses();
	if (addresses.length > 0 && !addresses.includes(walletAccount.address)) throw new WalletAccountNotSelectedError({
		expectedAddress: walletAccount.address,
		selectedAddress: addresses[0]
	});
};

//#endregion
//#region src/modules/wallets/utils/assertWalletProviderMethodDefined/assertWalletProviderMethodDefined.ts
/**
* Asserts that a specific wallet provider method is defined, throwing an error if it's not.
* This function acts as a type guard, narrowing the type to ensure the method exists.
*
* @template T - The specific wallet provider method key being checked
* @param walletProvider - The wallet provider object to check
* @param methodName - The name of the method to check for availability
* @throws Throws WalletProviderMethodUnavailableError if the method is not defined
* @example
* ```typescript
* const walletProvider: WalletProvider = getWalletProvider();
* assertWalletProviderMethodDefined(walletProvider, 'connect');
* // walletProvider.connect is now guaranteed to be defined
* await walletProvider.connect();
* ```
*/
function assertWalletProviderMethodDefined(walletProvider, methodName) {
	if (walletProvider[methodName] === void 0) throw new WalletProviderMethodUnavailableError({
		methodName,
		walletProviderKey: walletProvider.key
	});
}

//#endregion
//#region src/modules/wallets/utils/getAddressesWithTypesFromConnectionResult/getAddressesWithTypesFromConnectionResult.ts
const getAddressesWithTypesFromConnectionResult = (connectionResult) => {
	return connectionResult.addresses.filter((address) => !!address.address && !!address.type);
};

//#endregion
//#region src/modules/wallets/connectWithWalletProvider/connectWithWalletProvider.ts
/**
* Connects to a wallet provider and returns the connected wallet account.
*
* Note: This function will not verify the wallet account, use the verifyWalletAccount function to do that
* or connectAndVerifyWithWalletProvider to do that in a single step.
* @see verifyWalletAccount
* @see connectAndVerifyWithWalletProvider
*
* @param params.walletProviderKey - The unique key identifying the wallet provider to connect to (e.g. 'metamaskevm', 'phantomsol').
* @param [params.addToDynamicWalletAccounts] - Whether to add the connected wallet account to the user's wallet accounts. Defaults to true.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the connected wallet account.
* @throws NoAddressFoundError If the request to connect was successful but no address is connected to your app.
*/
const connectWithWalletProvider = async ({ walletProviderKey, addToDynamicWalletAccounts = true }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);
	assertWalletProviderMethodDefined(walletProvider, "connect");
	const { addresses } = await walletProvider.connect();
	const currentAddresses = getWalletAccounts(client).map(({ address }) => address);
	const mainAddress = addresses?.length ? addresses[0].address : null;
	/**
	* This error is thrown in case the wallet has no addresses connected
	* to the dapp. Then the error is thrown so the consumer can instruct the
	* user on the next steps.
	*/
	if (!mainAddress) throw new NoAddressFoundError();
	const walletAccount = {
		address: mainAddress,
		addressesWithTypes: getAddressesWithTypesFromConnectionResult({ addresses }),
		chain: walletProvider.chain,
		id: formatWalletAccountId({
			address: mainAddress,
			chain: walletProvider.chain,
			walletProviderKey
		}),
		lastSelectedAt: null,
		verifiedCredentialId: null,
		walletProviderKey
	};
	if (currentAddresses.includes(mainAddress)) return walletAccount;
	if (addToDynamicWalletAccounts) {
		setUnverifiedWalletAccounts({ unverifiedWalletAccountsToUpdate: [walletAccount] }, client);
		emitWalletAccountsChangedEvent(client);
		createVisit({ walletAccount }, client);
	}
	return walletAccount;
};

//#endregion
//#region src/modules/wallets/utils/getChainIdForAccountVerification/getChainIdForAccountVerification.ts
const getChainIdForAccountVerification = async ({ walletProvider }) => {
	if ([
		"BTC",
		"SOL",
		"SUI"
	].includes(walletProvider.chain)) return;
	const { networkId } = await walletProvider.getActiveNetworkId();
	if (networkId) return networkId;
	if (walletProvider.chain === "EVM") return "1";
};

//#endregion
//#region src/modules/wallets/utils/getSignInMessage/getSignInMessage.ts
const getSignInMessage = async ({ walletAccount }, client) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	const appUrl = core.metadata?.url;
	assertDefined(appUrl, "App URL is not set");
	const url = new URL(appUrl);
	const { nonce } = await apiClient.getNonce({ environmentId: core.environmentId });
	assertDefined(nonce, "Failed to get nonce");
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	const statement = createSignInMessageStatement(client);
	return await formatSignInMessage({
		address: walletAccount.address,
		blockchainName: CHAINS_INFO_MAP[walletProvider.chain].blockchainName,
		chainId: await getChainIdForAccountVerification({ walletProvider }),
		domain: url.host,
		issuedAt: (/* @__PURE__ */ new Date()).toISOString(),
		nonce,
		requestId: core.environmentId,
		statement,
		uri: url.toString()
	});
};

//#endregion
//#region src/modules/wallets/proveWalletAccountOwnership/proveWalletAccountOwnership.ts
/**
* Proves ownership of a wallet account by signing a verification message.
*
* This function generates a sign-in message and requires the user to sign it
* with their wallet's private key, proving they control the wallet address.
*
* @param params.walletAccount - The wallet account to prove ownership of.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an object containing the message and signature.
*/
const proveWalletAccountOwnership = async ({ walletAccount }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	assertWalletProviderMethodDefined(walletProvider, "signMessage");
	const messageToSign = await getSignInMessage({ walletAccount }, client);
	const { signature } = await walletProvider.signMessage({
		message: messageToSign,
		walletAccount
	});
	return {
		messageToSign,
		signature
	};
};

//#endregion
//#region src/modules/wallets/utils/isSameAddress/isSameAddress.ts
const isSameAddress = (left, right, chain) => normalizeAddress(left, chain) === normalizeAddress(right, chain);

//#endregion
//#region src/modules/wallets/verifyWalletAccountForSignInOrTransfer/verifyWalletAccountForSignInOrTransfer.ts
const verifyWalletAccountForSignInOrTransfer = async ({ walletAccount, isTransfer }, client) => {
	if (walletAccount.verifiedCredentialId) throw new WalletAccountAlreadyVerifiedError(walletAccount.address);
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	const { messageToSign, signature } = await proveWalletAccountOwnership({ walletAccount }, client);
	const response = await verifyMessageSignatureOwnership({
		addressesWithTypes: walletAccount.addressesWithTypes,
		chain: walletAccount.chain,
		isTransfer,
		messageToSign,
		signature,
		walletAddress: walletAccount.address,
		walletDisplayName: walletProvider.metadata.displayName,
		walletProviderType: walletProvider.walletProviderType
	}, client);
	const walletVerifiedCredential = response.user?.verifiedCredentials.find((verifiedCredential) => isSameAddress(verifiedCredential.address ?? "", walletAccount.address, walletAccount.chain));
	assertDefined(walletVerifiedCredential, `After verifying, still unable to find verified wallet credential for wallet account ${walletAccount.address} on chain ${walletAccount.chain}`);
	updateWalletProviderKeysForVerifiedCredentials({ keysToUpdate: { [walletVerifiedCredential.id]: walletProvider.key } }, client);
	/**
	* Adds the user with the new wallet verified credential
	* This will add the new verified wallet account to the client`s state
	*/
	updateAuthFromVerifyResponse({ response }, client);
	/**
	* Remove the now verified wallet account from the unverified wallet accounts
	*/
	removeUnverifiedWalletAccount({ unverifiedWalletAccount: walletAccount }, client);
	const verifiedWalletAccount = getWalletAccounts(client).find(({ address }) => isSameAddress(address, walletAccount.address, walletAccount.chain));
	assertDefined(verifiedWalletAccount, `Unable to find wallet account ${walletAccount.address} on chain ${walletAccount.chain} for verified credential ${walletVerifiedCredential.id}`);
	return verifiedWalletAccount;
};

//#endregion
//#region src/modules/wallets/verifyWalletAccount/verifyWalletAccount.ts
/**
* Verifies ownership of a wallet account and adds it to the user's profile.
*
* This function requires the user to sign a message to prove wallet ownership,
* then sets the wallet account as verified.
*
* @param params.walletAccount - The wallet account to verify ownership of.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the verified wallet account.
* @throws WalletAccountAlreadyVerifiedError If the wallet is already verified.
* @throws WalletAlreadyLinkedToAnotherUserError If the wallet is linked to another user.
*/
const verifyWalletAccount = async ({ walletAccount }, client = getDefaultClient()) => {
	return verifyWalletAccountForSignInOrTransfer({
		isTransfer: false,
		walletAccount
	}, client);
};

//#endregion
//#region src/modules/wallets/connectAndVerifyWithWalletProvider/connectAndVerifyWithWalletProvider.ts
/**
* Connects to a wallet provider and verifies ownership through message signing.
*
* This function combines wallet connection and verification in a single step,
* requiring the user to sign a message to prove wallet ownership before
* the wallet account is added to their profile.
*
* @param params.walletProviderKey - The unique key identifying the wallet provider to connect to.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the connected and verified wallet account.
*/
const connectAndVerifyWithWalletProvider = async ({ walletProviderKey }, client = getDefaultClient()) => {
	const walletAccount = await connectWithWalletProvider({
		addToDynamicWalletAccounts: false,
		walletProviderKey
	}, client);
	await verifyWalletAccount({ walletAccount }, client);
	createVisit({
		authMode: AuthModeEnum.AndSign,
		walletAccount
	}, client);
	return walletAccount;
};

//#endregion
//#region src/modules/wallets/getAvailableWalletProvidersData/getAvailableWalletProvidersData.ts
/**
* Retrieves data for all available wallet providers that can be used for connection.
*
* This function returns metadata about wallet providers that users can
* connect to, like MetaMask, Phantom, etc.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns An array of wallet provider data including chain, keys, and metadata.
*/
const getAvailableWalletProvidersData = (client = getDefaultClient()) => {
	return getWalletProviders(client).filter((walletProvider) => Boolean(walletProvider.connect)).map((walletProvider) => ({
		chain: walletProvider.chain,
		groupKey: walletProvider.groupKey,
		key: walletProvider.key,
		metadata: walletProvider.metadata,
		walletProviderType: walletProvider.walletProviderType
	}));
};

//#endregion
//#region src/modules/wallets/getConnectedAddresses/getConnectedAddresses.ts
/**
* Retrieves all connected addresses for a specific wallet provider.
*
* This function returns the list of wallet addresses that are currently
* connected and available through the specified wallet provider.
*
* @param params.walletProviderKey - The unique key of the wallet provider to query.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns An array of connected wallet addresses.
*/
const getConnectedAddresses = ({ walletProviderKey }, client = getDefaultClient()) => {
	return getWalletProviderByKey({ walletProviderKey }, client).getConnectedAddresses();
};

//#endregion
//#region src/modules/wallets/getOwnerWalletAccountForSmartWalletAccount/getOwnerWalletAccountForSmartWalletAccount.ts
const getOwnerWalletAccountForSmartWalletAccount = ({ smartWalletAccount }, client = getDefaultClient()) => {
	const smartWalletVerifiedCredential = getVerifiedCredentialForWalletAccount({ walletAccount: smartWalletAccount }, client);
	assertDefined(smartWalletVerifiedCredential?.signerRefId, "Invalid smart wallet account");
	return getWalletAccounts(client).find((walletAccount) => walletAccount.verifiedCredentialId === smartWalletVerifiedCredential.signerRefId);
};

//#endregion
//#region src/modules/wallets/getWalletAccountAddressByType/getWalletAccountAddressByType.ts
const getWalletAccountAddressByType = ({ type, walletAccount }) => {
	return walletAccount.addressesWithTypes?.find((address) => address.type === type)?.address;
};

//#endregion
//#region src/modules/wallets/getWalletProviderDataByKey/getWalletProviderDataByKey.ts
/**
* Retrieves data for a specific wallet provider that can be used for display or connection.
*
* @param params.walletProviderKey - The key of the wallet provider to retrieve data for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns The data for the wallet provider.
*/
const getWalletProviderDataByKey = ({ walletProviderKey }, client = getDefaultClient()) => {
	const { chain, groupKey, key, metadata, walletProviderType } = getWalletProviderByKey({ walletProviderKey }, client);
	return {
		chain,
		groupKey,
		key,
		metadata,
		walletProviderType
	};
};

//#endregion
//#region src/modules/wallets/isWalletAccountVerified/isWalletAccountVerified.ts
/**
* Checks if a wallet account has been verified by a user.
*
* @param walletAccount - The wallet account to check.
* @returns True if the wallet account has been verified, false otherwise.
*/
const isWalletAccountVerified = ({ walletAccount }) => {
	return walletAccount.verifiedCredentialId !== null;
};

//#endregion
//#region src/modules/wallets/networks/addNetwork/addNetwork.ts
/**
* Adds a network to the wallet provider.
*
* This function requests that the wallet provider add a network
* to its list of available networks.
*
* @param params.networkData - The network configuration data to add to the wallet.
* @param params.walletAccount - The wallet account to add the network for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the network addition is complete.
* @throws NetworkAddingUnavailableError If the wallet provider doesn't support adding networks.
*/
const addNetwork = async ({ networkData, walletAccount }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderByKey({ walletProviderKey: walletAccount.walletProviderKey }, client);
	if (walletProvider.addNetwork === void 0) throw new NetworkAddingUnavailableError({
		extraMessages: [`Wallet provider ${walletAccount.walletProviderKey} does not have addNetwork method`],
		originalError: null,
		walletProviderKey: walletAccount.walletProviderKey
	});
	return walletProvider.addNetwork({ networkData });
};

//#endregion
//#region src/modules/wallets/networks/getActiveNetworkData/getActiveNetworkData.ts
/**
* Retrieves the network configuration data for the currently active network.
*
* This function returns detailed network information including RPC URLs,
* native currency details, and block explorer URLs for the network that
* the wallet account is currently connected to.
*
* @param params.walletAccount - The wallet account to get network data for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the network data, or undefined if not found.
*/
const getActiveNetworkData = async ({ walletAccount }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	const { networkId } = await walletProvider.getActiveNetworkId();
	return { networkData: getNetworksData(client).find((data) => data.networkId === networkId && data.chain === walletProvider.chain) };
};

//#endregion
//#region src/modules/wallets/networks/getActiveNetworkId/getActiveNetworkId.ts
/**
* This function returns the network identifier that this wallet account's provider is currently connected to.
*
* @param params.walletAccount - The wallet account to get the network ID for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the active network ID for the wallet account.
*/
const getActiveNetworkId = ({ walletAccount }, client = getDefaultClient()) => {
	return getWalletProviderFromWalletAccount({ walletAccount }, client).getActiveNetworkId();
};

//#endregion
//#region src/modules/wallets/networks/getBalance/getBalance.ts
/**
* Retrieves the native token balance for a wallet account.
*
* This function fetches the balance of the native cryptocurrency
* (e.g., ETH, SOL, BTC, etc.) for the specified wallet account.
*
* @param params.walletAccount - The wallet account to get the balance for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an object containing the balance as a string or null.
*/
const getBalance = async ({ walletAccount }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	const { networkId } = await walletProvider.getActiveNetworkId();
	return getNetworkProviderFromNetworkId({
		chain: walletProvider.chain,
		networkId
	}, client).getBalance({ address: walletAccount.address });
};

//#endregion
//#region src/modules/wallets/networks/getBalanceForAddress/getBalanceForAddress.ts
/**
* Retrieves the native token balance for a specific address on a given network.
*
* This function queries the balance directly for any address without requiring
* a connected wallet account, useful for checking balances of external addresses.
*
* @param params.address - The wallet address to check the balance for.
* @param params.chain - The chain (e.g., 'EVM', 'SOL').
* @param params.networkId - The specific network ID within the chain.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an object containing the balance as a string or null.
*/
const getBalanceForAddress = async ({ address, chain, networkId }, client = getDefaultClient()) => {
	const networkProvider = getNetworkProviderFromNetworkId({
		chain,
		networkId
	}, client);
	assertDefined(networkProvider, `No network found for chain ${chain} and network id ${networkId}. Please ensure you've enabled this network in the Dashboard.`);
	return networkProvider.getBalance({ address });
};

//#endregion
//#region src/modules/wallets/networks/getTransactionHistory/getTransactionHistory.ts
/**
* Retrieves the transaction history for a given wallet address, chain and network.
*
* This function fetches the transaction history for a specified wallet address and chain,
* returning a list of transactions associated with that address along with nextOffset for pagination.
*
* @param params.address - The wallet address to query transactions for.
* @param params.chain - The chain to query transactions for.
* @param [params.limit] - The maximum number of transactions to return.
* @param params.networkId - The network ID to query transactions for.
* @param [params.offset] - The offset to use for pagination.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the transaction history along with nextOffset for the given wallet address and chain.
*/
const getTransactionHistory = async (params, client = getDefaultClient()) => {
	const core = getCore(client);
	return await createApiClient({}, client).getWalletTransactions({
		address: params.address,
		chainName: params.chain,
		environmentId: core.environmentId,
		networkId: params.networkId
	});
};

//#endregion
//#region src/modules/wallets/networks/isProgrammaticNetworkSwitchAvailable/isProgrammaticNetworkSwitchAvailable.ts
/**
* Checks if programmatic network switching is available for a wallet account.
*
* This function determines whether the wallet provider supports automatic
* network switching without requiring the user to manually switch networks on their wallet app.
*
* @param params.walletAccount - The wallet account to check network switching support for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns True if programmatic network switching is available, false otherwise.
*/
const isProgrammaticNetworkSwitchAvailable = ({ walletAccount }, client = getDefaultClient()) => {
	return getWalletProviderByKey({ walletProviderKey: walletAccount.walletProviderKey }, client).switchActiveNetwork !== void 0;
};

//#endregion
//#region src/modules/wallets/networks/switchActiveNetwork/switchActiveNetwork.ts
/**
* Switches the active network for a wallet account.
*
* This function programmatically changes the network
* that the wallet is currently connected to.
*
* @param params.networkId - The identifier of the network to switch to. Should match the networkId of the network data.
* @param params.walletAccount - The wallet account to switch networks for.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the network switch is complete.
* @throws NetworkSwitchingUnavailableError If the wallet provider doesn't support network switching.
*/
const switchActiveNetwork = async ({ networkId, walletAccount }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderByKey({ walletProviderKey: walletAccount.walletProviderKey }, client);
	if (walletProvider.switchActiveNetwork === void 0) throw new NetworkSwitchingUnavailableError({
		extraMessages: [`Wallet provider ${walletAccount.walletProviderKey} does not have switchActiveNetwork method`],
		originalError: null,
		walletProviderKey: walletAccount.walletProviderKey
	});
	return walletProvider.switchActiveNetwork({ networkId });
};

//#endregion
//#region src/modules/wallets/primaryWalletAccount/selectPrimaryWalletAccount/selectPrimaryWalletAccount.ts
/**
* Make the wallet account provided as the primary wallet account.
*/
const selectPrimaryWalletAccount = async ({ walletAccount }, client = getDefaultClient()) => {
	const core = getCore(client);
	if (getPrimaryWalletAccount(client)?.id === walletAccount.id) return;
	if (walletAccount.verifiedCredentialId) updateAuthFromVerifyResponse({ response: await createApiClient({}, client).selectUserWallet({
		environmentId: core.environmentId,
		userWalletSelectionRequest: { walletId: walletAccount.verifiedCredentialId }
	}) }, client);
	else setUnverifiedWalletAccounts({ unverifiedWalletAccountsToUpdate: [{
		...walletAccount,
		lastSelectedAt: /* @__PURE__ */ new Date()
	}] }, client);
};

//#endregion
//#region src/modules/wallets/disconnectWalletAccount/disconnectWalletAccount.ts
/**
* This function disconnects the specified wallet account with the wallet provider.
*
* The wallet account is not removed from the user's profile or from dynamic's state,
* it is only responsible for terminating the connection with the wallet provider.
*/
const disconnectWalletAccount = async ({ walletAccount }, client) => {
	try {
		await getWalletProviderFromWalletAccount({ walletAccount }, client).disconnectWalletAccount?.({ walletAccount });
	} catch (error) {
		if (error instanceof NoWalletProviderFoundError) return;
		throw error;
	}
};

//#endregion
//#region src/modules/wallets/removeWalletAccount/removeWalletAccount.ts
/**
* Removes a wallet account from the current session or user (if authenticated).
*
* This function both disconnects and removes the specified wallet account,
* updating local state and server records (if there is an authenticated user).
* For verified wallets, it will unlink them from the user's account.
*
* @param params.walletAccount - The wallet account to remove.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves when the wallet account is successfully removed.
*/
const removeWalletAccount = async ({ walletAccount }, client = getDefaultClient()) => {
	const core = getCore(client);
	const apiClient = createApiClient({}, client);
	await disconnectWalletAccount({ walletAccount }, client);
	if (!walletAccount.verifiedCredentialId) {
		removeUnverifiedWalletAccount({ unverifiedWalletAccount: walletAccount }, client);
		return;
	}
	updateAuthFromVerifyResponse({ response: await apiClient.verifyUnlink({
		environmentId: core.environmentId,
		verifyUnlinkRequest: { walletId: walletAccount.verifiedCredentialId }
	}) }, client);
};

//#endregion
//#region src/modules/wallets/signMessage/signMessage.ts
/**
* Signs a message using the specified wallet account.
*
* This function uses the wallet's private key to cryptographically sign
* the provided message.
*
* @param params.walletAccount - The wallet account to use for signing.
* @param params.message - The message to sign.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to an object containing the signature.
*/
const signMessage = async ({ walletAccount, message }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderFromWalletAccount({ walletAccount }, client);
	assertWalletProviderMethodDefined(walletProvider, "signMessage");
	const { signature } = await walletProvider.signMessage({
		message,
		walletAccount
	});
	return { signature };
};

//#endregion
//#region src/modules/wallets/transferWalletAccount/transferWalletAccount.ts
/**
* Transfer a wallet account to the current user's account.
*
* This function requires the user to sign a message to prove wallet ownership,
* then transfers the wallet account to the current user's account.
*
* @param params.walletProviderKey - The key of the wallet provider of the wallet account to transfer.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A promise that resolves to the transferred wallet account.
*/
const transferWalletAccount = async ({ walletProviderKey }, client = getDefaultClient()) => {
	return verifyWalletAccountForSignInOrTransfer({
		isTransfer: true,
		walletAccount: await connectWithWalletProvider({
			addToDynamicWalletAccounts: false,
			walletProviderKey
		}, client)
	}, client);
};

//#endregion
//#region src/modules/wallets/utils/getWalletAccountFromAddress/getWalletAccountFromAddress.ts
/**
* Finds a wallet account by address and blockchain.
*
* This function searches through the current session's wallet accounts
* to find one matching the specified address and chain.
*
* @param params.address - The wallet address to search for.
* @param params.chain - The blockchain the wallet belongs to.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns The matching wallet account, or undefined if not found.
*/
const getWalletAccountFromAddress = ({ address, chain }, client = getDefaultClient()) => {
	return getWalletAccounts(client).find((walletAccount) => walletAccount.address === address && walletAccount.chain === chain);
};

//#endregion
//#region src/modules/wallets/walletProvider/events/offWalletProviderEvent/offWalletProviderEvent.ts
/**
* Removes a listener from a wallet provider event.
* You can alternatively use the returned function from `onWalletProviderEvent` instead of using this function.
*
* @param params.callback - The callback function to remove. This should be the same function that was passed to the `onWalletProviderEvent` function.
* @see onWalletProviderEvent
* @param params.event - The event name to remove the listener from.
* @param params.walletProviderKey - The unique key identifying the wallet provider to remove the listener from.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
*/
const offWalletProviderEvent = ({ callback, event, walletProviderKey }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);
	assertWalletProviderMethodDefined(walletProvider, "events");
	walletProvider.events.off(event, callback);
};

//#endregion
//#region src/modules/wallets/walletProvider/events/onWalletProviderEvent/onWalletProviderEvent.ts
/**
* Listens to a wallet provider event.
*
* @param params.callback - The callback function to execute when the event is fired.
* @param params.event - The event name to listen for.
* @param params.walletProviderKey - The unique key identifying the wallet provider to listen to.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A function that can be called to remove the listener.
*/
const onWalletProviderEvent = ({ callback, event, walletProviderKey }, client = getDefaultClient()) => {
	const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);
	assertWalletProviderMethodDefined(walletProvider, "events");
	walletProvider.events.on(event, callback);
	return () => {
		walletProvider.events.off(event, callback);
	};
};

//#endregion
//#region src/utils/isMobile/isMobile.ts
/**
* Sourced from http://detectmobilebrowsers.com/
*/
const userAgentRegex1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ios|ipad|playbook|silk/i;
const userAgentRegex2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
const isMobile = (maxTouchPointsOverride) => {
	if (typeof window === "undefined" || typeof navigator === "undefined") return false;
	return userAgentRegex1.test(navigator.userAgent) || userAgentRegex2.test(navigator.userAgent.substring(0, 4)) || isIPad(maxTouchPointsOverride) || isIPhone();
};
const isIPhone = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : /iPhone|ios/.test(navigator.userAgent);
/**
* @param [optional] maxTouchPointsOverride - this is used for testing since
* it seems that JSDOM doesn't support maxTouchPoints, so it was impossible
* to mock it
*/
const isIPad = (maxTouchPointsOverride) => {
	if (typeof window === "undefined" || typeof navigator === "undefined") return false;
	const maxTouchPoints = maxTouchPointsOverride || navigator.maxTouchPoints;
	return /iPad/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && maxTouchPoints === 5;
};

//#endregion
//#region src/exports/index.ts
assertPackageVersion(name, version);

//#endregion
export { BaseError, ClientAlreadyInitializedError, InvalidExternalAuthError, InvalidParamError, InvalidRedirectStorageStateError, LinkCredentialError, MFAAction, MfaInvalidOtpError, MfaRateLimitedError, MissingRedirectStorageStateError, MissingSocialUrlParamError, MissingUserVerificationError, NetworkAddingUnavailableError, NetworkNotAddedError, NetworkSwitchingUnavailableError, NoAddressFoundError, NoNetworkProvidersError, NoPasskeyCredentialsFoundError, NoSmartWalletAccountSignerFoundError, NoWebAuthNSupportError, NotWaasWalletAccountError, SandboxMaximumThresholdReachedError, UnavailableInServerSideError, UnrecognizedNetworkError, UserNotAuthenticatedError, UserRejectedError, WalletAccountAlreadyVerifiedError, WalletAccountNotSelectedError, WalletAlreadyLinkedToAnotherUserError, WalletProviderMethodUnavailableError, acknowledgeRecoveryCodes, addCoinbaseOnrampOrderEventListener, addNetwork, assertWalletAccountSigningAvailability, assertWalletProviderMethodDefined, authenticateMfaRecoveryCode, authenticatePasskeyMFA, authenticateTotpMfaDevice, authenticateWithSocial, completeSocialAuthentication, connectAndVerifyWithWalletProvider, connectWithWalletProvider, consumeMfaToken, createCoinbaseOnrampOrder, createCryptoDotComPayment, createDynamicClient, createNewMfaRecoveryCodes, deleteMfaDevice, deletePasskey, deleteUser, detectOAuthRedirect, fetchProjectSettings, getActiveNetworkData, getActiveNetworkId, getAvailableWalletProvidersData, getBalance, getBalanceForAddress, getCoinbaseBuyUrl, getConnectedAddresses, getDefaultClient, getMfaDevices, getMfaMethods, getMfaRecoveryCodes, getMissingVerificationForCoinbaseOnrampOrder, getMultichainBalances, getNetworksData, getOwnerWalletAccountForSmartWalletAccount, getPasskeys, getPrimaryWalletAccount, getTransactionHistory, getUserSocialAccounts, getWalletAccountAddressByType, getWalletAccountFromAddress, getWalletAccounts, getWalletConnectCatalog, getWalletConnectCatalogWalletByWalletProviderKey, getWalletProviderDataByKey, hasExtension, initializeClient, isCaptchaRequired, isMfaRequiredForAction, isMobile, isPendingRecoveryCodesAcknowledgment, isProgrammaticNetworkSwitchAvailable, isSignedIn, isUserMissingMfaAuth, isWalletAccountVerified, logout, offEvent, offWalletProviderEvent, onEvent, onWalletProviderEvent, onceEvent, proveWalletAccountOwnership, refreshAuth, refreshUser, registerPasskey, registerTotpMfaDevice, removeWalletAccount, selectPrimaryWalletAccount, sendEmailOTP, sendSmsOTP, setCaptchaToken, setDefaultMfaDevice, signInWithExternalJwt, signInWithPasskey, signMessage, switchActiveNetwork, transferWalletAccount, unlinkSocialAccount, updateUser, verifyOTP, verifyWalletAccount, waitForClientInitialized };
//# sourceMappingURL=index.esm.js.map