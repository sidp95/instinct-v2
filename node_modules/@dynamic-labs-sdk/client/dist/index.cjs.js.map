{"version":3,"file":"index.cjs.js","names":["BaseError","getDefaultClient","getWalletAccounts","createStorageKeySchema","z","getDefaultClient","getCore","createApiClient","CLIENT_SDK_NAME","bufferToHex","getCore","getBuffer","getCore","walletProvidersMap: Map<string, WalletProvider>","getWalletAccounts","getWalletProviderFromWalletAccount","getCore","getDefaultClient","getCore","createApiClient","isCookieEnabled","DYNAMIC_AUTH_COOKIE_NAME","timeoutId: ReturnType<typeof setTimeout> | null","getCore","clearExpirationTimeout: VoidFunction | null","subscribeWithSelector","getCore","isEqualShallow","z","z","createStorageKeySchema","z","getCore","stateChanges: Partial<DynamicCoreState>","SDK_API_CORE_VERSION","getCore","SDK_API_CORE_VERSION","BaseError","getDefaultClient","getCore","fetchProjectSettingsPromise: Promise<void>","generateSessionKeysPromise: Promise<void>","refreshUserStateFromCookiePromise: Promise<void>","isCookieEnabled","refreshAuth","INITIALIZE_STORAGE_SYNC_TRACKER_KEY","FETCH_PROJECT_SETTINGS_TRACKER_KEY","GENERATE_SESSION_KEYS_TRACKER_KEY","REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY","restoreUserSharesForAllWalletAccounts","eventEmitter: AsyncTrackEmitter","EventEmitter","createDeferredPromise","track: AsyncTrack['track']","CannotTrackError","name","waitForAll: AsyncTrack['waitForAll']","getTracker: AsyncTrack['getTracker']","EventEmitter","BaseError","createDeferredPromise","resolutionPromise","BaseError","getInitialState","createLogger","createStorage","createLocalStorageAdapter","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","BaseError","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getCore","createApiClient","getCore","createApiClient","getDefaultClient","getCore","getCore","createApiClient","getCore","createApiClient","getDefaultClient","getCore","formattedOptions: PublicKeyCredentialRequestOptionsJSON","getDefaultClient","JwtVerifiedCredentialFormatEnum","createStorageKeySchema","z","ProviderEnum","numberArray: number[]","ProviderEnum","ProviderEnum","randomString","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","response: VerifyResponse","consumeCaptchaToken","getDefaultClient","getCore","getDefaultClient","getWalletAccounts","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","ValueMustBeDefinedError","getDefaultClient","InvalidParamError","fieldsMissingVerification: FieldMissingVerificationForCoinbaseOnramp[]","JwtVerifiedCredentialFormatEnum","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","getCore","APIError","createStorageKeySchema","z","getCore","DYNAMIC_ICONIC_SPRITE_URL","INJECTED_CHAIN_TO_CHAIN_MAP: Record<string, Chain>","WALLET_KEY_CHAIN_PATTERNS: Array<{ chain: Chain; pattern: string }>","getChainFromVerifiedCredentialChain","groups: Record<string, WalletConnectCatalogGroup>","wallets: Record<string, WalletConnectCatalogWallet>","getDefaultClient","CHAINS_INFO_MAP","getDefaultClient","splitWalletProviderKey","getDefaultClient","getCore","createApiClient","getDefaultClient","MfaBackupCodeAcknowledgement","getDefaultClient","getCore","createApiClient","getCore","createApiClient","getCore","createApiClient","getDefaultClient","getCore","formattedOptions: PublicKeyCredentialRequestOptionsJSON","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","MfaBackupCodeAcknowledgement","getDefaultClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","consumeCaptchaToken","supportedCountries: CountryPhoneData","getDefaultClient","getCore","createApiClient","consumeCaptchaToken","getCore","createApiClient","getCore","createApiClient","getDefaultClient","response: VerifyResponse","getDefaultClient","getCore","createApiClient","getDefaultClient","getCore","createApiClient","getDefaultClient","getWalletProviderFromWalletAccount","getDefaultClient","getWalletProviderByKey","getWalletAccounts","walletAccount: WalletAccount","formatWalletAccountId","createVisit","getCore","createApiClient","getWalletProviderFromWalletAccount","createSignInMessageStatement","formatSignInMessage","CHAINS_INFO_MAP","getDefaultClient","getWalletProviderFromWalletAccount","normalizeAddress","getWalletProviderFromWalletAccount","verifyMessageSignatureOwnership","getWalletAccounts","getDefaultClient","getDefaultClient","createVisit","AuthModeEnum","getDefaultClient","getWalletProviders","getDefaultClient","getWalletProviderByKey","getDefaultClient","getVerifiedCredentialForWalletAccount","getWalletAccounts","getDefaultClient","getWalletProviderByKey","getDefaultClient","getWalletProviderByKey","getDefaultClient","getWalletProviderFromWalletAccount","getNetworksData","getDefaultClient","getWalletProviderFromWalletAccount","getDefaultClient","getWalletProviderFromWalletAccount","getNetworkProviderFromNetworkId","getDefaultClient","getNetworkProviderFromNetworkId","getDefaultClient","getCore","createApiClient","getDefaultClient","getWalletProviderByKey","getDefaultClient","getWalletProviderByKey","getDefaultClient","getCore","createApiClient","getWalletProviderFromWalletAccount","NoWalletProviderFoundError","getDefaultClient","getCore","createApiClient","getDefaultClient","getWalletProviderFromWalletAccount","getDefaultClient","getDefaultClient","getWalletAccounts","getDefaultClient","getWalletProviderByKey","getDefaultClient","getWalletProviderByKey","packageName","packageVersion"],"sources":["../src/modules/state/raiseStateEvents/events.ts","../src/utils/retryOnFail/InvalidRetryOnFailCallError.ts","../src/utils/retryOnFail/retryOnFail.ts","../src/modules/auth/isSignedIn/isSignedIn.ts","../src/modules/projectSettings/fetchProjectSettings/projectSettingsExpirationScheme.ts","../src/modules/projectSettings/fetchProjectSettings/fetchProjectSettings.ts","../src/utils/base64UrlDecode/base64UrlDecode.ts","../src/utils/compressRawPublicKey/compressRawPublicKey.ts","../src/utils/p256Keygen/p256Keygen.ts","../src/modules/sessionKeys/generateSessionKeys/generateSessionKeys.ts","../src/services/runtimeServices/createRuntimeServices/createRuntimeServices.ts","../src/modules/wallets/utils/getAvailableWalletProvidersFromWalletAccounts/getAvailableWalletProvidersFromWalletAccounts.ts","../src/modules/wallets/disconnectAndTerminateWalletProviders/disconnectAndTerminateWalletProviders.ts","../src/modules/auth/logout/logout.ts","../src/modules/auth/initializeAuth/setLongTimeout/setLongTimeout.ts","../src/modules/auth/initializeAuth/initializeAuth.ts","../src/modules/state/raiseStateEvents/raiseStateEvents.ts","../src/modules/wallets/unverifiedWalletAccounts/schema.ts","../src/modules/wallets/walletProvider/walletProviderKeyMap/schema.ts","../src/modules/storageSync/schema.ts","../src/modules/storageSync/hydrateStateWithStorage/hydrateStateWithStorage.ts","../src/modules/storageSync/syncStateWithStorage/syncStateWithStorage.ts","../src/modules/storageSync/initializeStorageSync.ts","../src/errors/ClientAlreadyInitializedError.ts","../src/modules/initializeClient/initializeClient.ts","../src/utils/isServerSideRendering/isServerSideRendering.ts","../src/services/asyncTrack/createAsyncTrack.ts","../src/services/eventEmitter/createEventEmitter.ts","../src/errors/UnavailableInServerSideError.ts","../src/services/fetch/createWebFetch.ts","../src/services/navigate/createNavigationHandler/createNavigationHandler.ts","../src/services/openDeeplink/createWebDeeplinkOpener/createWebDeeplinkOpener.ts","../src/services/passkey/createWebPasskeyService/createWebPasskeyService.ts","../src/utils/debouncedMutex/createDebouncedMutex/createDebouncedMutex.ts","../src/errors/InvalidStorageValue.ts","../src/utils/observable/createObservableState/createObservableState.ts","../src/client/consts.ts","../src/client/core/createCore/getInitialState.ts","../src/client/core/createCore/createCore.ts","../src/client/createDynamicClient/createDynamicClient.ts","../src/errors/InvalidRedirectStorageStateError.ts","../src/errors/MissingRedirectStorageStateError.ts","../src/errors/MissingSocialUrlParamError.ts","../src/errors/MissingUserVerificationError.ts","../src/errors/NetworkAddingUnavailableError.ts","../src/errors/NetworkNotAddedError.ts","../src/errors/NetworkSwitchingUnavailableError.ts","../src/errors/NoAddressFoundError.ts","../src/errors/NoPasskeyCredentialsFoundError.ts","../src/errors/NoSmartWalletAccountSignerFoundError.ts","../src/errors/NoWebAuthNSupportError.ts","../src/errors/UnrecognizedNetworkError.ts","../src/errors/UserNotAuthenticatedError.ts","../src/errors/UserRejectedError.ts","../src/errors/WalletAccountAlreadyVerifiedError.ts","../src/errors/WalletAccountNotSelectedError.ts","../src/errors/WalletProviderMethodUnavailableError.ts","../src/modules/auth/externalAuth/signInWithExternalJwt/signInWithExternalJwt.ts","../src/modules/auth/passkeys/deletePasskey/deletePasskey.ts","../src/modules/auth/passkeys/getPasskeys/getPasskeys.ts","../src/modules/auth/passkeys/getPasskeyRegistrationOptions/getPasskeyRegistrationOptions.ts","../src/modules/auth/passkeys/serverRegisterPasskey/serverRegisterPasskey.ts","../src/modules/auth/passkeys/registerPasskey/registerPasskey.ts","../src/modules/auth/passkeys/getPasskeyAuthenticationSignInOptions/getPasskeyAuthenticationSignInOptions.ts","../src/modules/auth/passkeys/serverSigninPasskey/serverSigninPasskey.ts","../src/modules/auth/passkeys/signInWithPasskey/signInWithPasskey.ts","../src/modules/auth/social/getUserSocialAccounts/getUserSocialAccounts.ts","../src/modules/auth/social/removeDynamicOauthParamsFromUrl/removeDynamicOauthParamsFromUrl.ts","../src/modules/auth/social/oauth/redirectStateStorageSchema/redirectStateStorageSchema.ts","../src/utils/digestSHA256/digestSHA256.ts","../src/utils/encodeBase64Url/encodeBase64Url.ts","../src/modules/auth/social/oauth/authenticateWithSocial/buildOAuthUrl/addOAuthUrlParams/addOAuthUrlParams.ts","../src/modules/auth/social/oauth/authenticateWithSocial/buildOAuthUrl/getOAuthBaseUrl/getOAuthBaseUrl.ts","../src/modules/auth/social/oauth/authenticateWithSocial/buildOAuthUrl/buildOAuthUrl.ts","../src/modules/auth/social/oauth/authenticateWithSocial/authenticateWithSocial.ts","../src/modules/auth/social/oauth/completeSocialAuthentication/completeSocialAuthentication.ts","../src/modules/auth/social/oauth/detectOAuthRedirect/detectOAuthRedirect.ts","../src/modules/wallets/primaryWalletAccount/getPrimaryWalletAccount/getPrimaryWalletAccount.ts","../src/modules/auth/social/oauth/unlinkSocialAccount/unlinkSocialAccount.ts","../src/modules/balances/getMultichainBalances/getMultichainBalances.ts","../src/modules/funding/coinbase/addCoinbaseOnrampOrderEventListener/addCoinbaseOnrampOrderEventListener.ts","../src/modules/funding/coinbase/getMissingVerificationForCoinbaseOnrampOrder/getMissingVerificationForCoinbaseOnrampOrder.ts","../src/modules/funding/coinbase/utils/validateUserCredentialsForCoinbaseOnrampOrder/validateUserCredentialsForCoinbaseOnrampOrder.ts","../src/modules/funding/coinbase/createCoinbaseOnrampOrder/createCoinbaseOnrampOrder.ts","../src/modules/funding/coinbase/getCoinbaseBuyUrl/getCoinbaseBuyUrl.ts","../src/modules/funding/cryptoDotCom/createCryptoDotComPayment/createCryptoDotComPayment.ts","../src/modules/initializeClient/waitForClientInitialized/waitForClientInitialized.ts","../src/modules/legacyWalletBook/getWalletBookCdnUrl/getWalletBookCdnUrl.ts","../src/modules/legacyWalletBook/fetchLegacyWalletBook/fetchWithTimeout/fetchWithTimeout.ts","../src/modules/legacyWalletBook/fetchLegacyWalletBook/walletBookCacheStorageKeySchema.ts","../src/modules/legacyWalletBook/fetchLegacyWalletBook/fetchLegacyWalletBook.ts","../src/modules/legacyWalletBook/getWalletConnectCatalog/shouldFilterWallet/shouldFilterWallet.ts","../src/modules/legacyWalletBook/getSpriteUrl/getSpriteUrl.ts","../src/modules/legacyWalletBook/getWalletConnectCatalog/transformGroup/transformGroup.ts","../src/modules/legacyWalletBook/getWalletConnectCatalog/getChainFromWalletSchema/getChainFromWalletSchema.ts","../src/modules/legacyWalletBook/getWalletConnectCatalog/transformWallet/transformWallet.ts","../src/modules/legacyWalletBook/getWalletConnectCatalog/transformWalletBook/transformWalletBook.ts","../src/modules/legacyWalletBook/getWalletConnectCatalog/getWalletConnectCatalog.ts","../src/modules/wallets/walletProvider/extractChainFromNormalizedName/extractChainFromNormalizedName.ts","../src/modules/legacyWalletBook/getWalletConnectCatalogWalletByWalletProviderKey/getWalletConnectCatalogWalletByWalletProviderKey.ts","../src/modules/user/updateUser/updateUser.ts","../src/modules/mfa/acknowledgeRecoveryCodes/acknowledgeRecoveryCodes.ts","../src/modules/mfa/authenticateMfaRecoveryCode/authenticateMfaRecoveryCode.ts","../src/modules/auth/passkeys/getPasskeyAuthenticationOptions/getPasskeyAuthenticationOptions.ts","../src/modules/auth/passkeys/serverAuthenticatePasskey/serverAuthenticatePasskey.ts","../src/modules/mfa/authenticatePasskeyMFA/authenticatePasskeyMFA.ts","../src/modules/mfa/authenticateTotpMfaDevice/authenticateTotpMfaDevice.ts","../src/modules/mfa/createNewMfaRecoveryCodes/createNewMfaRecoveryCodes.ts","../src/modules/mfa/deleteMfaDevice/deleteMfaDevice.ts","../src/modules/mfa/getMfaDevices/getMfaDevices.ts","../src/modules/mfa/getMfaRecoveryCodes/getMfaRecoveryCodes.ts","../src/modules/mfa/isPendingRecoveryCodesAcknowledgment/isPendingRecoveryCodesAcknowledgment.ts","../src/modules/mfa/isUserMissingMfaAuth/isUserMissingMfaAuth.ts","../src/modules/mfa/registerTotpMfaDevice/registerTotpMfaDevice.ts","../src/modules/mfa/setDefaultMfaDevice/setDefaultMfaDevice.ts","../src/modules/otp/sendEmailOTP/sendEmailOTP.ts","../src/modules/otp/sendSmsOTP/supportedCountries.ts","../src/modules/otp/sendSmsOTP/sendSmsOTP.ts","../src/modules/otp/verifyOTP/verifyOTPForUserSignIn/verifyOTPForUserSignIn.ts","../src/modules/otp/verifyOTP/verifyOTPForUserUpdate/verifyOTPForUserUpdate.ts","../src/modules/otp/verifyOTP/verifyOTP.ts","../src/modules/user/deleteUser/deleteUser.ts","../src/modules/user/refreshUser/refreshUser.ts","../src/modules/wallets/assertWalletAccountSigningAvailability/assertWalletAccountSigningAvailability.ts","../src/modules/wallets/utils/assertWalletProviderMethodDefined/assertWalletProviderMethodDefined.ts","../src/modules/wallets/utils/getAddressesWithTypesFromConnectionResult/getAddressesWithTypesFromConnectionResult.ts","../src/modules/wallets/connectWithWalletProvider/connectWithWalletProvider.ts","../src/modules/wallets/utils/getChainIdForAccountVerification/getChainIdForAccountVerification.ts","../src/modules/wallets/utils/getSignInMessage/getSignInMessage.ts","../src/modules/wallets/proveWalletAccountOwnership/proveWalletAccountOwnership.ts","../src/modules/wallets/utils/isSameAddress/isSameAddress.ts","../src/modules/wallets/verifyWalletAccountForSignInOrTransfer/verifyWalletAccountForSignInOrTransfer.ts","../src/modules/wallets/verifyWalletAccount/verifyWalletAccount.ts","../src/modules/wallets/connectAndVerifyWithWalletProvider/connectAndVerifyWithWalletProvider.ts","../src/modules/wallets/getAvailableWalletProvidersData/getAvailableWalletProvidersData.ts","../src/modules/wallets/getConnectedAddresses/getConnectedAddresses.ts","../src/modules/wallets/getOwnerWalletAccountForSmartWalletAccount/getOwnerWalletAccountForSmartWalletAccount.ts","../src/modules/wallets/getWalletAccountAddressByType/getWalletAccountAddressByType.ts","../src/modules/wallets/getWalletProviderDataByKey/getWalletProviderDataByKey.ts","../src/modules/wallets/isWalletAccountVerified/isWalletAccountVerified.ts","../src/modules/wallets/networks/addNetwork/addNetwork.ts","../src/modules/wallets/networks/getActiveNetworkData/getActiveNetworkData.ts","../src/modules/wallets/networks/getActiveNetworkId/getActiveNetworkId.ts","../src/modules/wallets/networks/getBalance/getBalance.ts","../src/modules/wallets/networks/getBalanceForAddress/getBalanceForAddress.ts","../src/modules/wallets/networks/getTransactionHistory/getTransactionHistory.ts","../src/modules/wallets/networks/isProgrammaticNetworkSwitchAvailable/isProgrammaticNetworkSwitchAvailable.ts","../src/modules/wallets/networks/switchActiveNetwork/switchActiveNetwork.ts","../src/modules/wallets/primaryWalletAccount/selectPrimaryWalletAccount/selectPrimaryWalletAccount.ts","../src/modules/wallets/disconnectWalletAccount/disconnectWalletAccount.ts","../src/modules/wallets/removeWalletAccount/removeWalletAccount.ts","../src/modules/wallets/signMessage/signMessage.ts","../src/modules/wallets/transferWalletAccount/transferWalletAccount.ts","../src/modules/wallets/utils/getWalletAccountFromAddress/getWalletAccountFromAddress.ts","../src/modules/wallets/walletProvider/events/offWalletProviderEvent/offWalletProviderEvent.ts","../src/modules/wallets/walletProvider/events/onWalletProviderEvent/onWalletProviderEvent.ts","../src/utils/isMobile/isMobile.ts","../src/exports/index.ts"],"sourcesContent":["import type { DynamicClient } from '../../../client/types';\n\n/**\n * Maps the state keys to the event names.\n *\n * This is mainly to ensure that whenever a new state key is added, the developer\n * will have to come to this file and remember to add it here and in the interface.\n */\nexport const stateChangeEvents = {\n  initStatus: 'initStatusChanged',\n  mfaToken: 'mfaTokenChanged',\n  projectSettings: 'projectSettingsChanged',\n  sessionExpiresAt: 'sessionExpiresAtChanged',\n  token: 'tokenChanged',\n  user: 'userChanged',\n} satisfies {\n  [K in keyof DynamicClient]: `${K}Changed`;\n};\n\n// Add the state change events to the global events interface.\ndeclare global {\n  interface DynamicEvents {\n    initStatusChanged: (args: {\n      initStatus: DynamicClient['initStatus'];\n    }) => void;\n\n    mfaTokenChanged: (args: { mfaToken: DynamicClient['mfaToken'] }) => void;\n\n    projectSettingsChanged: (args: {\n      projectSettings: DynamicClient['projectSettings'];\n    }) => void;\n\n    sessionExpiresAtChanged: (args: {\n      sessionExpiresAt: DynamicClient['sessionExpiresAt'];\n    }) => void;\n\n    tokenChanged: (args: { token: DynamicClient['token'] }) => void;\n\n    userChanged: (args: { user: DynamicClient['user'] }) => void;\n  }\n}\n\nexport type DynamicStateChangeEvents =\n  DynamicEvents[(typeof stateChangeEvents)[keyof typeof stateChangeEvents]];\n","import { BaseError } from '../../errors/base';\n\n/**\n * This error is thrown when the `retryOnFail` function is called with an invalid\n * number of retries (i.e. less than 0).\n */\nexport class InvalidRetryOnFailCallError extends BaseError {\n  constructor(maxRetries: number) {\n    super({\n      cause: null,\n      code: 'invalid_retry_on_fail_call_error',\n      docsUrl: null,\n      name: 'InvalidRetryOnFailCallError',\n      shortMessage: `Invalid retries parameter for retryOnFail call: ${maxRetries}`,\n    });\n  }\n}\n","import { InvalidRetryOnFailCallError } from './InvalidRetryOnFailCallError';\n\nexport type RetryOnFailParams<T> = {\n  /**\n   * The delay between retries in milliseconds.\n   */\n  delay?: number;\n  /**\n   * The function to call.\n   */\n  fn: () => Promise<T>;\n  /**\n   * The maximum number of retries.\n   *\n   * When set to 0, the function will be called only once and is\n   * therefore equivalent to calling the function directly.\n   */\n  maxRetries: number;\n};\n\nexport const retryOnFail = async <T>({\n  delay = 0,\n  fn,\n  maxRetries,\n}: RetryOnFailParams<T>) => {\n  for (let retry = 0; retry <= maxRetries; retry++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (retry >= maxRetries) {\n        throw error;\n      }\n\n      if (delay > 0) {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  /**\n   * Reaching this point should never happen and this\n   * error is thrown to help us debug the issue.\n   */\n  throw new InvalidRetryOnFailCallError(maxRetries);\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { getWalletAccounts } from '../../wallets/getWalletAccounts';\n\n/**\n * Checks if the user is currently signed in to the Dynamic client.\n *\n * The client is considered to be in a signed in state if a user has\n * authenticated or if the client has at least one wallet connected.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns True if the user is signed in, false otherwise.\n */\nexport const isSignedIn = (client = getDefaultClient()) =>\n  Boolean(client.user || getWalletAccounts(client).length > 0);\n","import * as z from 'zod/mini';\n\nimport { createStorageKeySchema } from '../../../services/storage';\n\n/**\n * The schema to track the expiration time of the project settings.\n */\nexport const projectSettingsExpirationStorageKeySchema = createStorageKeySchema(\n  {\n    key: 'projectSettingsExpiration',\n    schema: z.number(),\n  }\n);\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { retryOnFail } from '../../../utils/retryOnFail';\nimport { createApiClient } from '../../apiClient';\nimport { CLIENT_SDK_NAME } from '../../apiClient/constants';\nimport { isSignedIn } from '../../auth/isSignedIn';\nimport { projectSettingsExpirationStorageKeySchema } from './projectSettingsExpirationScheme';\n\n/**\n * Expiration time of the project settings in milliseconds.\n */\nexport const PROJECT_SETTINGS_EXPIRATION_TIME = 1000 * 60 * 5; // 5 minutes\n\n/**\n * Fetches and updates the project settings from the API.\n *\n * This function retrieves the latest project configuration settings\n * from Dynamic's servers, including authentication options, enabled chains,\n * and security configurations. The settings are cached for performance.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the updated project settings.\n */\nexport const fetchProjectSettings = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n\n  const currentExpiration = await core.storage.getItem(\n    projectSettingsExpirationStorageKeySchema\n  );\n\n  const hasProjectSettings = Boolean(client.projectSettings);\n  const isExpired = currentExpiration && currentExpiration < Date.now();\n\n  // We want to cache the project settings if its valid and user is connected.\n  // This avoids unnecessary API calls and speeds up the initial load.\n  if (hasProjectSettings && !isExpired && isSignedIn(client)) {\n    return client.projectSettings;\n  }\n\n  const apiClient = createApiClient({}, client);\n\n  core.logger.debug('[fetchProjectSettings] Fetching project settings...');\n\n  const doFetch = async () =>\n    apiClient.getEnvironmentSettings(\n      {\n        environmentId: core.environmentId,\n        sdkVersion: `${CLIENT_SDK_NAME}/${core.version}`,\n      },\n      {\n        credentials: 'omit',\n      }\n    );\n\n  const projectSettings = await retryOnFail({\n    fn: doFetch,\n    maxRetries: 2,\n  });\n\n  core.state.set({ projectSettings: projectSettings ?? null });\n\n  await core.storage.setItem(\n    projectSettingsExpirationStorageKeySchema,\n    Date.now() + PROJECT_SETTINGS_EXPIRATION_TIME\n  );\n\n  return projectSettings;\n};\n","/**\n * Takes a base64url-encoded string (e.g. \"nMueRPiAm51YXEjRtka8S_8Ura3HaqbmqDqMJCZmvkM\")\n * and return the corresponding bytes, as an array buffer.\n */\nexport const base64UrlDecode = (s?: string) => {\n  // Go from base64url encoding to base64 encoding\n  s = s?.replace(/-/g, '+').replace(/_/g, '/') || '';\n  // use `atob` to decode base64\n  return Uint8Array.from(atob(s), (c) => c.charCodeAt(0));\n};\n","/**\n * Accepts a public key array buffer, and returns a buffer with the compressed version of the public key\n */\nexport const compressRawPublicKey = (rawPublicKey: ArrayBuffer) => {\n  const rawPublicKeyBytes = new Uint8Array(rawPublicKey);\n  const len = rawPublicKeyBytes.byteLength;\n\n  // Drop the y coordinate\n  const compressedBytes = rawPublicKeyBytes.slice(0, (1 + len) >>> 1);\n\n  // Encode the parity of `y` in first bit\n  compressedBytes[0] = 0x2 | (rawPublicKeyBytes[len - 1] & 0x01);\n  return compressedBytes.buffer;\n};\n","import { base64UrlDecode } from '../base64UrlDecode';\nimport { bufferToHex } from '../bufferToHex';\nimport { compressRawPublicKey } from '../compressRawPublicKey';\n\nexport const p256Keygen = async () => {\n  // Create a new P-256 keypair\n  const p256Keypair = await crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    true,\n    ['sign', 'verify']\n  );\n\n  // Export the raw public key. By default this will export in uncompressed format\n  const rawPublicKey = await crypto.subtle.exportKey(\n    'raw',\n    p256Keypair.publicKey\n  );\n\n  // We need to export with JWK format because exporting EC private keys with \"raw\" isn't supported\n  const privateKeyJwk = await crypto.subtle.exportKey(\n    'jwk',\n    p256Keypair.privateKey\n  );\n\n  const compressedPublicKeyBuffer = compressRawPublicKey(rawPublicKey);\n\n  const privateKeyBuffer = base64UrlDecode(privateKeyJwk.d);\n\n  return {\n    private: bufferToHex(privateKeyBuffer),\n    privateJwk: privateKeyJwk,\n    public: bufferToHex(compressedPublicKeyBuffer),\n  };\n};\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types';\nimport { getBuffer } from '../../../utils/getBuffer';\nimport { p256Keygen } from '../../../utils/p256Keygen';\nimport type { SessionKeys } from '../sessionKeys.types';\n\nexport const generateSessionKeys = async (\n  client: DynamicClient\n): Promise<SessionKeys> => {\n  const {\n    private: privateKey,\n    public: publicKey,\n    privateJwk: privateKeyJwk,\n  } = await p256Keygen();\n\n  const core = getCore(client);\n\n  // stringify and encode the session keys to store in storage\n  const stringifiedSessionKeys = JSON.stringify({\n    privateKey,\n    privateKeyJwk,\n    publicKey,\n    registered: false,\n  });\n\n  const encodedSessionKeys = getBuffer()\n    .from(stringifiedSessionKeys)\n    .toString('base64');\n\n  core.state.set({\n    sessionKeys: encodedSessionKeys,\n  });\n\n  return { privateKey, privateKeyJwk, publicKey };\n};\n","import type { RuntimeServices } from '../runtimeServices.types';\n\n/**\n * Creates a new runtime services instance that manages service registration and retrieval.\n *\n * @returns A RuntimeServices object with methods to get, register, and unregister services\n */\nexport const createRuntimeServices = (): RuntimeServices => {\n  const registry = new Map<string, unknown>();\n\n  return {\n    getByKey: <T>(key: string) => registry.get(key) as T | null,\n    register: (key: string, service: unknown) => registry.set(key, service),\n    unregister: (key: string) => registry.delete(key),\n  };\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { getWalletAccounts } from '../../getWalletAccounts';\nimport type { WalletProvider } from '../../walletProvider';\nimport { getWalletProviderFromWalletAccount } from '../getWalletProviderFromWalletAccount';\n\nexport const getAvailableWalletProvidersFromWalletAccounts = (\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  const walletProvidersMap: Map<string, WalletProvider> = new Map();\n\n  const walletAccounts = getWalletAccounts(client);\n\n  walletAccounts.forEach((walletAccount) => {\n    if (walletProvidersMap.has(walletAccount.walletProviderKey)) {\n      return;\n    }\n\n    try {\n      const walletProvider = getWalletProviderFromWalletAccount(\n        {\n          walletAccount,\n        },\n        client\n      );\n\n      walletProvidersMap.set(walletAccount.walletProviderKey, walletProvider);\n    } catch (error) {\n      core.logger.debug('Wallet provider not found for wallet account', {\n        error,\n        walletAccount: walletAccount.address,\n      });\n    }\n  });\n\n  return Array.from(walletProvidersMap.values());\n};\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types/DynamicClient';\nimport { getAvailableWalletProvidersFromWalletAccounts } from '../utils/getAvailableWalletProvidersFromWalletAccounts';\n\n/**\n * Disconnect and terminate each wallet provider, if available.\n */\nexport const disconnectAndTerminateWalletProviders = async (\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  const walletProviders = getAvailableWalletProvidersFromWalletAccounts(client);\n\n  await Promise.all(\n    walletProviders.map(async (walletProvider) => {\n      if (walletProvider.terminate) {\n        await walletProvider.terminate();\n      }\n\n      if (walletProvider.disconnect) {\n        try {\n          await walletProvider.disconnect();\n        } catch (err) {\n          core.logger.error(\n            `Error disconnecting from wallet ${walletProvider.key}`,\n            err\n          );\n        }\n      }\n    })\n  );\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { setCookie } from '../../../utils/setCookie';\nimport { createApiClient } from '../../apiClient';\nimport { emitEvent } from '../../clientEvents';\nimport { fetchProjectSettings } from '../../projectSettings/fetchProjectSettings';\nimport { isCookieEnabled } from '../../projectSettings/isCookieEnabled';\nimport { generateSessionKeys } from '../../sessionKeys/generateSessionKeys';\nimport { disconnectAndTerminateWalletProviders } from '../../wallets/disconnectAndTerminateWalletProviders';\nimport { DYNAMIC_AUTH_COOKIE_NAME } from '../consts';\n\n/**\n * Logs out the current user and clears all authentication data.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the logout process is complete.\n */\nexport const logout = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n\n  core.logger.debug('[logout] Logging out...');\n\n  await disconnectAndTerminateWalletProviders(client);\n\n  if (client.user !== null) {\n    const apiClient = createApiClient({}, client);\n\n    try {\n      await apiClient.revokeSession({\n        environmentId: core.environmentId,\n      });\n    } catch (error) {\n      core.logger.error('Failed to revoke session', error);\n    }\n\n    /**\n     * This deletes the auth cookie if it exists.\n     * If the cookie doesn't exist, this sets a new cookie that expires immediately.\n     */\n    if (isCookieEnabled(client)) {\n      setCookie(\n        `${DYNAMIC_AUTH_COOKIE_NAME}=; Max-Age=-99999999; path=/; SameSite=Lax`\n      );\n    }\n  }\n\n  core.state.set({\n    captchaToken: null,\n    legacyToken: null,\n    mfaToken: null,\n    sessionExpiresAt: null,\n    sessionKeys: null,\n    token: null,\n    unverifiedWalletAccounts: [],\n    user: null,\n  });\n\n  emitEvent({ event: 'logout' }, client);\n\n  // Refetch project settings\n  void fetchProjectSettings(client);\n\n  // Regenerate session keys\n  void generateSessionKeys(client);\n};\n","/**\n * A replacement for setTimeout that supports delays longer than 2147483647ms (~24.8 days).\n */\nexport const setLongTimeout = (\n  callback: () => void,\n  delay: number\n): VoidFunction => {\n  const MAX_DELAY = 2147483647; // Maximum delay for setTimeout (2^31 - 1)\n\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n  let remaining = delay;\n\n  const run = () => {\n    if (remaining <= MAX_DELAY) {\n      timeoutId = setTimeout(callback, remaining);\n    } else {\n      timeoutId = setTimeout(() => {\n        remaining -= MAX_DELAY;\n        run();\n      }, MAX_DELAY);\n    }\n  };\n\n  run();\n\n  // Return a cancel function\n  return () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n  };\n};\n","import type { DynamicClient } from '../../../client/types';\nimport { getCore } from '../../../client/core/getCore';\nimport { subscribeWithSelector } from '../../../utils/observable/subscribeWithSelector';\nimport { logout } from '../logout';\nimport { setLongTimeout } from './setLongTimeout';\n\n/**\n * Sets up a timeout to log out the user when their token expires.\n */\nexport const initializeAuth = (client: DynamicClient) => {\n  const core = getCore(client);\n\n  let clearExpirationTimeout: VoidFunction | null = null;\n\n  const onChangeExpiration = subscribeWithSelector(\n    core.state,\n    (state) => state.sessionExpiresAt\n  );\n\n  const checkExpiration = () => {\n    const expiration = core.state.get().sessionExpiresAt;\n\n    clearExpirationTimeout?.();\n\n    if (!expiration) {\n      return;\n    }\n\n    const now = new Date();\n\n    const timeUntilExpiration = expiration.getTime() - now.getTime();\n\n    if (timeUntilExpiration <= 0) {\n      void logout(client);\n      return;\n    }\n\n    // Wait for token expiration\n    clearExpirationTimeout = setLongTimeout(\n      checkExpiration,\n      timeUntilExpiration\n    );\n  };\n\n  onChangeExpiration(checkExpiration);\n\n  checkExpiration();\n};\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicCoreState } from '../../../client/core/types';\nimport type { DynamicClient } from '../../../client/types';\nimport { isEqualShallow } from '../../../utils/isEqualShallow';\nimport { emitEvent } from '../../clientEvents';\nimport { stateChangeEvents } from './events';\n\nexport const raiseStateEvents = (client: DynamicClient) => {\n  const core = getCore(client);\n\n  core.state.subscribe((value, previous) => {\n    const eventEntries = Object.entries(stateChangeEvents) as Array<\n      [keyof DynamicCoreState, keyof DynamicEvents]\n    >;\n\n    eventEntries.forEach(([key, event]) => {\n      // Check if this key had a change\n      if (isEqualShallow(value[key], previous[key])) return;\n\n      emitEvent(\n        {\n          args: { [key]: value[key] },\n          event,\n        },\n        client\n      );\n    });\n  });\n};\n","import * as z from 'zod/mini';\n\nimport type { Chain } from '../../chain';\nimport type { WalletAddressType } from '../walletAccount';\n\nexport const unverifiedWalletAccountSchema = z.object({\n  address: z.string(),\n  addressesWithTypes: z.optional(\n    z.array(\n      z.object({\n        address: z.string(),\n        publicKey: z.optional(z.string()),\n        type: z.custom<WalletAddressType>((val) => typeof val === 'string'),\n      })\n    )\n  ),\n  chain: z.custom<Chain>((val) => typeof val === 'string'),\n  id: z.string(),\n  lastSelectedAt: z.nullable(z.date()),\n  walletProviderKey: z.string(),\n});\n","import * as z from 'zod/mini';\n\nexport const walletProviderKeyMapSchema = z.record(z.string(), z.string());\n","import type { ProjectSettings, SdkUser } from '@dynamic-labs/sdk-api-core';\nimport * as z from 'zod/mini';\n\nimport { createStorageKeySchema } from '../../services/storage';\nimport { unverifiedWalletAccountSchema } from '../wallets/unverifiedWalletAccounts';\nimport { walletProviderKeyMapSchema } from '../wallets/walletProvider/walletProviderKeyMap/schema';\n\nexport const stateStorageKeySchema = createStorageKeySchema({\n  key: 'state',\n  schema: z.object({\n    apiVersion: z.string(),\n    projectSettings: z.custom<ProjectSettings | null>(),\n    unverifiedWalletAccounts: z.array(unverifiedWalletAccountSchema),\n    user: z.custom<SdkUser | null>(),\n    walletProviderKeyMap: walletProviderKeyMapSchema,\n  }),\n});\n\nexport const sessionStorageKeySchema = createStorageKeySchema({\n  key: 'session',\n  schema: z.object({\n    /**\n     * The current available captcha token.\n     */\n    captchaToken: z.nullable(z.string()),\n\n    /**\n     * Legacy token will be undefined in environments with cookie based sessions.\n     *\n     * @deprecated Use `token` instead.\n     */\n    legacyToken: z.nullable(z.string()),\n\n    /**\n     * The current available MFA token.\n     */\n    mfaToken: z.nullable(z.string()),\n\n    /**\n     * Milliseconds since epoch of session expiration.\n     */\n    sessionExpiration: z.number(),\n\n    /**\n     * The current session keys.\n     */\n    sessionKeys: z.nullable(z.string()),\n\n    /**\n     * Token will be undefined in environments with cookie based sessions.\n     */\n    token: z.nullable(z.string()),\n  }),\n});\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicCoreState } from '../../../client/core/types';\nimport type { DynamicClient } from '../../../client/types';\nimport { SDK_API_CORE_VERSION } from '../../../constants';\nimport { checkAndRaiseWalletAccountsChangedEvent } from '../../auth/updateAuthFromVerifyResponse/checkAndRaiseWalletAccountsChangedEvent';\nimport { sessionStorageKeySchema, stateStorageKeySchema } from '../schema';\n\nexport const hydrateStateWithStorage = async (\n  client: DynamicClient\n): Promise<void> => {\n  const core = getCore(client);\n\n  const previousState = core.state.get();\n\n  const stateChanges: Partial<DynamicCoreState> = {};\n\n  // ================ TOKEN =================\n\n  const session = await core.storage.getItem(sessionStorageKeySchema);\n\n  const isSessionValid =\n    session?.sessionExpiration && session.sessionExpiration > Date.now();\n\n  if (isSessionValid) {\n    stateChanges.token = session.token;\n    stateChanges.legacyToken = session.legacyToken;\n    stateChanges.sessionExpiresAt = new Date(session.sessionExpiration);\n    stateChanges.mfaToken = session.mfaToken;\n    stateChanges.captchaToken = session.captchaToken;\n    stateChanges.sessionKeys = session.sessionKeys;\n  }\n\n  // ================ STATE =================\n\n  const storedState = await core.storage.getItem(stateStorageKeySchema);\n\n  // Only hydrate state if it came from an API with the same version as the current SDK\n  if (storedState?.apiVersion === SDK_API_CORE_VERSION) {\n    stateChanges.unverifiedWalletAccounts =\n      storedState.unverifiedWalletAccounts;\n\n    stateChanges.walletProviderKeyMap = storedState.walletProviderKeyMap;\n\n    // Variables that should only be hydrated if the session is valid\n    if (isSessionValid) {\n      stateChanges.user = storedState.user;\n    }\n\n    // if there's a session/user or connected unverified wallets, we should hydrate project settings\n    // so we don't refetch it on initial load\n    if (\n      isSessionValid ||\n      (storedState.unverifiedWalletAccounts ?? []).length > 0\n    ) {\n      stateChanges.projectSettings = storedState.projectSettings;\n    }\n  }\n\n  if (Object.keys(stateChanges).length > 0) {\n    core.state.set(stateChanges);\n  }\n\n  checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);\n};\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types';\nimport { SDK_API_CORE_VERSION } from '../../../constants';\nimport { sessionStorageKeySchema, stateStorageKeySchema } from '../schema';\n\nexport const syncStateWithStorage = (client: DynamicClient) => {\n  const core = getCore(client);\n\n  core.state.subscribe((state) => {\n    if (state.sessionExpiresAt === null) {\n      void core.storage.removeItem(sessionStorageKeySchema);\n    } else {\n      void core.storage.setItem(sessionStorageKeySchema, {\n        captchaToken: state.captchaToken,\n        legacyToken: state.legacyToken,\n        mfaToken: state.mfaToken,\n        sessionExpiration: state.sessionExpiresAt.getTime(),\n        sessionKeys: state.sessionKeys,\n        token: state.token,\n      });\n    }\n\n    void core.storage.setItem(stateStorageKeySchema, {\n      apiVersion: SDK_API_CORE_VERSION,\n      projectSettings: state.projectSettings,\n      unverifiedWalletAccounts: state.unverifiedWalletAccounts,\n      user: state.user,\n      walletProviderKeyMap: state.walletProviderKeyMap,\n    });\n  });\n};\n","import type { DynamicClient } from '../../client/types';\nimport { hydrateStateWithStorage } from './hydrateStateWithStorage';\nimport { syncStateWithStorage } from './syncStateWithStorage';\n\nexport const initializeStorageSync = async (client: DynamicClient) => {\n  // Initialize the state value with what's stored in the storage\n  await hydrateStateWithStorage(client);\n\n  // Keep the storage up to date with the state\n  syncStateWithStorage(client);\n};\n","import { BaseError } from './base';\n\nexport class ClientAlreadyInitializedError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'client_already_initialized_error',\n      docsUrl: null,\n      name: 'ClientAlreadyInitializedError',\n      shortMessage: 'Client must not be initialized more than once',\n    });\n  }\n}\n","import { getCore } from '../../client/core/getCore';\nimport { getDefaultClient } from '../../client/defaultClient';\nimport { initializeAuth } from '../auth/initializeAuth';\nimport { logout } from '../auth/logout';\nimport { fetchProjectSettings } from '../projectSettings/fetchProjectSettings';\nimport { isCookieEnabled } from '../projectSettings/isCookieEnabled';\nimport { generateSessionKeys } from '../sessionKeys/generateSessionKeys';\nimport { raiseStateEvents } from '../state/raiseStateEvents';\nimport { initializeStorageSync } from '../storageSync';\nimport { refreshAuth } from '../user/refreshAuth';\nimport { restoreUserSharesForAllWalletAccounts } from '../waas/restoreUserSharesForAllWalletAccounts';\nimport { ClientAlreadyInitializedError } from './../../errors/ClientAlreadyInitializedError';\nimport {\n  FETCH_PROJECT_SETTINGS_TRACKER_KEY,\n  GENERATE_SESSION_KEYS_TRACKER_KEY,\n  INITIALIZE_STORAGE_SYNC_TRACKER_KEY,\n  REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY,\n} from './consts';\n\n/**\n * Initializes the Dynamic client and all its modules and services.\n *\n * This function orchestrates the initialization of authentication, project settings,\n * session keys, and storage sync. It manages the initialization status and handles\n * any errors that occur during the process.\n *\n * You only need to call this function if you are not using `autoInitialize: true` in createDynamicClient.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when initialization is complete.\n * @throws ClientAlreadyInitializedError If the client is already initialized.\n */\nexport const initializeClient = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n\n  core.logger.debug(\n    '[initializeClient] Initializing client. Current init status',\n    core.state.get().initStatus\n  );\n\n  if (core.state.get().initStatus !== 'uninitialized') {\n    throw new ClientAlreadyInitializedError();\n  }\n\n  core.state.set({ initStatus: 'in-progress' });\n\n  initializeAuth(client);\n\n  raiseStateEvents(client);\n\n  const initializeStorageSyncPromise = initializeStorageSync(client);\n\n  const fetchProjectSettingsPromise: Promise<void> =\n    initializeStorageSyncPromise.then(async () => {\n      if (!core.state.get().projectSettings) {\n        await fetchProjectSettings(client);\n      }\n    });\n\n  /**\n   * Generate session keys if they don't exist\n   */\n  const generateSessionKeysPromise: Promise<void> =\n    fetchProjectSettingsPromise.then(async () => {\n      if (!core.state.get().sessionKeys) {\n        await generateSessionKeys(client);\n      }\n    });\n\n  /**\n   * Refresh user state on initialization when cookie is enabled.\n   * This is necessary for supporting multiple subdomain domains.\n   *\n   * When a user logs in on sub1.example.com, they will have a cookie set. However, when they access\n   * sub2.example.com, the cookie will be present but the user state will not be present.\n   * We need to fetch the user to access the expiration date of the cookie on the new subdomain.\n   *\n   * This is also needed in case a user logs in with a new user on sub1.example.com and then accesses\n   * sub2.example.com that had the original logged-in user. We need to fetch the user to refresh\n   * the user state with the correct logged-in user.\n   */\n  const refreshUserStateFromCookiePromise: Promise<void> =\n    fetchProjectSettingsPromise.then(async () => {\n      /**\n       * When cookies are enabled, we need to refresh the user as part of the initialization process\n       * to ensure the user is logged in and sync the auth state with the server.\n       *\n       * This call can fail with a 401 error if the user is not logged in and the SDK should finish its initialization process\n       * without throwing an error because that is an expected behavior.\n       */\n      if (isCookieEnabled(client)) {\n        await refreshAuth(client).catch(async (error) => {\n          if (error.status === 401) {\n            if (client.user) {\n              await logout(client);\n            }\n          } else {\n            throw error;\n          }\n        });\n      }\n    });\n\n  core.initTrack.track({\n    name: INITIALIZE_STORAGE_SYNC_TRACKER_KEY,\n    promise: initializeStorageSyncPromise,\n  });\n\n  core.initTrack.track({\n    name: FETCH_PROJECT_SETTINGS_TRACKER_KEY,\n    promise: fetchProjectSettingsPromise,\n  });\n\n  core.initTrack.track({\n    name: GENERATE_SESSION_KEYS_TRACKER_KEY,\n    promise: generateSessionKeysPromise,\n  });\n\n  core.initTrack.track({\n    name: REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY,\n    promise: refreshUserStateFromCookiePromise,\n  });\n\n  try {\n    await core.initTrack.waitForAll();\n\n    core.state.set({ initStatus: 'finished' });\n  } catch (error) {\n    core.state.set({ initStatus: 'failed' });\n\n    throw error;\n  }\n\n  if (client.user) {\n    void restoreUserSharesForAllWalletAccounts(client);\n  }\n};\n","/**\n * Indicates if the code is running in a server-side environment.\n */\n// eslint-disable-next-line no-restricted-globals\nexport const isServerSideRendering = () => typeof window === 'undefined';\n","import { EventEmitter } from 'eventemitter3';\n\nimport { createDeferredPromise } from '../../utils/deferredPromise';\nimport { CannotTrackError } from './../../errors/CannotTrackError';\nimport type {\n  AsyncProcessEntry,\n  AsyncTrack,\n  AsyncTrackEmitter,\n} from './asyncTrack.types';\n\n/**\n * Creates a tracker that associates names with promises and raises as promises resolve.\n */\nexport const createAsyncTrack = (): AsyncTrack => {\n  /**\n   * Whether tracking is enabled.\n   * All processes must be tracked on the same node tick.\n   *\n   * This ensures no process is missed (as it would throw when tracked on a different node tick).\n   */\n  let isTrackEnabled = true;\n\n  const eventEmitter: AsyncTrackEmitter = new EventEmitter();\n\n  const allSettledPromise = createDeferredPromise<void>();\n\n  const tracker = new Map<string, AsyncProcessEntry>();\n\n  /**\n   * Checks if all processes are initialized and resolves the main promise if they are.\n   */\n  const checkIfAllSettled = () => {\n    const allSettled = Array.from(tracker.values()).every(\n      ({ status }) => status === 'resolved'\n    );\n\n    if (!allSettled) return;\n\n    allSettledPromise.resolve();\n  };\n\n  const track: AsyncTrack['track'] = ({ name, promise }) => {\n    if (!isTrackEnabled) {\n      throw new CannotTrackError();\n    }\n\n    // Disable tracking in the next node tick\n    void Promise.resolve().then(() => (isTrackEnabled = false));\n\n    tracker.set(name, { promise, status: 'pending' });\n\n    promise\n      .then(() => {\n        tracker.set(name, { promise, status: 'resolved' });\n\n        eventEmitter.emit('resolved', name);\n\n        checkIfAllSettled();\n      })\n      .catch((error) => {\n        tracker.set(name, { promise, status: 'failed' });\n\n        eventEmitter.emit('failed', name, error);\n\n        allSettledPromise.reject(error);\n      });\n  };\n\n  const waitForAll: AsyncTrack['waitForAll'] = () => allSettledPromise.promise;\n\n  const getTracker: AsyncTrack['getTracker'] = <T>(trackerKey: string) =>\n    tracker.get(trackerKey) as AsyncProcessEntry<T>;\n\n  return {\n    getTracker,\n    off: eventEmitter.off.bind(eventEmitter),\n    on: eventEmitter.on.bind(eventEmitter),\n    track,\n    waitForAll,\n  };\n};\n","import EventEmitter from 'eventemitter3';\n\nexport const createEventEmitter = () => new EventEmitter();\n","import { BaseError } from './base';\n\nexport class UnavailableInServerSideError extends BaseError {\n  constructor(unavailableFeature: string) {\n    super({\n      cause: null,\n      code: 'unavailable_in_server_side_error',\n      docsUrl: null,\n      name: 'UnavailableInServerSideError',\n      shortMessage: `This function is not available in server-side rendering: ${unavailableFeature}`,\n    });\n  }\n}\n","import { UnavailableInServerSideError } from '../../errors/UnavailableInServerSideError';\nimport { isServerSideRendering } from '../../utils/isServerSideRendering';\nimport type { Fetch } from './fetch.types';\n\n/**\n * Creates a fetch instance that uses the native window.fetch API.\n */\nexport const createWebFetch = (): Fetch => {\n  if (isServerSideRendering()) {\n    return () =>\n      Promise.reject(new UnavailableInServerSideError('createWebFetch'));\n  }\n\n  // eslint-disable-next-line no-restricted-globals -- this is the abstraction for fetch\n  return window.fetch.bind(window);\n};\n","import { UnavailableInServerSideError } from '../../../errors/UnavailableInServerSideError';\nimport { isServerSideRendering } from '../../../utils/isServerSideRendering';\nimport type { NavigationHandler } from '../navigate.types';\n\n/**\n * Creates a navigation handler that uses the native window.location API.\n */\nexport const createNavigationHandler = (): NavigationHandler => {\n  if (isServerSideRendering()) {\n    return () =>\n      Promise.reject(\n        new UnavailableInServerSideError('createNavigationHandler')\n      );\n  }\n\n  return async (url) => {\n    // eslint-disable-next-line no-restricted-globals -- this is the abstraction for navigation\n    window.location.href = url;\n  };\n};\n","import { UnavailableInServerSideError } from '../../../errors/UnavailableInServerSideError';\nimport { isServerSideRendering } from '../../../utils/isServerSideRendering';\nimport type { OpenDeeplink } from '../openDeeplink.types';\n\n/**\n * Creates a deeplink opener that uses the native window.open API.\n */\nexport const createWebDeeplinkOpener = (): OpenDeeplink => {\n  if (isServerSideRendering()) {\n    return () =>\n      Promise.reject(\n        new UnavailableInServerSideError('createWebDeeplinkOpener')\n      );\n  }\n\n  return async (url) => {\n    // eslint-disable-next-line no-restricted-globals -- this is the abstraction for opening a deeplink\n    window.open(url, '_blank');\n  };\n};\n","/**\n * Because this is the web implementation of the passkey service, we need to\n * import the browser's WebAuthn API directly.\n */\nimport {\n  // eslint-disable-next-line no-restricted-syntax\n  browserSupportsWebAuthn,\n  // eslint-disable-next-line no-restricted-syntax\n  startAuthentication,\n  // eslint-disable-next-line no-restricted-syntax\n  startRegistration,\n} from '@simplewebauthn/browser';\n\nimport type { PasskeyService } from '../passkey.types';\n\n/**\n * Create a passkey service that uses the browser's WebAuthn API.\n */\nexport const createWebPasskeyService = (): PasskeyService => ({\n  authenticate: (options) => startAuthentication(options),\n  isSupported: () => browserSupportsWebAuthn(),\n  register: (options) => startRegistration(options),\n});\n","import { assertDefined } from '../../assertDefined';\nimport type { DeferredPromise } from '../../deferredPromise';\nimport { createDeferredPromise } from '../../deferredPromise';\nimport type { DebouncedMutex } from '../debouncedMutex.types';\n\n/**\n * State for a debounced mutex.\n */\ntype DebouncedMutexState = {\n  /**\n   * Next callback to run.\n   */\n  nextCallback: (() => Promise<void>) | null;\n  /**\n   * Promise that resolves when the debounced mutex is released.\n   */\n  queuePromise: Promise<void>;\n  /**\n   * Promises that allow callers to await the completion of the next callback execution.\n   * Each invocation adds a promise to this array, which gets resolved when the callback finishes.\n   */\n  resolutionPromises: DeferredPromise<void>[];\n  /**\n   * Timer for the debounced mutex.\n   */\n  timer: NodeJS.Timeout | null;\n};\n\nexport const createDebouncedMutex = (): DebouncedMutex => {\n  const mutexState = new Map<string, DebouncedMutexState>();\n\n  return async ({ lockKey, callback, debounceTime = 0 }) => {\n    const resolutionPromise = createDeferredPromise<void>();\n\n    // Prefill the state for this key if it doesn't exist to avoid needing to check for existence later.\n    if (!mutexState.has(lockKey)) {\n      mutexState.set(lockKey, {\n        nextCallback: null,\n        queuePromise: Promise.resolve(),\n        resolutionPromises: [],\n        timer: null,\n      });\n    }\n\n    const currentState = mutexState.get(lockKey);\n\n    // This should never happen, but we'll assert it for TS safety.\n    assertDefined(currentState, `Mutex state for key ${lockKey} not found`);\n\n    currentState.resolutionPromises.push(resolutionPromise);\n\n    if (currentState.timer) {\n      clearTimeout(currentState.timer);\n    }\n\n    // The last invocation wins. Always.\n    currentState.nextCallback = callback;\n\n    const addCallbackToQueue = async () => {\n      currentState.queuePromise = currentState.queuePromise.then(async () => {\n        if (!currentState.nextCallback) {\n          return;\n        }\n\n        // We can't just use the callback param directly because later invocations\n        // should override previous ones.\n        // Scenario to illustrate this (none of these will use the timer param for simplicity):\n        // 1. Very long running promise callback A runs\n        // 2. While it's running, we invoke callback B, which queues itself with \"then\" and overrides nextCallback with B.\n        // 3. While A is still running, we invoke callback C, same thing happens, now nextCallback is C.\n        // 4. A resolves, nextCallback is invoked with C.\n        // 5. After C resolves, nextCallback is invoked with null, so it doesn't run.\n        // Conclusion: B was never executed and only the last invocation runs.\n        const { nextCallback } = currentState;\n\n        currentState.nextCallback = null;\n\n        const promisesToResolve = currentState.resolutionPromises;\n\n        currentState.resolutionPromises = [];\n\n        try {\n          await nextCallback();\n\n          promisesToResolve.forEach((resolutionPromise) =>\n            resolutionPromise.resolve()\n          );\n        } catch (error) {\n          promisesToResolve.forEach((resolutionPromise) =>\n            resolutionPromise.reject(error)\n          );\n        }\n      });\n    };\n\n    if (debounceTime > 0) {\n      currentState.timer = setTimeout(addCallbackToQueue, debounceTime);\n    } else {\n      await addCallbackToQueue();\n    }\n\n    return resolutionPromise.promise;\n  };\n};\n","import { BaseError } from './base';\n\nexport class InvalidStorageValue extends BaseError {\n  constructor(key: string, value: unknown) {\n    super({\n      cause: null,\n      code: 'invalid_storage_value',\n      docsUrl: null,\n      name: 'InvalidStorageValue',\n      shortMessage: `Tried to store state with a forbidden value. Key: ${key}, Value: ${value}`,\n    });\n  }\n}\n","import { InvalidStorageValue } from '../../../errors/InvalidStorageValue';\nimport type { ObservableState } from '../observable.types';\n\n/**\n * Creates an observable state object that allows subscribing to immutable state changes.\n *\n * This function creates a state management system with the following capabilities:\n * - Get the current state\n * - Update state partially\n * - Subscribe to state changes\n * - Unsubscribe from state changes\n *\n * @param getInitialState - A function that returns the initial state object\n * @returns An ObservableState object with methods to manage and observe state changes\n * @example\n * ```typescript\n * const state = createObservableState(() => ({\n *   count: 0,\n *   name: 'John'\n * }));\n *\n * // Subscribe to changes\n * const unsubscribe = state.subscribe((current, previous) => {\n *   console.log('State changed:', current, 'Previous:', previous);\n * });\n *\n * // Update state\n * state.set({ count: 1 });\n *\n * // Get current state\n * const currentState = state.get();\n *\n * // Unsubscribe when done\n * unsubscribe();\n * ```\n */\nexport const createObservableState = <T extends Record<string, unknown>>(\n  getInitialState: () => T\n): ObservableState<T> => {\n  // ===============\n  // NOTIFICATIONS\n  // ===============\n  const subscribers = new Set<(value: T, previous: T) => void>();\n\n  const notifySubscribers = (value: T, previous: T) => {\n    subscribers.forEach((callback) => callback(value, previous));\n  };\n\n  const subscribe = (\n    callback: (value: Readonly<T>, previous: Readonly<T>) => void\n  ) => {\n    subscribers.add(callback);\n\n    return () => unsubscribe(callback);\n  };\n\n  const unsubscribe = (\n    callback: (value: Readonly<T>, previous: Readonly<T>) => void\n  ) => {\n    subscribers.delete(callback);\n  };\n\n  // ===============\n  // STATE\n  // ===============\n\n  let currentState = getInitialState();\n\n  const get = () => currentState;\n\n  const set = (partial: Partial<T>) => {\n    const previous = currentState;\n\n    Object.entries(partial).forEach(([key, value]) => {\n      if (value === undefined) {\n        throw new InvalidStorageValue(key, value);\n      }\n    });\n\n    currentState = Object.assign({}, currentState, partial);\n\n    notifySubscribers(currentState, previous);\n  };\n\n  return {\n    get,\n    getInitialState,\n    set,\n    subscribe,\n    unsubscribe,\n  };\n};\n","/**\n * The default API base URL for Dynamic apps in production.\n */\nexport const DEFAULT_API_BASE_URL = 'https://app.dynamicauth.com/api/v0';\n","import type { DynamicCoreState } from '../types';\n\n/**\n * The initial values for the state of the client.\n */\nexport const getInitialState = (): DynamicCoreState => ({\n  captchaToken: null,\n  initStatus: 'uninitialized',\n  legacyToken: null,\n  mfaToken: null,\n  projectSettings: null,\n  sessionExpiresAt: null,\n  sessionKeys: null,\n  token: null,\n  unverifiedWalletAccounts: [],\n  user: null,\n  walletProviderKeyMap: {},\n});\n","import { version } from '../../../../package.json';\nimport { createAsyncTrack } from '../../../services/asyncTrack';\nimport { createEventEmitter } from '../../../services/eventEmitter';\nimport { createWebFetch } from '../../../services/fetch/createWebFetch';\nimport { createLogger } from '../../../services/logger/createLogger';\nimport { createNavigationHandler } from '../../../services/navigate/createNavigationHandler';\nimport { createWebDeeplinkOpener } from '../../../services/openDeeplink/createWebDeeplinkOpener';\nimport { createWebPasskeyService } from '../../../services/passkey';\nimport { createRuntimeServices } from '../../../services/runtimeServices';\nimport {\n  createLocalStorageAdapter,\n  createStorage,\n} from '../../../services/storage';\nimport { createDebouncedMutex } from '../../../utils/debouncedMutex/createDebouncedMutex';\nimport { createObservableState } from '../../../utils/observable/createObservableState';\nimport { DEFAULT_API_BASE_URL } from '../../consts';\nimport type { DynamicClientConfig } from '../../types';\nimport type { DynamicCore, DynamicCoreState } from '../types';\nimport { getInitialState } from './getInitialState';\n\n/**\n * Creates a core instance that contains all the services and state of the Dynamic SDK client.\n */\nexport const createCore = (config: DynamicClientConfig): DynamicCore => {\n  const apiBaseUrl = config.coreConfig?.apiBaseUrl ?? DEFAULT_API_BASE_URL;\n\n  const logger =\n    config.coreConfig?.logger ?? createLogger({ level: config.logLevel });\n\n  const storage = createStorage({\n    prefix: `dynamic_${config.environmentId}`,\n    storageAdapter:\n      config.coreConfig?.storageAdapter ?? createLocalStorageAdapter(),\n  });\n\n  const fetch = config.coreConfig?.fetch ?? createWebFetch();\n\n  const openDeeplink =\n    config.coreConfig?.openDeeplink ?? createWebDeeplinkOpener();\n\n  const navigate = config.coreConfig?.navigate ?? createNavigationHandler();\n\n  const state = createObservableState<DynamicCoreState>(getInitialState);\n\n  const debouncedMutex = createDebouncedMutex();\n\n  const eventEmitter = createEventEmitter();\n\n  const initTrack = createAsyncTrack();\n\n  const runtimeServices = createRuntimeServices();\n\n  const passkey = config.coreConfig?.passkey ?? createWebPasskeyService();\n\n  return {\n    apiBaseUrl,\n    debouncedMutex,\n    environmentId: config.environmentId,\n    eventEmitter,\n    extensions: new Set(),\n    fetch,\n    getApiHeaders: config.coreConfig?.getApiHeaders ?? (() => ({})),\n    initTrack,\n    logger,\n    metadata: config.metadata,\n    navigate,\n    openDeeplink,\n    passkey,\n    runtimeServices,\n    state,\n    storage,\n    version,\n  };\n};\n","import { initializeClient } from '../../modules/initializeClient';\nimport { isServerSideRendering } from '../../utils/isServerSideRendering';\nimport { createCore } from '../core/createCore';\nimport { setDefaultClient } from '../defaultClient';\nimport type { DynamicClient, DynamicClientConfig } from '../types';\n\n/**\n * Creates a new DynamicClient instance.\n *\n * Notice the `autoInitialize` flag is true by default (unless you're running\n * in SSR), so the client will be automatically initialized when created  if\n * you want to manually initialize the client, you can set the `autoInitialize`\n * flag to false and then later call the `initializeClient` function.\n *\n * Manually calling `initializeClient` also allows you to catch any potential\n * errors that may occur during initialization.\n *\n * @param config - The configuration for the Dynamic client, like the environment ID, app url, etc.\n * @returns The Dynamic client instance.\n */\nexport const createDynamicClient = (\n  config: DynamicClientConfig\n): DynamicClient => {\n  const core = createCore(config);\n\n  const client = {\n    get __core() {\n      return core;\n    },\n    get initStatus() {\n      return core.state.get().initStatus;\n    },\n    get mfaToken() {\n      return core.state.get().mfaToken;\n    },\n    get projectSettings() {\n      return core.state.get().projectSettings;\n    },\n    get sessionExpiresAt() {\n      return core.state.get().sessionExpiresAt;\n    },\n    get token() {\n      return core.state.get().token;\n    },\n    get user() {\n      return core.state.get().user;\n    },\n  };\n\n  // Define if SDK should auto initialize, default to true\n  const autoInitialize = config.autoInitialize ?? true;\n\n  // Prevent the auto initialization in SSR\n  const shouldAutoInitialize = isServerSideRendering() ? false : autoInitialize;\n\n  core.logger.debug('[createDynamicClient] Creating client...');\n\n  if (shouldAutoInitialize) {\n    core.logger.debug('[createDynamicClient] Initializing client...');\n    void initializeClient(client);\n  }\n\n  setDefaultClient(client);\n\n  return client;\n};\n","import { BaseError } from './base';\n\nexport class InvalidRedirectStorageStateError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'invalid_redirect_storage_state_error',\n      docsUrl: null,\n      name: 'InvalidRedirectStorageStateError',\n      shortMessage:\n        'The social redirect data found in local storage does not match the expected state. Try connecting again.',\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class MissingRedirectStorageStateError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'missing_redirect_storage_state_error',\n      docsUrl: null,\n      name: 'MissingRedirectStorageStateError',\n      shortMessage:\n        'The social redirect data was not found in local storage. Try connecting again.',\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class MissingSocialUrlParamError extends BaseError {\n  constructor(param: string) {\n    super({\n      cause: null,\n      code: 'missing_social_url_param_error',\n      docsUrl: null,\n      name: 'MissingSocialParamError',\n      shortMessage: `To complete social sign in, the following URL query parameter is required to be set but was not found: ${param}`,\n    });\n  }\n}\n","import type { UserFields } from '@dynamic-labs/sdk-api-core';\n\nimport { BaseError } from './base';\n\ntype MissingUserVerificationErrorParams = {\n  informationToVerify: Extract<keyof UserFields, 'email' | 'phoneNumber'>;\n  message?: string;\n};\n\nexport class MissingUserVerificationError extends BaseError {\n  public readonly informationToVerify: MissingUserVerificationErrorParams['informationToVerify'];\n\n  constructor({\n    informationToVerify,\n    message,\n  }: MissingUserVerificationErrorParams) {\n    super({\n      cause: null,\n      code: 'missing_user_verification_error',\n      docsUrl: null,\n      name: 'MissingUserVerificationError',\n      shortMessage:\n        message ??\n        `The user is missing verification for ${informationToVerify}. Please verify the user's ${informationToVerify}`,\n    });\n\n    this.informationToVerify = informationToVerify;\n  }\n}\n","import { BaseError } from './base';\n\ntype NetworkAddingUnavailableErrorParams = {\n  extraMessages?: string[];\n  originalError: unknown;\n  walletProviderKey: string;\n};\n\nexport class NetworkAddingUnavailableError extends BaseError {\n  constructor({\n    walletProviderKey,\n    originalError,\n    extraMessages,\n  }: NetworkAddingUnavailableErrorParams) {\n    const cause = originalError instanceof Error ? originalError : null;\n\n    super({\n      cause,\n      code: 'network_adding_unavailable',\n      docsUrl: null,\n      metaMessages: [\n        `Wallet provider key: ${walletProviderKey}`,\n        ...(extraMessages ?? []),\n      ],\n      name: 'NetworkAddingUnavailableError',\n      shortMessage: `Network adding is not available for this wallet provider. The user should manually add the network in their wallet`,\n    });\n  }\n}\n","import type { NetworkData } from '../modules/wallets/networks/networkProvider/networkProvider.types';\nimport { BaseError } from './base';\n\ntype NetworkNotAddedErrorParams = {\n  networkData: NetworkData;\n  networkId: string;\n  originalError: unknown;\n  walletProviderKey: string;\n};\n\nexport class NetworkNotAddedError extends BaseError {\n  readonly networkData: NetworkData;\n\n  constructor({\n    networkData,\n    networkId,\n    originalError,\n    walletProviderKey,\n  }: NetworkNotAddedErrorParams) {\n    const cause = originalError instanceof Error ? originalError : null;\n\n    super({\n      cause,\n      code: 'network_not_added',\n      docsUrl: null,\n      metaMessages: [\n        `Wallet provider key: ${walletProviderKey}`,\n        `Network ID: ${networkId}`,\n        'The network is not added to the wallet. If the wallet provider supports adding networks, call the `addNetwork` method before switching.',\n        'The network data is available in the error payload as `error.networkData` and can be passed directly to `addNetwork`.',\n      ],\n      name: 'NetworkNotAddedError',\n      shortMessage: `Cannot switch to network ${networkId} because it is not added to the wallet. If the wallet provider supports it, call \\`addNetwork\\` with the network data from \\`error.networkData\\` first.`,\n    });\n\n    this.networkData = networkData;\n  }\n}\n","import { BaseError } from './base';\n\ntype NetworkSwitchingUnavailableErrorParams = {\n  extraMessages?: string[];\n  originalError: unknown;\n  walletProviderKey: string;\n};\n\nexport class NetworkSwitchingUnavailableError extends BaseError {\n  constructor({\n    walletProviderKey,\n    originalError,\n    extraMessages,\n  }: NetworkSwitchingUnavailableErrorParams) {\n    const cause = originalError instanceof Error ? originalError : null;\n\n    super({\n      cause,\n      code: 'network_switching_unavailable',\n      docsUrl: null,\n      metaMessages: [\n        `Wallet provider key: ${walletProviderKey}`,\n        ...(extraMessages ?? []),\n      ],\n      name: 'NetworkSwitchingUnavailableError',\n      shortMessage: `Network switching is not available at this time. The user should manually switch networks in their wallet`,\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class NoAddressFoundError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'no_address_found_error',\n      docsUrl: null,\n      name: 'NoAddressFoundError',\n      shortMessage: 'No address is connected to the wallet',\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class NoPasskeyCredentialsFoundError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'no_passkey_credentials_found_error',\n      docsUrl: null,\n      name: 'NoPasskeyCredentialsFoundError',\n      shortMessage: 'No passkey credentials found',\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class NoSmartWalletAccountSignerFoundError extends BaseError {\n  constructor(smartWalletAddress: string) {\n    super({\n      cause: null,\n      code: 'no_smart_wallet_account_signer_found_error',\n      docsUrl: null,\n      name: 'NoSmartWalletAccountSignerFoundError',\n      shortMessage: `No signer wallet account found for smart wallet account ${smartWalletAddress}`,\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class NoWebAuthNSupportError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'no_webauthn_support_error',\n      docsUrl: null,\n      name: 'NoWebAuthNSupportError',\n      shortMessage: 'Browser does not support WebAuthn',\n    });\n  }\n}\n","import { BaseError } from './base';\n\ntype UnrecognizedNetworkErrorParams = {\n  networkId: string;\n  originalError: unknown;\n  walletProviderKey: string;\n};\n\nexport class UnrecognizedNetworkError extends BaseError {\n  constructor({\n    networkId,\n    originalError,\n    walletProviderKey,\n  }: UnrecognizedNetworkErrorParams) {\n    const cause = originalError instanceof Error ? originalError : null;\n\n    super({\n      cause,\n      code: 'unrecognized_network',\n      docsUrl: null,\n      metaMessages: [`Wallet provider key: ${walletProviderKey}`],\n      name: 'UnrecognizedNetworkError',\n      shortMessage: `Attempt to switch to unrecognized network of ID ${networkId}. Please enable this network in your dashboard configuration first.`,\n    });\n  }\n}\n","import { BaseError, type BaseErrorParameters } from './base';\n\nexport class UserNotAuthenticatedError extends BaseError {\n  constructor({\n    shortMessage,\n  }: Partial<Pick<BaseErrorParameters, 'shortMessage'>> = {}) {\n    super({\n      cause: null,\n      code: 'user_not_authenticated_error',\n      docsUrl: null,\n      name: 'UserNotAuthenticatedError',\n      shortMessage: shortMessage ?? 'User not authenticated',\n    });\n  }\n}\n","import { BaseError } from './base';\n\ntype UserRejectedErrorParams = {\n  action: string;\n};\n\nexport class UserRejectedError extends BaseError {\n  constructor({ action }: UserRejectedErrorParams) {\n    super({\n      cause: null,\n      code: 'user_rejected',\n      docsUrl: null,\n      name: 'UserRejectedError',\n      shortMessage: `User rejected action \"${action}\"`,\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class WalletAccountAlreadyVerifiedError extends BaseError {\n  constructor(address: string) {\n    super({\n      cause: null,\n      code: 'wallet_account_already_verified_error',\n      docsUrl: null,\n      name: 'WalletAccountAlreadyVerifiedError',\n      shortMessage: `Wallet account ${address} is already verified`,\n    });\n  }\n}\n","import { BaseError } from './base';\n\nexport class WalletAccountNotSelectedError extends BaseError {\n  public readonly expectedAddress: string;\n  public readonly selectedAddress: string;\n\n  constructor(params: { expectedAddress: string; selectedAddress: string }) {\n    const currentAccountInfo = params.selectedAddress\n      ? ` (currently ${params.selectedAddress})`\n      : '';\n    super({\n      cause: null,\n      code: 'wallet_account_not_selected_error',\n      docsUrl: null,\n      name: 'WalletAccountNotSelected',\n      shortMessage: `This wallet only supports signing with its selected account${currentAccountInfo}. Please select account ${params.expectedAddress} in your wallet app and try again`,\n    });\n\n    this.expectedAddress = params.expectedAddress;\n    this.selectedAddress = params.selectedAddress;\n  }\n}\n","import { BaseError } from './base';\n\ntype WalletProviderMethodUnavailableErrorParams = {\n  methodName: string;\n  walletProviderKey: string;\n};\n\nexport class WalletProviderMethodUnavailableError extends BaseError {\n  constructor({\n    methodName,\n    walletProviderKey,\n  }: WalletProviderMethodUnavailableErrorParams) {\n    super({\n      cause: null,\n      code: 'wallet_provider_method_unavailable_error',\n      docsUrl: null,\n      name: 'WalletProviderMethodUnavailableError',\n      shortMessage: `Wallet provider ${walletProviderKey} does not have ${methodName} available`,\n    });\n  }\n}\n","import { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\nimport { updateAuthFromVerifyResponse } from '../../updateAuthFromVerifyResponse';\n\ntype SignInWithExternalJwtParams = {\n  externalJwt?: string;\n  sessionPublicKey?: string;\n};\n\n/**\n * Signs in a user using an external JWT token.\n *\n * This function allows authentication using JWT tokens from external providers,\n * enabling integration with custom authentication systems.\n *\n * @param [params.externalJwt] - Optional external JWT token to authenticate with. Not required when using cookie based auth.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the authentication response from the server.\n */\nexport const signInWithExternalJwt = async (\n  { externalJwt, sessionPublicKey }: SignInWithExternalJwtParams = {},\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.externalAuthSignin({\n    environmentId: core.environmentId,\n    externalAuthSigninRequest: {\n      jwt: externalJwt,\n      sessionPublicKey,\n    },\n  });\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  return response;\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\n\n/**\n * Deletes a passkey for the current user.\n *\n * @param params.passkeyId - The unique identifier of the passkey to delete.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the passkey is successfully deleted.\n */\nexport const deletePasskey = async (\n  { passkeyId }: { passkeyId: string },\n  client = getDefaultClient()\n): Promise<void> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({ includeMfaToken: true }, client);\n\n  await apiClient.deletePasskey({\n    deleteUserPasskeyRequest: {\n      passkeyId,\n    },\n    environmentId: core.environmentId,\n  });\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\n\n/**\n * Retrieves all passkeys associated with the current user.\n *\n * This function fetches the list of registered passkeys (WebAuthn credentials)\n * that the user can use for multi-factor authentication.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an array of the user's registered passkeys.\n */\nexport const getPasskeys = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.getUserPasskeys({\n    environmentId: core.environmentId,\n  });\n\n  return response.passkeys;\n};\n","import type { GetPasskeyRegistrationOptionsResponse } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\n\nexport const getPasskeyRegistrationOptions = async (\n  client: DynamicClient\n): Promise<PublicKeyCredentialCreationOptionsJSON> => {\n  const core = getCore(client);\n\n  const apiClient = createApiClient({}, client);\n\n  const options: GetPasskeyRegistrationOptionsResponse =\n    await apiClient.getPasskeyRegistrationOptions({\n      environmentId: core.environmentId,\n    });\n\n  return options as PublicKeyCredentialCreationOptionsJSON;\n};\n","import type { CreateMfaToken } from '@dynamic-labs/sdk-api-core';\nimport { type RegistrationResponseJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\n\ntype ServerRegisterPasskeyParams = {\n  createMfaToken?: CreateMfaToken;\n  registration: RegistrationResponseJSON;\n};\n\nexport const serverRegisterPasskey = async (\n  { registration, createMfaToken }: ServerRegisterPasskeyParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.registerPasskey({\n    environmentId: core.environmentId,\n    passkeyRegisterRequest: {\n      ...registration,\n      createMfaToken,\n      response: {\n        ...registration.response,\n        clientDataJson: registration.response.clientDataJSON,\n      },\n    } as Parameters<\n      typeof apiClient.registerPasskey\n    >[0]['passkeyRegisterRequest'],\n  });\n\n  return response;\n};\n","import type { CreateMfaToken } from '@dynamic-labs/sdk-api-core';\nimport type { PublicKeyCredentialCreationOptionsJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { NoWebAuthNSupportError } from '../../../../errors/NoWebAuthNSupportError';\nimport { updateAuthFromVerifyResponse } from '../../updateAuthFromVerifyResponse';\nimport { getPasskeyRegistrationOptions } from '../getPasskeyRegistrationOptions';\nimport { serverRegisterPasskey } from '../serverRegisterPasskey';\n\ntype RegisterPasskeyParams = {\n  createMfaToken?: CreateMfaToken;\n};\n\n/**\n * Registers a new passkey for the current user.\n *\n * This function creates a new WebAuthn credential that can be used for\n * passwordless authentication. The user will be prompted to create a passkey\n * using their device's biometric authentication or security key.\n *\n * @param [params.createMfaToken] - Optional configuration for MFA token creation.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the registration response.\n * @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.\n */\nexport const registerPasskey = async (\n  { createMfaToken }: RegisterPasskeyParams = {},\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n\n  if (!core.passkey.isSupported()) {\n    throw new NoWebAuthNSupportError();\n  }\n\n  const options = await getPasskeyRegistrationOptions(client);\n\n  const registration = await core.passkey.register({\n    optionsJSON: options as PublicKeyCredentialCreationOptionsJSON,\n  });\n\n  const response = await serverRegisterPasskey(\n    { createMfaToken, registration },\n    client\n  );\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  return response;\n};\n","import type { GetPasskeyAuthenticationOptionsResponse } from '@dynamic-labs/sdk-api-core';\nimport type { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\n\nexport type GetPasskeyAuthenticationSignInOptionsParams = {\n  relatedOriginRpId?: string;\n};\n\nexport const getPasskeyAuthenticationSignInOptions = async (\n  { relatedOriginRpId }: GetPasskeyAuthenticationSignInOptionsParams = {},\n  client: DynamicClient\n): Promise<PublicKeyCredentialRequestOptionsJSON> => {\n  const core = getCore(client);\n\n  const apiClient = createApiClient({}, client);\n\n  const options: GetPasskeyAuthenticationOptionsResponse =\n    await apiClient.getPasskeyAuthenticationSigninOptions({\n      environmentId: core.environmentId,\n      relatedOriginRpId: relatedOriginRpId,\n    });\n\n  return options as PublicKeyCredentialRequestOptionsJSON;\n};\n","import type {\n  CreateMfaToken,\n  PasskeyAuthRequest,\n} from '@dynamic-labs/sdk-api-core';\nimport type { AuthenticationResponseJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\n\ntype ServerSigninPasskeyParams = {\n  authentication: AuthenticationResponseJSON;\n  createMfaToken?: CreateMfaToken;\n};\n\nexport const serverSigninPasskey = async (\n  { authentication, createMfaToken }: ServerSigninPasskeyParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.signinWithPasskey({\n    environmentId: core.environmentId,\n    passkeyAuthRequest: {\n      ...authentication,\n      createMfaToken,\n      response: {\n        ...authentication.response,\n        clientDataJson: authentication.response.clientDataJSON,\n      },\n    } as PasskeyAuthRequest,\n  });\n\n  return response;\n};\n","import type { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { NoWebAuthNSupportError } from '../../../../errors/NoWebAuthNSupportError';\nimport { updateAuthFromVerifyResponse } from '../../updateAuthFromVerifyResponse';\nimport { getPasskeyAuthenticationSignInOptions } from '../getPasskeyAuthenticationSignInOptions';\nimport { serverSigninPasskey } from '../serverSigninPasskey';\n\nexport type SignInWithPasskeyParams = {\n  relatedOriginRpId?: string;\n};\n\n/**\n * Signs in the user using a registered passkey.\n *\n * This function authenticates the user with a previously registered WebAuthn\n * credential, providing passwordless authentication using biometrics or\n * security keys.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the authentication response.\n * @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.\n */\nexport const signInWithPasskey = async (\n  { relatedOriginRpId }: SignInWithPasskeyParams = {},\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  if (!core.passkey.isSupported()) {\n    throw new NoWebAuthNSupportError();\n  }\n\n  const options = await getPasskeyAuthenticationSignInOptions(\n    { relatedOriginRpId },\n    client\n  );\n\n  const formattedOptions: PublicKeyCredentialRequestOptionsJSON = {\n    ...options,\n  };\n\n  const authentication = await core.passkey.authenticate({\n    optionsJSON: formattedOptions,\n  });\n\n  const response = await serverSigninPasskey({ authentication }, client);\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  return response;\n};\n","import { JwtVerifiedCredentialFormatEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport type { SocialAccount, SocialProvider } from '../social.types';\n\n/**\n * Retrieves all social accounts associated with the current user.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns An array of `SocialAccount` objects associated with the user.\n */\nexport const getUserSocialAccounts = (\n  client = getDefaultClient()\n): SocialAccount[] => {\n  const { user } = client;\n\n  assertDefined(user, 'User is not authenticated');\n\n  const socialCredentials =\n    user.verifiedCredentials.filter(\n      (credential) =>\n        credential.format === JwtVerifiedCredentialFormatEnum.Oauth\n    ) ?? [];\n\n  return socialCredentials.map((credential) => ({\n    accountId: credential.oauthAccountId ?? undefined,\n    displayName: credential.oauthDisplayName ?? undefined,\n    emails: credential.oauthEmails ?? [],\n    photos: credential.oauthAccountPhotos ?? [],\n    provider: credential.oauthProvider as SocialProvider,\n    username: credential.oauthUsername ?? undefined,\n    verifiedCredentialId: credential.id,\n  }));\n};\n","export const removeDynamicOauthParamsFromUrl = (url: string) => {\n  const urlObject = new URL(url);\n\n  urlObject.searchParams.delete('dynamicOauthState');\n  urlObject.searchParams.delete('dynamicOauthCode');\n\n  return urlObject.toString();\n};\n","import { ProviderEnum } from '@dynamic-labs/sdk-api-core';\nimport * as z from 'zod/mini';\n\nimport { createStorageKeySchema } from '../../../../../services/storage';\n\n/** The schema to track the state of the OAuth flow. */\nexport const redirectStateStorageKeySchema = createStorageKeySchema({\n  key: 'redirectState',\n  schema: z.object({\n    codeVerifier: z.optional(z.string()),\n    provider: z.enum(ProviderEnum),\n    state: z.string(),\n  }),\n});\n","export const digestSHA256 = (str: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(str);\n  return crypto.subtle.digest('SHA-256', data);\n};\n","/**\n * Encodes a string to base64url.\n *\n * @param str - The string to encode as an ArrayBuffer.\n * @returns The base64url encoded string.\n */\nexport const encodeBase64Url = (str: ArrayBuffer) => {\n  const numberArray: number[] = [];\n  new Uint8Array(str).forEach((item) => numberArray.push(item));\n\n  // Deprecated btoa used for web compatibility\n  return btoa(String.fromCharCode.apply(null, numberArray))\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n};\n","import { type Provider, ProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { assertDefined } from '../../../../../../../utils/assertDefined';\n\nconst APPLE_RESPONSE_MODE = 'form_post' as const;\nconst APPLE_RESPONSE_TYPE = 'code id_token' as const;\n\n/** Helper function to add OAuth URL parameters to a given base URL. */\nexport const addOAuthUrlParams = (provider: Provider, baseUrl: URL): URL => {\n  assertDefined(provider.clientId, 'Client ID not found');\n  assertDefined(provider.provider, 'Provider type not found');\n  assertDefined(provider.redirectUrl, 'Redirect URL not found');\n\n  const providerType = provider.provider;\n\n  baseUrl.searchParams.set('client_id', provider.clientId);\n  baseUrl.searchParams.set('response_type', 'code');\n  baseUrl.searchParams.set('redirect_uri', provider.redirectUrl);\n\n  if (providerType === ProviderEnum.Tiktok) {\n    baseUrl.searchParams.delete('client_id');\n    baseUrl.searchParams.set('client_key', provider.clientId);\n  }\n\n  if (providerType === ProviderEnum.Google) {\n    baseUrl.searchParams.set('access_type', 'offline');\n  }\n\n  // Add logic for providers that require additional parameters\n  if (providerType === ProviderEnum.Apple) {\n    baseUrl.searchParams.set('response_mode', APPLE_RESPONSE_MODE);\n    baseUrl.searchParams.set('response_type', APPLE_RESPONSE_TYPE);\n  }\n\n  if (provider.scopes) {\n    baseUrl.searchParams.set('scope', provider.scopes);\n  }\n\n  return baseUrl;\n};\n","import { type Provider, ProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { assertDefined } from '../../../../../../../utils/assertDefined';\n\n/** Helper function to build the OAuth base URL for a given provider. */\nexport const getOAuthBaseUrl = (provider: Provider): URL => {\n  assertDefined(provider.provider, 'Provider type not found');\n\n  const providerType = provider.provider;\n\n  if (providerType === ProviderEnum.Telegram) {\n    assertDefined(\n      provider.authorizationUrl,\n      'Telegram authorization URL not found'\n    );\n    return new URL(provider.authorizationUrl);\n  }\n\n  assertDefined(provider.baseAuthUrl, 'Base auth URL not found');\n\n  if (providerType === ProviderEnum.Shopify) {\n    assertDefined(\n      provider.shopifyStore,\n      'Shopify store value not found in provider'\n    );\n    const loginBaseUrl = provider.baseAuthUrl.replace(\n      '{{shopifyStore}}',\n      provider.shopifyStore\n    );\n    return new URL(loginBaseUrl);\n  }\n\n  return new URL(provider.baseAuthUrl);\n};\n","import type { ProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport type { DynamicCore } from '../../../../../../client/core/types';\nimport { assertDefined } from '../../../../../../utils/assertDefined';\nimport { digestSHA256 } from '../../../../../../utils/digestSHA256';\nimport { encodeBase64Url } from '../../../../../../utils/encodeBase64Url';\nimport { randomString } from '../../../../../../utils/randomString';\nimport { addOAuthUrlParams } from './addOAuthUrlParams';\nimport { getOAuthBaseUrl } from './getOAuthBaseUrl';\n\nconst providersRequiringPkce = ['twitter', 'github'];\n\ntype OAuthUrl = {\n  /** A randomly generated string for PKCE flows. */\n  codeVerifier?: string;\n\n  /** A randomly generated string for the OAuth flow. */\n  state: string;\n\n  /** The OAuth URL for the given provider. */\n  url: URL;\n};\n\n/** Helper function to build the OAuth URL for a given provider. */\nexport const buildOAuthUrl = async (\n  /** The core instance. */\n  core: DynamicCore,\n\n  /** The provider to build the OAuth URL for. */\n  provider: ProviderEnum\n): Promise<OAuthUrl> => {\n  const { projectSettings } = core.state.get();\n\n  // Check if the provider is supported\n  assertDefined(projectSettings, 'Project settings not found');\n  assertDefined(projectSettings.providers, 'Project providers not found');\n\n  const socialProvider = projectSettings.providers.find(\n    (p) => p.provider === provider\n  );\n\n  assertDefined(socialProvider, `Social provider ${provider} not supported`);\n\n  // Build the OAuth URL\n  const loginBaseUrl = getOAuthBaseUrl(socialProvider);\n  const socialProviderUrl = addOAuthUrlParams(socialProvider, loginBaseUrl);\n\n  // Add PKCE and state parameters\n  const usingPkce = providersRequiringPkce.includes(provider);\n  const state = randomString(32);\n  const codeVerifier = randomString(43);\n\n  socialProviderUrl.searchParams.set('state', state);\n  socialProviderUrl.searchParams.set('response_type', 'code');\n\n  if (usingPkce) {\n    const digest = await digestSHA256(codeVerifier);\n\n    socialProviderUrl.searchParams.set(\n      'code_challenge',\n      encodeBase64Url(digest)\n    );\n    socialProviderUrl.searchParams.set('code_challenge_method', 'S256');\n  }\n\n  return {\n    codeVerifier: usingPkce ? codeVerifier : undefined,\n    state,\n    url: socialProviderUrl,\n  };\n};\n","import type { ProviderEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../../client/defaultClient';\nimport { createApiClient } from '../../../../apiClient';\nimport { removeDynamicOauthParamsFromUrl } from '../../removeDynamicOauthParamsFromUrl';\nimport type { SocialProvider } from '../../social.types';\nimport { redirectStateStorageKeySchema } from '../redirectStateStorageSchema';\nimport { buildOAuthUrl } from './buildOAuthUrl';\n\ntype AuthenticateWithSocialParams = {\n  provider: SocialProvider;\n  redirectUrl: string;\n};\n\n/**\n * Initiates social authentication by redirecting to the OAuth provider.\n *\n * This function redirects the user to the specified social provider's\n * authorization page to complete OAuth authentication flow.\n * After the oauth flow is complete, the user will be redirected back to your app.\n * You can then call `detectOAuthRedirect` to check if the user got redirected back to your app due to the oauth flow,\n * and finally call `completeSocialAuthentication` to complete the social authentication flow.\n *\n * @param params.provider - The social provider to authenticate with (e.g., 'google', 'github').\n * @param params.redirectUrl - The URL to redirect back to after authentication.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n */\nexport const authenticateWithSocial = async (\n  { provider, redirectUrl }: AuthenticateWithSocialParams,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  await core.initTrack.waitForAll();\n\n  const providerType = provider as ProviderEnum;\n\n  const { url, state, codeVerifier } = await buildOAuthUrl(core, providerType);\n\n  await apiClient.initAuth({\n    environmentId: core.environmentId,\n    oauthInitAuthRequest: {\n      redirectUrl: removeDynamicOauthParamsFromUrl(redirectUrl),\n      state,\n    },\n    providerType,\n  });\n\n  await core.storage.setItem(redirectStateStorageKeySchema, {\n    codeVerifier,\n    provider: providerType,\n    state,\n  });\n\n  await core.navigate(url.toString());\n};\n","import type { VerifyResponse } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../../client/defaultClient';\nimport { InvalidRedirectStorageStateError } from '../../../../../errors/InvalidRedirectStorageStateError';\nimport { MissingRedirectStorageStateError } from '../../../../../errors/MissingRedirectStorageStateError';\nimport { MissingSocialUrlParamError } from '../../../../../errors/MissingSocialUrlParamError';\nimport { createApiClient } from '../../../../apiClient';\nimport { consumeCaptchaToken } from '../../../../captcha/consumeCaptchaToken';\nimport type { User } from '../../../../user/user.types';\nimport { updateAuthFromVerifyResponse } from '../../../updateAuthFromVerifyResponse';\nimport { redirectStateStorageKeySchema } from '../redirectStateStorageSchema';\n\ntype CompleteSocialAuthenticationParams = {\n  url: URL;\n};\n\n/**\n * Completes the social authentication flow after OAuth redirect.\n *\n * This function processes the OAuth callback URL with authorization codes\n * and completes the user authentication with the social provider.\n *\n * @param params.url - The callback URL containing OAuth response parameters.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the authenticated user or null.\n * @throws MissingSocialUrlParamError If required OAuth parameters are missing.\n * @throws InvalidRedirectStorageStateError If the stored state doesn't match.\n */\nexport const completeSocialAuthentication = async (\n  { url }: CompleteSocialAuthenticationParams,\n  client = getDefaultClient()\n): Promise<User | null> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  await core.initTrack.waitForAll();\n\n  const dynamicOauthState = url.searchParams.get('dynamicOauthState');\n  const dynamicOauthCode = url.searchParams.get('dynamicOauthCode');\n\n  if (!dynamicOauthState) {\n    throw new MissingSocialUrlParamError('dynamicOauthState');\n  }\n\n  if (!dynamicOauthCode) {\n    throw new MissingSocialUrlParamError('dynamicOauthCode');\n  }\n\n  const storedSocialRedirectState = await core.storage.getItem(\n    redirectStateStorageKeySchema\n  );\n\n  if (!storedSocialRedirectState) {\n    throw new MissingRedirectStorageStateError();\n  }\n\n  if (storedSocialRedirectState.state !== dynamicOauthState) {\n    throw new InvalidRedirectStorageStateError();\n  }\n\n  const { provider, codeVerifier } = storedSocialRedirectState;\n\n  await core.storage.removeItem(redirectStateStorageKeySchema);\n\n  let response: VerifyResponse;\n\n  // if user is alreadyauthenticated, we're verifying the social auth to link it to the user\n  if (client.user) {\n    response = await apiClient.oauthVerify({\n      environmentId: core.environmentId,\n      oauthRequest: {\n        code: dynamicOauthCode,\n        codeVerifier,\n        state: dynamicOauthState,\n      },\n      providerType: provider,\n    });\n  } else {\n    // if user is not authenticated, we're signing in with the social auth\n    response = await apiClient.oauthSignIn({\n      environmentId: core.environmentId,\n      oauthRequest: {\n        captchaToken: consumeCaptchaToken(client),\n        code: dynamicOauthCode,\n        codeVerifier,\n        state: dynamicOauthState,\n      },\n      providerType: provider,\n    });\n  }\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  return response.user;\n};\n","import { getCore } from '../../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../../client/defaultClient';\nimport { redirectStateStorageKeySchema } from '../redirectStateStorageSchema';\n\ntype DetectOAuthRedirectParams = {\n  url: URL;\n};\n\n/**\n * Detects if the current URL is an OAuth redirect from a social provider.\n *\n * This function examines the URL parameters to determine if it contains\n * OAuth callback data from a social authentication flow.\n *\n * @param params.url - The URL to check for OAuth redirect parameters.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to true if the URL is an OAuth redirect, false otherwise.\n */\nexport const detectOAuthRedirect = async (\n  { url }: DetectOAuthRedirectParams,\n  client = getDefaultClient()\n): Promise<boolean> => {\n  const core = getCore(client);\n\n  const dynamicOauthState = url.searchParams.get('dynamicOauthState');\n  const dynamicOauthCode = url.searchParams.get('dynamicOauthCode');\n\n  if (!dynamicOauthState || !dynamicOauthCode) {\n    return false;\n  }\n\n  // Wait for SDK to load\n  await core.initTrack.waitForAll();\n\n  const storedSocialRedirectState = await core.storage.getItem(\n    redirectStateStorageKeySchema\n  );\n\n  if (\n    !storedSocialRedirectState ||\n    storedSocialRedirectState.state !== dynamicOauthState\n  ) {\n    return false;\n  }\n\n  return true;\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { getWalletAccounts } from '../../getWalletAccounts';\nimport type { WalletAccount } from '../../walletAccount';\n\n/**\n * Get the primary wallet account.\n * The primary wallet account is the one that was last selected by the user.\n * This information is stored in both unverified and verified wallet accounts.\n * This function consolidates this information to determine which wallet was most recently selected.\n */\nexport const getPrimaryWalletAccount = (\n  client = getDefaultClient()\n): WalletAccount | null => {\n  const walletAccounts = getWalletAccounts(client);\n\n  const sortedLastSelectedWalletAccounts = walletAccounts\n    .filter(\n      (\n        walletAccount\n      ): walletAccount is WalletAccount & { lastSelectedAt: Date } =>\n        Boolean(walletAccount.lastSelectedAt)\n    )\n    .sort((a, b) => b.lastSelectedAt.getTime() - a.lastSelectedAt.getTime());\n\n  if (sortedLastSelectedWalletAccounts.length === 0) {\n    return null;\n  }\n\n  const [primaryWalletAccount] = sortedLastSelectedWalletAccounts;\n\n  return primaryWalletAccount;\n};\n","import type { VerifyResponse } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../../client/defaultClient';\nimport { createApiClient } from '../../../../apiClient';\nimport { getPrimaryWalletAccount } from '../../../../wallets/primaryWalletAccount/getPrimaryWalletAccount';\nimport { updateAuthFromVerifyResponse } from '../../../updateAuthFromVerifyResponse';\n\ntype UnlinkSocialAccountParams = {\n  verifiedCredentialId: string;\n};\n\n/**\n * Unlinks a social account from the user's account.\n *\n * @param params.verifiedCredentialId - The verified credential ID of the social account to unlink.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the verify response.\n */\nexport const unlinkSocialAccount = async (\n  { verifiedCredentialId }: UnlinkSocialAccountParams,\n  client = getDefaultClient()\n): Promise<VerifyResponse> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  // the api seems to require us to pass the primary wallet id when\n  // unlinking a social account if the user has wallets\n  const primaryWalletAccount = getPrimaryWalletAccount(client);\n  const walletId = primaryWalletAccount?.verifiedCredentialId?.replace(\n    '-zerodev',\n    ''\n  );\n\n  const response = await apiClient.verifyUnlink({\n    environmentId: core.environmentId,\n    verifyUnlinkRequest: {\n      verifiedCredentialId,\n      walletId: walletId ?? undefined,\n    },\n  });\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  return response;\n};\n","import type {\n  MultichainAccountBalanceResponse,\n  MultichainAccountBalancesRequest,\n} from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\n\nexport type GetMultichainBalancesParams = {\n  balanceRequest: MultichainAccountBalancesRequest;\n};\n\n/**\n * Retrieves token balances across multiple blockchain networks.\n *\n * This function fetches cryptocurrency and token balances for the user's\n * wallet addresses across different chains, networks and addresses specified in the request.\n *\n * @param params.balanceRequest - The balance request configuration specifying which chains, networks and addresses to query.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the chain balances across multiple networks.\n */\nexport const getMultichainBalances = async (\n  { balanceRequest }: GetMultichainBalancesParams,\n  client = getDefaultClient()\n): Promise<MultichainAccountBalanceResponse['chainBalances']> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.postMultichainAccountBalances({\n    environmentId: core.environmentId,\n    multichainAccountBalancesRequest: balanceRequest,\n  });\n\n  return response.chainBalances;\n};\n","/* eslint-disable no-restricted-globals */\n\nimport { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { ValueMustBeDefinedError } from '../../../../errors/ValueMustBeDefinedError';\n\ntype AddCoinbaseOnrampOrderEventListenerParams = {\n  listener: (event: {\n    data: Record<string, unknown>;\n    eventName: string;\n  }) => void;\n};\n\n/**\n * Adds a listener for Coinbase onramp order events.\n *\n * @param params.listener - The listener function to call when an event is received.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A function to remove the listener.\n * @throws {ValueMustBeDefinedError} If the window is not available.\n * @docs https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api#events-names\n */\nexport const addCoinbaseOnrampOrderEventListener = (\n  { listener }: AddCoinbaseOnrampOrderEventListenerParams,\n  client = getDefaultClient()\n): VoidFunction => {\n  const core = getCore(client);\n\n  if (typeof window === 'undefined') {\n    throw new ValueMustBeDefinedError(\n      'Window is not available to listen for Coinbase onramp order events'\n    );\n  }\n\n  const handleMessageEvent = (event: MessageEvent) => {\n    if (event.origin !== 'https://pay.coinbase.com') {\n      return;\n    }\n\n    core.logger.debug(\n      '[addCoinbaseOnrampOrderEventListener] pay.coinbase.com event received',\n      { event }\n    );\n\n    try {\n      const coinbaseOnrampOrderEventData = JSON.parse(event.data);\n\n      if (!coinbaseOnrampOrderEventData.eventName?.startsWith('onramp_api.')) {\n        return;\n      }\n\n      listener({\n        data: coinbaseOnrampOrderEventData.data,\n        eventName: coinbaseOnrampOrderEventData.eventName,\n      });\n    } catch (error) {\n      core.logger.debug(\n        '[addCoinbaseOnrampOrderEventListener] Failed to parse Coinbase onramp order event data',\n        {\n          error,\n        }\n      );\n    }\n  };\n\n  window.addEventListener('message', handleMessageEvent);\n\n  return () => {\n    window.removeEventListener('message', handleMessageEvent);\n  };\n};\n","import { JwtVerifiedCredentialFormatEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { InvalidParamError } from '../../../../errors/InvalidParamError';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport type {\n  CoinbaseOnrampOrderPaymentMethod,\n  FieldMissingVerificationForCoinbaseOnramp,\n} from '../coinbase.types';\n\ntype GetMissingVerificationForCoinbaseOnrampOrderResponse =\n  FieldMissingVerificationForCoinbaseOnramp[];\n\ntype GetMissingVerificationForCoinbaseOnrampOrderParams = {\n  paymentMethod: CoinbaseOnrampOrderPaymentMethod;\n};\n\n/**\n * This function is used to get a list of fields that are missing verification for a Coinbase onramp order\n *\n * - If the user is missing information for an email or phone number, the field will be returned with the error code MISSING_INFORMATION\n * - If the user is missing verification for an email or phone number, the field will be returned with the error code MISSING_VERIFICATION\n *   and the existing unverified email or phone number will be included in the data field.\n * - If the user's phone number has not been verified in the last 60 days, the field will be returned with the error code VERIFICATION_EXPIRED\n *   and the existing phone number will be included in the data field.\n *\n * @param params.paymentMethod - The payment method that will be used to create the onramp order\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns FieldMissingVerificationForCoinbaseOnramp[] - An array of fields that are missing verification for a Coinbase onramp order\n * @throws {InvalidParamError} - If the payment method is not valid\n * @throws {ValueMustBeDefinedError} - If the user is not authenticated\n */\nexport const getMissingVerificationForCoinbaseOnrampOrder = (\n  { paymentMethod }: GetMissingVerificationForCoinbaseOnrampOrderParams,\n  client = getDefaultClient()\n): GetMissingVerificationForCoinbaseOnrampOrderResponse => {\n  // adding the payment method as a param for now just so a user has to pass an object as the first param\n  // that way, when we add more payment methods, we can easily add them to the param object\n  // and not have to change the function signature\n  if (paymentMethod !== 'GUEST_CHECKOUT_APPLE_PAY') {\n    throw new InvalidParamError(`Invalid payment method: ${paymentMethod}`);\n  }\n\n  const { user } = client;\n\n  assertDefined(user, 'User is not authenticated');\n\n  const fieldsMissingVerification: FieldMissingVerificationForCoinbaseOnramp[] =\n    [];\n\n  const emailVerifiedCredential = user.verifiedCredentials.find(\n    (credential) => credential.format === JwtVerifiedCredentialFormatEnum.Email\n  );\n\n  if (!user.email) {\n    // when user has no email at all (verified or not)\n    fieldsMissingVerification.push({\n      errorCode: 'MISSING_INFORMATION',\n      field: 'email',\n    });\n  } else if (!emailVerifiedCredential) {\n    // when user has an email but it is not verified\n    fieldsMissingVerification.push({\n      data: user.email,\n      errorCode: 'MISSING_VERIFICATION',\n      field: 'email',\n    });\n  }\n\n  const phoneVerifiedCredential = user.verifiedCredentials.find(\n    (credential) =>\n      credential.format === JwtVerifiedCredentialFormatEnum.PhoneNumber\n  );\n\n  const phoneNumberVerifiedInPast60Days =\n    phoneVerifiedCredential?.verifiedAt &&\n    phoneVerifiedCredential.verifiedAt >=\n      new Date(Date.now() - 60 * 24 * 60 * 60 * 1000);\n\n  if (!user.phoneNumber) {\n    // when user has no phone number at all (verified or not)\n    fieldsMissingVerification.push({\n      errorCode: 'MISSING_INFORMATION',\n      field: 'phoneNumber',\n    });\n  } else if (!phoneVerifiedCredential) {\n    // when user has a phone number but it is not verified\n    fieldsMissingVerification.push({\n      data: user.phoneNumber,\n      errorCode: 'MISSING_VERIFICATION',\n      field: 'phoneNumber',\n    });\n  } else if (!phoneNumberVerifiedInPast60Days) {\n    // when user has a verified phone number but it is not verified in the last 60 days\n    fieldsMissingVerification.push({\n      data: user.phoneNumber,\n      errorCode: 'VERIFICATION_EXPIRED',\n      field: 'phoneNumber',\n    });\n  }\n\n  return fieldsMissingVerification;\n};\n","import { type SdkUser } from '@dynamic-labs/sdk-api-core';\n\nimport type { DynamicClient } from '../../../../../client/types/DynamicClient';\nimport { MissingUserVerificationError } from '../../../../../errors/MissingUserVerificationError';\nimport { assertDefined } from '../../../../../utils/assertDefined';\nimport { getMissingVerificationForCoinbaseOnrampOrder } from '../../getMissingVerificationForCoinbaseOnrampOrder';\n\nexport const validateUserCredentialsForCoinbaseOnrampOrder = (\n  client: DynamicClient\n): SdkUser => {\n  const { user } = client;\n\n  assertDefined(user, 'User is not authenticated');\n\n  const fieldsMissingVerification =\n    getMissingVerificationForCoinbaseOnrampOrder(\n      { paymentMethod: 'GUEST_CHECKOUT_APPLE_PAY' },\n      client\n    );\n\n  const missingEmailVerification = fieldsMissingVerification.find(\n    (field) => field.field === 'email'\n  );\n\n  if (missingEmailVerification) {\n    throw new MissingUserVerificationError({\n      informationToVerify: 'email',\n      message:\n        'User must have a verified email to create a Coinbase onramp order',\n    });\n  }\n\n  const missingPhoneNumberVerification = fieldsMissingVerification.find(\n    (field) => field.field === 'phoneNumber'\n  );\n\n  if (\n    missingPhoneNumberVerification &&\n    missingPhoneNumberVerification.errorCode !== 'VERIFICATION_EXPIRED'\n  ) {\n    throw new MissingUserVerificationError({\n      informationToVerify: 'phoneNumber',\n      message:\n        'User must have a verified phone number to create a Coinbase onramp order',\n    });\n  }\n\n  // this is a requirement for Coinbase Onramp\n  // https://docs.cdp.coinbase.com/api-reference/v2/rest-api/onramp/create-an-onramp-order#body-phone-number-verified-at\n  if (\n    missingPhoneNumberVerification &&\n    missingPhoneNumberVerification.errorCode === 'VERIFICATION_EXPIRED'\n  ) {\n    throw new MissingUserVerificationError({\n      informationToVerify: 'phoneNumber',\n      message:\n        \"The user's phone number has not been verified in the last 60 days. Please re-verify the user's phone number\",\n    });\n  }\n\n  return user;\n};\n","import type { CoinbaseOnrampOrderPaymentMethod } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\nimport type {\n  CoinbaseCreateOnrampOrderRequest,\n  CoinbaseOnrampOrderResponse,\n} from '../coinbase.types';\nimport { validateUserCredentialsForCoinbaseOnrampOrder } from '../utils/validateUserCredentialsForCoinbaseOnrampOrder';\n\n/**\n * Creates a Coinbase onramp order\n *\n * @param orderParams CoinbaseCreateOnrampOrderRequest - The parameters for the onramp order.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns The created order\n * @throws {MissingUserVerificationError} If the user is missing verification for email or phone\n */\nexport const createCoinbaseOnrampOrder = async (\n  orderParams: CoinbaseCreateOnrampOrderRequest,\n  client = getDefaultClient()\n): Promise<CoinbaseOnrampOrderResponse> => {\n  const user = validateUserCredentialsForCoinbaseOnrampOrder(client);\n\n  const core = getCore(client);\n  const apiClient = createApiClient({ includeMfaToken: true }, client);\n\n  const { isSandbox, ...restOrderParams } = orderParams;\n\n  const orderResponse = await apiClient.createCoinbaseOnrampOrder({\n    coinbaseOnrampOrderCreateRequest: {\n      ...restOrderParams,\n      // to create a sandbox order, we need to prefix the partner user ref with 'sandbox-'\n      // https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api#testing\n      partnerUserRef:\n        orderParams.partnerUserRef ??\n        (isSandbox ? `sandbox-${user.id}` : user.id),\n      paymentMethod:\n        orderParams.paymentMethod as CoinbaseOnrampOrderPaymentMethod,\n    },\n    environmentId: core.environmentId,\n  });\n\n  if (!isSandbox || !orderResponse.paymentLink) {\n    return orderResponse;\n  }\n\n  return {\n    ...orderResponse,\n    paymentLink: {\n      ...orderResponse.paymentLink,\n      url: `${orderResponse.paymentLink.url}&useApplePaySandbox=true`,\n    },\n  };\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\nimport type {\n  CoinbaseOnrampGetBuyUrlRequest,\n  CoinbaseOnrampGetBuyUrlResponse,\n} from '../coinbase.types';\n\n/**\n * Gets a Coinbase buy URL\n *\n * @param buyUrlParams CoinbaseOnrampGetBuyUrlRequest - The parameters for the buy URL.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns an object containing the buy URL\n */\nexport const getCoinbaseBuyUrl = async (\n  buyUrlParams: CoinbaseOnrampGetBuyUrlRequest,\n  client = getDefaultClient()\n): Promise<CoinbaseOnrampGetBuyUrlResponse> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({ includeMfaToken: true }, client);\n\n  const response = await apiClient.generateCoinbaseOnrampBuyUrl({\n    coinbaseOnrampGetBuyUrlRequest: buyUrlParams,\n    environmentId: core.environmentId,\n  });\n\n  return response;\n};\n","import type { ChainEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\nimport type {\n  CryptoDotComPaymentCreateRequest,\n  CryptoDotComPaymentResponse,\n} from '../cryptoDotCom.types';\n\n/**\n * Creates a crypto.com payment\n *\n * @param paymentParams CryptoDotComPaymentCreateRequest - The parameters for the payment.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns The created payment\n */\nexport const createCryptoDotComPayment = async (\n  paymentParams: CryptoDotComPaymentCreateRequest,\n  client = getDefaultClient()\n): Promise<CryptoDotComPaymentResponse> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({ includeMfaToken: true }, client);\n\n  const response = await apiClient.createCryptoDotComPayment({\n    cryptoDotComPaymentCreateRequest: {\n      ...paymentParams,\n      // eslint-disable-next-line custom-rules/ban-chain-enum\n      chain: paymentParams.chain as ChainEnum,\n    },\n    environmentId: core.environmentId,\n  });\n\n  return response;\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\n\n/**\n * Allows waiting until all modules of the client have been properly initialized\n * and are ready for use.\n *\n * @returns a promise that resolves once the client is fully initialized.\n */\nexport const waitForClientInitialized = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n\n  await core.initTrack.waitForAll();\n};\n","/**\n * Default CDN URL for the wallet book.\n */\nconst DEFAULT_WALLET_BOOK_CDN_URL =\n  'https://dynamic-static-assets.com/wallet-book/v1/stable/wallet-book.json';\n\n/**\n * Gets the wallet book CDN URL from environment variables with fallback to default.\n *\n * Checks for environment variables in the following order:\n * 1. WALLET_BOOK_CDN_URL\n * 2. NEXT_PUBLIC_WALLET_BOOK_CDN_URL\n * 4. Default CDN URL\n *\n * @returns The wallet book CDN URL to use.\n */\nexport const getWalletBookCdnUrl = (): string => {\n  if (typeof process !== 'undefined' && process.env) {\n    const envVar =\n      process.env.WALLET_BOOK_CDN_URL ||\n      process.env.NEXT_PUBLIC_WALLET_BOOK_CDN_URL;\n\n    if (envVar) {\n      return envVar;\n    }\n  }\n\n  return DEFAULT_WALLET_BOOK_CDN_URL;\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { APIError } from '../../../../errors/APIError';\nimport { getWalletBookCdnUrl } from '../../getWalletBookCdnUrl';\nimport type { WalletBookSchema } from '../../legacyWalletBook.types';\n\n/**\n * The timeout for each fetch attempt in milliseconds.\n */\nconst FETCH_TIMEOUT_MS = 30000; // 30 seconds\n\n/**\n * Fetches the wallet book from the CDN endpoint with timeout handling.\n *\n * @param client - The Dynamic client instance.\n * @returns A promise that resolves to the wallet book data.\n */\nexport const fetchWithTimeout = async (\n  client: DynamicClient\n): Promise<WalletBookSchema> => {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);\n  const core = getCore(client);\n\n  try {\n    const response = await core.fetch(getWalletBookCdnUrl(), {\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new APIError(\n        `Failed to fetch wallet book: ${response.status} ${response.statusText}`,\n        'wallet_book_fetch_error',\n        response.status\n      );\n    }\n\n    const data = (await response.json()) as WalletBookSchema;\n\n    return data;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\n","import * as z from 'zod/mini';\n\nimport { createStorageKeySchema } from '../../../services/storage';\nimport type { WalletBookSchema } from '../legacyWalletBook.types';\n\n/**\n * The schema to store the cached wallet book data.\n */\nexport const walletBookCacheStorageKeySchema = createStorageKeySchema({\n  key: 'legacyWalletBookCache',\n  schema: z.object({\n    groups: z.record(z.string(), z.any()),\n    wallets: z.record(z.string(), z.any()),\n  }) as z.ZodMiniType<WalletBookSchema>,\n});\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types';\nimport { retryOnFail } from '../../../utils/retryOnFail';\nimport type { WalletBookSchema } from '../legacyWalletBook.types';\nimport { fetchWithTimeout } from './fetchWithTimeout';\nimport { walletBookCacheStorageKeySchema } from './walletBookCacheStorageKeySchema';\n\n/**\n * The maximum number of retry attempts.\n */\nconst MAX_RETRIES = 3;\n\n/**\n * The delay between retries in milliseconds.\n */\nconst RETRY_DELAY_MS = 100;\n\n/**\n * Fetches the legacy wallet book from Dynamic's CDN endpoint.\n *\n * This function implements a two-tier fallback strategy:\n * 1. Primary: Fetch from CDN endpoint (with retries)\n * 2. Secondary: Use cached version from localStorage if available\n *\n * @param client - The Dynamic client instance.\n * @returns A promise that resolves to the wallet book data.\n * @throws If both CDN fetch and cache retrieval fail.\n */\nexport const fetchLegacyWalletBook = async (\n  client: DynamicClient\n): Promise<WalletBookSchema> => {\n  const core = getCore(client);\n\n  core.logger.debug('[fetchLegacyWalletBook] Fetching wallet book...');\n\n  // Try to fetch from CDN with retry logic\n  try {\n    const walletBook = await retryOnFail({\n      delay: RETRY_DELAY_MS,\n      fn: async () => fetchWithTimeout(client),\n      maxRetries: MAX_RETRIES,\n    });\n\n    await core.storage.setItem(walletBookCacheStorageKeySchema, walletBook);\n\n    core.logger.debug(\n      '[fetchLegacyWalletBook] Successfully fetched wallet book from CDN'\n    );\n\n    return walletBook;\n  } catch (error) {\n    core.logger.debug(\n      '[fetchLegacyWalletBook] Failed to fetch from CDN, trying cache...',\n      error\n    );\n\n    // Try to get from cache\n    const cachedWalletBook = await core.storage.getItem(\n      walletBookCacheStorageKeySchema\n    );\n\n    if (cachedWalletBook) {\n      core.logger.debug('[fetchLegacyWalletBook] Using cached wallet book');\n\n      return cachedWalletBook as WalletBookSchema;\n    }\n\n    // If both CDN and cache fail, throw the original error\n    core.logger.debug(\n      '[fetchLegacyWalletBook] Failed to fetch from CDN and no cache available'\n    );\n\n    throw error;\n  }\n};\n","import type { WalletSchema } from '../../legacyWalletBook.types';\n\n/**\n * Embedded wallet keys that should be filtered out from the WalletConnect catalog.\n * These wallets are not meant to be displayed in wallet selection lists.\n */\nexport const EMBEDDED_WALLET_KEYS = [\n  'magicemailotp',\n  'magiclink',\n  'magicsocial',\n  'turnkey',\n  'turnkeyhd',\n  'zerodev',\n  'dynamicwaas',\n  'coinbasempc',\n  'mpcvault',\n  'mpcwallet',\n];\n\n/**\n * Checks if a wallet should be filtered out from the WalletConnect catalog.\n *\n * @param walletKey - The wallet key identifier.\n * @param wallet - The wallet schema to check.\n * @returns True if the wallet should be filtered out, false otherwise.\n */\nexport const shouldFilterWallet = (\n  walletKey: string,\n  wallet: WalletSchema\n): boolean => {\n  // Filter out embedded wallets\n  if (EMBEDDED_WALLET_KEYS.includes(walletKey)) {\n    return true;\n  }\n\n  // Filter out wallets that don't support WalletConnect sign_v2\n  if (!wallet.walletConnect || !wallet.walletConnect.sdks.includes('sign_v2')) {\n    return true;\n  }\n\n  // Filter out wallets that are only injected (have injectedConfig but no mobile/desktop links)\n  const hasInjectedConfig =\n    wallet.injectedConfig && wallet.injectedConfig.length > 0;\n  const hasMobileLinks = Boolean(\n    wallet.mobile?.androidId ||\n      wallet.mobile?.iosId ||\n      wallet.mobile?.native ||\n      wallet.mobile?.universal\n  );\n  const hasDesktopLinks = Boolean(\n    wallet.desktop?.chromeId ||\n      wallet.desktop?.edgeId ||\n      wallet.desktop?.firefoxId ||\n      wallet.desktop?.operaId ||\n      wallet.desktop?.safariId ||\n      wallet.desktop?.universal\n  );\n\n  if (hasInjectedConfig && !hasMobileLinks && !hasDesktopLinks) {\n    return true;\n  }\n\n  return false;\n};\n","import { DYNAMIC_ICONIC_SPRITE_URL } from '../../../constants';\n\ntype GetSpriteUrlParams = {\n  spriteId: string;\n};\n\n/**\n * Gets the sprite URL for a given sprite ID.\n *\n * @param params.spriteId - The sprite identifier from the wallet book.\n * @returns The full URL to the sprite icon\n */\nexport const getSpriteUrl = ({ spriteId }: GetSpriteUrlParams): string =>\n  `${DYNAMIC_ICONIC_SPRITE_URL}#${spriteId}`;\n","import { getSpriteUrl } from '../../getSpriteUrl';\nimport type { WalletBookSchema } from '../../legacyWalletBook.types';\nimport type { WalletConnectCatalogGroup } from '../getWalletConnectCatalog.types';\n\ntype TransformGroupParams = {\n  group: WalletBookSchema['groups'][string];\n};\n\n/**\n * Transforms a wallet group schema into a WalletConnect catalog group.\n */\nexport const transformGroup = ({\n  group,\n}: TransformGroupParams): WalletConnectCatalogGroup => {\n  const spriteId = group.brand?.spriteId ?? '';\n\n  return {\n    key: group.key,\n    name: group.name,\n    primaryColor: group.brand?.primaryColor,\n    spriteUrl: spriteId ? getSpriteUrl({ spriteId }) : '',\n  };\n};\n","import { getChainFromVerifiedCredentialChain } from '../../../../utils/getChainFromVerifiedCredentialChain';\nimport type { Chain } from '../../../chain';\nimport type { WalletSchema } from '../../legacyWalletBook.types';\n\n/**\n * Maps wallet book injected config chain identifiers to Chain type.\n */\nconst INJECTED_CHAIN_TO_CHAIN_MAP: Record<string, Chain> = {\n  algo: 'ALGO',\n  aptos: 'APTOS',\n  bitcoin: 'BTC',\n  btc: 'BTC',\n  cosmos: 'COSMOS',\n  eclipse: 'ECLIPSE',\n  evm: 'EVM',\n  flow: 'FLOW',\n  sol: 'SOL',\n  spark: 'SPARK',\n  starknet: 'STARK',\n  sui: 'SUI',\n  ton: 'TON',\n  tron: 'TRON',\n};\n\ntype ExtractChainPrefixParams = {\n  chainIdentifier: string;\n};\n\n/**\n * Extracts the chain prefix from a chain identifier string.\n * For example, \"eip155:1\" -> \"eip155\", \"solana:...\" -> \"solana\"\n */\nconst extractChainPrefix = ({\n  chainIdentifier,\n}: ExtractChainPrefixParams): string => {\n  const colonIndex = chainIdentifier.indexOf(':');\n\n  if (colonIndex === -1) {\n    return chainIdentifier;\n  }\n\n  return chainIdentifier.substring(0, colonIndex);\n};\n\n/**\n * Maps chain name patterns found in wallet keys to Chain type.\n * These are common suffixes or embedded chain identifiers in wallet keys.\n */\nconst WALLET_KEY_CHAIN_PATTERNS: Array<{ chain: Chain; pattern: string }> = [\n  { chain: 'SOL', pattern: 'sol' },\n  { chain: 'SOL', pattern: 'solana' },\n  { chain: 'BTC', pattern: 'btc' },\n  { chain: 'BTC', pattern: 'bitcoin' },\n  { chain: 'STARK', pattern: 'stark' },\n  { chain: 'STARK', pattern: 'starknet' },\n  { chain: 'SUI', pattern: 'sui' },\n  { chain: 'APTOS', pattern: 'aptos' },\n  { chain: 'COSMOS', pattern: 'cosmos' },\n  { chain: 'FLOW', pattern: 'flow' },\n  { chain: 'ALGO', pattern: 'algo' },\n  { chain: 'TRON', pattern: 'tron' },\n  { chain: 'TON', pattern: 'ton' },\n  { chain: 'SPARK', pattern: 'spark' },\n  { chain: 'ECLIPSE', pattern: 'eclipse' },\n];\n\ntype GetChainFromWalletKeyParams = {\n  walletKey: string;\n};\n\n/**\n * Attempts to extract the chain from a wallet key by looking for embedded chain identifiers.\n *\n * @param params.walletKey - The wallet key identifier.\n * @returns The chain type if found, undefined otherwise.\n */\nconst getChainFromWalletKey = ({\n  walletKey,\n}: GetChainFromWalletKeyParams): Chain | undefined => {\n  const lowerKey = walletKey.toLowerCase();\n\n  for (const { chain, pattern } of WALLET_KEY_CHAIN_PATTERNS) {\n    if (lowerKey.includes(pattern)) {\n      return chain;\n    }\n  }\n\n  return undefined;\n};\n\ntype GetChainFromWalletSchemaParams = {\n  wallet: WalletSchema;\n  walletKey?: string;\n};\n\n/**\n * Gets the chain from a wallet book entry.\n * Checks injectedConfig first, then falls back to the chains array, then the wallet key.\n * If no chain can be determined, defaults to EVM.\n *\n * @param params.wallet - The wallet schema from the wallet book.\n * @param params.walletKey - The wallet key identifier (optional, used as last resort fallback).\n * @returns The chain type, defaults to EVM if no chain can be determined.\n */\nexport const getChainFromWalletSchema = ({\n  wallet,\n  walletKey,\n}: GetChainFromWalletSchemaParams): Chain => {\n  // First, check injectedConfig for the chain field\n  if (wallet.injectedConfig && wallet.injectedConfig.length > 0) {\n    const injectedChain = wallet.injectedConfig[0].chain?.toLowerCase();\n\n    if (injectedChain && INJECTED_CHAIN_TO_CHAIN_MAP[injectedChain]) {\n      return INJECTED_CHAIN_TO_CHAIN_MAP[injectedChain];\n    }\n  }\n\n  // Fall back to checking the chains array\n  if (wallet.chains && wallet.chains.length > 0) {\n    const firstChain = wallet.chains[0];\n    const chainPrefix = extractChainPrefix({ chainIdentifier: firstChain });\n\n    try {\n      return getChainFromVerifiedCredentialChain(chainPrefix);\n    } catch {\n      // If the chain prefix is not recognized, fall back to wallet key check\n    }\n  }\n\n  // Last resort: try to extract chain from wallet key\n  if (walletKey) {\n    const chainFromKey = getChainFromWalletKey({ walletKey });\n\n    if (chainFromKey) {\n      return chainFromKey;\n    }\n  }\n\n  // Default to EVM if no chain can be determined\n  return 'EVM';\n};\n","import { getSpriteUrl } from '../../getSpriteUrl';\nimport type { WalletBookSchema } from '../../legacyWalletBook.types';\nimport { getChainFromWalletSchema } from '../getChainFromWalletSchema';\nimport type { WalletConnectCatalogWallet } from '../getWalletConnectCatalog.types';\n\ntype TransformWalletParams = {\n  wallet: WalletBookSchema['wallets'][string];\n  walletKey: string;\n};\n\n/**\n * Transforms a wallet schema into a WalletConnect catalog wallet entry.\n */\nexport const transformWallet = ({\n  wallet,\n  walletKey,\n}: TransformWalletParams): WalletConnectCatalogWallet => {\n  const spriteId = wallet.brand?.spriteId ?? '';\n\n  const androidId = wallet.mobile?.androidId;\n  const iosId = wallet.mobile?.iosId;\n\n  return {\n    chain: getChainFromWalletSchema({ wallet, walletKey }),\n    deeplinks: {\n      native: wallet.mobile?.native,\n      universal: wallet.mobile?.universal,\n    },\n    downloadLinks: {\n      androidUrl: androidId\n        ? `https://play.google.com/store/apps/details?id=${androidId}`\n        : undefined,\n      iosUrl: iosId ? `https://apps.apple.com/app/${iosId}` : undefined,\n    },\n    groupId: wallet.group,\n    name: wallet.name,\n    primaryColor: wallet.brand?.primaryColor,\n    spriteUrl: spriteId ? getSpriteUrl({ spriteId }) : '',\n  };\n};\n","import type { WalletBookSchema } from '../../legacyWalletBook.types';\nimport type {\n  WalletConnectCatalog,\n  WalletConnectCatalogGroup,\n  WalletConnectCatalogWallet,\n} from '../getWalletConnectCatalog.types';\nimport { shouldFilterWallet } from '../shouldFilterWallet';\nimport { transformGroup } from '../transformGroup';\nimport { transformWallet } from '../transformWallet';\n\ntype TransformWalletBookParams = {\n  walletBook: WalletBookSchema;\n};\n\n/**\n * Transforms the legacy wallet book into a WalletConnect catalog structure.\n * Filters out embedded wallets and injected-only wallets.\n */\nexport const transformWalletBook = ({\n  walletBook,\n}: TransformWalletBookParams): WalletConnectCatalog => {\n  const groups: Record<string, WalletConnectCatalogGroup> = {};\n\n  for (const [groupKey, group] of Object.entries(walletBook.groups)) {\n    groups[groupKey] = transformGroup({ group });\n  }\n\n  const wallets: Record<string, WalletConnectCatalogWallet> = {};\n\n  for (const [walletKey, wallet] of Object.entries(walletBook.wallets)) {\n    if (shouldFilterWallet(walletKey, wallet)) {\n      continue;\n    }\n\n    wallets[walletKey] = transformWallet({ wallet, walletKey });\n  }\n\n  return { groups, wallets };\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { fetchLegacyWalletBook } from '../fetchLegacyWalletBook';\nimport type { WalletConnectCatalog } from './getWalletConnectCatalog.types';\nimport { transformWalletBook } from './transformWalletBook';\n\n/**\n * Retrieves the WalletConnect catalog from Dynamic's wallet book.\n *\n * This function fetches the wallet book and returns a WalletConnect catalog structure\n * that can be used for displaying wallet information and performing deep links for mobile wallet connections.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the WalletConnect catalog containing groups and wallets.\n * @throws If unable to fetch the wallet book from the API (when both CDN fetch and cache retrieval fail).\n */\nexport const getWalletConnectCatalog = async (\n  client = getDefaultClient()\n): Promise<WalletConnectCatalog> => {\n  const walletBook = await fetchLegacyWalletBook(client);\n\n  return transformWalletBook({ walletBook });\n};\n","import type { Chain } from '../../../chain';\nimport { CHAINS_INFO_MAP } from '../../constants';\n\ntype ExtractChainFromNormalizedNameParams = {\n  normalizedWalletNameWithChain: string;\n};\n\n/**\n * Extracts the chain from a normalized wallet name with chain suffix.\n * The chain is appended in lowercase at the end (e.g., \"metamaskevm\" -> \"EVM\").\n *\n * @param params.normalizedWalletNameWithChain - The normalized wallet name with chain suffix.\n * @returns The chain if found, undefined otherwise.\n */\nexport const extractChainFromNormalizedName = ({\n  normalizedWalletNameWithChain,\n}: ExtractChainFromNormalizedNameParams): Chain | undefined => {\n  const lowerName = normalizedWalletNameWithChain.toLowerCase();\n\n  // Get all chain names in lowercase, sorted by length (longest first) to match longest suffix first\n  const chainSuffixes = (Object.keys(CHAINS_INFO_MAP) as Chain[])\n    .map((chain) => chain.toLowerCase())\n    .sort((a, b) => b.length - a.length);\n\n  for (const suffix of chainSuffixes) {\n    if (lowerName.endsWith(suffix)) {\n      return suffix.toUpperCase() as Chain;\n    }\n  }\n\n  return undefined;\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { extractChainFromNormalizedName } from '../../wallets/walletProvider/extractChainFromNormalizedName';\nimport { splitWalletProviderKey } from '../../wallets/walletProvider/splitWalletProviderKey';\nimport { getWalletConnectCatalog } from '../getWalletConnectCatalog';\nimport type { WalletConnectCatalogWallet } from '../getWalletConnectCatalog/getWalletConnectCatalog.types';\n\ntype GetWalletConnectCatalogWalletByWalletProviderKeyParams = {\n  walletProviderKey: string;\n};\n\n/**\n * Gets the WalletConnect catalog wallet entry for a given wallet provider key.\n *\n * This function extracts the wallet name and chain from the wallet provider key and matches it\n * against the WalletConnect catalog to find the corresponding wallet entry, which includes\n * deep link information for mobile wallet connections.\n *\n * @param params.walletProviderKey - The wallet provider key to get the catalog wallet entry for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the WalletConnect catalog wallet entry, or undefined if not found.\n */\nexport const getWalletConnectCatalogWalletByWalletProviderKey = async (\n  { walletProviderKey }: GetWalletConnectCatalogWalletByWalletProviderKeyParams,\n  client = getDefaultClient()\n): Promise<WalletConnectCatalogWallet | undefined> => {\n  const { normalizedWalletNameWithChain } =\n    splitWalletProviderKey(walletProviderKey);\n\n  const chain = extractChainFromNormalizedName({\n    normalizedWalletNameWithChain,\n  });\n\n  if (!chain) {\n    return undefined;\n  }\n\n  // Remove chain suffix from wallet name (e.g., \"metamaskevm\" -> \"metamask\")\n  let walletProviderName = normalizedWalletNameWithChain.toLowerCase();\n\n  if (walletProviderName.endsWith(chain.toLowerCase())) {\n    walletProviderName = walletProviderName.slice(0, -chain.length);\n  }\n\n  // Remove \"wallet\" substring (e.g., \"trustwallet\" -> \"trust\", \"okxwallet\" -> \"okx\")\n  walletProviderName = walletProviderName.replace(/wallet/g, '');\n\n  const walletConnectCatalog = await getWalletConnectCatalog(client);\n\n  for (const [walletKey, wallet] of Object.entries(\n    walletConnectCatalog.wallets\n  )) {\n    if (wallet.chain !== chain) {\n      continue;\n    }\n\n    const walletKeyLower = walletKey.toLowerCase();\n    const walletNameLower = wallet.name.toLowerCase().replace(/\\s+/g, '');\n\n    if (\n      walletKeyLower.includes(walletProviderName) ||\n      walletNameLower.includes(walletProviderName)\n    ) {\n      return wallet;\n    }\n  }\n\n  return undefined;\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport type { OTPVerification } from '../../otp/otp.types';\nimport type { UpdateUserFields } from '../user.types';\n\ntype UpdateUserParams = {\n  userFields: UpdateUserFields;\n};\n\n/**\n * Updates the current user's profile information.\n *\n * This function allows updating various user fields such as email, name,\n * and other profile information. Some updates may require OTP verification,\n * like email and phone number.\n *\n * @param params.userFields - The user fields to update.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to OTP verification details if verification is required, or undefined.\n */\nexport const updateUser = async (\n  { userFields }: UpdateUserParams,\n  client = getDefaultClient()\n): Promise<OTPVerification | undefined> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({ includeMfaToken: true }, client);\n\n  const response = await apiClient.updateSelf({\n    environmentId: core.environmentId,\n    userFields,\n  });\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  if (response.emailVerification) {\n    return {\n      email: response.emailVerification.email,\n      verificationUUID: response.emailVerification.verificationUUID,\n    };\n  }\n\n  if (response.smsVerification) {\n    return {\n      isoCountryCode: response.smsVerification.isoCountryCode,\n      phoneCountryCode: response.smsVerification.phoneCountryCode,\n      phoneNumber: response.smsVerification.phoneNumber,\n      verificationUUID: response.smsVerification.verificationUUID,\n    };\n  }\n\n  return undefined;\n};\n","import { MfaBackupCodeAcknowledgement } from '@dynamic-labs/sdk-api-core';\n\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { updateUser } from '../../user/updateUser';\n\n/**\n * Acknowledges that the user has viewed and saved their MFA recovery codes.\n *\n * This function marks the recovery codes as acknowledged, indicating that\n * the user has properly backed up their MFA recovery codes for account recovery.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the acknowledgment is complete.\n */\nexport const acknowledgeRecoveryCodes = async (client = getDefaultClient()) => {\n  return updateUser(\n    {\n      userFields: {\n        mfaBackupCodeAcknowledgement: MfaBackupCodeAcknowledgement.Complete,\n      },\n    },\n    client\n  );\n};\n","import type { CreateMfaToken } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport { emitEvent } from '../../clientEvents';\n\ntype AuthenticateMfaRecoveryCodeParams = {\n  code: string;\n  createMfaTokenOptions?: CreateMfaToken;\n};\n\n/**\n * Authenticates using an MFA recovery code.\n *\n * This function allows users to bypass normal MFA requirements by using\n * one of their backup recovery codes when none of the registered MFA methods are available.\n *\n * @param params.code - The recovery code to authenticate with.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the MFA authentication response with token.\n */\nexport const authenticateMfaRecoveryCode = async (\n  { code, createMfaTokenOptions }: AuthenticateMfaRecoveryCodeParams,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  try {\n    const response = await apiClient.authMfaRecovery({\n      environmentId: core.environmentId,\n      mFAAuthRecoveryDevicePostRequest: {\n        code,\n        createMfaToken: createMfaTokenOptions,\n      },\n    });\n\n    updateAuthFromVerifyResponse({ response }, client);\n\n    emitEvent(\n      {\n        args: { mfaToken: response.mfaToken },\n        event: 'mfaCompletionSuccess',\n      },\n      client\n    );\n\n    return response;\n  } catch (error) {\n    emitEvent(\n      {\n        args: { error },\n        event: 'mfaCompletionFailure',\n      },\n      client\n    );\n    throw error;\n  }\n};\n","import type { GetPasskeyAuthenticationOptionsResponse } from '@dynamic-labs/sdk-api-core';\nimport type { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\n\nexport type GetPasskeyAuthenticationOptionsParams = {\n  relatedOriginRpId?: string;\n};\n\nexport const getPasskeyAuthenticationOptions = async (\n  { relatedOriginRpId }: GetPasskeyAuthenticationOptionsParams = {},\n  client: DynamicClient\n): Promise<PublicKeyCredentialRequestOptionsJSON> => {\n  const core = getCore(client);\n\n  const apiClient = createApiClient({}, client);\n\n  const options: GetPasskeyAuthenticationOptionsResponse =\n    await apiClient.getPasskeyAuthenticationOptions({\n      environmentId: core.environmentId,\n      relatedOriginRpId,\n    });\n\n  return options as PublicKeyCredentialRequestOptionsJSON;\n};\n","import type {\n  CreateMfaToken,\n  PasskeyAuthRequest,\n} from '@dynamic-labs/sdk-api-core';\nimport type { AuthenticationResponseJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\n\ntype ServerAuthenticatePasskeyParams = {\n  authentication: AuthenticationResponseJSON;\n  createMfaToken?: CreateMfaToken;\n};\n\nexport const serverAuthenticatePasskey = async (\n  { authentication, createMfaToken }: ServerAuthenticatePasskeyParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.authenticateMfaPasskeyDevice({\n    environmentId: core.environmentId,\n    passkeyAuthRequest: {\n      ...authentication,\n      createMfaToken,\n      response: {\n        ...authentication.response,\n        clientDataJson: authentication.response.clientDataJSON,\n      },\n    } as PasskeyAuthRequest,\n  });\n\n  return response;\n};\n","import type { CreateMfaToken } from '@dynamic-labs/sdk-api-core';\nimport type { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/browser';\n\nimport { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { NoPasskeyCredentialsFoundError } from '../../../errors/NoPasskeyCredentialsFoundError';\nimport { NoWebAuthNSupportError } from '../../../errors/NoWebAuthNSupportError';\nimport { getPasskeyAuthenticationOptions } from '../../auth/passkeys/getPasskeyAuthenticationOptions';\nimport { serverAuthenticatePasskey } from '../../auth/passkeys/serverAuthenticatePasskey';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport { emitEvent } from '../../clientEvents';\n\ntype AuthenticatePasskeyMFAParams = {\n  createMfaToken?: CreateMfaToken;\n  relatedOriginRpId?: string;\n};\n\n/**\n * Authenticates using a passkey for multi-factor authentication.\n *\n * This function prompts the user to authenticate with their registered\n * passkey to complete an MFA challenge and obtain an MFA token.\n *\n * @param [params.createMfaToken] - Optional configuration for MFA token creation.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the MFA authentication response.\n * @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.\n * @throws NoPasskeyCredentialsFoundError If no passkey credentials are found.\n */\nexport const authenticatePasskeyMFA = async (\n  { createMfaToken, relatedOriginRpId }: AuthenticatePasskeyMFAParams = {},\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n\n  try {\n    if (!core.passkey.isSupported()) {\n      throw new NoWebAuthNSupportError();\n    }\n\n    const options = await getPasskeyAuthenticationOptions(\n      { relatedOriginRpId },\n      client\n    );\n    const allowCredentials = options.allowCredentials?.map((credential) => ({\n      ...credential,\n      type: 'public-key' as const,\n    }));\n\n    if (!allowCredentials?.length) {\n      throw new NoPasskeyCredentialsFoundError();\n    }\n\n    // Ensure allowCredentials has the required type property\n    const formattedOptions: PublicKeyCredentialRequestOptionsJSON = {\n      ...options,\n      allowCredentials,\n    };\n\n    const authentication = await core.passkey.authenticate({\n      optionsJSON: formattedOptions,\n    });\n\n    const response = await serverAuthenticatePasskey(\n      { authentication, createMfaToken },\n      client\n    );\n\n    updateAuthFromVerifyResponse({ response }, client);\n\n    emitEvent(\n      {\n        args: { mfaToken: response.mfaToken },\n        event: 'mfaCompletionSuccess',\n      },\n      client\n    );\n\n    return response;\n  } catch (error) {\n    emitEvent(\n      {\n        args: { error },\n        event: 'mfaCompletionFailure',\n      },\n      client\n    );\n    throw error;\n  }\n};\n","import type { CreateMfaToken } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport { emitEvent } from '../../clientEvents';\n\ntype AuthenticateTotpMfaDeviceParams = {\n  code: string;\n  createMfaTokenOptions?: CreateMfaToken;\n  deviceId?: string;\n};\n\n/**\n * Authenticates using a TOTP (Time-based One-Time Password) MFA device.\n *\n * This function validates a TOTP code from an authenticator app and returns\n * an MFA token upon successful authentication.\n *\n * @param params.code - The 6-digit TOTP code from the authenticator app.\n * @param [params.deviceId] - The ID of the specific TOTP device to authenticate with.\n * @param [params.createMfaTokenOptions] - Optional configuration for MFA token creation.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the MFA authentication response.\n */\nexport const authenticateTotpMfaDevice = async (\n  { deviceId, code, createMfaTokenOptions }: AuthenticateTotpMfaDeviceParams,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  try {\n    const response = await apiClient.authMfaTotpDevice({\n      environmentId: core.environmentId,\n      mFAAuthTotpDevicePostRequest: {\n        code,\n        createMfaToken: createMfaTokenOptions,\n        id: deviceId,\n      },\n    });\n\n    updateAuthFromVerifyResponse({ response }, client);\n\n    emitEvent(\n      {\n        args: { deviceId, mfaToken: response.mfaToken },\n        event: 'mfaCompletionSuccess',\n      },\n      client\n    );\n\n    return response;\n  } catch (error) {\n    emitEvent(\n      {\n        args: { deviceId, error },\n        event: 'mfaCompletionFailure',\n      },\n      client\n    );\n    throw error;\n  }\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\n\n/**\n * Generates new MFA recovery codes for the current user.\n *\n * This function creates a fresh set of backup codes that can be used\n * to bypass MFA requirements if none of the registered MFA methods are available.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the newly generated recovery codes.\n */\nexport const createNewMfaRecoveryCodes = async (\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  return apiClient.createNewRecoveryCodes({\n    environmentId: core.environmentId,\n  });\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { assertDefined } from '../../../utils/assertDefined';\nimport { createApiClient } from '../../apiClient';\n\ntype DeleteMfaDeviceParams = {\n  deviceId: string;\n  mfaAuthToken: string;\n};\n\n/**\n * Deletes a specific MFA device from the user's account.\n *\n * This function removes a multi-factor authentication device such as\n * a TOTP authenticator from the user's registered devices.\n *\n * @param params.deviceId - The unique identifier of the MFA device to delete.\n * @param params.mfaAuthToken - The MFA authentication token required for device deletion.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the MFA device is successfully deleted.\n */\nexport const deleteMfaDevice = async (\n  { deviceId, mfaAuthToken }: DeleteMfaDeviceParams,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  assertDefined(deviceId, 'deviceId is required');\n  assertDefined(mfaAuthToken, 'mfaAuthToken is required');\n\n  return apiClient.deleteMfaDevice({\n    environmentId: core.environmentId,\n    mfaDeviceId: deviceId,\n    xMfaAuthToken: mfaAuthToken,\n  });\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\n\n/**\n * Retrieves all MFA devices registered for the current user.\n *\n * This function fetches the list of multi-factor authentication devices\n * associated with the user's account, such as TOTP authenticators.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an array of the user's registered MFA devices.\n */\nexport const getMfaDevices = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const { devices } = await apiClient.getUserMfaDevices({\n    environmentId: core.environmentId,\n  });\n\n  return devices;\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\n\n/**\n * Retrieves the current MFA recovery codes for the user.\n *\n * This function fetches the backup codes that can be used to bypass\n * MFA requirements if none of the registered MFA methods are available.\n * If user doesn't have any recovery codes, it will create them,\n * otherwise it will return the existing ones.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the user's MFA recovery codes.\n */\nexport const getMfaRecoveryCodes = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  return apiClient.getRecoveryCodes({\n    environmentId: core.environmentId,\n  });\n};\n","import { MfaBackupCodeAcknowledgement } from '@dynamic-labs/sdk-api-core';\n\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { assertDefined } from '../../../utils/assertDefined';\n\n/**\n * Checks if the user is still pending acknowledgment of their MFA recovery codes.\n *\n * This function determines whether the user has been presented with recovery\n * codes that they have not yet acknowledged as saved or backed up.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns True if recovery codes are pending acknowledgment, false otherwise.\n */\nexport const isPendingRecoveryCodesAcknowledgment = (\n  client = getDefaultClient()\n) => {\n  const user = client.user;\n\n  assertDefined(user, 'User not logged in');\n\n  return (\n    user.mfaBackupCodeAcknowledgement !== MfaBackupCodeAcknowledgement.Complete\n  );\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { assertDefined } from '../../../utils/assertDefined';\n\n/**\n * Checks if the user requires additional MFA authentication.\n *\n * This function determines if the current user session requires\n * additional multi-factor authentication to access certain features.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns True if the user needs additional MFA authentication, false otherwise.\n */\nexport const isUserMissingMfaAuth = (client = getDefaultClient()) => {\n  const user = client.user;\n\n  assertDefined(user, 'User not logged in');\n\n  return Boolean(user.scope?.includes('requiresAdditionalAuth'));\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\n\n/**\n * Registers a new TOTP (Time-based One-Time Password) MFA device.\n *\n * This function initiates the registration of a TOTP authenticator app\n * (like Google Authenticator or Authy) for multi-factor authentication.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the TOTP registration response containing setup information,\n * like the secret key and the OTP Auth URI.\n */\nexport const registerTotpMfaDevice = async (client = getDefaultClient()) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  return apiClient.registerTotpMfaDevice({\n    environmentId: core.environmentId,\n  });\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { assertDefined } from '../../../utils/assertDefined';\nimport { createApiClient } from '../../apiClient';\n\ntype SetDefaultMfaDeviceParams = {\n  deviceId: string;\n};\n\n/**\n * Sets the default MFA device for the current user.\n *\n * This function designates a specific MFA TOTP device as the primary method\n * for multi-factor authentication challenges.\n *\n * @param params.deviceId - The unique identifier of the MFA device to set as default.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the default MFA device is successfully set.\n */\nexport const setDefaultMfaDevice = async (\n  { deviceId }: SetDefaultMfaDeviceParams,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  assertDefined(deviceId, 'deviceId is required');\n\n  // All that this endpoint does is set the default device to the one provided.\n  return apiClient.updateUserMfaDevice({\n    environmentId: core.environmentId,\n    mfaDeviceId: deviceId,\n  });\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { consumeCaptchaToken } from '../../captcha/consumeCaptchaToken';\nimport type { OTPVerification } from '../otp.types';\n\nexport type SendEmailOTPParams = {\n  email: string;\n};\n\n/**\n * Sends a one-time password (OTP) to the specified email address.\n *\n * Once you have the OTP code, you should then use `verifyOTP` to verify it and complete the authentication process.\n *\n * @param params.email - The email address to send the OTP to.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an OTPVerification object containing the email and verification UUID.\n */\nexport const sendEmailOTP = async (\n  { email }: SendEmailOTPParams,\n  client = getDefaultClient()\n): Promise<OTPVerification> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const { verificationUUID } = await apiClient.createEmailVerification({\n    emailVerificationCreateRequest: {\n      captchaToken: consumeCaptchaToken(client),\n      email,\n    },\n    environmentId: core.environmentId,\n  });\n\n  return { email, verificationUUID };\n};\n","// Source:\n// https://github.com/dynamic-labs/redcoast/blob/main/apps/dashboard/src/app/routes/Configurations/Providers/components/SmsProviderSection/utils/countries.ts\n\n// these are the countries was populated based on the wikipedia page\n// referenced in twilio's docs: https://www.twilio.com/docs/voice/api/dialingpermissions-country-resource\n// and this doc for country codes: https://www.itu.int/itudoc/itu-t/ob-lists/icc/e164_763.pdf\nexport type CountryCode =\n  | 'AC'\n  | 'AD'\n  | 'AE'\n  | 'AF'\n  | 'AG'\n  | 'AI'\n  | 'AL'\n  | 'AM'\n  | 'AO'\n  | 'AR'\n  | 'AS'\n  | 'AT'\n  | 'AU'\n  | 'AW'\n  | 'AZ'\n  | 'BA'\n  | 'BB'\n  | 'BD'\n  | 'BE'\n  | 'BF'\n  | 'BG'\n  | 'BH'\n  | 'BI'\n  | 'BJ'\n  | 'BM'\n  | 'BN'\n  | 'BO'\n  | 'BR'\n  | 'BS'\n  | 'BT'\n  | 'BW'\n  | 'BY'\n  | 'BZ'\n  | 'CA'\n  | 'CD'\n  | 'CF'\n  | 'CG'\n  | 'CH'\n  | 'CI'\n  | 'CK'\n  | 'CL'\n  | 'CM'\n  | 'CN'\n  | 'CO'\n  | 'CR'\n  | 'CU'\n  | 'CV'\n  | 'CW'\n  | 'CY'\n  | 'CZ'\n  | 'DE'\n  | 'DJ'\n  | 'DK'\n  | 'DM'\n  | 'DO'\n  | 'DZ'\n  | 'EC'\n  | 'EE'\n  | 'EG'\n  | 'ER'\n  | 'ES'\n  | 'ET'\n  | 'FI'\n  | 'FJ'\n  | 'FK'\n  | 'FM'\n  | 'FO'\n  | 'FR'\n  | 'GA'\n  | 'GB'\n  | 'GD'\n  | 'GE'\n  | 'GF'\n  | 'GG'\n  | 'GH'\n  | 'GI'\n  | 'GL'\n  | 'GM'\n  | 'GN'\n  | 'GP'\n  | 'GQ'\n  | 'GR'\n  | 'GT'\n  | 'GU'\n  | 'GW'\n  | 'GY'\n  | 'HK'\n  | 'HN'\n  | 'HR'\n  | 'HT'\n  | 'HU'\n  | 'IC'\n  | 'ID'\n  | 'IE'\n  | 'IL'\n  | 'IM'\n  | 'IN'\n  | 'IQ'\n  | 'IR'\n  | 'IS'\n  | 'IT'\n  | 'JM'\n  | 'JO'\n  | 'JP'\n  | 'KE'\n  | 'KG'\n  | 'KH'\n  | 'KI'\n  | 'KM'\n  | 'KN'\n  | 'KP'\n  | 'KR'\n  | 'KW'\n  | 'KY'\n  | 'LA'\n  | 'LB'\n  | 'LC'\n  | 'LI'\n  | 'LK'\n  | 'LR'\n  | 'LS'\n  | 'LT'\n  | 'LU'\n  | 'LV'\n  | 'LY'\n  | 'MA'\n  | 'MC'\n  | 'MD'\n  | 'ME'\n  | 'MG'\n  | 'MH'\n  | 'MK'\n  | 'ML'\n  | 'MM'\n  | 'MN'\n  | 'MO'\n  | 'MP'\n  | 'MQ'\n  | 'MR'\n  | 'MS'\n  | 'MT'\n  | 'MU'\n  | 'MV'\n  | 'MW'\n  | 'MX'\n  | 'MY'\n  | 'MZ'\n  | 'NA'\n  | 'NC'\n  | 'NE'\n  | 'NF'\n  | 'NG'\n  | 'NI'\n  | 'NL'\n  | 'NO'\n  | 'NP'\n  | 'NU'\n  | 'NZ'\n  | 'OM'\n  | 'PA'\n  | 'PE'\n  | 'PF'\n  | 'PG'\n  | 'PH'\n  | 'PK'\n  | 'PL'\n  | 'PM'\n  | 'PR'\n  | 'PS'\n  | 'PT'\n  | 'PW'\n  | 'PY'\n  | 'QA'\n  | 'RE'\n  | 'RO'\n  | 'RS'\n  | 'RU'\n  | 'RW'\n  | 'SA'\n  | 'SB'\n  | 'SC'\n  | 'SD'\n  | 'SE'\n  | 'SG'\n  | 'SI'\n  | 'SK'\n  | 'SL'\n  | 'SM'\n  | 'SN'\n  | 'SO'\n  | 'SR'\n  | 'SS'\n  | 'ST'\n  | 'SV'\n  | 'SY'\n  | 'SZ'\n  | 'TC'\n  | 'TD'\n  | 'TG'\n  | 'TH'\n  | 'TJ'\n  | 'TL'\n  | 'TM'\n  | 'TN'\n  | 'TO'\n  | 'TR'\n  | 'TT'\n  | 'TV'\n  | 'TW'\n  | 'TZ'\n  | 'UA'\n  | 'UG'\n  | 'US'\n  | 'UY'\n  | 'UZ'\n  | 'VA'\n  | 'VC'\n  | 'VE'\n  | 'VG'\n  | 'VI'\n  | 'VN'\n  | 'VU'\n  | 'WF'\n  | 'WS'\n  | 'XK'\n  | 'YE'\n  | 'ZA'\n  | 'ZM'\n  | 'ZW';\n\nexport type CountryData = {\n  code: string;\n  name: string;\n};\n\nexport type CountryPhoneData = Record<CountryCode, CountryData>;\n\nexport const supportedCountries: CountryPhoneData = {\n  AC: {\n    code: '247',\n    name: 'Ascension',\n  },\n  AD: {\n    code: '376',\n    name: 'Andorra',\n  },\n  AE: {\n    code: '971',\n    name: 'United Arab Emirates',\n  },\n  AF: {\n    code: '93',\n    name: 'Afghanistan',\n  },\n  AG: {\n    code: '1268',\n    name: 'Antigua and Barbuda',\n  },\n  AI: {\n    code: '1264',\n    name: 'Anguilla',\n  },\n  AL: {\n    code: '355',\n    name: 'Albania',\n  },\n  AM: {\n    code: '374',\n    name: 'Armenia',\n  },\n  AO: {\n    code: '244',\n    name: 'Angola',\n  },\n  AR: {\n    code: '54',\n    name: 'Argentina',\n  },\n  AS: {\n    code: '1684',\n    name: 'American Samoa',\n  },\n  AT: {\n    code: '43',\n    name: 'Austria',\n  },\n  AU: {\n    code: '61',\n    name: 'Australia/Cocos/Christmas Island',\n  },\n  AW: {\n    code: '297',\n    name: 'Aruba',\n  },\n  AZ: {\n    code: '994',\n    name: 'Azerbaijan',\n  },\n  BA: {\n    code: '387',\n    name: 'Bosnia and Herzegovina',\n  },\n  BB: {\n    code: '1246',\n    name: 'Barbados',\n  },\n  BD: {\n    code: '880',\n    name: 'Bangladesh',\n  },\n  BE: {\n    code: '32',\n    name: 'Belgium',\n  },\n  BF: {\n    code: '226',\n    name: 'Burkina Faso',\n  },\n  BG: {\n    code: '359',\n    name: 'Bulgaria',\n  },\n  BH: {\n    code: '973',\n    name: 'Bahrain',\n  },\n  BI: {\n    code: '257',\n    name: 'Burundi',\n  },\n  BJ: {\n    code: '229',\n    name: 'Benin',\n  },\n  BM: {\n    code: '1441',\n    name: 'Bermuda',\n  },\n  BN: {\n    code: '673',\n    name: 'Brunei',\n  },\n  BO: {\n    code: '591',\n    name: 'Bolivia',\n  },\n  BR: {\n    code: '55',\n    name: 'Brazil',\n  },\n  BS: {\n    code: '1242',\n    name: 'Bahamas',\n  },\n  BT: {\n    code: '975',\n    name: 'Bhutan',\n  },\n  BW: {\n    code: '267',\n    name: 'Botswana',\n  },\n  BY: {\n    code: '375',\n    name: 'Belarus',\n  },\n  BZ: {\n    code: '501',\n    name: 'Belize',\n  },\n  CA: {\n    code: '1',\n    name: 'Canada',\n  },\n  CD: {\n    code: '243',\n    name: 'Congo, Dem Rep',\n  },\n  CF: {\n    code: '236',\n    name: 'Central Africa',\n  },\n  CG: {\n    code: '242',\n    name: 'Congo',\n  },\n  CH: {\n    code: '41',\n    name: 'Switzerland',\n  },\n  CI: {\n    code: '225',\n    name: 'Ivory Coast',\n  },\n  CK: {\n    code: '682',\n    name: 'Cook Islands',\n  },\n  CL: {\n    code: '56',\n    name: 'Chile',\n  },\n  CM: {\n    code: '237',\n    name: 'Cameroon',\n  },\n  CN: {\n    code: '86',\n    name: 'China',\n  },\n  CO: {\n    code: '57',\n    name: 'Colombia',\n  },\n  CR: {\n    code: '506',\n    name: 'Costa Rica',\n  },\n  CU: {\n    code: '53',\n    name: 'Cuba',\n  },\n  CV: {\n    code: '238',\n    name: 'Cape Verde',\n  },\n  CW: {\n    code: '599',\n    name: 'Curaao and Caribbean Netherlands (Bonaire, Sint Eustatius, Sint Maarten, Saba)',\n  },\n  CY: {\n    code: '357',\n    name: 'Cyprus',\n  },\n  CZ: {\n    code: '420',\n    name: 'Czech Republic',\n  },\n  DE: {\n    code: '49',\n    name: 'Germany',\n  },\n  DJ: {\n    code: '253',\n    name: 'Djibouti',\n  },\n  DK: {\n    code: '45',\n    name: 'Denmark',\n  },\n  DM: {\n    code: '1767',\n    name: 'Dominica',\n  },\n  DO: {\n    code: '1829',\n    name: 'Dominican Republic',\n  },\n  DZ: {\n    code: '213',\n    name: 'Algeria',\n  },\n  EC: {\n    code: '593',\n    name: 'Ecuador',\n  },\n  EE: {\n    code: '372',\n    name: 'Estonia',\n  },\n  EG: {\n    code: '20',\n    name: 'Egypt',\n  },\n  ER: {\n    code: '291',\n    name: 'Eritrea',\n  },\n  ES: {\n    code: '34',\n    name: 'Spain',\n  },\n  ET: {\n    code: '251',\n    name: 'Ethiopia',\n  },\n  FI: {\n    code: '358',\n    name: 'Finland/Aland Islands',\n  },\n  FJ: {\n    code: '679',\n    name: 'Fiji',\n  },\n  FK: {\n    code: '500',\n    name: 'Falkland Islands',\n  },\n  FM: {\n    code: '691',\n    name: 'Micronesia',\n  },\n  FO: {\n    code: '298',\n    name: 'Faroe Islands',\n  },\n  FR: {\n    code: '33',\n    name: 'France',\n  },\n  GA: {\n    code: '241',\n    name: 'Gabon',\n  },\n  GB: {\n    code: '44',\n    name: 'United Kingdom',\n  },\n  GD: {\n    code: '1473',\n    name: 'Grenada',\n  },\n  GE: {\n    code: '995',\n    name: 'Georgia',\n  },\n  GF: {\n    code: '594',\n    name: 'French Guiana',\n  },\n  GG: {\n    code: '44',\n    name: 'Guernsey/Jersey',\n  },\n  GH: {\n    code: '233',\n    name: 'Ghana',\n  },\n  GI: {\n    code: '350',\n    name: 'Gibraltar',\n  },\n  GL: {\n    code: '299',\n    name: 'Greenland',\n  },\n  GM: {\n    code: '220',\n    name: 'Gambia',\n  },\n  GN: {\n    code: '224',\n    name: 'Guinea',\n  },\n  GP: {\n    code: '590',\n    name: 'Guadeloupe',\n  },\n  GQ: {\n    code: '240',\n    name: 'Equatorial Guinea',\n  },\n  GR: {\n    code: '30',\n    name: 'Greece',\n  },\n  GT: {\n    code: '502',\n    name: 'Guatemala',\n  },\n  GU: {\n    code: '1671',\n    name: 'Guam',\n  },\n  GW: {\n    code: '245',\n    name: 'Guinea-Bissau',\n  },\n  GY: {\n    code: '592',\n    name: 'Guyana',\n  },\n  HK: {\n    code: '852',\n    name: 'Hong Kong',\n  },\n  HN: {\n    code: '504',\n    name: 'Honduras',\n  },\n  HR: {\n    code: '385',\n    name: 'Croatia',\n  },\n  HT: {\n    code: '509',\n    name: 'Haiti',\n  },\n  HU: {\n    code: '36',\n    name: 'Hungary',\n  },\n  IC: {\n    code: '3491',\n    name: 'Canary Islands',\n  },\n  ID: {\n    code: '62',\n    name: 'Indonesia',\n  },\n  IE: {\n    code: '353',\n    name: 'Ireland',\n  },\n  IL: {\n    code: '972',\n    name: 'Israel',\n  },\n  IM: {\n    code: '44',\n    name: 'Isle of Man',\n  },\n  IN: {\n    code: '91',\n    name: 'India',\n  },\n  IQ: {\n    code: '964',\n    name: 'Iraq',\n  },\n  IR: {\n    code: '98',\n    name: 'Iran',\n  },\n  IS: {\n    code: '354',\n    name: 'Iceland',\n  },\n  IT: {\n    code: '39',\n    name: 'Italy',\n  },\n  JM: {\n    code: '1876',\n    name: 'Jamaica',\n  },\n  JO: {\n    code: '962',\n    name: 'Jordan',\n  },\n  JP: {\n    code: '81',\n    name: 'Japan',\n  },\n  KE: {\n    code: '254',\n    name: 'Kenya',\n  },\n  KG: {\n    code: '996',\n    name: 'Kyrgyzstan',\n  },\n  KH: {\n    code: '855',\n    name: 'Cambodia',\n  },\n  KI: {\n    code: '686',\n    name: 'Kiribati',\n  },\n  KM: {\n    code: '269',\n    name: 'Comoros',\n  },\n  KN: {\n    code: '1869',\n    name: 'St Kitts and Nevis',\n  },\n  KP: {\n    code: '850',\n    name: \"Korea Dem People's Rep\",\n  },\n  KR: {\n    code: '82',\n    name: 'Korea Republic of',\n  },\n  KW: {\n    code: '965',\n    name: 'Kuwait',\n  },\n  KY: {\n    code: '1345',\n    name: 'Cayman Islands',\n  },\n  LA: {\n    code: '856',\n    name: 'Laos PDR',\n  },\n  LB: {\n    code: '961',\n    name: 'Lebanon',\n  },\n  LC: {\n    code: '1758',\n    name: 'St Lucia',\n  },\n  LI: {\n    code: '423',\n    name: 'Liechtenstein',\n  },\n  LK: {\n    code: '94',\n    name: 'Sri Lanka',\n  },\n  LR: {\n    code: '231',\n    name: 'Liberia',\n  },\n  LS: {\n    code: '266',\n    name: 'Lesotho',\n  },\n  LT: {\n    code: '370',\n    name: 'Lithuania',\n  },\n  LU: {\n    code: '352',\n    name: 'Luxembourg',\n  },\n  LV: {\n    code: '371',\n    name: 'Latvia',\n  },\n  LY: {\n    code: '218',\n    name: 'Libya',\n  },\n  MA: {\n    code: '212',\n    name: 'Morocco/Western Sahara',\n  },\n  MC: {\n    code: '377',\n    name: 'Monaco',\n  },\n  MD: {\n    code: '373',\n    name: 'Moldova',\n  },\n  ME: {\n    code: '382',\n    name: 'Montenegro',\n  },\n  MG: {\n    code: '261',\n    name: 'Madagascar',\n  },\n  MH: {\n    code: '692',\n    name: 'Marshall Islands',\n  },\n  MK: {\n    code: '389',\n    name: 'Republic of North Macedonia',\n  },\n  ML: {\n    code: '223',\n    name: 'Mali',\n  },\n  MM: {\n    code: '95',\n    name: 'Myanmar (Burma)',\n  },\n  MN: {\n    code: '976',\n    name: 'Mongolia',\n  },\n  MO: {\n    code: '853',\n    name: 'Macau',\n  },\n  MP: {\n    code: '1670',\n    name: 'Northern Mariana Islands',\n  },\n  MQ: {\n    code: '596',\n    name: 'Martinique',\n  },\n  MR: {\n    code: '222',\n    name: 'Mauritania',\n  },\n  MS: {\n    code: '1664',\n    name: 'Montserrat',\n  },\n  MT: {\n    code: '356',\n    name: 'Malta',\n  },\n  MU: {\n    code: '230',\n    name: 'Mauritius',\n  },\n  MV: {\n    code: '960',\n    name: 'Maldives',\n  },\n  MW: {\n    code: '265',\n    name: 'Malawi',\n  },\n  MX: {\n    code: '52',\n    name: 'Mexico',\n  },\n  MY: {\n    code: '60',\n    name: 'Malaysia',\n  },\n  MZ: {\n    code: '258',\n    name: 'Mozambique',\n  },\n  NA: {\n    code: '264',\n    name: 'Namibia',\n  },\n  NC: {\n    code: '687',\n    name: 'New Caledonia',\n  },\n  NE: {\n    code: '227',\n    name: 'Niger',\n  },\n  NF: {\n    code: '672',\n    name: 'Norfolk Island',\n  },\n  NG: {\n    code: '234',\n    name: 'Nigeria',\n  },\n  NI: {\n    code: '505',\n    name: 'Nicaragua',\n  },\n  NL: {\n    code: '31',\n    name: 'Netherlands',\n  },\n  NO: {\n    code: '47',\n    name: 'Norway',\n  },\n  NP: {\n    code: '977',\n    name: 'Nepal',\n  },\n  NU: {\n    code: '683',\n    name: 'Niue',\n  },\n  NZ: {\n    code: '64',\n    name: 'New Zealand',\n  },\n  OM: {\n    code: '968',\n    name: 'Oman',\n  },\n  PA: {\n    code: '507',\n    name: 'Panama',\n  },\n  PE: {\n    code: '51',\n    name: 'Peru',\n  },\n  PF: {\n    code: '689',\n    name: 'French Polynesia',\n  },\n  PG: {\n    code: '675',\n    name: 'Papua New Guinea',\n  },\n  PH: {\n    code: '63',\n    name: 'Philippines',\n  },\n  PK: {\n    code: '92',\n    name: 'Pakistan',\n  },\n  PL: {\n    code: '48',\n    name: 'Poland',\n  },\n  PM: {\n    code: '508',\n    name: 'St Pierre and Miquelon',\n  },\n  PR: {\n    code: '1787',\n    name: 'Puerto Rico',\n  },\n  PS: {\n    code: '970, 972',\n    name: 'Palestinian Territory',\n  },\n  PT: {\n    code: '351',\n    name: 'Portugal',\n  },\n  PW: {\n    code: '680',\n    name: 'Palau',\n  },\n  PY: {\n    code: '595',\n    name: 'Paraguay',\n  },\n  QA: {\n    code: '974',\n    name: 'Qatar',\n  },\n  RE: {\n    code: '262',\n    name: 'Reunion/Mayotte',\n  },\n  RO: {\n    code: '40',\n    name: 'Romania',\n  },\n  RS: {\n    code: '381',\n    name: 'Serbia',\n  },\n  RU: {\n    code: '7',\n    name: 'Russia/Kazakhstan',\n  },\n  RW: {\n    code: '250',\n    name: 'Rwanda',\n  },\n  SA: {\n    code: '966',\n    name: 'Saudi Arabia',\n  },\n  SB: {\n    code: '677',\n    name: 'Solomon Islands',\n  },\n  SC: {\n    code: '248',\n    name: 'Seychelles',\n  },\n  SD: {\n    code: '249',\n    name: 'Sudan',\n  },\n  SE: {\n    code: '46',\n    name: 'Sweden',\n  },\n  SG: {\n    code: '65',\n    name: 'Singapore',\n  },\n  SI: {\n    code: '386',\n    name: 'Slovenia',\n  },\n  SK: {\n    code: '421',\n    name: 'Slovakia',\n  },\n  SL: {\n    code: '232',\n    name: 'Sierra Leone',\n  },\n  SM: {\n    code: '378',\n    name: 'San Marino',\n  },\n  SN: {\n    code: '221',\n    name: 'Senegal',\n  },\n  SO: {\n    code: '252',\n    name: 'Somalia',\n  },\n  SR: {\n    code: '597',\n    name: 'Suriname',\n  },\n  SS: {\n    code: '211',\n    name: 'South Sudan',\n  },\n  ST: {\n    code: '239',\n    name: 'Sao Tome and Principe',\n  },\n  SV: {\n    code: '503',\n    name: 'El Salvador',\n  },\n  SY: {\n    code: '963',\n    name: 'Syria',\n  },\n  SZ: {\n    code: '268',\n    name: 'Swaziland',\n  },\n  TC: {\n    code: '1649',\n    name: 'Turks and Caicos Islands',\n  },\n  TD: {\n    code: '235',\n    name: 'Chad',\n  },\n  TG: {\n    code: '228',\n    name: 'Togo',\n  },\n  TH: {\n    code: '66',\n    name: 'Thailand',\n  },\n  TJ: {\n    code: '992',\n    name: 'Tajikistan',\n  },\n  TL: {\n    code: '670',\n    name: 'East Timor',\n  },\n  TM: {\n    code: '993',\n    name: 'Turkmenistan',\n  },\n  TN: {\n    code: '216',\n    name: 'Tunisia',\n  },\n  TO: {\n    code: '676',\n    name: 'Tonga',\n  },\n  TR: {\n    code: '90',\n    name: 'Turkiye',\n  },\n  TT: {\n    code: '1868',\n    name: 'Trinidad and Tobago',\n  },\n  TV: {\n    code: '688',\n    name: 'Tuvalu',\n  },\n  TW: {\n    code: '886',\n    name: 'Taiwan',\n  },\n  TZ: {\n    code: '255',\n    name: 'Tanzania',\n  },\n  UA: {\n    code: '380',\n    name: 'Ukraine',\n  },\n  UG: {\n    code: '256',\n    name: 'Uganda',\n  },\n  US: {\n    code: '1',\n    name: 'United States',\n  },\n  UY: {\n    code: '598',\n    name: 'Uruguay',\n  },\n  UZ: {\n    code: '998',\n    name: 'Uzbekistan',\n  },\n  VA: {\n    code: '379',\n    name: 'Vatican City',\n  },\n  VC: {\n    code: '1784',\n    name: 'St Vincent Grenadines',\n  },\n  VE: {\n    code: '58',\n    name: 'Venezuela',\n  },\n  VG: {\n    code: '1284',\n    name: 'Virgin Islands, British',\n  },\n  VI: {\n    code: '1340',\n    name: 'Virgin Islands, U.S.',\n  },\n  VN: {\n    code: '84',\n    name: 'Vietnam',\n  },\n  VU: {\n    code: '678',\n    name: 'Vanuatu',\n  },\n  WF: {\n    code: '681',\n    name: 'Wallis and Futuna',\n  },\n  WS: {\n    code: '685',\n    name: 'Samoa',\n  },\n  XK: {\n    code: '383',\n    name: 'Kosovo',\n  },\n  YE: {\n    code: '967',\n    name: 'Yemen',\n  },\n  ZA: {\n    code: '27',\n    name: 'South Africa',\n  },\n  ZM: {\n    code: '260',\n    name: 'Zambia',\n  },\n  ZW: {\n    code: '263',\n    name: 'Zimbabwe',\n  },\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { consumeCaptchaToken } from '../../captcha/consumeCaptchaToken';\nimport type { OTPVerification } from '../otp.types';\nimport type { CountryCode } from './supportedCountries';\nimport { supportedCountries } from './supportedCountries';\n\nexport type SendSmsOTPParams = {\n  isoCountryCode: CountryCode;\n  phoneNumber: string;\n};\n\n/**\n * Sends a one-time password (OTP) via SMS to the specified phone number.\n *\n * @param params.isoCountryCode - The ISO country code for the phone number (e.g., 'US', 'CA', 'GB').\n * @param params.phoneNumber - The phone number to send the OTP to.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an OTPVerification object containing the phone details and verification UUID.\n */\nexport const sendSmsOTP = async (\n  { isoCountryCode, phoneNumber }: SendSmsOTPParams,\n  client = getDefaultClient()\n): Promise<OTPVerification> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const phoneCountryCode = supportedCountries[isoCountryCode].code;\n\n  const { verificationUUID } = await apiClient.createSmsVerification({\n    environmentId: core.environmentId,\n    smsVerificationCreateRequest: {\n      captchaToken: consumeCaptchaToken(client),\n      isoCountryCode,\n      phoneCountryCode,\n      phoneNumber,\n    },\n  });\n\n  return { isoCountryCode, phoneCountryCode, phoneNumber, verificationUUID };\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\nimport type { VerifyOTPParams } from '../verifyOTP';\n\nexport const verifyOTPForUserSignIn = async (\n  { otpVerification, verificationToken }: VerifyOTPParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const verifyRequest = {\n    verificationToken,\n    verificationUUID: otpVerification.verificationUUID,\n  };\n\n  if (otpVerification.email) {\n    return apiClient.signInWithEmailVerification({\n      emailVerificationVerifyRequest: verifyRequest,\n      environmentId: core.environmentId,\n    });\n  }\n\n  return apiClient.signInWithSmsVerification({\n    environmentId: core.environmentId,\n    smsVerificationVerifyRequest: verifyRequest,\n  });\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { createApiClient } from '../../../apiClient';\nimport type { VerifyOTPParams } from '../verifyOTP';\n\nexport const verifyOTPForUserUpdate = async (\n  { otpVerification, verificationToken }: VerifyOTPParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const verifyRequest = {\n    verificationToken,\n    verificationUUID: otpVerification.verificationUUID,\n  };\n\n  if (otpVerification.email) {\n    return apiClient.verifyEmailVerification({\n      emailVerificationVerifyRequest: verifyRequest,\n      environmentId: core.environmentId,\n    });\n  }\n\n  return apiClient.verifySmsVerification({\n    environmentId: core.environmentId,\n    smsVerificationVerifyRequest: verifyRequest,\n  });\n};\n","import type { VerifyResponse } from '@dynamic-labs/sdk-api-core';\n\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport type { OTPVerification } from '../otp.types';\nimport { verifyOTPForUserSignIn } from './verifyOTPForUserSignIn';\nimport { verifyOTPForUserUpdate } from './verifyOTPForUserUpdate';\n\nexport type VerifyOTPParams = {\n  otpVerification: OTPVerification;\n  verificationToken: string;\n};\n\n/**\n * Verifies a one-time password (OTP) for user authentication or updates.\n *\n * This function validates the OTP code provided by the user and completes\n * the verification process for either sign-in or account updates.\n *\n * @param params.otpVerification - The OTP verification object containing verification details.\n * @param params.verificationToken - The token received from the OTP verification process.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the verify response object upon successful verification.\n */\nexport const verifyOTP = async (\n  { otpVerification, verificationToken }: VerifyOTPParams,\n  client = getDefaultClient()\n): Promise<VerifyResponse> => {\n  const verifyOTPFunction = client.user\n    ? verifyOTPForUserUpdate\n    : verifyOTPForUserSignIn;\n\n  const response: VerifyResponse = await verifyOTPFunction(\n    {\n      otpVerification,\n      verificationToken,\n    },\n    client\n  );\n\n  updateAuthFromVerifyResponse({ response }, client);\n\n  return response;\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { logout } from '../../auth/logout';\n\n/**\n * Deletes the current user's account permanently.\n *\n * This function performs a hard delete of the user account. Upon successful deletion,\n * the user will be automatically logged out and all authentication data will be cleared.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the user account is successfully deleted.\n */\nexport const deleteUser = async (\n  client = getDefaultClient()\n): Promise<void> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({ includeMfaToken: true }, client);\n\n  await apiClient.hardDeleteUser({\n    environmentId: core.environmentId,\n  });\n\n  await logout(client);\n};\n\n","import type { SdkUser } from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { checkAndRaiseWalletAccountsChangedEvent } from '../../auth/updateAuthFromVerifyResponse/checkAndRaiseWalletAccountsChangedEvent';\n\n/**\n * Refreshes the current user's data from the server.\n *\n * This function fetches the latest authenticated user information from the backend\n * and updates the local user state.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the authenticated user.\n */\nexport const refreshUser = async (\n  client = getDefaultClient()\n): Promise<SdkUser> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const previousState = { ...core.state.get() };\n\n  const user = await apiClient.getAuthenticatedUser({\n    environmentId: core.environmentId,\n  });\n\n  core.state.set({ user });\n\n  checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);\n\n  return user;\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { getWalletProviderFromWalletAccount } from '../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../walletAccount';\nimport { WalletAccountNotSelectedError } from './../../../errors/WalletAccountNotSelectedError';\n\ntype AssertWalletAccountSigningAvailabilityParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Asserts that a wallet account is available and ready for signing operations.\n *\n * This function verifies that the specified wallet account is currently\n * connected and selected in the wallet app, ensuring it can perform signing operations.\n *\n * If the wallet account is not available, the user might need to reconnect it or\n * change the account in their wallet app to make it active.\n *\n * @param params.walletAccount - The wallet account to verify signing availability for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves if the wallet is available for signing.\n * @throws WalletAccountNotSelectedError If the wallet account is not currently selected.\n */\nexport const assertWalletAccountSigningAvailability = async (\n  { walletAccount }: AssertWalletAccountSigningAvailabilityParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderFromWalletAccount(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  const { addresses } = await walletProvider.getConnectedAddresses();\n\n  if (addresses.length > 0 && !addresses.includes(walletAccount.address)) {\n    throw new WalletAccountNotSelectedError({\n      expectedAddress: walletAccount.address,\n      selectedAddress: addresses[0],\n    });\n  }\n};\n","/* eslint-disable func-style -- javascript requires this to be a function */\n\nimport { WalletProviderMethodUnavailableError } from '../../../../errors/WalletProviderMethodUnavailableError';\nimport type { WalletProvider } from '../../walletProvider/walletProvider.types';\n\n/**\n * Asserts that a specific wallet provider method is defined, throwing an error if it's not.\n * This function acts as a type guard, narrowing the type to ensure the method exists.\n *\n * @template T - The specific wallet provider method key being checked\n * @param walletProvider - The wallet provider object to check\n * @param methodName - The name of the method to check for availability\n * @throws Throws WalletProviderMethodUnavailableError if the method is not defined\n * @example\n * ```typescript\n * const walletProvider: WalletProvider = getWalletProvider();\n * assertWalletProviderMethodDefined(walletProvider, 'connect');\n * // walletProvider.connect is now guaranteed to be defined\n * await walletProvider.connect();\n * ```\n */\nexport function assertWalletProviderMethodDefined<\n  T extends keyof WalletProvider\n>(\n  walletProvider: WalletProvider,\n  methodName: T\n): asserts walletProvider is WalletProvider &\n  Required<Pick<WalletProvider, T>> {\n  if (walletProvider[methodName] === undefined) {\n    throw new WalletProviderMethodUnavailableError({\n      methodName: methodName as string,\n      walletProviderKey: walletProvider.key,\n    });\n  }\n}\n","import type { WalletAddressWithType } from '../../walletAccount/walletAccount.types';\nimport type { WalletProviderConnectResult } from '../../walletProvider/walletProvider.types';\n\nexport const getAddressesWithTypesFromConnectionResult = (\n  connectionResult: WalletProviderConnectResult\n): WalletAddressWithType[] => {\n  return connectionResult.addresses.filter(\n    (address): address is WalletAddressWithType =>\n      !!address.address && !!address.type\n  );\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { createVisit } from '../../auth/createVisit';\nimport { emitWalletAccountsChangedEvent } from '../emitWalletAccountsChangedEvent';\nimport { getWalletAccounts } from '../getWalletAccounts';\nimport { getWalletProviderByKey } from '../getWalletProviderByKey';\nimport { setUnverifiedWalletAccounts } from '../unverifiedWalletAccounts/setUnverifiedWalletAccounts';\nimport { assertWalletProviderMethodDefined } from '../utils/assertWalletProviderMethodDefined';\nimport { formatWalletAccountId } from '../utils/formatWalletAccountId';\nimport { getAddressesWithTypesFromConnectionResult } from '../utils/getAddressesWithTypesFromConnectionResult';\nimport type { WalletAccount } from '../walletAccount';\nimport { NoAddressFoundError } from './../../../errors/NoAddressFoundError';\n\ntype ConnectWithWalletProviderParams = {\n  addToDynamicWalletAccounts?: boolean;\n  walletProviderKey: string;\n};\n\n/**\n * Connects to a wallet provider and returns the connected wallet account.\n *\n * Note: This function will not verify the wallet account, use the verifyWalletAccount function to do that\n * or connectAndVerifyWithWalletProvider to do that in a single step.\n * @see verifyWalletAccount\n * @see connectAndVerifyWithWalletProvider\n *\n * @param params.walletProviderKey - The unique key identifying the wallet provider to connect to (e.g. 'metamaskevm', 'phantomsol').\n * @param [params.addToDynamicWalletAccounts] - Whether to add the connected wallet account to the user's wallet accounts. Defaults to true.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the connected wallet account.\n * @throws NoAddressFoundError If the request to connect was successful but no address is connected to your app.\n */\nexport const connectWithWalletProvider = async (\n  {\n    walletProviderKey,\n    addToDynamicWalletAccounts = true,\n  }: ConnectWithWalletProviderParams,\n  client = getDefaultClient()\n): Promise<WalletAccount> => {\n  const walletProvider = getWalletProviderByKey(\n    {\n      walletProviderKey,\n    },\n    client\n  );\n\n  assertWalletProviderMethodDefined(walletProvider, 'connect');\n\n  const { addresses } = await walletProvider.connect();\n\n  const currentAddresses = getWalletAccounts(client).map(\n    ({ address }) => address\n  );\n\n  const mainAddress = addresses?.length ? addresses[0].address : null;\n\n  /**\n   * This error is thrown in case the wallet has no addresses connected\n   * to the dapp. Then the error is thrown so the consumer can instruct the\n   * user on the next steps.\n   */\n  if (!mainAddress) {\n    throw new NoAddressFoundError();\n  }\n\n  const walletAccount: WalletAccount = {\n    address: mainAddress,\n    addressesWithTypes: getAddressesWithTypesFromConnectionResult({\n      addresses,\n    }),\n    chain: walletProvider.chain,\n    id: formatWalletAccountId({\n      address: mainAddress,\n      chain: walletProvider.chain,\n      walletProviderKey,\n    }),\n    lastSelectedAt: null,\n    verifiedCredentialId: null,\n    walletProviderKey,\n  };\n\n  if (currentAddresses.includes(mainAddress)) {\n    return walletAccount;\n  }\n\n  if (addToDynamicWalletAccounts) {\n    setUnverifiedWalletAccounts(\n      { unverifiedWalletAccountsToUpdate: [walletAccount] },\n      client\n    );\n\n    emitWalletAccountsChangedEvent(client);\n\n    /*\n     * send information to backend to kick off background jobs\n     * this is an async work, but does not need to be awaited\n     */\n    void createVisit({ walletAccount }, client);\n  }\n\n  return walletAccount;\n};\n","import type { Chain } from '../../../chain';\nimport type { WalletProvider } from '../../../wallets/walletProvider/walletProvider.types';\n\nexport const getChainIdForAccountVerification = async ({\n  walletProvider,\n}: {\n  walletProvider: WalletProvider;\n}) => {\n  // for some chains, we don't need to specify a chain id for account verification because it's\n  // not required and it might break the message signature in some wallets (e.g. Trust Wallet SOL)\n  const chainsThatDontNeedChainId: Chain[] = ['BTC', 'SOL', 'SUI'];\n\n  if (chainsThatDontNeedChainId.includes(walletProvider.chain)) {\n    return undefined;\n  }\n\n  const { networkId } = await walletProvider.getActiveNetworkId();\n\n  if (networkId) {\n    return networkId;\n  }\n\n  // default to ethereum mainnet\n  if (walletProvider.chain === 'EVM') {\n    return '1';\n  }\n\n  return undefined;\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport { createApiClient } from '../../../apiClient';\nimport { CHAINS_INFO_MAP } from '../../constants';\nimport type { WalletAccount } from '../../walletAccount';\nimport { formatSignInMessage } from '../formatSignInMessage';\nimport { getChainIdForAccountVerification } from '../getChainIdForAccountVerification';\nimport { getWalletProviderFromWalletAccount } from '../getWalletProviderFromWalletAccount';\nimport { createSignInMessageStatement } from './createSignInMessageStatement';\n\ntype GetSignInMessageParams = {\n  walletAccount: WalletAccount;\n};\n\nexport const getSignInMessage = async (\n  { walletAccount }: GetSignInMessageParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n  const appUrl = core.metadata?.url;\n\n  assertDefined(appUrl, 'App URL is not set');\n\n  const url = new URL(appUrl);\n\n  const { nonce } = await apiClient.getNonce({\n    environmentId: core.environmentId,\n  });\n\n  assertDefined(nonce, 'Failed to get nonce');\n\n  const walletProvider = getWalletProviderFromWalletAccount(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  const statement = createSignInMessageStatement(client);\n\n  const messageToSign = await formatSignInMessage({\n    address: walletAccount.address,\n    blockchainName: CHAINS_INFO_MAP[walletProvider.chain].blockchainName,\n    chainId: await getChainIdForAccountVerification({ walletProvider }),\n    domain: url.host,\n    issuedAt: new Date().toISOString(),\n    nonce,\n    requestId: core.environmentId,\n    statement,\n    uri: url.toString(),\n  });\n\n  return messageToSign;\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { assertWalletProviderMethodDefined } from '../utils/assertWalletProviderMethodDefined';\nimport { getSignInMessage } from '../utils/getSignInMessage';\nimport { getWalletProviderFromWalletAccount } from '../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../walletAccount';\n\ntype ProveWalletAccountOwnershipParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Proves ownership of a wallet account by signing a verification message.\n *\n * This function generates a sign-in message and requires the user to sign it\n * with their wallet's private key, proving they control the wallet address.\n *\n * @param params.walletAccount - The wallet account to prove ownership of.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an object containing the message and signature.\n */\nexport const proveWalletAccountOwnership = async (\n  { walletAccount }: ProveWalletAccountOwnershipParams,\n  client = getDefaultClient()\n): Promise<{\n  messageToSign: string;\n  signature: string;\n}> => {\n  const walletProvider = getWalletProviderFromWalletAccount(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  assertWalletProviderMethodDefined(walletProvider, 'signMessage');\n\n  const messageToSign = await getSignInMessage({ walletAccount }, client);\n\n  const { signature } = await walletProvider.signMessage({\n    message: messageToSign,\n    walletAccount,\n  });\n\n  return { messageToSign, signature };\n};\n","import type { Chain } from '../../../chain';\nimport { normalizeAddress } from '../normalizeAddress';\n\nexport const isSameAddress = (left: string, right: string, chain: Chain) =>\n  normalizeAddress(left, chain) === normalizeAddress(right, chain);\n","import type { DynamicClient } from '../../../client/types';\nimport { assertDefined } from '../../../utils/assertDefined';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport { getWalletAccounts } from '../getWalletAccounts';\nimport { proveWalletAccountOwnership } from '../proveWalletAccountOwnership';\nimport { removeUnverifiedWalletAccount } from '../unverifiedWalletAccounts/removeUnverifiedWalletAccount';\nimport { getWalletProviderFromWalletAccount } from '../utils/getWalletProviderFromWalletAccount';\nimport { isSameAddress } from '../utils/isSameAddress';\nimport { verifyMessageSignatureOwnership } from '../verifyMessageSignatureOwnership';\nimport type { WalletAccount } from '../walletAccount';\nimport { updateWalletProviderKeysForVerifiedCredentials } from '../walletProvider/walletProviderKeyMap/updateWalletProviderKeysForVerifiedCredentials';\nimport { WalletAccountAlreadyVerifiedError } from './../../../errors/WalletAccountAlreadyVerifiedError';\n\ntype VerifyWalletAccountForSignInOrTransferParams = {\n  isTransfer: boolean;\n  walletAccount: WalletAccount;\n};\n\nexport const verifyWalletAccountForSignInOrTransfer = async (\n  { walletAccount, isTransfer }: VerifyWalletAccountForSignInOrTransferParams,\n  client: DynamicClient\n): Promise<WalletAccount> => {\n  if (walletAccount.verifiedCredentialId) {\n    throw new WalletAccountAlreadyVerifiedError(walletAccount.address);\n  }\n\n  const walletProvider = getWalletProviderFromWalletAccount(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  const { messageToSign, signature } = await proveWalletAccountOwnership(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  const response = await verifyMessageSignatureOwnership(\n    {\n      addressesWithTypes: walletAccount.addressesWithTypes,\n      chain: walletAccount.chain,\n      isTransfer,\n      messageToSign,\n      signature,\n      walletAddress: walletAccount.address,\n      walletDisplayName: walletProvider.metadata.displayName,\n      walletProviderType: walletProvider.walletProviderType,\n    },\n    client\n  );\n\n  const walletVerifiedCredential = response.user?.verifiedCredentials.find(\n    (verifiedCredential) =>\n      isSameAddress(\n        verifiedCredential.address ?? '',\n        walletAccount.address,\n        walletAccount.chain\n      )\n  );\n\n  assertDefined(\n    walletVerifiedCredential,\n    `After verifying, still unable to find verified wallet credential for wallet account ${walletAccount.address} on chain ${walletAccount.chain}`\n  );\n\n  updateWalletProviderKeysForVerifiedCredentials(\n    {\n      keysToUpdate: {\n        [walletVerifiedCredential.id]: walletProvider.key,\n      },\n    },\n    client\n  );\n\n  /**\n   * Adds the user with the new wallet verified credential\n   * This will add the new verified wallet account to the client`s state\n   */\n  updateAuthFromVerifyResponse({ response }, client);\n\n  /**\n   * Remove the now verified wallet account from the unverified wallet accounts\n   */\n  removeUnverifiedWalletAccount(\n    { unverifiedWalletAccount: walletAccount },\n    client\n  );\n\n  const verifiedWalletAccount = getWalletAccounts(client).find(({ address }) =>\n    isSameAddress(address, walletAccount.address, walletAccount.chain)\n  );\n\n  assertDefined(\n    verifiedWalletAccount,\n    `Unable to find wallet account ${walletAccount.address} on chain ${walletAccount.chain} for verified credential ${walletVerifiedCredential.id}`\n  );\n\n  return verifiedWalletAccount;\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { verifyWalletAccountForSignInOrTransfer } from '../verifyWalletAccountForSignInOrTransfer';\nimport type { WalletAccount } from '../walletAccount';\n\ntype VerifyWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Verifies ownership of a wallet account and adds it to the user's profile.\n *\n * This function requires the user to sign a message to prove wallet ownership,\n * then sets the wallet account as verified.\n *\n * @param params.walletAccount - The wallet account to verify ownership of.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the verified wallet account.\n * @throws WalletAccountAlreadyVerifiedError If the wallet is already verified.\n * @throws WalletAlreadyLinkedToAnotherUserError If the wallet is linked to another user.\n */\nexport const verifyWalletAccount = async (\n  { walletAccount }: VerifyWalletAccountParams,\n  client = getDefaultClient()\n): Promise<WalletAccount> => {\n  return verifyWalletAccountForSignInOrTransfer(\n    {\n      isTransfer: false,\n      walletAccount,\n    },\n    client\n  );\n};\n","import { AuthModeEnum } from '@dynamic-labs/sdk-api-core';\n\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createVisit } from '../../auth/createVisit';\nimport { connectWithWalletProvider } from '../connectWithWalletProvider';\nimport { verifyWalletAccount } from '../verifyWalletAccount';\n\ntype ConnectAndVerifyWithWalletProviderParams = {\n  walletProviderKey: string;\n};\n\n/**\n * Connects to a wallet provider and verifies ownership through message signing.\n *\n * This function combines wallet connection and verification in a single step,\n * requiring the user to sign a message to prove wallet ownership before\n * the wallet account is added to their profile.\n *\n * @param params.walletProviderKey - The unique key identifying the wallet provider to connect to.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the connected and verified wallet account.\n */\nexport const connectAndVerifyWithWalletProvider = async (\n  { walletProviderKey }: ConnectAndVerifyWithWalletProviderParams,\n  client = getDefaultClient()\n) => {\n  const walletAccount = await connectWithWalletProvider(\n    { addToDynamicWalletAccounts: false, walletProviderKey },\n    client\n  );\n\n  await verifyWalletAccount({ walletAccount }, client);\n\n  /*\n   * send information to backend to kick off background jobs\n   * this is an async work, but does not need to be awaited\n   */\n  void createVisit({ authMode: AuthModeEnum.AndSign, walletAccount }, client);\n\n  return walletAccount;\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { getWalletProviders } from '../getWalletProviders';\nimport type { WalletProviderData } from '../walletProvider';\n\n/**\n * Retrieves data for all available wallet providers that can be used for connection.\n *\n * This function returns metadata about wallet providers that users can\n * connect to, like MetaMask, Phantom, etc.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns An array of wallet provider data including chain, keys, and metadata.\n */\nexport const getAvailableWalletProvidersData = (\n  client = getDefaultClient()\n): WalletProviderData[] => {\n  const allWalletProviders = getWalletProviders(client);\n\n  // This is to avoid returning the wallet providers that are connected via different means\n  // than by the \"connect\" method  like the Dynamic Waas providers, AA providers, or WalletConnect providers.\n  const filteredWalletProviders = allWalletProviders.filter((walletProvider) =>\n    Boolean(walletProvider.connect)\n  );\n\n  return filteredWalletProviders.map((walletProvider) => ({\n    chain: walletProvider.chain,\n    groupKey: walletProvider.groupKey,\n    key: walletProvider.key,\n    metadata: walletProvider.metadata,\n    walletProviderType: walletProvider.walletProviderType,\n  }));\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { getWalletProviderByKey } from '../getWalletProviderByKey';\n\ntype GetConnectedAddressesParams = {\n  walletProviderKey: string;\n};\n\n/**\n * Retrieves all connected addresses for a specific wallet provider.\n *\n * This function returns the list of wallet addresses that are currently\n * connected and available through the specified wallet provider.\n *\n * @param params.walletProviderKey - The unique key of the wallet provider to query.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns An array of connected wallet addresses.\n */\nexport const getConnectedAddresses = (\n  { walletProviderKey }: GetConnectedAddressesParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);\n\n  return walletProvider.getConnectedAddresses();\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { assertDefined } from '../../../utils/assertDefined';\nimport type { WalletAccount } from '../../wallets/walletAccount';\nimport { getWalletAccounts } from '../getWalletAccounts';\nimport { getVerifiedCredentialForWalletAccount } from '../utils/getVerifiedCredentialForWalletAccount';\n\ntype GetOwnerWalletAccountForSmartWalletAccountParams = {\n  smartWalletAccount: WalletAccount;\n};\n\nexport const getOwnerWalletAccountForSmartWalletAccount = (\n  { smartWalletAccount }: GetOwnerWalletAccountForSmartWalletAccountParams,\n  client = getDefaultClient()\n): WalletAccount | undefined => {\n  const smartWalletVerifiedCredential = getVerifiedCredentialForWalletAccount(\n    { walletAccount: smartWalletAccount },\n    client\n  );\n\n  assertDefined(\n    smartWalletVerifiedCredential?.signerRefId,\n    'Invalid smart wallet account'\n  );\n\n  return getWalletAccounts(client).find(\n    (walletAccount) =>\n      walletAccount.verifiedCredentialId ===\n      smartWalletVerifiedCredential.signerRefId\n  );\n};\n","import type { WalletAccount, WalletAddressType } from '../walletAccount';\n\ntype GetWalletAccountAddressByTypeParams = {\n  type: WalletAddressType;\n  walletAccount: WalletAccount;\n};\n\nexport const getWalletAccountAddressByType = ({\n  type,\n  walletAccount,\n}: GetWalletAccountAddressByTypeParams) => {\n  return walletAccount.addressesWithTypes?.find(\n    (address) => address.type === type\n  )?.address;\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { getWalletProviderByKey } from '../getWalletProviderByKey';\nimport type { WalletProviderData } from '../walletProvider';\n\ntype GetWalletProviderDataByKeyParams = {\n  walletProviderKey: string;\n};\n\n/**\n * Retrieves data for a specific wallet provider that can be used for display or connection.\n *\n * @param params.walletProviderKey - The key of the wallet provider to retrieve data for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns The data for the wallet provider.\n */\nexport const getWalletProviderDataByKey = (\n  { walletProviderKey }: GetWalletProviderDataByKeyParams,\n  client = getDefaultClient()\n): WalletProviderData => {\n  const { chain, groupKey, key, metadata, walletProviderType } =\n    getWalletProviderByKey({ walletProviderKey }, client);\n\n  return { chain, groupKey, key, metadata, walletProviderType };\n};\n","import type { WalletAccount } from '../walletAccount';\n\ntype isWalletAccountVerifiedParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Checks if a wallet account has been verified by a user.\n *\n * @param walletAccount - The wallet account to check.\n * @returns True if the wallet account has been verified, false otherwise.\n */\nexport const isWalletAccountVerified = ({\n  walletAccount,\n}: isWalletAccountVerifiedParams) => {\n  return walletAccount.verifiedCredentialId !== null;\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { NetworkAddingUnavailableError } from '../../../../errors/NetworkAddingUnavailableError';\nimport { getWalletProviderByKey } from '../../getWalletProviderByKey';\nimport type { WalletAccount } from '../../walletAccount';\nimport type { NetworkData } from '../networkProvider/networkProvider.types';\n\ntype AddNetworkParams = {\n  networkData: NetworkData;\n  walletAccount: WalletAccount;\n};\n\n/**\n * Adds a network to the wallet provider.\n *\n * This function requests that the wallet provider add a network\n * to its list of available networks.\n *\n * @param params.networkData - The network configuration data to add to the wallet.\n * @param params.walletAccount - The wallet account to add the network for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the network addition is complete.\n * @throws NetworkAddingUnavailableError If the wallet provider doesn't support adding networks.\n */\nexport const addNetwork = async (\n  { networkData, walletAccount }: AddNetworkParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderByKey(\n    { walletProviderKey: walletAccount.walletProviderKey },\n    client\n  );\n\n  if (walletProvider.addNetwork === undefined) {\n    throw new NetworkAddingUnavailableError({\n      extraMessages: [\n        `Wallet provider ${walletAccount.walletProviderKey} does not have addNetwork method`,\n      ],\n      originalError: null,\n      walletProviderKey: walletAccount.walletProviderKey,\n    });\n  }\n\n  return walletProvider.addNetwork({ networkData });\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { getWalletProviderFromWalletAccount } from '../../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../../walletAccount';\nimport { getNetworksData } from '../getNetworksData';\n\ntype GetActiveNetworkDataParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Retrieves the network configuration data for the currently active network.\n *\n * This function returns detailed network information including RPC URLs,\n * native currency details, and block explorer URLs for the network that\n * the wallet account is currently connected to.\n *\n * @param params.walletAccount - The wallet account to get network data for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the network data, or undefined if not found.\n */\nexport const getActiveNetworkData = async (\n  { walletAccount }: GetActiveNetworkDataParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderFromWalletAccount(\n    { walletAccount },\n    client\n  );\n\n  const { networkId } = await walletProvider.getActiveNetworkId();\n\n  const networksData = getNetworksData(client);\n\n  const activeNetworkData = networksData.find(\n    (data) =>\n      data.networkId === networkId && data.chain === walletProvider.chain\n  );\n\n  return { networkData: activeNetworkData };\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { getWalletProviderFromWalletAccount } from '../../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../../walletAccount';\n\ntype GetActiveNetworkIdParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * This function returns the network identifier that this wallet account's provider is currently connected to.\n *\n * @param params.walletAccount - The wallet account to get the network ID for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the active network ID for the wallet account.\n */\nexport const getActiveNetworkId = (\n  { walletAccount }: GetActiveNetworkIdParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderFromWalletAccount(\n    { walletAccount },\n    client\n  );\n\n  return walletProvider.getActiveNetworkId();\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { getWalletProviderFromWalletAccount } from '../../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../../walletAccount';\nimport { getNetworkProviderFromNetworkId } from '../getNetworkProviderFromNetworkId';\n\ntype GetBalanceParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Retrieves the native token balance for a wallet account.\n *\n * This function fetches the balance of the native cryptocurrency\n * (e.g., ETH, SOL, BTC, etc.) for the specified wallet account.\n *\n * @param params.walletAccount - The wallet account to get the balance for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an object containing the balance as a string or null.\n */\nexport const getBalance = async (\n  { walletAccount }: GetBalanceParams,\n  client = getDefaultClient()\n): Promise<{ balance: string | null }> => {\n  const walletProvider = getWalletProviderFromWalletAccount(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  const { networkId } = await walletProvider.getActiveNetworkId();\n\n  const networkProvider = getNetworkProviderFromNetworkId(\n    { chain: walletProvider.chain, networkId },\n    client\n  );\n\n  return networkProvider.getBalance({ address: walletAccount.address });\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport type { Chain } from '../../../chain';\nimport { getNetworkProviderFromNetworkId } from '../getNetworkProviderFromNetworkId';\n\ntype GetBalanceForAddressParams = {\n  address: string;\n  chain: Chain;\n  networkId: string;\n};\n\n/**\n * Retrieves the native token balance for a specific address on a given network.\n *\n * This function queries the balance directly for any address without requiring\n * a connected wallet account, useful for checking balances of external addresses.\n *\n * @param params.address - The wallet address to check the balance for.\n * @param params.chain - The chain (e.g., 'EVM', 'SOL').\n * @param params.networkId - The specific network ID within the chain.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an object containing the balance as a string or null.\n */\nexport const getBalanceForAddress = async (\n  { address, chain, networkId }: GetBalanceForAddressParams,\n  client = getDefaultClient()\n): Promise<{ balance: string | null }> => {\n  const networkProvider = getNetworkProviderFromNetworkId(\n    { chain, networkId },\n    client\n  );\n\n  assertDefined(\n    networkProvider,\n    `No network found for chain ${chain} and network id ${networkId}. Please ensure you've enabled this network in the Dashboard.`\n  );\n\n  return networkProvider.getBalance({ address });\n};\n","import type {\n  ChainEnum,\n  WalletTransactionsResponse,\n} from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\nimport type { Chain } from '../../../chain/chain.types';\n\nexport type GetTransactionHistoryParams = {\n  address: string;\n  chain: Chain;\n  limit?: number;\n  networkId: number;\n  offset?: string;\n};\n\nexport type GetTransactionHistoryResponse = WalletTransactionsResponse;\n\n/**\n * Retrieves the transaction history for a given wallet address, chain and network.\n *\n * This function fetches the transaction history for a specified wallet address and chain,\n * returning a list of transactions associated with that address along with nextOffset for pagination.\n *\n * @param params.address - The wallet address to query transactions for.\n * @param params.chain - The chain to query transactions for.\n * @param [params.limit] - The maximum number of transactions to return.\n * @param params.networkId - The network ID to query transactions for.\n * @param [params.offset] - The offset to use for pagination.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the transaction history along with nextOffset for the given wallet address and chain.\n */\nexport const getTransactionHistory = async (\n  params: GetTransactionHistoryParams,\n  client = getDefaultClient()\n): Promise<WalletTransactionsResponse> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const response = await apiClient.getWalletTransactions({\n    address: params.address,\n    // eslint-disable-next-line custom-rules/ban-chain-enum\n    chainName: params.chain as ChainEnum,\n    environmentId: core.environmentId,\n    networkId: params.networkId,\n  });\n\n  return response;\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { getWalletProviderByKey } from '../../getWalletProviderByKey';\nimport type { WalletAccount } from '../../walletAccount';\n\ntype IsProgrammaticNetworkSwitchAvailableParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Checks if programmatic network switching is available for a wallet account.\n *\n * This function determines whether the wallet provider supports automatic\n * network switching without requiring the user to manually switch networks on their wallet app.\n *\n * @param params.walletAccount - The wallet account to check network switching support for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns True if programmatic network switching is available, false otherwise.\n */\nexport const isProgrammaticNetworkSwitchAvailable = (\n  { walletAccount }: IsProgrammaticNetworkSwitchAvailableParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderByKey(\n    { walletProviderKey: walletAccount.walletProviderKey },\n    client\n  );\n\n  return walletProvider.switchActiveNetwork !== undefined;\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport { NetworkSwitchingUnavailableError } from '../../../../errors/NetworkSwitchingUnavailableError';\nimport { getWalletProviderByKey } from '../../getWalletProviderByKey';\nimport type { WalletAccount } from '../../walletAccount';\n\ntype SwitchActiveNetworkParams = {\n  networkId: string;\n  walletAccount: WalletAccount;\n};\n\n/**\n * Switches the active network for a wallet account.\n *\n * This function programmatically changes the network\n * that the wallet is currently connected to.\n *\n * @param params.networkId - The identifier of the network to switch to. Should match the networkId of the network data.\n * @param params.walletAccount - The wallet account to switch networks for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the network switch is complete.\n * @throws NetworkSwitchingUnavailableError If the wallet provider doesn't support network switching.\n */\nexport const switchActiveNetwork = async (\n  { networkId, walletAccount }: SwitchActiveNetworkParams,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderByKey(\n    { walletProviderKey: walletAccount.walletProviderKey },\n    client\n  );\n\n  if (walletProvider.switchActiveNetwork === undefined) {\n    throw new NetworkSwitchingUnavailableError({\n      extraMessages: [\n        `Wallet provider ${walletAccount.walletProviderKey} does not have switchActiveNetwork method`,\n      ],\n      originalError: null,\n      walletProviderKey: walletAccount.walletProviderKey,\n    });\n  }\n\n  return walletProvider.switchActiveNetwork({ networkId });\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { createApiClient } from '../../../apiClient';\nimport { updateAuthFromVerifyResponse } from '../../../auth/updateAuthFromVerifyResponse';\nimport { setUnverifiedWalletAccounts } from '../../unverifiedWalletAccounts/setUnverifiedWalletAccounts';\nimport type { WalletAccount } from '../../walletAccount';\nimport { getPrimaryWalletAccount } from './../getPrimaryWalletAccount';\n\ntype SelectPrimaryWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Make the wallet account provided as the primary wallet account.\n */\nexport const selectPrimaryWalletAccount = async (\n  { walletAccount }: SelectPrimaryWalletAccountParams,\n  client = getDefaultClient()\n): Promise<void> => {\n  const core = getCore(client);\n\n  const currentPrimaryWalletAccount = getPrimaryWalletAccount(client);\n\n  if (currentPrimaryWalletAccount?.id === walletAccount.id) {\n    return;\n  }\n\n  if (walletAccount.verifiedCredentialId) {\n    const apiClient = createApiClient({}, client);\n\n    const response = await apiClient.selectUserWallet({\n      environmentId: core.environmentId,\n      userWalletSelectionRequest: {\n        walletId: walletAccount.verifiedCredentialId,\n      },\n    });\n\n    updateAuthFromVerifyResponse({ response }, client);\n  } else {\n    const updatedWalletAccount = {\n      ...walletAccount,\n      lastSelectedAt: new Date(),\n    };\n\n    setUnverifiedWalletAccounts(\n      {\n        unverifiedWalletAccountsToUpdate: [updatedWalletAccount],\n      },\n      client\n    );\n  }\n};\n","import type { DynamicClient } from '../../../client/types';\nimport { NoWalletProviderFoundError } from '../../../errors/NoWalletProviderFoundError';\nimport { getWalletProviderFromWalletAccount } from '../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../walletAccount';\n\ntype DisconnectWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * This function disconnects the specified wallet account with the wallet provider.\n *\n * The wallet account is not removed from the user's profile or from dynamic's state,\n * it is only responsible for terminating the connection with the wallet provider.\n */\nexport const disconnectWalletAccount = async (\n  { walletAccount }: DisconnectWalletAccountParams,\n  client: DynamicClient\n): Promise<void> => {\n  try {\n    const walletProvider = getWalletProviderFromWalletAccount(\n      { walletAccount },\n      client\n    );\n\n    await walletProvider.disconnectWalletAccount?.({ walletAccount });\n  } catch (error) {\n    // If there is no wallet provider, we don't need to do anything\n    // as the wallet account is not connected. It's fine to ignore this error.\n    if (error instanceof NoWalletProviderFoundError) {\n      return;\n    }\n\n    throw error;\n  }\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\nimport { createApiClient } from '../../apiClient';\nimport { updateAuthFromVerifyResponse } from '../../auth/updateAuthFromVerifyResponse';\nimport { disconnectWalletAccount } from '../disconnectWalletAccount';\nimport { removeUnverifiedWalletAccount } from '../unverifiedWalletAccounts/removeUnverifiedWalletAccount';\nimport type { WalletAccount } from '../walletAccount';\n\ntype RemoveWalletAccountParams = {\n  walletAccount: WalletAccount;\n};\n\n/**\n * Removes a wallet account from the current session or user (if authenticated).\n *\n * This function both disconnects and removes the specified wallet account,\n * updating local state and server records (if there is an authenticated user).\n * For verified wallets, it will unlink them from the user's account.\n *\n * @param params.walletAccount - The wallet account to remove.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves when the wallet account is successfully removed.\n */\nexport const removeWalletAccount = async (\n  { walletAccount }: RemoveWalletAccountParams,\n  client = getDefaultClient()\n): Promise<void> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  await disconnectWalletAccount({ walletAccount }, client);\n\n  if (!walletAccount.verifiedCredentialId) {\n    removeUnverifiedWalletAccount(\n      { unverifiedWalletAccount: walletAccount },\n      client\n    );\n\n    return;\n  }\n\n  const response = await apiClient.verifyUnlink({\n    environmentId: core.environmentId,\n    verifyUnlinkRequest: {\n      walletId: walletAccount.verifiedCredentialId,\n    },\n  });\n\n  updateAuthFromVerifyResponse({ response }, client);\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { assertWalletProviderMethodDefined } from '../utils/assertWalletProviderMethodDefined';\nimport { getWalletProviderFromWalletAccount } from '../utils/getWalletProviderFromWalletAccount';\nimport type { WalletAccount } from '../walletAccount';\n\ntype SignMessageParams = {\n  message: string;\n  walletAccount: WalletAccount;\n};\n\n/**\n * Signs a message using the specified wallet account.\n *\n * This function uses the wallet's private key to cryptographically sign\n * the provided message.\n *\n * @param params.walletAccount - The wallet account to use for signing.\n * @param params.message - The message to sign.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to an object containing the signature.\n */\nexport const signMessage = async (\n  { walletAccount, message }: SignMessageParams,\n  client = getDefaultClient()\n): Promise<{ signature: string }> => {\n  const walletProvider = getWalletProviderFromWalletAccount(\n    {\n      walletAccount,\n    },\n    client\n  );\n\n  assertWalletProviderMethodDefined(walletProvider, 'signMessage');\n\n  const { signature } = await walletProvider.signMessage({\n    message,\n    walletAccount,\n  });\n\n  return { signature };\n};\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { connectWithWalletProvider } from '../connectWithWalletProvider';\nimport { verifyWalletAccountForSignInOrTransfer } from '../verifyWalletAccountForSignInOrTransfer';\n\ntype TransferWalletAccountParams = {\n  walletProviderKey: string;\n};\n\n/**\n * Transfer a wallet account to the current user's account.\n *\n * This function requires the user to sign a message to prove wallet ownership,\n * then transfers the wallet account to the current user's account.\n *\n * @param params.walletProviderKey - The key of the wallet provider of the wallet account to transfer.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A promise that resolves to the transferred wallet account.\n */\nexport const transferWalletAccount = async (\n  { walletProviderKey }: TransferWalletAccountParams,\n  client = getDefaultClient()\n) => {\n  const walletAccount = await connectWithWalletProvider(\n    { addToDynamicWalletAccounts: false, walletProviderKey },\n    client\n  );\n\n  return verifyWalletAccountForSignInOrTransfer(\n    {\n      isTransfer: true,\n      walletAccount,\n    },\n    client\n  );\n};\n","import { getDefaultClient } from '../../../../client/defaultClient';\nimport type { Chain } from '../../../chain';\nimport { getWalletAccounts } from '../../getWalletAccounts';\n\ntype GetWalletAccountFromAddressParams = {\n  address: string;\n  chain: Chain;\n};\n\n/**\n * Finds a wallet account by address and blockchain.\n *\n * This function searches through the current session's wallet accounts\n * to find one matching the specified address and chain.\n *\n * @param params.address - The wallet address to search for.\n * @param params.chain - The blockchain the wallet belongs to.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns The matching wallet account, or undefined if not found.\n */\nexport const getWalletAccountFromAddress = (\n  { address, chain }: GetWalletAccountFromAddressParams,\n  client = getDefaultClient()\n) => {\n  const walletAccounts = getWalletAccounts(client);\n\n  return walletAccounts.find(\n    (walletAccount) =>\n      walletAccount.address === address && walletAccount.chain === chain\n  );\n};\n","import { getDefaultClient } from '../../../../../client/defaultClient';\nimport { getWalletProviderByKey } from '../../../getWalletProviderByKey';\nimport { assertWalletProviderMethodDefined } from '../../../utils/assertWalletProviderMethodDefined';\nimport type { WalletProviderEvents } from '../walletProviderEvents.types';\n\ntype OffWalletProviderEventParams<\n  E extends Extract<keyof WalletProviderEvents, string>\n> = {\n  callback: WalletProviderEvents[E];\n  event: E;\n  walletProviderKey: string;\n};\n\n/**\n * Removes a listener from a wallet provider event.\n * You can alternatively use the returned function from `onWalletProviderEvent` instead of using this function.\n *\n * @param params.callback - The callback function to remove. This should be the same function that was passed to the `onWalletProviderEvent` function.\n * @see onWalletProviderEvent\n * @param params.event - The event name to remove the listener from.\n * @param params.walletProviderKey - The unique key identifying the wallet provider to remove the listener from.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n */\nexport const offWalletProviderEvent = <\n  E extends Extract<keyof WalletProviderEvents, string>\n>(\n  { callback, event, walletProviderKey }: OffWalletProviderEventParams<E>,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);\n\n  assertWalletProviderMethodDefined(walletProvider, 'events');\n\n  // We use any here because typescript is messing up the type inference\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  walletProvider.events.off(event, callback as any);\n};\n","import { getDefaultClient } from '../../../../../client/defaultClient';\nimport { getWalletProviderByKey } from '../../../getWalletProviderByKey';\nimport { assertWalletProviderMethodDefined } from '../../../utils/assertWalletProviderMethodDefined';\nimport type { WalletProviderEvents } from '../walletProviderEvents.types';\n\ntype OnWalletProviderEventParams<\n  E extends Extract<keyof WalletProviderEvents, string>\n> = {\n  callback: WalletProviderEvents[E];\n  event: E;\n  walletProviderKey: string;\n};\n\n/**\n * Listens to a wallet provider event.\n *\n * @param params.callback - The callback function to execute when the event is fired.\n * @param params.event - The event name to listen for.\n * @param params.walletProviderKey - The unique key identifying the wallet provider to listen to.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns A function that can be called to remove the listener.\n */\nexport const onWalletProviderEvent = <\n  E extends Extract<keyof WalletProviderEvents, string>\n>(\n  { callback, event, walletProviderKey }: OnWalletProviderEventParams<E>,\n  client = getDefaultClient()\n) => {\n  const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);\n\n  assertWalletProviderMethodDefined(walletProvider, 'events');\n\n  // We use any here because typescript is messing up the type inference\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  walletProvider.events.on(event, callback as any);\n\n  return () => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    walletProvider.events.off(event, callback as any);\n  };\n};\n","/* eslint-disable no-useless-escape */\n/* eslint-disable no-restricted-globals */\n/**\n * Sourced from http://detectmobilebrowsers.com/\n */\n\nconst userAgentRegex1 =\n  /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ios|ipad|playbook|silk/i;\n\nconst userAgentRegex2 =\n  /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i;\n\n// This is a regex that covers both iphone, android and any other mobile device.\nexport const isMobile = (maxTouchPointsOverride?: number) => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n\n  return (\n    userAgentRegex1.test(navigator.userAgent) ||\n    userAgentRegex2.test(navigator.userAgent.substring(0, 4)) ||\n    isIPad(maxTouchPointsOverride) ||\n    isIPhone()\n  );\n};\n\nexport const isIPhone = () =>\n  typeof window === 'undefined' || typeof navigator === 'undefined'\n    ? false\n    : /iPhone|ios/.test(navigator.userAgent);\n\nexport const isIPhone8OrEarlier = () =>\n  typeof window === 'undefined' || typeof navigator === 'undefined'\n    ? false\n    : iPhoneLegacyRegex.some(({ regex }) => regex.test(navigator.userAgent));\n\n/**\n * @param [optional] maxTouchPointsOverride - this is used for testing since\n * it seems that JSDOM doesn't support maxTouchPoints, so it was impossible\n * to mock it\n */\nexport const isIPad = (maxTouchPointsOverride?: number) => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n\n  const maxTouchPoints = maxTouchPointsOverride || navigator.maxTouchPoints;\n\n  return (\n    /iPad/.test(navigator.userAgent) ||\n    (/Mac/.test(navigator.userAgent) && maxTouchPoints === 5)\n  );\n};\n\nexport const isIOS = (maxTouchPointsOverride?: number) => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n\n  return isIPhone() || isIPad(maxTouchPointsOverride);\n};\n\nexport const isAndroid = () => isMobile() && !isIOS();\n\nexport const isLegacySafari = () => {\n  // We need to check if window.CSS exists and if it has supports function.\n  // We can use it only in browsers. This prevents customer tests from failing because of that.\n  if (\n    typeof window === 'undefined' ||\n    !window.CSS ||\n    typeof window.CSS.supports !== 'function'\n  ) {\n    return false;\n  }\n\n  // Older versions of Safari <15 are not supporting aspect-ratio css property.\n  // We can use that to check if user is on older browser.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio\n  const cssValue = 'aspect-ratio: 1 / 1';\n\n  return !CSS.supports(cssValue);\n};\n\nexport const isSamsungBrowser = () => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n\n  return navigator.userAgent.includes('SamsungBrowser');\n};\n\nexport const isSafariBrowser = () => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n\n  const { userAgent } = navigator;\n\n  const isSafari =\n    userAgent.includes('Safari') &&\n    !userAgent.includes('Chrome') &&\n    !userAgent.includes('Chromium');\n\n  return isSafari;\n};\n\nexport const isWindows = () => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n\n  return navigator.userAgent.indexOf('Windows') !== -1;\n};\n\n// regex from: https://github.com/matomo-org/device-detector/blob/master/regexes/device/mobiles.yml\nconst iPhoneLegacyRegex = [\n  {\n    model: 'iPhone 5',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]12|5)$/,\n  },\n  {\n    model: 'iPhone 5C',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]34)$/,\n  },\n  {\n    model: 'iPhone 5S',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?6[C,_]12|5S)$/,\n  },\n  {\n    model: 'iPhone 6 Plus',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]1|1C2%257enohPi|6PLUS)$/,\n  },\n  {\n    model: 'iPhone 6',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]2|6)$/,\n  },\n  {\n    model: 'iPhone 6s Plus',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]2|6SPLUS)$/,\n  },\n  {\n    model: 'iPhone 6s',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]1|iPhone[ /]6s|6S)$/,\n  },\n  {\n    model: 'iPhone SE',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]4|SE)$/,\n  },\n  {\n    model: 'iPhone 7',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]13|iphone7|7)$/,\n  },\n  {\n    model: 'iPhone 7 Plus',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]24|7PLUS)$/,\n  },\n  {\n    model: 'iPhone 8',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]14|8)$/,\n  },\n  {\n    model: 'iPhone 8 Plus',\n    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]25|8PLUS)$/,\n  },\n];\n\nexport const getAndroidVersion = () => {\n  if (typeof navigator === 'undefined') {\n    return;\n  }\n\n  const androidVersionMatch = navigator.userAgent.match(\n    /Android (\\d+(\\.\\d+)?)/\n  );\n\n  if (!androidVersionMatch) {\n    return;\n  }\n\n  const androidVersion = parseFloat(androidVersionMatch[1]);\n\n  return androidVersion;\n};\n","/* eslint-disable import/no-unassigned-import */\n\nimport { assertPackageVersion } from '@dynamic-labs-sdk/assert-package-version';\n\nimport {\n  name as packageName,\n  version as packageVersion,\n} from '../../package.json';\nassertPackageVersion(packageName, packageVersion);\n\n// Import the modules states so that they are available in the global scope.\nimport '../modules/auth/state';\nimport '../modules/captcha/state';\nimport '../modules/initializeClient/state';\nimport '../modules/mfa/state';\nimport '../modules/projectSettings/state';\nimport '../modules/sessionKeys/state';\nimport '../modules/wallets/unverifiedWalletAccounts/state';\nimport '../modules/wallets/walletProvider/walletProviderKeyMap/state';\n\n// Import the event types for the modules so that they are available in the global scope.\nimport '../modules/auth/events';\nimport '../modules/mfa/events';\nimport '../modules/state/raiseStateEvents/events';\nimport '../modules/wallets/walletAccount/events';\nimport '../modules/wallets/walletProviderRegistry/events';\n\nexport { MFAAction } from '@dynamic-labs/sdk-api-core';\nexport type {\n  CreateMfaToken,\n  UserPasskey,\n  VerifyResponse,\n} from '@dynamic-labs/sdk-api-core';\nexport type { DynamicCoreConfig } from '../client/core/types';\nexport { createDynamicClient } from '../client/createDynamicClient';\nexport { getDefaultClient } from '../client/defaultClient';\nexport type { DynamicClient, DynamicClientConfig } from '../client/types';\nexport { BaseError, type BaseErrorParameters } from '../errors/base';\nexport { ClientAlreadyInitializedError } from '../errors/ClientAlreadyInitializedError';\nexport { InvalidExternalAuthError } from '../errors/InvalidExternalAuthError';\nexport { InvalidParamError } from '../errors/InvalidParamError';\nexport { InvalidRedirectStorageStateError } from '../errors/InvalidRedirectStorageStateError';\nexport { LinkCredentialError } from '../errors/LinkCredentialError';\nexport { MfaInvalidOtpError } from '../errors/MfaInvalidOtpError';\nexport { MfaRateLimitedError } from '../errors/MfaRateLimitedError';\nexport { MissingRedirectStorageStateError } from '../errors/MissingRedirectStorageStateError';\nexport { MissingSocialUrlParamError } from '../errors/MissingSocialUrlParamError';\nexport { MissingUserVerificationError } from '../errors/MissingUserVerificationError';\nexport { NetworkAddingUnavailableError } from '../errors/NetworkAddingUnavailableError';\nexport { NetworkNotAddedError } from '../errors/NetworkNotAddedError';\nexport { NetworkSwitchingUnavailableError } from '../errors/NetworkSwitchingUnavailableError';\nexport { NoAddressFoundError } from '../errors/NoAddressFoundError';\nexport { NoNetworkProvidersError } from '../errors/NoNetworkProvidersError';\nexport { NoPasskeyCredentialsFoundError } from '../errors/NoPasskeyCredentialsFoundError';\nexport { NoSmartWalletAccountSignerFoundError } from '../errors/NoSmartWalletAccountSignerFoundError';\nexport { NotWaasWalletAccountError } from '../errors/NotWaasWalletAccountError';\nexport { NoWebAuthNSupportError } from '../errors/NoWebAuthNSupportError';\nexport { SandboxMaximumThresholdReachedError } from '../errors/SandboxMaximumThresholdReachedError';\nexport { UnavailableInServerSideError } from '../errors/UnavailableInServerSideError';\nexport { UnrecognizedNetworkError } from '../errors/UnrecognizedNetworkError';\nexport { UserNotAuthenticatedError } from '../errors/UserNotAuthenticatedError';\nexport { UserRejectedError } from '../errors/UserRejectedError';\nexport { WalletAccountAlreadyVerifiedError } from '../errors/WalletAccountAlreadyVerifiedError';\nexport { WalletAccountNotSelectedError } from '../errors/WalletAccountNotSelectedError';\nexport { WalletAlreadyLinkedToAnotherUserError } from '../errors/WalletAlreadyLinkedToAnotherUserError';\nexport { WalletProviderMethodUnavailableError } from '../errors/WalletProviderMethodUnavailableError';\nexport { signInWithExternalJwt } from '../modules/auth/externalAuth/signInWithExternalJwt';\nexport { isSignedIn } from '../modules/auth/isSignedIn';\nexport { logout } from '../modules/auth/logout';\nexport { deletePasskey } from '../modules/auth/passkeys/deletePasskey';\nexport { getPasskeys } from '../modules/auth/passkeys/getPasskeys';\nexport { registerPasskey } from '../modules/auth/passkeys/registerPasskey';\nexport { signInWithPasskey } from '../modules/auth/passkeys/signInWithPasskey';\nexport { getUserSocialAccounts } from '../modules/auth/social/getUserSocialAccounts';\nexport { authenticateWithSocial } from '../modules/auth/social/oauth/authenticateWithSocial';\nexport { completeSocialAuthentication } from '../modules/auth/social/oauth/completeSocialAuthentication';\nexport { detectOAuthRedirect } from '../modules/auth/social/oauth/detectOAuthRedirect';\nexport { unlinkSocialAccount } from '../modules/auth/social/oauth/unlinkSocialAccount';\nexport type {\n  SocialAccount,\n  SocialProvider,\n} from '../modules/auth/social/social.types';\nexport {\n  getMultichainBalances,\n  type GetMultichainBalancesParams,\n} from '../modules/balances/getMultichainBalances';\nexport { isCaptchaRequired } from '../modules/captcha/isCaptchaRequired';\nexport { setCaptchaToken } from '../modules/captcha/setCaptchaToken';\nexport type { Chain } from '../modules/chain';\nexport { offEvent, onceEvent, onEvent } from '../modules/clientEvents';\nexport type {\n  DynamicEvents,\n  OffEventParams,\n  OnceEventParams,\n  OnEventParams,\n} from '../modules/clientEvents/clientEvents.types';\nexport { hasExtension } from '../modules/extension/hasExtension';\nexport { addCoinbaseOnrampOrderEventListener } from '../modules/funding/coinbase/addCoinbaseOnrampOrderEventListener';\nexport type {\n  CoinbaseCreateOnrampOrderRequest,\n  CoinbaseOnrampFeeType,\n  CoinbaseOnrampGetBuyUrlRequest,\n  CoinbaseOnrampGetBuyUrlResponse,\n  CoinbaseOnrampMissingVerificationErrorCode,\n  CoinbaseOnrampOrderPaymentLinkType,\n  CoinbaseOnrampOrderPaymentMethod,\n  CoinbaseOnrampOrderResponse,\n  CoinbaseOnrampOrderStatus,\n  FieldMissingVerificationForCoinbaseOnramp,\n} from '../modules/funding/coinbase/coinbase.types';\nexport { createCoinbaseOnrampOrder } from '../modules/funding/coinbase/createCoinbaseOnrampOrder';\nexport { getCoinbaseBuyUrl } from '../modules/funding/coinbase/getCoinbaseBuyUrl';\nexport { getMissingVerificationForCoinbaseOnrampOrder } from '../modules/funding/coinbase/getMissingVerificationForCoinbaseOnrampOrder';\nexport { createCryptoDotComPayment } from '../modules/funding/cryptoDotCom/createCryptoDotComPayment';\nexport type {\n  CryptoDotComPaymentCreateRequest,\n  CryptoDotComPaymentResponse,\n} from '../modules/funding/cryptoDotCom/cryptoDotCom.types';\nexport { initializeClient } from '../modules/initializeClient';\nexport type { DynamicInitStatus } from '../modules/initializeClient/state';\nexport { waitForClientInitialized } from '../modules/initializeClient/waitForClientInitialized';\nexport { getWalletConnectCatalog } from '../modules/legacyWalletBook/getWalletConnectCatalog';\nexport type {\n  WalletConnectCatalog,\n  WalletConnectCatalogDeepLinks,\n  WalletConnectCatalogGroup,\n  WalletConnectCatalogWallet,\n} from '../modules/legacyWalletBook/getWalletConnectCatalog';\nexport { getWalletConnectCatalogWalletByWalletProviderKey } from '../modules/legacyWalletBook/getWalletConnectCatalogWalletByWalletProviderKey';\nexport { acknowledgeRecoveryCodes } from '../modules/mfa/acknowledgeRecoveryCodes';\nexport { authenticateMfaRecoveryCode } from '../modules/mfa/authenticateMfaRecoveryCode';\nexport { authenticatePasskeyMFA } from '../modules/mfa/authenticatePasskeyMFA';\nexport { authenticateTotpMfaDevice } from '../modules/mfa/authenticateTotpMfaDevice';\nexport { consumeMfaToken } from '../modules/mfa/consumeMfaToken';\nexport { createNewMfaRecoveryCodes } from '../modules/mfa/createNewMfaRecoveryCodes';\nexport { deleteMfaDevice } from '../modules/mfa/deleteMfaDevice';\nexport { getMfaDevices } from '../modules/mfa/getMfaDevices';\nexport { getMfaMethods } from '../modules/mfa/getMfaMethods';\nexport { getMfaRecoveryCodes } from '../modules/mfa/getMfaRecoveryCodes';\nexport { isMfaRequiredForAction } from '../modules/mfa/isMfaRequiredForAction';\nexport { isPendingRecoveryCodesAcknowledgment } from '../modules/mfa/isPendingRecoveryCodesAcknowledgment';\nexport { isUserMissingMfaAuth } from '../modules/mfa/isUserMissingMfaAuth';\nexport type { MFADevice } from '../modules/mfa/mfa.types';\nexport { registerTotpMfaDevice } from '../modules/mfa/registerTotpMfaDevice';\nexport { setDefaultMfaDevice } from '../modules/mfa/setDefaultMfaDevice';\nexport type { OTPVerification } from '../modules/otp/otp.types';\nexport { sendEmailOTP } from '../modules/otp/sendEmailOTP';\nexport { sendSmsOTP } from '../modules/otp/sendSmsOTP';\nexport { verifyOTP } from '../modules/otp/verifyOTP';\nexport { fetchProjectSettings } from '../modules/projectSettings/fetchProjectSettings';\nexport { deleteUser } from '../modules/user/deleteUser';\nexport { refreshAuth } from '../modules/user/refreshAuth';\nexport { refreshUser } from '../modules/user/refreshUser';\nexport { updateUser } from '../modules/user/updateUser';\nexport type { UpdateUserFields } from '../modules/user/user.types';\nexport { assertWalletAccountSigningAvailability } from '../modules/wallets/assertWalletAccountSigningAvailability';\nexport { connectAndVerifyWithWalletProvider } from '../modules/wallets/connectAndVerifyWithWalletProvider';\nexport { connectWithWalletProvider } from '../modules/wallets/connectWithWalletProvider';\nexport { getAvailableWalletProvidersData } from '../modules/wallets/getAvailableWalletProvidersData';\nexport { getConnectedAddresses } from '../modules/wallets/getConnectedAddresses';\nexport { getOwnerWalletAccountForSmartWalletAccount } from '../modules/wallets/getOwnerWalletAccountForSmartWalletAccount';\nexport { getWalletAccountAddressByType } from '../modules/wallets/getWalletAccountAddressByType';\nexport { getWalletAccounts } from '../modules/wallets/getWalletAccounts';\nexport { getWalletProviderDataByKey } from '../modules/wallets/getWalletProviderDataByKey';\nexport { isWalletAccountVerified } from '../modules/wallets/isWalletAccountVerified';\nexport { addNetwork } from '../modules/wallets/networks/addNetwork';\nexport { getActiveNetworkData } from '../modules/wallets/networks/getActiveNetworkData';\nexport { getActiveNetworkId } from '../modules/wallets/networks/getActiveNetworkId';\nexport { getBalance } from '../modules/wallets/networks/getBalance';\nexport { getBalanceForAddress } from '../modules/wallets/networks/getBalanceForAddress';\nexport { getNetworksData } from '../modules/wallets/networks/getNetworksData';\nexport {\n  getTransactionHistory,\n  type GetTransactionHistoryParams,\n  type GetTransactionHistoryResponse,\n} from '../modules/wallets/networks/getTransactionHistory';\nexport { isProgrammaticNetworkSwitchAvailable } from '../modules/wallets/networks/isProgrammaticNetworkSwitchAvailable';\nexport type { NetworkProvider } from '../modules/wallets/networks/networkProvider';\nexport type { NetworkData } from '../modules/wallets/networks/networkProvider/networkProvider.types';\nexport { switchActiveNetwork } from '../modules/wallets/networks/switchActiveNetwork';\nexport { getPrimaryWalletAccount } from '../modules/wallets/primaryWalletAccount/getPrimaryWalletAccount';\nexport { selectPrimaryWalletAccount } from '../modules/wallets/primaryWalletAccount/selectPrimaryWalletAccount';\nexport { proveWalletAccountOwnership } from '../modules/wallets/proveWalletAccountOwnership';\nexport { removeWalletAccount } from '../modules/wallets/removeWalletAccount';\nexport { signMessage } from '../modules/wallets/signMessage';\nexport { transferWalletAccount } from '../modules/wallets/transferWalletAccount';\nexport { assertWalletProviderMethodDefined } from '../modules/wallets/utils/assertWalletProviderMethodDefined';\nexport { getWalletAccountFromAddress } from '../modules/wallets/utils/getWalletAccountFromAddress';\nexport { verifyWalletAccount } from '../modules/wallets/verifyWalletAccount';\nexport type {\n  WalletAccount,\n  WalletAddressType,\n} from '../modules/wallets/walletAccount';\nexport type {\n  WalletProviderData,\n  WalletProviderMetadata,\n} from '../modules/wallets/walletProvider';\nexport { offWalletProviderEvent } from '../modules/wallets/walletProvider/events/offWalletProviderEvent';\nexport { onWalletProviderEvent } from '../modules/wallets/walletProvider/events/onWalletProviderEvent';\nexport { isMobile } from '../utils/isMobile';\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAQA,MAAa,oBAAoB;CAC/B,YAAY;CACZ,UAAU;CACV,iBAAiB;CACjB,kBAAkB;CAClB,OAAO;CACP,MAAM;CACP;;;;;;;;ACTD,IAAa,8BAAb,cAAiDA,4BAAU;CACzD,YAAY,YAAoB;AAC9B,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,mDAAmD;GAClE,CAAC;;;;;;ACMN,MAAa,cAAc,OAAU,EACnC,QAAQ,GACR,IACA,iBAC0B;AAC1B,MAAK,IAAI,QAAQ,GAAG,SAAS,YAAY,QACvC,KAAI;AACF,SAAO,MAAM,IAAI;UACV,OAAO;AACd,MAAI,SAAS,WACX,OAAM;AAGR,MAAI,QAAQ,EACV,OAAM,IAAI,SAAS,YAAY,WAAW,SAAS,MAAM,CAAC;;;;;;AAShE,OAAM,IAAI,4BAA4B,WAAW;;;;;;;;;;;;;;AC/BnD,MAAa,cAAc,SAASC,oCAAkB,KACpD,QAAQ,OAAO,QAAQC,gEAAkB,OAAO,CAAC,SAAS,EAAE;;;;;;;ACN9D,MAAa,4CAA4CC,+DACvD;CACE,KAAK;CACL,QAAQC,SAAE,QAAQ;CACnB,CACF;;;;;;;ACDD,MAAa,mCAAmC,MAAO,KAAK;;;;;;;;;;;AAY5D,MAAa,uBAAuB,OAAO,SAASC,oCAAkB,KAAK;CACzE,MAAM,OAAOC,0BAAQ,OAAO;CAE5B,MAAM,oBAAoB,MAAM,KAAK,QAAQ,QAC3C,0CACD;AAOD,KAL2B,QAAQ,OAAO,gBAAgB,IAKhC,EAJR,qBAAqB,oBAAoB,KAAK,KAAK,KAI7B,WAAW,OAAO,CACxD,QAAO,OAAO;CAGhB,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,MAAK,OAAO,MAAM,sDAAsD;CAExE,MAAM,UAAU,YACd,UAAU,uBACR;EACE,eAAe,KAAK;EACpB,YAAY,GAAGC,kCAAgB,GAAG,KAAK;EACxC,EACD,EACE,aAAa,QACd,CACF;CAEH,MAAM,kBAAkB,MAAM,YAAY;EACxC,IAAI;EACJ,YAAY;EACb,CAAC;AAEF,MAAK,MAAM,IAAI,EAAE,iBAAiB,mBAAmB,MAAM,CAAC;AAE5D,OAAM,KAAK,QAAQ,QACjB,2CACA,KAAK,KAAK,GAAG,iCACd;AAED,QAAO;;;;;;;;;AC9DT,MAAa,mBAAmB,MAAe;AAE7C,KAAI,GAAG,QAAQ,MAAM,IAAI,CAAC,QAAQ,MAAM,IAAI,IAAI;AAEhD,QAAO,WAAW,KAAK,KAAK,EAAE,GAAG,MAAM,EAAE,WAAW,EAAE,CAAC;;;;;;;;ACLzD,MAAa,wBAAwB,iBAA8B;CACjE,MAAM,oBAAoB,IAAI,WAAW,aAAa;CACtD,MAAM,MAAM,kBAAkB;CAG9B,MAAM,kBAAkB,kBAAkB,MAAM,GAAI,IAAI,QAAS,EAAE;AAGnE,iBAAgB,KAAK,IAAO,kBAAkB,MAAM,KAAK;AACzD,QAAO,gBAAgB;;;;;ACRzB,MAAa,aAAa,YAAY;CAEpC,MAAM,cAAc,MAAM,OAAO,OAAO,YACtC;EACE,MAAM;EACN,YAAY;EACb,EACD,MACA,CAAC,QAAQ,SAAS,CACnB;CAGD,MAAM,eAAe,MAAM,OAAO,OAAO,UACvC,OACA,YAAY,UACb;CAGD,MAAM,gBAAgB,MAAM,OAAO,OAAO,UACxC,OACA,YAAY,WACb;CAED,MAAM,4BAA4B,qBAAqB,aAAa;AAIpE,QAAO;EACL,SAASC,2CAHc,gBAAgB,cAAc,EAAE,CAGjB;EACtC,YAAY;EACZ,QAAQA,2CAAY,0BAA0B;EAC/C;;;;;AC7BH,MAAa,sBAAsB,OACjC,WACyB;CACzB,MAAM,EACJ,SAAS,YACT,QAAQ,WACR,YAAY,kBACV,MAAM,YAAY;CAEtB,MAAM,OAAOC,0BAAQ,OAAO;CAG5B,MAAM,yBAAyB,KAAK,UAAU;EAC5C;EACA;EACA;EACA,YAAY;EACb,CAAC;CAEF,MAAM,qBAAqBC,6BAAW,CACnC,KAAK,uBAAuB,CAC5B,SAAS,SAAS;AAErB,MAAK,MAAM,IAAI,EACb,aAAa,oBACd,CAAC;AAEF,QAAO;EAAE;EAAY;EAAe;EAAW;;;;;;;;;;AC1BjD,MAAa,8BAA+C;CAC1D,MAAM,2BAAW,IAAI,KAAsB;AAE3C,QAAO;EACL,WAAc,QAAgB,SAAS,IAAI,IAAI;EAC/C,WAAW,KAAa,YAAqB,SAAS,IAAI,KAAK,QAAQ;EACvE,aAAa,QAAgB,SAAS,OAAO,IAAI;EAClD;;;;;ACRH,MAAa,iDACX,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAE5B,MAAMC,qCAAkD,IAAI,KAAK;AAIjE,CAFuBC,gEAAkB,OAAO,CAEjC,SAAS,kBAAkB;AACxC,MAAI,mBAAmB,IAAI,cAAc,kBAAkB,CACzD;AAGF,MAAI;GACF,MAAM,iBAAiBC,iFACrB,EACE,eACD,EACD,OACD;AAED,sBAAmB,IAAI,cAAc,mBAAmB,eAAe;WAChE,OAAO;AACd,QAAK,OAAO,MAAM,gDAAgD;IAChE;IACA,eAAe,cAAc;IAC9B,CAAC;;GAEJ;AAEF,QAAO,MAAM,KAAK,mBAAmB,QAAQ,CAAC;;;;;;;;AC9BhD,MAAa,wCAAwC,OACnD,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAE5B,MAAM,kBAAkB,8CAA8C,OAAO;AAE7E,OAAM,QAAQ,IACZ,gBAAgB,IAAI,OAAO,mBAAmB;AAC5C,MAAI,eAAe,UACjB,OAAM,eAAe,WAAW;AAGlC,MAAI,eAAe,WACjB,KAAI;AACF,SAAM,eAAe,YAAY;WAC1B,KAAK;AACZ,QAAK,OAAO,MACV,mCAAmC,eAAe,OAClD,IACD;;GAGL,CACH;;;;;;;;;;;ACdH,MAAa,SAAS,OAAO,SAASC,oCAAkB,KAAK;CAC3D,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,MAAK,OAAO,MAAM,0BAA0B;AAE5C,OAAM,sCAAsC,OAAO;AAEnD,KAAI,OAAO,SAAS,MAAM;EACxB,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,MAAI;AACF,SAAM,UAAU,cAAc,EAC5B,eAAe,KAAK,eACrB,CAAC;WACK,OAAO;AACd,QAAK,OAAO,MAAM,4BAA4B,MAAM;;;;;;AAOtD,MAAIC,kCAAgB,OAAO,CACzB,yDACE,GAAGC,uEAAyB,4CAC7B;;AAIL,MAAK,MAAM,IAAI;EACb,cAAc;EACd,aAAa;EACb,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,OAAO;EACP,0BAA0B,EAAE;EAC5B,MAAM;EACP,CAAC;AAEF,yDAAU,EAAE,OAAO,UAAU,EAAE,OAAO;AAGtC,CAAK,qBAAqB,OAAO;AAGjC,CAAK,oBAAoB,OAAO;;;;;;;;AC5DlC,MAAa,kBACX,UACA,UACiB;CACjB,MAAM,YAAY;CAElB,IAAIC,YAAkD;CACtD,IAAI,YAAY;CAEhB,MAAM,YAAY;AAChB,MAAI,aAAa,UACf,aAAY,WAAW,UAAU,UAAU;MAE3C,aAAY,iBAAiB;AAC3B,gBAAa;AACb,QAAK;KACJ,UAAU;;AAIjB,MAAK;AAGL,cAAa;AACX,MAAI,cAAc,KAChB,cAAa,UAAU;;;;;;;;;ACnB7B,MAAa,kBAAkB,WAA0B;CACvD,MAAM,OAAOC,0BAAQ,OAAO;CAE5B,IAAIC,yBAA8C;CAElD,MAAM,qBAAqBC,8DACzB,KAAK,QACJ,UAAU,MAAM,iBAClB;CAED,MAAM,wBAAwB;EAC5B,MAAM,aAAa,KAAK,MAAM,KAAK,CAAC;AAEpC,4BAA0B;AAE1B,MAAI,CAAC,WACH;EAGF,MAAM,sBAAM,IAAI,MAAM;EAEtB,MAAM,sBAAsB,WAAW,SAAS,GAAG,IAAI,SAAS;AAEhE,MAAI,uBAAuB,GAAG;AAC5B,GAAK,OAAO,OAAO;AACnB;;AAIF,2BAAyB,eACvB,iBACA,oBACD;;AAGH,oBAAmB,gBAAgB;AAEnC,kBAAiB;;;;;ACvCnB,MAAa,oBAAoB,WAA0B;AAGzD,CAFaC,0BAAQ,OAAO,CAEvB,MAAM,WAAW,OAAO,aAAa;AAKxC,EAJqB,OAAO,QAAQ,kBAAkB,CAIzC,SAAS,CAAC,KAAK,WAAW;AAErC,OAAIC,uDAAe,MAAM,MAAM,SAAS,KAAK,CAAE;AAE/C,2DACE;IACE,MAAM,GAAG,MAAM,MAAM,MAAM;IAC3B;IACD,EACD,OACD;IACD;GACF;;;;;ACtBJ,MAAa,gCAAgCC,SAAE,OAAO;CACpD,SAASA,SAAE,QAAQ;CACnB,oBAAoBA,SAAE,SACpBA,SAAE,MACAA,SAAE,OAAO;EACP,SAASA,SAAE,QAAQ;EACnB,WAAWA,SAAE,SAASA,SAAE,QAAQ,CAAC;EACjC,MAAMA,SAAE,QAA2B,QAAQ,OAAO,QAAQ,SAAS;EACpE,CAAC,CACH,CACF;CACD,OAAOA,SAAE,QAAe,QAAQ,OAAO,QAAQ,SAAS;CACxD,IAAIA,SAAE,QAAQ;CACd,gBAAgBA,SAAE,SAASA,SAAE,MAAM,CAAC;CACpC,mBAAmBA,SAAE,QAAQ;CAC9B,CAAC;;;;AClBF,MAAa,6BAA6BC,SAAE,OAAOA,SAAE,QAAQ,EAAEA,SAAE,QAAQ,CAAC;;;;ACK1E,MAAa,wBAAwBC,+DAAuB;CAC1D,KAAK;CACL,QAAQC,SAAE,OAAO;EACf,YAAYA,SAAE,QAAQ;EACtB,iBAAiBA,SAAE,QAAgC;EACnD,0BAA0BA,SAAE,MAAM,8BAA8B;EAChE,MAAMA,SAAE,QAAwB;EAChC,sBAAsB;EACvB,CAAC;CACH,CAAC;AAEF,MAAa,0BAA0BD,+DAAuB;CAC5D,KAAK;CACL,QAAQC,SAAE,OAAO;EAIf,cAAcA,SAAE,SAASA,SAAE,QAAQ,CAAC;EAOpC,aAAaA,SAAE,SAASA,SAAE,QAAQ,CAAC;EAKnC,UAAUA,SAAE,SAASA,SAAE,QAAQ,CAAC;EAKhC,mBAAmBA,SAAE,QAAQ;EAK7B,aAAaA,SAAE,SAASA,SAAE,QAAQ,CAAC;EAKnC,OAAOA,SAAE,SAASA,SAAE,QAAQ,CAAC;EAC9B,CAAC;CACH,CAAC;;;;AC9CF,MAAa,0BAA0B,OACrC,WACkB;CAClB,MAAM,OAAOC,0BAAQ,OAAO;CAE5B,MAAM,gBAAgB,KAAK,MAAM,KAAK;CAEtC,MAAMC,eAA0C,EAAE;CAIlD,MAAM,UAAU,MAAM,KAAK,QAAQ,QAAQ,wBAAwB;CAEnE,MAAM,iBACJ,SAAS,qBAAqB,QAAQ,oBAAoB,KAAK,KAAK;AAEtE,KAAI,gBAAgB;AAClB,eAAa,QAAQ,QAAQ;AAC7B,eAAa,cAAc,QAAQ;AACnC,eAAa,mBAAmB,IAAI,KAAK,QAAQ,kBAAkB;AACnE,eAAa,WAAW,QAAQ;AAChC,eAAa,eAAe,QAAQ;AACpC,eAAa,cAAc,QAAQ;;CAKrC,MAAM,cAAc,MAAM,KAAK,QAAQ,QAAQ,sBAAsB;AAGrE,KAAI,aAAa,eAAeC,wCAAsB;AACpD,eAAa,2BACX,YAAY;AAEd,eAAa,uBAAuB,YAAY;AAGhD,MAAI,eACF,cAAa,OAAO,YAAY;AAKlC,MACE,mBACC,YAAY,4BAA4B,EAAE,EAAE,SAAS,EAEtD,cAAa,kBAAkB,YAAY;;AAI/C,KAAI,OAAO,KAAK,aAAa,CAAC,SAAS,EACrC,MAAK,MAAM,IAAI,aAAa;AAG9B,uFAAwC,EAAE,eAAe,EAAE,OAAO;;;;;ACzDpE,MAAa,wBAAwB,WAA0B;CAC7D,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,MAAK,MAAM,WAAW,UAAU;AAC9B,MAAI,MAAM,qBAAqB,KAC7B,CAAK,KAAK,QAAQ,WAAW,wBAAwB;MAErD,CAAK,KAAK,QAAQ,QAAQ,yBAAyB;GACjD,cAAc,MAAM;GACpB,aAAa,MAAM;GACnB,UAAU,MAAM;GAChB,mBAAmB,MAAM,iBAAiB,SAAS;GACnD,aAAa,MAAM;GACnB,OAAO,MAAM;GACd,CAAC;AAGJ,EAAK,KAAK,QAAQ,QAAQ,uBAAuB;GAC/C,YAAYC;GACZ,iBAAiB,MAAM;GACvB,0BAA0B,MAAM;GAChC,MAAM,MAAM;GACZ,sBAAsB,MAAM;GAC7B,CAAC;GACF;;;;;ACzBJ,MAAa,wBAAwB,OAAO,WAA0B;AAEpE,OAAM,wBAAwB,OAAO;AAGrC,sBAAqB,OAAO;;;;;ACP9B,IAAa,gCAAb,cAAmDC,4BAAU;CAC3D,cAAc;AACZ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc;GACf,CAAC;;;;;;;;;;;;;;;;;;;ACsBN,MAAa,mBAAmB,OAAO,SAASC,oCAAkB,KAAK;CACrE,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,MAAK,OAAO,MACV,+DACA,KAAK,MAAM,KAAK,CAAC,WAClB;AAED,KAAI,KAAK,MAAM,KAAK,CAAC,eAAe,gBAClC,OAAM,IAAI,+BAA+B;AAG3C,MAAK,MAAM,IAAI,EAAE,YAAY,eAAe,CAAC;AAE7C,gBAAe,OAAO;AAEtB,kBAAiB,OAAO;CAExB,MAAM,+BAA+B,sBAAsB,OAAO;CAElE,MAAMC,8BACJ,6BAA6B,KAAK,YAAY;AAC5C,MAAI,CAAC,KAAK,MAAM,KAAK,CAAC,gBACpB,OAAM,qBAAqB,OAAO;GAEpC;;;;CAKJ,MAAMC,6BACJ,4BAA4B,KAAK,YAAY;AAC3C,MAAI,CAAC,KAAK,MAAM,KAAK,CAAC,YACpB,OAAM,oBAAoB,OAAO;GAEnC;;;;;;;;;;;;;CAcJ,MAAMC,oCACJ,4BAA4B,KAAK,YAAY;;;;;;;;AAQ3C,MAAIC,kCAAgB,OAAO,CACzB,OAAMC,8CAAY,OAAO,CAAC,MAAM,OAAO,UAAU;AAC/C,OAAI,MAAM,WAAW,KACnB;QAAI,OAAO,KACT,OAAM,OAAO,OAAO;SAGtB,OAAM;IAER;GAEJ;AAEJ,MAAK,UAAU,MAAM;EACnB,MAAMC;EACN,SAAS;EACV,CAAC;AAEF,MAAK,UAAU,MAAM;EACnB,MAAMC;EACN,SAAS;EACV,CAAC;AAEF,MAAK,UAAU,MAAM;EACnB,MAAMC;EACN,SAAS;EACV,CAAC;AAEF,MAAK,UAAU,MAAM;EACnB,MAAMC;EACN,SAAS;EACV,CAAC;AAEF,KAAI;AACF,QAAM,KAAK,UAAU,YAAY;AAEjC,OAAK,MAAM,IAAI,EAAE,YAAY,YAAY,CAAC;UACnC,OAAO;AACd,OAAK,MAAM,IAAI,EAAE,YAAY,UAAU,CAAC;AAExC,QAAM;;AAGR,KAAI,OAAO,KACT,CAAKC,oFAAsC,OAAO;;;;;;;;AClItD,MAAa,8BAA8B,OAAO,WAAW;;;;;;;ACS7D,MAAa,yBAAqC;;;;;;;CAOhD,IAAI,iBAAiB;CAErB,MAAMC,eAAkC,IAAIC,4BAAc;CAE1D,MAAM,oBAAoBC,+DAA6B;CAEvD,MAAM,0BAAU,IAAI,KAAgC;;;;CAKpD,MAAM,0BAA0B;AAK9B,MAAI,CAJe,MAAM,KAAK,QAAQ,QAAQ,CAAC,CAAC,OAC7C,EAAE,aAAa,WAAW,WAC5B,CAEgB;AAEjB,oBAAkB,SAAS;;CAG7B,MAAMC,SAA8B,EAAE,cAAM,cAAc;AACxD,MAAI,CAAC,eACH,OAAM,IAAIC,0DAAkB;AAI9B,EAAK,QAAQ,SAAS,CAAC,WAAY,iBAAiB,MAAO;AAE3D,UAAQ,IAAIC,QAAM;GAAE;GAAS,QAAQ;GAAW,CAAC;AAEjD,UACG,WAAW;AACV,WAAQ,IAAIA,QAAM;IAAE;IAAS,QAAQ;IAAY,CAAC;AAElD,gBAAa,KAAK,YAAYA,OAAK;AAEnC,sBAAmB;IACnB,CACD,OAAO,UAAU;AAChB,WAAQ,IAAIA,QAAM;IAAE;IAAS,QAAQ;IAAU,CAAC;AAEhD,gBAAa,KAAK,UAAUA,QAAM,MAAM;AAExC,qBAAkB,OAAO,MAAM;IAC/B;;CAGN,MAAMC,mBAA6C,kBAAkB;CAErE,MAAMC,cAA2C,eAC/C,QAAQ,IAAI,WAAW;AAEzB,QAAO;EACL;EACA,KAAK,aAAa,IAAI,KAAK,aAAa;EACxC,IAAI,aAAa,GAAG,KAAK,aAAa;EACtC;EACA;EACD;;;;;AC7EH,MAAa,2BAA2B,IAAIC,uBAAc;;;;ACA1D,IAAa,+BAAb,cAAkDC,4BAAU;CAC1D,YAAY,oBAA4B;AACtC,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,4DAA4D;GAC3E,CAAC;;;;;;;;;ACHN,MAAa,uBAA8B;AACzC,KAAI,uBAAuB,CACzB,cACE,QAAQ,OAAO,IAAI,6BAA6B,iBAAiB,CAAC;AAItE,QAAO,OAAO,MAAM,KAAK,OAAO;;;;;;;;ACPlC,MAAa,gCAAmD;AAC9D,KAAI,uBAAuB,CACzB,cACE,QAAQ,OACN,IAAI,6BAA6B,0BAA0B,CAC5D;AAGL,QAAO,OAAO,QAAQ;AAEpB,SAAO,SAAS,OAAO;;;;;;;;;ACV3B,MAAa,gCAA8C;AACzD,KAAI,uBAAuB,CACzB,cACE,QAAQ,OACN,IAAI,6BAA6B,0BAA0B,CAC5D;AAGL,QAAO,OAAO,QAAQ;AAEpB,SAAO,KAAK,KAAK,SAAS;;;;;;;;;;;;;ACC9B,MAAa,iCAAiD;CAC5D,eAAe,6DAAgC,QAAQ;CACvD,yEAA4C;CAC5C,WAAW,2DAA8B,QAAQ;CAClD;;;;ACMD,MAAa,6BAA6C;CACxD,MAAM,6BAAa,IAAI,KAAkC;AAEzD,QAAO,OAAO,EAAE,SAAS,UAAU,eAAe,QAAQ;EACxD,MAAM,oBAAoBC,+DAA6B;AAGvD,MAAI,CAAC,WAAW,IAAI,QAAQ,CAC1B,YAAW,IAAI,SAAS;GACtB,cAAc;GACd,cAAc,QAAQ,SAAS;GAC/B,oBAAoB,EAAE;GACtB,OAAO;GACR,CAAC;EAGJ,MAAM,eAAe,WAAW,IAAI,QAAQ;AAG5C,kCAAc,cAAc,uBAAuB,QAAQ,YAAY;AAEvE,eAAa,mBAAmB,KAAK,kBAAkB;AAEvD,MAAI,aAAa,MACf,cAAa,aAAa,MAAM;AAIlC,eAAa,eAAe;EAE5B,MAAM,qBAAqB,YAAY;AACrC,gBAAa,eAAe,aAAa,aAAa,KAAK,YAAY;AACrE,QAAI,CAAC,aAAa,aAChB;IAYF,MAAM,EAAE,iBAAiB;AAEzB,iBAAa,eAAe;IAE5B,MAAM,oBAAoB,aAAa;AAEvC,iBAAa,qBAAqB,EAAE;AAEpC,QAAI;AACF,WAAM,cAAc;AAEpB,uBAAkB,SAAS,wBACzBC,oBAAkB,SAAS,CAC5B;aACM,OAAO;AACd,uBAAkB,SAAS,wBACzBA,oBAAkB,OAAO,MAAM,CAChC;;KAEH;;AAGJ,MAAI,eAAe,EACjB,cAAa,QAAQ,WAAW,oBAAoB,aAAa;MAEjE,OAAM,oBAAoB;AAG5B,SAAO,kBAAkB;;;;;;ACnG7B,IAAa,sBAAb,cAAyCC,4BAAU;CACjD,YAAY,KAAa,OAAgB;AACvC,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,qDAAqD,IAAI,WAAW;GACnF,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC0BN,MAAa,yBACX,sBACuB;CAIvB,MAAM,8BAAc,IAAI,KAAsC;CAE9D,MAAM,qBAAqB,OAAU,aAAgB;AACnD,cAAY,SAAS,aAAa,SAAS,OAAO,SAAS,CAAC;;CAG9D,MAAM,aACJ,aACG;AACH,cAAY,IAAI,SAAS;AAEzB,eAAa,YAAY,SAAS;;CAGpC,MAAM,eACJ,aACG;AACH,cAAY,OAAO,SAAS;;CAO9B,IAAI,eAAeC,mBAAiB;CAEpC,MAAM,YAAY;CAElB,MAAM,OAAO,YAAwB;EACnC,MAAM,WAAW;AAEjB,SAAO,QAAQ,QAAQ,CAAC,SAAS,CAAC,KAAK,WAAW;AAChD,OAAI,UAAU,OACZ,OAAM,IAAI,oBAAoB,KAAK,MAAM;IAE3C;AAEF,iBAAe,OAAO,OAAO,EAAE,EAAE,cAAc,QAAQ;AAEvD,oBAAkB,cAAc,SAAS;;AAG3C,QAAO;EACL;EACA;EACA;EACA;EACA;EACD;;;;;;;;ACvFH,MAAa,uBAAuB;;;;;;;ACEpC,MAAa,yBAA2C;CACtD,cAAc;CACd,YAAY;CACZ,aAAa;CACb,UAAU;CACV,iBAAiB;CACjB,kBAAkB;CAClB,aAAa;CACb,OAAO;CACP,0BAA0B,EAAE;CAC5B,MAAM;CACN,sBAAsB,EAAE;CACzB;;;;;;;ACMD,MAAa,cAAc,WAA6C;CACtE,MAAM,aAAa,OAAO,YAAY,cAAc;CAEpD,MAAM,SACJ,OAAO,YAAY,UAAUC,qDAAa,EAAE,OAAO,OAAO,UAAU,CAAC;CAEvE,MAAM,UAAUC,sDAAc;EAC5B,QAAQ,WAAW,OAAO;EAC1B,gBACE,OAAO,YAAY,kBAAkBC,mEAA2B;EACnE,CAAC;CAEF,MAAM,QAAQ,OAAO,YAAY,SAAS,gBAAgB;CAE1D,MAAM,eACJ,OAAO,YAAY,gBAAgB,yBAAyB;CAE9D,MAAM,WAAW,OAAO,YAAY,YAAY,yBAAyB;CAEzE,MAAM,QAAQ,sBAAwC,gBAAgB;CAEtE,MAAM,iBAAiB,sBAAsB;CAE7C,MAAM,eAAe,oBAAoB;CAEzC,MAAM,YAAY,kBAAkB;CAEpC,MAAM,kBAAkB,uBAAuB;CAE/C,MAAM,UAAU,OAAO,YAAY,WAAW,yBAAyB;AAEvE,QAAO;EACL;EACA;EACA,eAAe,OAAO;EACtB;EACA,4BAAY,IAAI,KAAK;EACrB;EACA,eAAe,OAAO,YAAY,yBAAyB,EAAE;EAC7D;EACA;EACA,UAAU,OAAO;EACjB;EACA;EACA;EACA;EACA;EACA;EACA;EACD;;;;;;;;;;;;;;;;;;;ACpDH,MAAa,uBACX,WACkB;CAClB,MAAM,OAAO,WAAW,OAAO;CAE/B,MAAM,SAAS;EACb,IAAI,SAAS;AACX,UAAO;;EAET,IAAI,aAAa;AACf,UAAO,KAAK,MAAM,KAAK,CAAC;;EAE1B,IAAI,WAAW;AACb,UAAO,KAAK,MAAM,KAAK,CAAC;;EAE1B,IAAI,kBAAkB;AACpB,UAAO,KAAK,MAAM,KAAK,CAAC;;EAE1B,IAAI,mBAAmB;AACrB,UAAO,KAAK,MAAM,KAAK,CAAC;;EAE1B,IAAI,QAAQ;AACV,UAAO,KAAK,MAAM,KAAK,CAAC;;EAE1B,IAAI,OAAO;AACT,UAAO,KAAK,MAAM,KAAK,CAAC;;EAE3B;CAGD,MAAM,iBAAiB,OAAO,kBAAkB;CAGhD,MAAM,uBAAuB,uBAAuB,GAAG,QAAQ;AAE/D,MAAK,OAAO,MAAM,2CAA2C;AAE7D,KAAI,sBAAsB;AACxB,OAAK,OAAO,MAAM,+CAA+C;AACjE,EAAK,iBAAiB,OAAO;;AAG/B,oCAAiB,OAAO;AAExB,QAAO;;;;;AC9DT,IAAa,mCAAb,cAAsDC,4BAAU;CAC9D,cAAc;AACZ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cACE;GACH,CAAC;;;;;;ACTN,IAAa,mCAAb,cAAsDC,4BAAU;CAC9D,cAAc;AACZ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cACE;GACH,CAAC;;;;;;ACTN,IAAa,6BAAb,cAAgDC,4BAAU;CACxD,YAAY,OAAe;AACzB,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,0GAA0G;GACzH,CAAC;;;;;;ACDN,IAAa,+BAAb,cAAkDC,4BAAU;CAC1D,AAAgB;CAEhB,YAAY,EACV,qBACA,WACqC;AACrC,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cACE,WACA,wCAAwC,oBAAoB,6BAA6B;GAC5F,CAAC;AAEF,OAAK,sBAAsB;;;;;;AClB/B,IAAa,gCAAb,cAAmDC,4BAAU;CAC3D,YAAY,EACV,mBACA,eACA,iBACsC;EACtC,MAAM,QAAQ,yBAAyB,QAAQ,gBAAgB;AAE/D,QAAM;GACJ;GACA,MAAM;GACN,SAAS;GACT,cAAc,CACZ,wBAAwB,qBACxB,GAAI,iBAAiB,EAAE,CACxB;GACD,MAAM;GACN,cAAc;GACf,CAAC;;;;;;AChBN,IAAa,uBAAb,cAA0CC,4BAAU;CAClD,AAAS;CAET,YAAY,EACV,aACA,WACA,eACA,qBAC6B;EAC7B,MAAM,QAAQ,yBAAyB,QAAQ,gBAAgB;AAE/D,QAAM;GACJ;GACA,MAAM;GACN,SAAS;GACT,cAAc;IACZ,wBAAwB;IACxB,eAAe;IACf;IACA;IACD;GACD,MAAM;GACN,cAAc,4BAA4B,UAAU;GACrD,CAAC;AAEF,OAAK,cAAc;;;;;;AC3BvB,IAAa,mCAAb,cAAsDC,4BAAU;CAC9D,YAAY,EACV,mBACA,eACA,iBACyC;EACzC,MAAM,QAAQ,yBAAyB,QAAQ,gBAAgB;AAE/D,QAAM;GACJ;GACA,MAAM;GACN,SAAS;GACT,cAAc,CACZ,wBAAwB,qBACxB,GAAI,iBAAiB,EAAE,CACxB;GACD,MAAM;GACN,cAAc;GACf,CAAC;;;;;;ACxBN,IAAa,sBAAb,cAAyCC,4BAAU;CACjD,cAAc;AACZ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc;GACf,CAAC;;;;;;ACRN,IAAa,iCAAb,cAAoDC,4BAAU;CAC5D,cAAc;AACZ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc;GACf,CAAC;;;;;;ACRN,IAAa,uCAAb,cAA0DC,4BAAU;CAClE,YAAY,oBAA4B;AACtC,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,2DAA2D;GAC1E,CAAC;;;;;;ACRN,IAAa,yBAAb,cAA4CC,4BAAU;CACpD,cAAc;AACZ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc;GACf,CAAC;;;;;;ACFN,IAAa,2BAAb,cAA8CC,4BAAU;CACtD,YAAY,EACV,WACA,eACA,qBACiC;EACjC,MAAM,QAAQ,yBAAyB,QAAQ,gBAAgB;AAE/D,QAAM;GACJ;GACA,MAAM;GACN,SAAS;GACT,cAAc,CAAC,wBAAwB,oBAAoB;GAC3D,MAAM;GACN,cAAc,mDAAmD,UAAU;GAC5E,CAAC;;;;;;ACrBN,IAAa,4BAAb,cAA+CC,4BAAU;CACvD,YAAY,EACV,iBACsD,EAAE,EAAE;AAC1D,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,gBAAgB;GAC/B,CAAC;;;;;;ACNN,IAAa,oBAAb,cAAuCC,4BAAU;CAC/C,YAAY,EAAE,UAAmC;AAC/C,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,yBAAyB,OAAO;GAC/C,CAAC;;;;;;ACZN,IAAa,oCAAb,cAAuDC,4BAAU;CAC/D,YAAY,SAAiB;AAC3B,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,kBAAkB,QAAQ;GACzC,CAAC;;;;;;ACRN,IAAa,gCAAb,cAAmDC,4BAAU;CAC3D,AAAgB;CAChB,AAAgB;CAEhB,YAAY,QAA8D;EACxE,MAAM,qBAAqB,OAAO,kBAC9B,eAAe,OAAO,gBAAgB,KACtC;AACJ,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,8DAA8D,mBAAmB,0BAA0B,OAAO,gBAAgB;GACjJ,CAAC;AAEF,OAAK,kBAAkB,OAAO;AAC9B,OAAK,kBAAkB,OAAO;;;;;;ACZlC,IAAa,uCAAb,cAA0DC,4BAAU;CAClE,YAAY,EACV,YACA,qBAC6C;AAC7C,QAAM;GACJ,OAAO;GACP,MAAM;GACN,SAAS;GACT,MAAM;GACN,cAAc,mBAAmB,kBAAkB,iBAAiB,WAAW;GAChF,CAAC;;;;;;;;;;;;;;;;ACEN,MAAa,wBAAwB,OACnC,EAAE,aAAa,qBAAkD,EAAE,EACnE,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAG5B,MAAM,WAAW,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,mBAAmB;EAClD,eAAe,KAAK;EACpB,2BAA2B;GACzB,KAAK;GACL;GACD;EACF,CAAC;AAEF,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,QAAO;;;;;;;;;;;;AC1BT,MAAa,gBAAgB,OAC3B,EAAE,aACF,SAASC,oCAAkB,KACT;CAClB,MAAM,OAAOC,0BAAQ,OAAO;AAG5B,OAFkBC,kCAAgB,EAAE,iBAAiB,MAAM,EAAE,OAAO,CAEpD,cAAc;EAC5B,0BAA0B,EACxB,WACD;EACD,eAAe,KAAK;EACrB,CAAC;;;;;;;;;;;;;;ACVJ,MAAa,cAAc,OAAO,SAASC,oCAAkB,KAAK;CAChE,MAAM,OAAOC,0BAAQ,OAAO;AAO5B,SAJiB,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,gBAAgB,EAC/C,eAAe,KAAK,eACrB,CAAC,EAEc;;;;;ACflB,MAAa,gCAAgC,OAC3C,WACoD;CACpD,MAAM,OAAOC,0BAAQ,OAAO;AAS5B,QAJE,MAHgBC,kCAAgB,EAAE,EAAE,OAAO,CAG3B,8BAA8B,EAC5C,eAAe,KAAK,eACrB,CAAC;;;;;ACJN,MAAa,wBAAwB,OACnC,EAAE,cAAc,kBAChB,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAiB5B,QAdiB,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,gBAAgB;EAC/C,eAAe,KAAK;EACpB,wBAAwB;GACtB,GAAG;GACH;GACA,UAAU;IACR,GAAG,aAAa;IAChB,gBAAgB,aAAa,SAAS;IACvC;GACF;EAGF,CAAC;;;;;;;;;;;;;;;;;ACLJ,MAAa,kBAAkB,OAC7B,EAAE,mBAA0C,EAAE,EAC9C,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,KAAI,CAAC,KAAK,QAAQ,aAAa,CAC7B,OAAM,IAAI,wBAAwB;CAGpC,MAAM,UAAU,MAAM,8BAA8B,OAAO;CAM3D,MAAM,WAAW,MAAM,sBACrB;EAAE;EAAgB,cALC,MAAM,KAAK,QAAQ,SAAS,EAC/C,aAAa,SACd,CAAC;EAGgC,EAChC,OACD;AAED,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,QAAO;;;;;ACtCT,MAAa,wCAAwC,OACnD,EAAE,sBAAmE,EAAE,EACvE,WACmD;CACnD,MAAM,OAAOC,0BAAQ,OAAO;AAU5B,QALE,MAHgBC,kCAAgB,EAAE,EAAE,OAAO,CAG3B,sCAAsC;EACpD,eAAe,KAAK;EACD;EACpB,CAAC;;;;;ACRN,MAAa,sBAAsB,OACjC,EAAE,gBAAgB,kBAClB,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAe5B,QAZiB,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,kBAAkB;EACjD,eAAe,KAAK;EACpB,oBAAoB;GAClB,GAAG;GACH;GACA,UAAU;IACR,GAAG,eAAe;IAClB,gBAAgB,eAAe,SAAS;IACzC;GACF;EACF,CAAC;;;;;;;;;;;;;;;;ACRJ,MAAa,oBAAoB,OAC/B,EAAE,sBAA+C,EAAE,EACnD,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAC5B,KAAI,CAAC,KAAK,QAAQ,aAAa,CAC7B,OAAM,IAAI,wBAAwB;CAQpC,MAAMC,mBAA0D,EAC9D,GANc,MAAM,sCACpB,EAAE,mBAAmB,EACrB,OACD,EAIA;CAMD,MAAM,WAAW,MAAM,oBAAoB,EAAE,gBAJtB,MAAM,KAAK,QAAQ,aAAa,EACrD,aAAa,kBACd,CAAC,EAE2D,EAAE,OAAO;AAEtE,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,QAAO;;;;;;;;;;;ACtCT,MAAa,yBACX,SAASC,oCAAkB,KACP;CACpB,MAAM,EAAE,SAAS;AAEjB,iCAAc,MAAM,4BAA4B;AAQhD,SALE,KAAK,oBAAoB,QACtB,eACC,WAAW,WAAWC,2DAAgC,MACzD,IAAI,EAAE,EAEgB,KAAK,gBAAgB;EAC5C,WAAW,WAAW,kBAAkB;EACxC,aAAa,WAAW,oBAAoB;EAC5C,QAAQ,WAAW,eAAe,EAAE;EACpC,QAAQ,WAAW,sBAAsB,EAAE;EAC3C,UAAU,WAAW;EACrB,UAAU,WAAW,iBAAiB;EACtC,sBAAsB,WAAW;EAClC,EAAE;;;;;ACjCL,MAAa,mCAAmC,QAAgB;CAC9D,MAAM,YAAY,IAAI,IAAI,IAAI;AAE9B,WAAU,aAAa,OAAO,oBAAoB;AAClD,WAAU,aAAa,OAAO,mBAAmB;AAEjD,QAAO,UAAU,UAAU;;;;;;ACA7B,MAAa,gCAAgCC,+DAAuB;CAClE,KAAK;CACL,QAAQC,SAAE,OAAO;EACf,cAAcA,SAAE,SAASA,SAAE,QAAQ,CAAC;EACpC,UAAUA,SAAE,KAAKC,wCAAa;EAC9B,OAAOD,SAAE,QAAQ;EAClB,CAAC;CACH,CAAC;;;;ACbF,MAAa,gBAAgB,QAAgB;CAE3C,MAAM,OADU,IAAI,aAAa,CACZ,OAAO,IAAI;AAChC,QAAO,OAAO,OAAO,OAAO,WAAW,KAAK;;;;;;;;;;;ACG9C,MAAa,mBAAmB,QAAqB;CACnD,MAAME,cAAwB,EAAE;AAChC,KAAI,WAAW,IAAI,CAAC,SAAS,SAAS,YAAY,KAAK,KAAK,CAAC;AAG7D,QAAO,KAAK,OAAO,aAAa,MAAM,MAAM,YAAY,CAAC,CACtD,QAAQ,MAAM,GAAG,CACjB,QAAQ,OAAO,IAAI,CACnB,QAAQ,OAAO,IAAI;;;;;ACVxB,MAAM,sBAAsB;AAC5B,MAAM,sBAAsB;;AAG5B,MAAa,qBAAqB,UAAoB,YAAsB;AAC1E,iCAAc,SAAS,UAAU,sBAAsB;AACvD,iCAAc,SAAS,UAAU,0BAA0B;AAC3D,iCAAc,SAAS,aAAa,yBAAyB;CAE7D,MAAM,eAAe,SAAS;AAE9B,SAAQ,aAAa,IAAI,aAAa,SAAS,SAAS;AACxD,SAAQ,aAAa,IAAI,iBAAiB,OAAO;AACjD,SAAQ,aAAa,IAAI,gBAAgB,SAAS,YAAY;AAE9D,KAAI,iBAAiBC,wCAAa,QAAQ;AACxC,UAAQ,aAAa,OAAO,YAAY;AACxC,UAAQ,aAAa,IAAI,cAAc,SAAS,SAAS;;AAG3D,KAAI,iBAAiBA,wCAAa,OAChC,SAAQ,aAAa,IAAI,eAAe,UAAU;AAIpD,KAAI,iBAAiBA,wCAAa,OAAO;AACvC,UAAQ,aAAa,IAAI,iBAAiB,oBAAoB;AAC9D,UAAQ,aAAa,IAAI,iBAAiB,oBAAoB;;AAGhE,KAAI,SAAS,OACX,SAAQ,aAAa,IAAI,SAAS,SAAS,OAAO;AAGpD,QAAO;;;;;;ACjCT,MAAa,mBAAmB,aAA4B;AAC1D,iCAAc,SAAS,UAAU,0BAA0B;CAE3D,MAAM,eAAe,SAAS;AAE9B,KAAI,iBAAiBC,wCAAa,UAAU;AAC1C,kCACE,SAAS,kBACT,uCACD;AACD,SAAO,IAAI,IAAI,SAAS,iBAAiB;;AAG3C,iCAAc,SAAS,aAAa,0BAA0B;AAE9D,KAAI,iBAAiBA,wCAAa,SAAS;AACzC,kCACE,SAAS,cACT,4CACD;EACD,MAAM,eAAe,SAAS,YAAY,QACxC,oBACA,SAAS,aACV;AACD,SAAO,IAAI,IAAI,aAAa;;AAG9B,QAAO,IAAI,IAAI,SAAS,YAAY;;;;;ACtBtC,MAAM,yBAAyB,CAAC,WAAW,SAAS;;AAcpD,MAAa,gBAAgB,OAE3B,MAGA,aACsB;CACtB,MAAM,EAAE,oBAAoB,KAAK,MAAM,KAAK;AAG5C,iCAAc,iBAAiB,6BAA6B;AAC5D,iCAAc,gBAAgB,WAAW,8BAA8B;CAEvE,MAAM,iBAAiB,gBAAgB,UAAU,MAC9C,MAAM,EAAE,aAAa,SACvB;AAED,iCAAc,gBAAgB,mBAAmB,SAAS,gBAAgB;CAI1E,MAAM,oBAAoB,kBAAkB,gBADvB,gBAAgB,eAAe,CACqB;CAGzE,MAAM,YAAY,uBAAuB,SAAS,SAAS;CAC3D,MAAM,QAAQC,+BAAa,GAAG;CAC9B,MAAM,eAAeA,+BAAa,GAAG;AAErC,mBAAkB,aAAa,IAAI,SAAS,MAAM;AAClD,mBAAkB,aAAa,IAAI,iBAAiB,OAAO;AAE3D,KAAI,WAAW;EACb,MAAM,SAAS,MAAM,aAAa,aAAa;AAE/C,oBAAkB,aAAa,IAC7B,kBACA,gBAAgB,OAAO,CACxB;AACD,oBAAkB,aAAa,IAAI,yBAAyB,OAAO;;AAGrE,QAAO;EACL,cAAc,YAAY,eAAe;EACzC;EACA,KAAK;EACN;;;;;;;;;;;;;;;;;;ACzCH,MAAa,yBAAyB,OACpC,EAAE,UAAU,eACZ,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,OAAM,KAAK,UAAU,YAAY;CAEjC,MAAM,eAAe;CAErB,MAAM,EAAE,KAAK,OAAO,iBAAiB,MAAM,cAAc,MAAM,aAAa;AAE5E,OAAM,UAAU,SAAS;EACvB,eAAe,KAAK;EACpB,sBAAsB;GACpB,aAAa,gCAAgC,YAAY;GACzD;GACD;EACD;EACD,CAAC;AAEF,OAAM,KAAK,QAAQ,QAAQ,+BAA+B;EACxD;EACA,UAAU;EACV;EACD,CAAC;AAEF,OAAM,KAAK,SAAS,IAAI,UAAU,CAAC;;;;;;;;;;;;;;;;;AC3BrC,MAAa,+BAA+B,OAC1C,EAAE,OACF,SAASC,oCAAkB,KACF;CACzB,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,OAAM,KAAK,UAAU,YAAY;CAEjC,MAAM,oBAAoB,IAAI,aAAa,IAAI,oBAAoB;CACnE,MAAM,mBAAmB,IAAI,aAAa,IAAI,mBAAmB;AAEjE,KAAI,CAAC,kBACH,OAAM,IAAI,2BAA2B,oBAAoB;AAG3D,KAAI,CAAC,iBACH,OAAM,IAAI,2BAA2B,mBAAmB;CAG1D,MAAM,4BAA4B,MAAM,KAAK,QAAQ,QACnD,8BACD;AAED,KAAI,CAAC,0BACH,OAAM,IAAI,kCAAkC;AAG9C,KAAI,0BAA0B,UAAU,kBACtC,OAAM,IAAI,kCAAkC;CAG9C,MAAM,EAAE,UAAU,iBAAiB;AAEnC,OAAM,KAAK,QAAQ,WAAW,8BAA8B;CAE5D,IAAIC;AAGJ,KAAI,OAAO,KACT,YAAW,MAAM,UAAU,YAAY;EACrC,eAAe,KAAK;EACpB,cAAc;GACZ,MAAM;GACN;GACA,OAAO;GACR;EACD,cAAc;EACf,CAAC;KAGF,YAAW,MAAM,UAAU,YAAY;EACrC,eAAe,KAAK;EACpB,cAAc;GACZ,cAAcC,4DAAoB,OAAO;GACzC,MAAM;GACN;GACA,OAAO;GACR;EACD,cAAc;EACf,CAAC;AAGJ,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,QAAO,SAAS;;;;;;;;;;;;;;;AC5ElB,MAAa,sBAAsB,OACjC,EAAE,OACF,SAASC,oCAAkB,KACN;CACrB,MAAM,OAAOC,0BAAQ,OAAO;CAE5B,MAAM,oBAAoB,IAAI,aAAa,IAAI,oBAAoB;CACnE,MAAM,mBAAmB,IAAI,aAAa,IAAI,mBAAmB;AAEjE,KAAI,CAAC,qBAAqB,CAAC,iBACzB,QAAO;AAIT,OAAM,KAAK,UAAU,YAAY;CAEjC,MAAM,4BAA4B,MAAM,KAAK,QAAQ,QACnD,8BACD;AAED,KACE,CAAC,6BACD,0BAA0B,UAAU,kBAEpC,QAAO;AAGT,QAAO;;;;;;;;;;;ACnCT,MAAa,2BACX,SAASC,oCAAkB,KACF;CAGzB,MAAM,mCAFiBC,gEAAkB,OAAO,CAG7C,QAEG,kBAEA,QAAQ,cAAc,eAAe,CACxC,CACA,MAAM,GAAG,MAAM,EAAE,eAAe,SAAS,GAAG,EAAE,eAAe,SAAS,CAAC;AAE1E,KAAI,iCAAiC,WAAW,EAC9C,QAAO;CAGT,MAAM,CAAC,wBAAwB;AAE/B,QAAO;;;;;;;;;;;;ACXT,MAAa,sBAAsB,OACjC,EAAE,wBACF,SAASC,oCAAkB,KACC;CAC5B,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;CAK7C,MAAM,WADuB,wBAAwB,OAAO,EACrB,sBAAsB,QAC3D,YACA,GACD;CAED,MAAM,WAAW,MAAM,UAAU,aAAa;EAC5C,eAAe,KAAK;EACpB,qBAAqB;GACnB;GACA,UAAU,YAAY;GACvB;EACF,CAAC;AAEF,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,QAAO;;;;;;;;;;;;;;;ACrBT,MAAa,wBAAwB,OACnC,EAAE,kBACF,SAASC,oCAAkB,KACoC;CAC/D,MAAM,OAAOC,0BAAQ,OAAO;AAQ5B,SALiB,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,8BAA8B;EAC7D,eAAe,KAAK;EACpB,kCAAkC;EACnC,CAAC,EAEc;;;;;;;;;;;;;;ACblB,MAAa,uCACX,EAAE,YACF,SAASC,oCAAkB,KACV;CACjB,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,KAAI,OAAO,WAAW,YACpB,OAAM,IAAIC,0CACR,qEACD;CAGH,MAAM,sBAAsB,UAAwB;AAClD,MAAI,MAAM,WAAW,2BACnB;AAGF,OAAK,OAAO,MACV,yEACA,EAAE,OAAO,CACV;AAED,MAAI;GACF,MAAM,+BAA+B,KAAK,MAAM,MAAM,KAAK;AAE3D,OAAI,CAAC,6BAA6B,WAAW,WAAW,cAAc,CACpE;AAGF,YAAS;IACP,MAAM,6BAA6B;IACnC,WAAW,6BAA6B;IACzC,CAAC;WACK,OAAO;AACd,QAAK,OAAO,MACV,0FACA,EACE,OACD,CACF;;;AAIL,QAAO,iBAAiB,WAAW,mBAAmB;AAEtD,cAAa;AACX,SAAO,oBAAoB,WAAW,mBAAmB;;;;;;;;;;;;;;;;;;;;;ACpC7D,MAAa,gDACX,EAAE,iBACF,SAASC,oCAAkB,KAC8B;AAIzD,KAAI,kBAAkB,2BACpB,OAAM,IAAIC,4CAAkB,2BAA2B,gBAAgB;CAGzE,MAAM,EAAE,SAAS;AAEjB,iCAAc,MAAM,4BAA4B;CAEhD,MAAMC,4BACJ,EAAE;CAEJ,MAAM,0BAA0B,KAAK,oBAAoB,MACtD,eAAe,WAAW,WAAWC,2DAAgC,MACvE;AAED,KAAI,CAAC,KAAK,MAER,2BAA0B,KAAK;EAC7B,WAAW;EACX,OAAO;EACR,CAAC;UACO,CAAC,wBAEV,2BAA0B,KAAK;EAC7B,MAAM,KAAK;EACX,WAAW;EACX,OAAO;EACR,CAAC;CAGJ,MAAM,0BAA0B,KAAK,oBAAoB,MACtD,eACC,WAAW,WAAWA,2DAAgC,YACzD;CAED,MAAM,kCACJ,yBAAyB,cACzB,wBAAwB,8BACtB,IAAI,KAAK,KAAK,KAAK,GAAG,OAAU,KAAK,KAAK,IAAK;AAEnD,KAAI,CAAC,KAAK,YAER,2BAA0B,KAAK;EAC7B,WAAW;EACX,OAAO;EACR,CAAC;UACO,CAAC,wBAEV,2BAA0B,KAAK;EAC7B,MAAM,KAAK;EACX,WAAW;EACX,OAAO;EACR,CAAC;UACO,CAAC,gCAEV,2BAA0B,KAAK;EAC7B,MAAM,KAAK;EACX,WAAW;EACX,OAAO;EACR,CAAC;AAGJ,QAAO;;;;;AC9FT,MAAa,iDACX,WACY;CACZ,MAAM,EAAE,SAAS;AAEjB,iCAAc,MAAM,4BAA4B;CAEhD,MAAM,4BACJ,6CACE,EAAE,eAAe,4BAA4B,EAC7C,OACD;AAMH,KAJiC,0BAA0B,MACxD,UAAU,MAAM,UAAU,QAC5B,CAGC,OAAM,IAAI,6BAA6B;EACrC,qBAAqB;EACrB,SACE;EACH,CAAC;CAGJ,MAAM,iCAAiC,0BAA0B,MAC9D,UAAU,MAAM,UAAU,cAC5B;AAED,KACE,kCACA,+BAA+B,cAAc,uBAE7C,OAAM,IAAI,6BAA6B;EACrC,qBAAqB;EACrB,SACE;EACH,CAAC;AAKJ,KACE,kCACA,+BAA+B,cAAc,uBAE7C,OAAM,IAAI,6BAA6B;EACrC,qBAAqB;EACrB,SACE;EACH,CAAC;AAGJ,QAAO;;;;;;;;;;;;;ACzCT,MAAa,4BAA4B,OACvC,aACA,SAASC,oCAAkB,KACc;CACzC,MAAM,OAAO,8CAA8C,OAAO;CAElE,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,iBAAiB,MAAM,EAAE,OAAO;CAEpE,MAAM,EAAE,WAAW,GAAG,oBAAoB;CAE1C,MAAM,gBAAgB,MAAM,UAAU,0BAA0B;EAC9D,kCAAkC;GAChC,GAAG;GAGH,gBACE,YAAY,mBACX,YAAY,WAAW,KAAK,OAAO,KAAK;GAC3C,eACE,YAAY;GACf;EACD,eAAe,KAAK;EACrB,CAAC;AAEF,KAAI,CAAC,aAAa,CAAC,cAAc,YAC/B,QAAO;AAGT,QAAO;EACL,GAAG;EACH,aAAa;GACX,GAAG,cAAc;GACjB,KAAK,GAAG,cAAc,YAAY,IAAI;GACvC;EACF;;;;;;;;;;;;ACvCH,MAAa,oBAAoB,OAC/B,cACA,SAASC,oCAAkB,KACkB;CAC7C,MAAM,OAAOC,0BAAQ,OAAO;AAQ5B,QALiB,MAFCC,kCAAgB,EAAE,iBAAiB,MAAM,EAAE,OAAO,CAEnC,6BAA6B;EAC5D,gCAAgC;EAChC,eAAe,KAAK;EACrB,CAAC;;;;;;;;;;;;ACRJ,MAAa,4BAA4B,OACvC,eACA,SAASC,oCAAkB,KACc;CACzC,MAAM,OAAOC,0BAAQ,OAAO;AAY5B,QATiB,MAFCC,kCAAgB,EAAE,iBAAiB,MAAM,EAAE,OAAO,CAEnC,0BAA0B;EACzD,kCAAkC;GAChC,GAAG;GAEH,OAAO,cAAc;GACtB;EACD,eAAe,KAAK;EACrB,CAAC;;;;;;;;;;;ACtBJ,MAAa,2BAA2B,OAAO,SAASC,oCAAkB,KAAK;AAG7E,OAFaC,0BAAQ,OAAO,CAEjB,UAAU,YAAY;;;;;;;;ACTnC,MAAM,8BACJ;;;;;;;;;;;AAYF,MAAa,4BAAoC;AAC/C,KAAI,OAAO,YAAY,eAAe,QAAQ,KAAK;EACjD,MAAM,SACJ,QAAQ,IAAI,uBACZ,QAAQ,IAAI;AAEd,MAAI,OACF,QAAO;;AAIX,QAAO;;;;;;;;AClBT,MAAM,mBAAmB;;;;;;;AAQzB,MAAa,mBAAmB,OAC9B,WAC8B;CAC9B,MAAM,aAAa,IAAI,iBAAiB;CACxC,MAAM,YAAY,iBAAiB,WAAW,OAAO,EAAE,iBAAiB;CACxE,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,KAAI;EACF,MAAM,WAAW,MAAM,KAAK,MAAM,qBAAqB,EAAE,EACvD,QAAQ,WAAW,QACpB,CAAC;AAEF,MAAI,CAAC,SAAS,GACZ,OAAM,IAAIC,2BACR,gCAAgC,SAAS,OAAO,GAAG,SAAS,cAC5D,2BACA,SAAS,OACV;AAKH,SAFc,MAAM,SAAS,MAAM;WAG3B;AACR,eAAa,UAAU;;;;;;;;;ACjC3B,MAAa,kCAAkCC,+DAAuB;CACpE,KAAK;CACL,QAAQC,SAAE,OAAO;EACf,QAAQA,SAAE,OAAOA,SAAE,QAAQ,EAAEA,SAAE,KAAK,CAAC;EACrC,SAASA,SAAE,OAAOA,SAAE,QAAQ,EAAEA,SAAE,KAAK,CAAC;EACvC,CAAC;CACH,CAAC;;;;;;;ACJF,MAAM,cAAc;;;;AAKpB,MAAM,iBAAiB;;;;;;;;;;;;AAavB,MAAa,wBAAwB,OACnC,WAC8B;CAC9B,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,MAAK,OAAO,MAAM,kDAAkD;AAGpE,KAAI;EACF,MAAM,aAAa,MAAM,YAAY;GACnC,OAAO;GACP,IAAI,YAAY,iBAAiB,OAAO;GACxC,YAAY;GACb,CAAC;AAEF,QAAM,KAAK,QAAQ,QAAQ,iCAAiC,WAAW;AAEvE,OAAK,OAAO,MACV,oEACD;AAED,SAAO;UACA,OAAO;AACd,OAAK,OAAO,MACV,qEACA,MACD;EAGD,MAAM,mBAAmB,MAAM,KAAK,QAAQ,QAC1C,gCACD;AAED,MAAI,kBAAkB;AACpB,QAAK,OAAO,MAAM,mDAAmD;AAErE,UAAO;;AAIT,OAAK,OAAO,MACV,0EACD;AAED,QAAM;;;;;;;;;;AClEV,MAAa,uBAAuB;CAClC;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACD;;;;;;;;AASD,MAAa,sBACX,WACA,WACY;AAEZ,KAAI,qBAAqB,SAAS,UAAU,CAC1C,QAAO;AAIT,KAAI,CAAC,OAAO,iBAAiB,CAAC,OAAO,cAAc,KAAK,SAAS,UAAU,CACzE,QAAO;CAIT,MAAM,oBACJ,OAAO,kBAAkB,OAAO,eAAe,SAAS;CAC1D,MAAM,iBAAiB,QACrB,OAAO,QAAQ,aACb,OAAO,QAAQ,SACf,OAAO,QAAQ,UACf,OAAO,QAAQ,UAClB;CACD,MAAM,kBAAkB,QACtB,OAAO,SAAS,YACd,OAAO,SAAS,UAChB,OAAO,SAAS,aAChB,OAAO,SAAS,WAChB,OAAO,SAAS,YAChB,OAAO,SAAS,UACnB;AAED,KAAI,qBAAqB,CAAC,kBAAkB,CAAC,gBAC3C,QAAO;AAGT,QAAO;;;;;;;;;;;AClDT,MAAa,gBAAgB,EAAE,eAC7B,GAAGC,4CAA0B,GAAG;;;;;;;ACFlC,MAAa,kBAAkB,EAC7B,YACqD;CACrD,MAAM,WAAW,MAAM,OAAO,YAAY;AAE1C,QAAO;EACL,KAAK,MAAM;EACX,MAAM,MAAM;EACZ,cAAc,MAAM,OAAO;EAC3B,WAAW,WAAW,aAAa,EAAE,UAAU,CAAC,GAAG;EACpD;;;;;;;;ACdH,MAAMC,8BAAqD;CACzD,MAAM;CACN,OAAO;CACP,SAAS;CACT,KAAK;CACL,QAAQ;CACR,SAAS;CACT,KAAK;CACL,MAAM;CACN,KAAK;CACL,OAAO;CACP,UAAU;CACV,KAAK;CACL,KAAK;CACL,MAAM;CACP;;;;;AAUD,MAAM,sBAAsB,EAC1B,sBACsC;CACtC,MAAM,aAAa,gBAAgB,QAAQ,IAAI;AAE/C,KAAI,eAAe,GACjB,QAAO;AAGT,QAAO,gBAAgB,UAAU,GAAG,WAAW;;;;;;AAOjD,MAAMC,4BAAsE;CAC1E;EAAE,OAAO;EAAO,SAAS;EAAO;CAChC;EAAE,OAAO;EAAO,SAAS;EAAU;CACnC;EAAE,OAAO;EAAO,SAAS;EAAO;CAChC;EAAE,OAAO;EAAO,SAAS;EAAW;CACpC;EAAE,OAAO;EAAS,SAAS;EAAS;CACpC;EAAE,OAAO;EAAS,SAAS;EAAY;CACvC;EAAE,OAAO;EAAO,SAAS;EAAO;CAChC;EAAE,OAAO;EAAS,SAAS;EAAS;CACpC;EAAE,OAAO;EAAU,SAAS;EAAU;CACtC;EAAE,OAAO;EAAQ,SAAS;EAAQ;CAClC;EAAE,OAAO;EAAQ,SAAS;EAAQ;CAClC;EAAE,OAAO;EAAQ,SAAS;EAAQ;CAClC;EAAE,OAAO;EAAO,SAAS;EAAO;CAChC;EAAE,OAAO;EAAS,SAAS;EAAS;CACpC;EAAE,OAAO;EAAW,SAAS;EAAW;CACzC;;;;;;;AAYD,MAAM,yBAAyB,EAC7B,gBACoD;CACpD,MAAM,WAAW,UAAU,aAAa;AAExC,MAAK,MAAM,EAAE,OAAO,aAAa,0BAC/B,KAAI,SAAS,SAAS,QAAQ,CAC5B,QAAO;;;;;;;;;;;AAqBb,MAAa,4BAA4B,EACvC,QACA,gBAC2C;AAE3C,KAAI,OAAO,kBAAkB,OAAO,eAAe,SAAS,GAAG;EAC7D,MAAM,gBAAgB,OAAO,eAAe,GAAG,OAAO,aAAa;AAEnE,MAAI,iBAAiB,4BAA4B,eAC/C,QAAO,4BAA4B;;AAKvC,KAAI,OAAO,UAAU,OAAO,OAAO,SAAS,GAAG;EAC7C,MAAM,aAAa,OAAO,OAAO;EACjC,MAAM,cAAc,mBAAmB,EAAE,iBAAiB,YAAY,CAAC;AAEvE,MAAI;AACF,UAAOC,sDAAoC,YAAY;UACjD;;AAMV,KAAI,WAAW;EACb,MAAM,eAAe,sBAAsB,EAAE,WAAW,CAAC;AAEzD,MAAI,aACF,QAAO;;AAKX,QAAO;;;;;;;;AC9HT,MAAa,mBAAmB,EAC9B,QACA,gBACuD;CACvD,MAAM,WAAW,OAAO,OAAO,YAAY;CAE3C,MAAM,YAAY,OAAO,QAAQ;CACjC,MAAM,QAAQ,OAAO,QAAQ;AAE7B,QAAO;EACL,OAAO,yBAAyB;GAAE;GAAQ;GAAW,CAAC;EACtD,WAAW;GACT,QAAQ,OAAO,QAAQ;GACvB,WAAW,OAAO,QAAQ;GAC3B;EACD,eAAe;GACb,YAAY,YACR,iDAAiD,cACjD;GACJ,QAAQ,QAAQ,8BAA8B,UAAU;GACzD;EACD,SAAS,OAAO;EAChB,MAAM,OAAO;EACb,cAAc,OAAO,OAAO;EAC5B,WAAW,WAAW,aAAa,EAAE,UAAU,CAAC,GAAG;EACpD;;;;;;;;;ACpBH,MAAa,uBAAuB,EAClC,iBACqD;CACrD,MAAMC,SAAoD,EAAE;AAE5D,MAAK,MAAM,CAAC,UAAU,UAAU,OAAO,QAAQ,WAAW,OAAO,CAC/D,QAAO,YAAY,eAAe,EAAE,OAAO,CAAC;CAG9C,MAAMC,UAAsD,EAAE;AAE9D,MAAK,MAAM,CAAC,WAAW,WAAW,OAAO,QAAQ,WAAW,QAAQ,EAAE;AACpE,MAAI,mBAAmB,WAAW,OAAO,CACvC;AAGF,UAAQ,aAAa,gBAAgB;GAAE;GAAQ;GAAW,CAAC;;AAG7D,QAAO;EAAE;EAAQ;EAAS;;;;;;;;;;;;;;;ACtB5B,MAAa,0BAA0B,OACrC,SAASC,oCAAkB,KACO;AAGlC,QAAO,oBAAoB,EAAE,YAFV,MAAM,sBAAsB,OAAO,EAEb,CAAC;;;;;;;;;;;;ACN5C,MAAa,kCAAkC,EAC7C,oCAC6D;CAC7D,MAAM,YAAY,8BAA8B,aAAa;CAG7D,MAAM,gBAAiB,OAAO,KAAKC,kCAAgB,CAChD,KAAK,UAAU,MAAM,aAAa,CAAC,CACnC,MAAM,GAAG,MAAM,EAAE,SAAS,EAAE,OAAO;AAEtC,MAAK,MAAM,UAAU,cACnB,KAAI,UAAU,SAAS,OAAO,CAC5B,QAAO,OAAO,aAAa;;;;;;;;;;;;;;;;ACLjC,MAAa,mDAAmD,OAC9D,EAAE,qBACF,SAASC,oCAAkB,KACyB;CACpD,MAAM,EAAE,kCACNC,qEAAuB,kBAAkB;CAE3C,MAAM,QAAQ,+BAA+B,EAC3C,+BACD,CAAC;AAEF,KAAI,CAAC,MACH;CAIF,IAAI,qBAAqB,8BAA8B,aAAa;AAEpE,KAAI,mBAAmB,SAAS,MAAM,aAAa,CAAC,CAClD,sBAAqB,mBAAmB,MAAM,GAAG,CAAC,MAAM,OAAO;AAIjE,sBAAqB,mBAAmB,QAAQ,WAAW,GAAG;CAE9D,MAAM,uBAAuB,MAAM,wBAAwB,OAAO;AAElE,MAAK,MAAM,CAAC,WAAW,WAAW,OAAO,QACvC,qBAAqB,QACtB,EAAE;AACD,MAAI,OAAO,UAAU,MACnB;EAGF,MAAM,iBAAiB,UAAU,aAAa;EAC9C,MAAM,kBAAkB,OAAO,KAAK,aAAa,CAAC,QAAQ,QAAQ,GAAG;AAErE,MACE,eAAe,SAAS,mBAAmB,IAC3C,gBAAgB,SAAS,mBAAmB,CAE5C,QAAO;;;;;;;;;;;;;;;;;ACxCb,MAAa,aAAa,OACxB,EAAE,cACF,SAASC,oCAAkB,KACc;CACzC,MAAM,OAAOC,0BAAQ,OAAO;CAG5B,MAAM,WAAW,MAFCC,kCAAgB,EAAE,iBAAiB,MAAM,EAAE,OAAO,CAEnC,WAAW;EAC1C,eAAe,KAAK;EACpB;EACD,CAAC;AAEF,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,KAAI,SAAS,kBACX,QAAO;EACL,OAAO,SAAS,kBAAkB;EAClC,kBAAkB,SAAS,kBAAkB;EAC9C;AAGH,KAAI,SAAS,gBACX,QAAO;EACL,gBAAgB,SAAS,gBAAgB;EACzC,kBAAkB,SAAS,gBAAgB;EAC3C,aAAa,SAAS,gBAAgB;EACtC,kBAAkB,SAAS,gBAAgB;EAC5C;;;;;;;;;;;;;;ACnCL,MAAa,2BAA2B,OAAO,SAASC,oCAAkB,KAAK;AAC7E,QAAO,WACL,EACE,YAAY,EACV,8BAA8BC,wDAA6B,UAC5D,EACF,EACD,OACD;;;;;;;;;;;;;;;ACCH,MAAa,8BAA8B,OACzC,EAAE,MAAM,yBACR,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,KAAI;EACF,MAAM,WAAW,MAAM,UAAU,gBAAgB;GAC/C,eAAe,KAAK;GACpB,kCAAkC;IAChC;IACA,gBAAgB;IACjB;GACF,CAAC;AAEF,6EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,0DACE;GACE,MAAM,EAAE,UAAU,SAAS,UAAU;GACrC,OAAO;GACR,EACD,OACD;AAED,SAAO;UACA,OAAO;AACd,0DACE;GACE,MAAM,EAAE,OAAO;GACf,OAAO;GACR,EACD,OACD;AACD,QAAM;;;;;;AC/CV,MAAa,kCAAkC,OAC7C,EAAE,sBAA6D,EAAE,EACjE,WACmD;CACnD,MAAM,OAAOC,0BAAQ,OAAO;AAU5B,QALE,MAHgBC,kCAAgB,EAAE,EAAE,OAAO,CAG3B,gCAAgC;EAC9C,eAAe,KAAK;EACpB;EACD,CAAC;;;;;ACRN,MAAa,4BAA4B,OACvC,EAAE,gBAAgB,kBAClB,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAe5B,QAZiB,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,6BAA6B;EAC5D,eAAe,KAAK;EACpB,oBAAoB;GAClB,GAAG;GACH;GACA,UAAU;IACR,GAAG,eAAe;IAClB,gBAAgB,eAAe,SAAS;IACzC;GACF;EACF,CAAC;;;;;;;;;;;;;;;;;ACHJ,MAAa,yBAAyB,OACpC,EAAE,gBAAgB,sBAAoD,EAAE,EACxE,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAE5B,KAAI;AACF,MAAI,CAAC,KAAK,QAAQ,aAAa,CAC7B,OAAM,IAAI,wBAAwB;EAGpC,MAAM,UAAU,MAAM,gCACpB,EAAE,mBAAmB,EACrB,OACD;EACD,MAAM,mBAAmB,QAAQ,kBAAkB,KAAK,gBAAgB;GACtE,GAAG;GACH,MAAM;GACP,EAAE;AAEH,MAAI,CAAC,kBAAkB,OACrB,OAAM,IAAI,gCAAgC;EAI5C,MAAMC,mBAA0D;GAC9D,GAAG;GACH;GACD;EAMD,MAAM,WAAW,MAAM,0BACrB;GAAE,gBALmB,MAAM,KAAK,QAAQ,aAAa,EACrD,aAAa,kBACd,CAAC;GAGkB;GAAgB,EAClC,OACD;AAED,6EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,0DACE;GACE,MAAM,EAAE,UAAU,SAAS,UAAU;GACrC,OAAO;GACR,EACD,OACD;AAED,SAAO;UACA,OAAO;AACd,0DACE;GACE,MAAM,EAAE,OAAO;GACf,OAAO;GACR,EACD,OACD;AACD,QAAM;;;;;;;;;;;;;;;;;;AC7DV,MAAa,4BAA4B,OACvC,EAAE,UAAU,MAAM,yBAClB,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,KAAI;EACF,MAAM,WAAW,MAAM,UAAU,kBAAkB;GACjD,eAAe,KAAK;GACpB,8BAA8B;IAC5B;IACA,gBAAgB;IAChB,IAAI;IACL;GACF,CAAC;AAEF,6EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,0DACE;GACE,MAAM;IAAE;IAAU,UAAU,SAAS;IAAU;GAC/C,OAAO;GACR,EACD,OACD;AAED,SAAO;UACA,OAAO;AACd,0DACE;GACE,MAAM;IAAE;IAAU;IAAO;GACzB,OAAO;GACR,EACD,OACD;AACD,QAAM;;;;;;;;;;;;;;;ACjDV,MAAa,4BAA4B,OACvC,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;AAG5B,QAFkBC,kCAAgB,EAAE,EAAE,OAAO,CAE5B,uBAAuB,EACtC,eAAe,KAAK,eACrB,CAAC;;;;;;;;;;;;;;;;ACAJ,MAAa,kBAAkB,OAC7B,EAAE,UAAU,gBACZ,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,iCAAc,UAAU,uBAAuB;AAC/C,iCAAc,cAAc,2BAA2B;AAEvD,QAAO,UAAU,gBAAgB;EAC/B,eAAe,KAAK;EACpB,aAAa;EACb,eAAe;EAChB,CAAC;;;;;;;;;;;;;;ACtBJ,MAAa,gBAAgB,OAAO,SAASC,oCAAkB,KAAK;CAClE,MAAM,OAAOC,0BAAQ,OAAO;CAG5B,MAAM,EAAE,YAAY,MAFFC,kCAAgB,EAAE,EAAE,OAAO,CAET,kBAAkB,EACpD,eAAe,KAAK,eACrB,CAAC;AAEF,QAAO;;;;;;;;;;;;;;;;ACNT,MAAa,sBAAsB,OAAO,SAASC,oCAAkB,KAAK;CACxE,MAAM,OAAOC,0BAAQ,OAAO;AAG5B,QAFkBC,kCAAgB,EAAE,EAAE,OAAO,CAE5B,iBAAiB,EAChC,eAAe,KAAK,eACrB,CAAC;;;;;;;;;;;;;;ACPJ,MAAa,wCACX,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAO,OAAO;AAEpB,iCAAc,MAAM,qBAAqB;AAEzC,QACE,KAAK,iCAAiCC,wDAA6B;;;;;;;;;;;;;;ACVvE,MAAa,wBAAwB,SAASC,oCAAkB,KAAK;CACnE,MAAM,OAAO,OAAO;AAEpB,iCAAc,MAAM,qBAAqB;AAEzC,QAAO,QAAQ,KAAK,OAAO,SAAS,yBAAyB,CAAC;;;;;;;;;;;;;;;ACHhE,MAAa,wBAAwB,OAAO,SAASC,oCAAkB,KAAK;CAC1E,MAAM,OAAOC,0BAAQ,OAAO;AAG5B,QAFkBC,kCAAgB,EAAE,EAAE,OAAO,CAE5B,sBAAsB,EACrC,eAAe,KAAK,eACrB,CAAC;;;;;;;;;;;;;;;ACDJ,MAAa,sBAAsB,OACjC,EAAE,YACF,SAASC,oCAAkB,KACxB;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,iCAAc,UAAU,uBAAuB;AAG/C,QAAO,UAAU,oBAAoB;EACnC,eAAe,KAAK;EACpB,aAAa;EACd,CAAC;;;;;;;;;;;;;;ACbJ,MAAa,eAAe,OAC1B,EAAE,SACF,SAASC,oCAAkB,KACE;CAC7B,MAAM,OAAOC,0BAAQ,OAAO;CAG5B,MAAM,EAAE,qBAAqB,MAFXC,kCAAgB,EAAE,EAAE,OAAO,CAEA,wBAAwB;EACnE,gCAAgC;GAC9B,cAAcC,4DAAoB,OAAO;GACzC;GACD;EACD,eAAe,KAAK;EACrB,CAAC;AAEF,QAAO;EAAE;EAAO;EAAkB;;;;;ACkNpC,MAAaC,qBAAuC;CAClD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACD,IAAI;EACF,MAAM;EACN,MAAM;EACP;CACF;;;;;;;;;;;;ACpnCD,MAAa,aAAa,OACxB,EAAE,gBAAgB,eAClB,SAASC,oCAAkB,KACE;CAC7B,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;CAE7C,MAAM,mBAAmB,mBAAmB,gBAAgB;CAE5D,MAAM,EAAE,qBAAqB,MAAM,UAAU,sBAAsB;EACjE,eAAe,KAAK;EACpB,8BAA8B;GAC5B,cAAcC,4DAAoB,OAAO;GACzC;GACA;GACA;GACD;EACF,CAAC;AAEF,QAAO;EAAE;EAAgB;EAAkB;EAAa;EAAkB;;;;;ACnC5E,MAAa,yBAAyB,OACpC,EAAE,iBAAiB,qBACnB,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;CAE7C,MAAM,gBAAgB;EACpB;EACA,kBAAkB,gBAAgB;EACnC;AAED,KAAI,gBAAgB,MAClB,QAAO,UAAU,4BAA4B;EAC3C,gCAAgC;EAChC,eAAe,KAAK;EACrB,CAAC;AAGJ,QAAO,UAAU,0BAA0B;EACzC,eAAe,KAAK;EACpB,8BAA8B;EAC/B,CAAC;;;;;ACtBJ,MAAa,yBAAyB,OACpC,EAAE,iBAAiB,qBACnB,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;CAE7C,MAAM,gBAAgB;EACpB;EACA,kBAAkB,gBAAgB;EACnC;AAED,KAAI,gBAAgB,MAClB,QAAO,UAAU,wBAAwB;EACvC,gCAAgC;EAChC,eAAe,KAAK;EACrB,CAAC;AAGJ,QAAO,UAAU,sBAAsB;EACrC,eAAe,KAAK;EACpB,8BAA8B;EAC/B,CAAC;;;;;;;;;;;;;;;;ACHJ,MAAa,YAAY,OACvB,EAAE,iBAAiB,qBACnB,SAASC,oCAAkB,KACC;CAK5B,MAAMC,WAA2B,OAJP,OAAO,OAC7B,yBACA,wBAGF;EACE;EACA;EACD,EACD,OACD;AAED,4EAA6B,EAAE,UAAU,EAAE,OAAO;AAElD,QAAO;;;;;;;;;;;;;;AC5BT,MAAa,aAAa,OACxB,SAASC,oCAAkB,KACT;CAClB,MAAM,OAAOC,0BAAQ,OAAO;AAG5B,OAFkBC,kCAAgB,EAAE,iBAAiB,MAAM,EAAE,OAAO,CAEpD,eAAe,EAC7B,eAAe,KAAK,eACrB,CAAC;AAEF,OAAM,OAAO,OAAO;;;;;;;;;;;;;;ACRtB,MAAa,cAAc,OACzB,SAASC,oCAAkB,KACN;CACrB,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;CAE7C,MAAM,gBAAgB,EAAE,GAAG,KAAK,MAAM,KAAK,EAAE;CAE7C,MAAM,OAAO,MAAM,UAAU,qBAAqB,EAChD,eAAe,KAAK,eACrB,CAAC;AAEF,MAAK,MAAM,IAAI,EAAE,MAAM,CAAC;AAExB,uFAAwC,EAAE,eAAe,EAAE,OAAO;AAElE,QAAO;;;;;;;;;;;;;;;;;;;ACTT,MAAa,yCAAyC,OACpD,EAAE,iBACF,SAASC,oCAAkB,KACxB;CAQH,MAAM,EAAE,cAAc,MAPCC,iFACrB,EACE,eACD,EACD,OACD,CAE0C,uBAAuB;AAElE,KAAI,UAAU,SAAS,KAAK,CAAC,UAAU,SAAS,cAAc,QAAQ,CACpE,OAAM,IAAI,8BAA8B;EACtC,iBAAiB,cAAc;EAC/B,iBAAiB,UAAU;EAC5B,CAAC;;;;;;;;;;;;;;;;;;;;;ACnBN,SAAgB,kCAGd,gBACA,YAEkC;AAClC,KAAI,eAAe,gBAAgB,OACjC,OAAM,IAAI,qCAAqC;EACjC;EACZ,mBAAmB,eAAe;EACnC,CAAC;;;;;AC7BN,MAAa,6CACX,qBAC4B;AAC5B,QAAO,iBAAiB,UAAU,QAC/B,YACC,CAAC,CAAC,QAAQ,WAAW,CAAC,CAAC,QAAQ,KAClC;;;;;;;;;;;;;;;;;;;ACsBH,MAAa,4BAA4B,OACvC,EACE,mBACA,6BAA6B,QAE/B,SAASC,oCAAkB,KACA;CAC3B,MAAM,iBAAiBC,qEACrB,EACE,mBACD,EACD,OACD;AAED,mCAAkC,gBAAgB,UAAU;CAE5D,MAAM,EAAE,cAAc,MAAM,eAAe,SAAS;CAEpD,MAAM,mBAAmBC,gEAAkB,OAAO,CAAC,KAChD,EAAE,cAAc,QAClB;CAED,MAAM,cAAc,WAAW,SAAS,UAAU,GAAG,UAAU;;;;;;AAO/D,KAAI,CAAC,YACH,OAAM,IAAI,qBAAqB;CAGjC,MAAMC,gBAA+B;EACnC,SAAS;EACT,oBAAoB,0CAA0C,EAC5D,WACD,CAAC;EACF,OAAO,eAAe;EACtB,IAAIC,oEAAsB;GACxB,SAAS;GACT,OAAO,eAAe;GACtB;GACD,CAAC;EACF,gBAAgB;EAChB,sBAAsB;EACtB;EACD;AAED,KAAI,iBAAiB,SAAS,YAAY,CACxC,QAAO;AAGT,KAAI,4BAA4B;AAC9B,sEACE,EAAE,kCAAkC,CAAC,cAAc,EAAE,EACrD,OACD;AAED,+EAA+B,OAAO;AAMtC,EAAKC,oDAAY,EAAE,eAAe,EAAE,OAAO;;AAG7C,QAAO;;;;;AChGT,MAAa,mCAAmC,OAAO,EACrD,qBAGI;AAKJ,KAF2C;EAAC;EAAO;EAAO;EAAM,CAElC,SAAS,eAAe,MAAM,CAC1D;CAGF,MAAM,EAAE,cAAc,MAAM,eAAe,oBAAoB;AAE/D,KAAI,UACF,QAAO;AAIT,KAAI,eAAe,UAAU,MAC3B,QAAO;;;;;ACTX,MAAa,mBAAmB,OAC9B,EAAE,iBACF,WACG;CACH,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;CAC7C,MAAM,SAAS,KAAK,UAAU;AAE9B,iCAAc,QAAQ,qBAAqB;CAE3C,MAAM,MAAM,IAAI,IAAI,OAAO;CAE3B,MAAM,EAAE,UAAU,MAAM,UAAU,SAAS,EACzC,eAAe,KAAK,eACrB,CAAC;AAEF,iCAAc,OAAO,sBAAsB;CAE3C,MAAM,iBAAiBC,iFACrB,EACE,eACD,EACD,OACD;CAED,MAAM,YAAYC,qEAA6B,OAAO;AActD,QAZsB,MAAMC,4DAAoB;EAC9C,SAAS,cAAc;EACvB,gBAAgBC,kCAAgB,eAAe,OAAO;EACtD,SAAS,MAAM,iCAAiC,EAAE,gBAAgB,CAAC;EACnE,QAAQ,IAAI;EACZ,2BAAU,IAAI,MAAM,EAAC,aAAa;EAClC;EACA,WAAW,KAAK;EAChB;EACA,KAAK,IAAI,UAAU;EACpB,CAAC;;;;;;;;;;;;;;;AChCJ,MAAa,8BAA8B,OACzC,EAAE,iBACF,SAASC,oCAAkB,KAIvB;CACJ,MAAM,iBAAiBC,iFACrB,EACE,eACD,EACD,OACD;AAED,mCAAkC,gBAAgB,cAAc;CAEhE,MAAM,gBAAgB,MAAM,iBAAiB,EAAE,eAAe,EAAE,OAAO;CAEvE,MAAM,EAAE,cAAc,MAAM,eAAe,YAAY;EACrD,SAAS;EACT;EACD,CAAC;AAEF,QAAO;EAAE;EAAe;EAAW;;;;;ACxCrC,MAAa,iBAAiB,MAAc,OAAe,UACzDC,+DAAiB,MAAM,MAAM,KAAKA,+DAAiB,OAAO,MAAM;;;;ACclE,MAAa,yCAAyC,OACpD,EAAE,eAAe,cACjB,WAC2B;AAC3B,KAAI,cAAc,qBAChB,OAAM,IAAI,kCAAkC,cAAc,QAAQ;CAGpE,MAAM,iBAAiBC,iFACrB,EACE,eACD,EACD,OACD;CAED,MAAM,EAAE,eAAe,cAAc,MAAM,4BACzC,EACE,eACD,EACD,OACD;CAED,MAAM,WAAW,MAAMC,wEACrB;EACE,oBAAoB,cAAc;EAClC,OAAO,cAAc;EACrB;EACA;EACA;EACA,eAAe,cAAc;EAC7B,mBAAmB,eAAe,SAAS;EAC3C,oBAAoB,eAAe;EACpC,EACD,OACD;CAED,MAAM,2BAA2B,SAAS,MAAM,oBAAoB,MACjE,uBACC,cACE,mBAAmB,WAAW,IAC9B,cAAc,SACd,cAAc,MACf,CACJ;AAED,iCACE,0BACA,uFAAuF,cAAc,QAAQ,YAAY,cAAc,QACxI;AAED,wFACE,EACE,cAAc,GACX,yBAAyB,KAAK,eAAe,KAC/C,EACF,EACD,OACD;;;;;AAMD,4EAA6B,EAAE,UAAU,EAAE,OAAO;;;;AAKlD,uEACE,EAAE,yBAAyB,eAAe,EAC1C,OACD;CAED,MAAM,wBAAwBC,gEAAkB,OAAO,CAAC,MAAM,EAAE,cAC9D,cAAc,SAAS,cAAc,SAAS,cAAc,MAAM,CACnE;AAED,iCACE,uBACA,iCAAiC,cAAc,QAAQ,YAAY,cAAc,MAAM,2BAA2B,yBAAyB,KAC5I;AAED,QAAO;;;;;;;;;;;;;;;;;AChFT,MAAa,sBAAsB,OACjC,EAAE,iBACF,SAASC,oCAAkB,KACA;AAC3B,QAAO,uCACL;EACE,YAAY;EACZ;EACD,EACD,OACD;;;;;;;;;;;;;;;;ACRH,MAAa,qCAAqC,OAChD,EAAE,qBACF,SAASC,oCAAkB,KACxB;CACH,MAAM,gBAAgB,MAAM,0BAC1B;EAAE,4BAA4B;EAAO;EAAmB,EACxD,OACD;AAED,OAAM,oBAAoB,EAAE,eAAe,EAAE,OAAO;AAMpD,CAAKC,oDAAY;EAAE,UAAUC,wCAAa;EAAS;EAAe,EAAE,OAAO;AAE3E,QAAO;;;;;;;;;;;;;;AC1BT,MAAa,mCACX,SAASC,oCAAkB,KACF;AASzB,QAR2BC,iEAAmB,OAAO,CAIF,QAAQ,mBACzD,QAAQ,eAAe,QAAQ,CAChC,CAE8B,KAAK,oBAAoB;EACtD,OAAO,eAAe;EACtB,UAAU,eAAe;EACzB,KAAK,eAAe;EACpB,UAAU,eAAe;EACzB,oBAAoB,eAAe;EACpC,EAAE;;;;;;;;;;;;;;;ACbL,MAAa,yBACX,EAAE,qBACF,SAASC,oCAAkB,KACxB;AAGH,QAFuBC,qEAAuB,EAAE,mBAAmB,EAAE,OAAO,CAEtD,uBAAuB;;;;;ACb/C,MAAa,8CACX,EAAE,sBACF,SAASC,oCAAkB,KACG;CAC9B,MAAM,gCAAgCC,oFACpC,EAAE,eAAe,oBAAoB,EACrC,OACD;AAED,iCACE,+BAA+B,aAC/B,+BACD;AAED,QAAOC,gEAAkB,OAAO,CAAC,MAC9B,kBACC,cAAc,yBACd,8BAA8B,YACjC;;;;;ACrBH,MAAa,iCAAiC,EAC5C,MACA,oBACyC;AACzC,QAAO,cAAc,oBAAoB,MACtC,YAAY,QAAQ,SAAS,KAC/B,EAAE;;;;;;;;;;;;ACEL,MAAa,8BACX,EAAE,qBACF,SAASC,oCAAkB,KACJ;CACvB,MAAM,EAAE,OAAO,UAAU,KAAK,UAAU,uBACtCC,qEAAuB,EAAE,mBAAmB,EAAE,OAAO;AAEvD,QAAO;EAAE;EAAO;EAAU;EAAK;EAAU;EAAoB;;;;;;;;;;;ACV/D,MAAa,2BAA2B,EACtC,oBACmC;AACnC,QAAO,cAAc,yBAAyB;;;;;;;;;;;;;;;;;ACQhD,MAAa,aAAa,OACxB,EAAE,aAAa,iBACf,SAASC,oCAAkB,KACxB;CACH,MAAM,iBAAiBC,qEACrB,EAAE,mBAAmB,cAAc,mBAAmB,EACtD,OACD;AAED,KAAI,eAAe,eAAe,OAChC,OAAM,IAAI,8BAA8B;EACtC,eAAe,CACb,mBAAmB,cAAc,kBAAkB,kCACpD;EACD,eAAe;EACf,mBAAmB,cAAc;EAClC,CAAC;AAGJ,QAAO,eAAe,WAAW,EAAE,aAAa,CAAC;;;;;;;;;;;;;;;;ACtBnD,MAAa,uBAAuB,OAClC,EAAE,iBACF,SAASC,oCAAkB,KACxB;CACH,MAAM,iBAAiBC,iFACrB,EAAE,eAAe,EACjB,OACD;CAED,MAAM,EAAE,cAAc,MAAM,eAAe,oBAAoB;AAS/D,QAAO,EAAE,aAPYC,wDAAgB,OAAO,CAEL,MACpC,SACC,KAAK,cAAc,aAAa,KAAK,UAAU,eAAe,MACjE,EAEwC;;;;;;;;;;;;ACvB3C,MAAa,sBACX,EAAE,iBACF,SAASC,oCAAkB,KACxB;AAMH,QALuBC,iFACrB,EAAE,eAAe,EACjB,OACD,CAEqB,oBAAoB;;;;;;;;;;;;;;;ACL5C,MAAa,aAAa,OACxB,EAAE,iBACF,SAASC,oCAAkB,KACa;CACxC,MAAM,iBAAiBC,iFACrB,EACE,eACD,EACD,OACD;CAED,MAAM,EAAE,cAAc,MAAM,eAAe,oBAAoB;AAO/D,QALwBC,wEACtB;EAAE,OAAO,eAAe;EAAO;EAAW,EAC1C,OACD,CAEsB,WAAW,EAAE,SAAS,cAAc,SAAS,CAAC;;;;;;;;;;;;;;;;;ACdvE,MAAa,uBAAuB,OAClC,EAAE,SAAS,OAAO,aAClB,SAASC,oCAAkB,KACa;CACxC,MAAM,kBAAkBC,wEACtB;EAAE;EAAO;EAAW,EACpB,OACD;AAED,iCACE,iBACA,8BAA8B,MAAM,kBAAkB,UAAU,+DACjE;AAED,QAAO,gBAAgB,WAAW,EAAE,SAAS,CAAC;;;;;;;;;;;;;;;;;;;ACHhD,MAAa,wBAAwB,OACnC,QACA,SAASC,oCAAkB,KACa;CACxC,MAAM,OAAOC,0BAAQ,OAAO;AAW5B,QARiB,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,sBAAsB;EACrD,SAAS,OAAO;EAEhB,WAAW,OAAO;EAClB,eAAe,KAAK;EACpB,WAAW,OAAO;EACnB,CAAC;;;;;;;;;;;;;;;AC7BJ,MAAa,wCACX,EAAE,iBACF,SAASC,oCAAkB,KACxB;AAMH,QALuBC,qEACrB,EAAE,mBAAmB,cAAc,mBAAmB,EACtD,OACD,CAEqB,wBAAwB;;;;;;;;;;;;;;;;;ACLhD,MAAa,sBAAsB,OACjC,EAAE,WAAW,iBACb,SAASC,oCAAkB,KACxB;CACH,MAAM,iBAAiBC,qEACrB,EAAE,mBAAmB,cAAc,mBAAmB,EACtD,OACD;AAED,KAAI,eAAe,wBAAwB,OACzC,OAAM,IAAI,iCAAiC;EACzC,eAAe,CACb,mBAAmB,cAAc,kBAAkB,2CACpD;EACD,eAAe;EACf,mBAAmB,cAAc;EAClC,CAAC;AAGJ,QAAO,eAAe,oBAAoB,EAAE,WAAW,CAAC;;;;;;;;AC1B1D,MAAa,6BAA6B,OACxC,EAAE,iBACF,SAASC,oCAAkB,KACT;CAClB,MAAM,OAAOC,0BAAQ,OAAO;AAI5B,KAFoC,wBAAwB,OAAO,EAElC,OAAO,cAAc,GACpD;AAGF,KAAI,cAAc,qBAUhB,4EAA6B,EAAE,UAPd,MAFCC,kCAAgB,EAAE,EAAE,OAAO,CAEZ,iBAAiB;EAChD,eAAe,KAAK;EACpB,4BAA4B,EAC1B,UAAU,cAAc,sBACzB;EACF,CAAC,EAEuC,EAAE,OAAO;KAOlD,qEACE,EACE,kCAAkC,CAPT;EAC3B,GAAG;EACH,gCAAgB,IAAI,MAAM;EAC3B,CAI2D,EACzD,EACD,OACD;;;;;;;;;;;AClCL,MAAa,0BAA0B,OACrC,EAAE,iBACF,WACkB;AAClB,KAAI;AAMF,QALuBC,iFACrB,EAAE,eAAe,EACjB,OACD,CAEoB,0BAA0B,EAAE,eAAe,CAAC;UAC1D,OAAO;AAGd,MAAI,iBAAiBC,yEACnB;AAGF,QAAM;;;;;;;;;;;;;;;;;ACVV,MAAa,sBAAsB,OACjC,EAAE,iBACF,SAASC,oCAAkB,KACT;CAClB,MAAM,OAAOC,0BAAQ,OAAO;CAC5B,MAAM,YAAYC,kCAAgB,EAAE,EAAE,OAAO;AAE7C,OAAM,wBAAwB,EAAE,eAAe,EAAE,OAAO;AAExD,KAAI,CAAC,cAAc,sBAAsB;AACvC,wEACE,EAAE,yBAAyB,eAAe,EAC1C,OACD;AAED;;AAUF,4EAA6B,EAAE,UAPd,MAAM,UAAU,aAAa;EAC5C,eAAe,KAAK;EACpB,qBAAqB,EACnB,UAAU,cAAc,sBACzB;EACF,CAAC,EAEuC,EAAE,OAAO;;;;;;;;;;;;;;;;AC3BpD,MAAa,cAAc,OACzB,EAAE,eAAe,WACjB,SAASC,oCAAkB,KACQ;CACnC,MAAM,iBAAiBC,iFACrB,EACE,eACD,EACD,OACD;AAED,mCAAkC,gBAAgB,cAAc;CAEhE,MAAM,EAAE,cAAc,MAAM,eAAe,YAAY;EACrD;EACA;EACD,CAAC;AAEF,QAAO,EAAE,WAAW;;;;;;;;;;;;;;;ACrBtB,MAAa,wBAAwB,OACnC,EAAE,qBACF,SAASC,oCAAkB,KACxB;AAMH,QAAO,uCACL;EACE,YAAY;EACZ,eARkB,MAAM,0BAC1B;GAAE,4BAA4B;GAAO;GAAmB,EACxD,OACD;EAME,EACD,OACD;;;;;;;;;;;;;;;;ACbH,MAAa,+BACX,EAAE,SAAS,SACX,SAASC,oCAAkB,KACxB;AAGH,QAFuBC,gEAAkB,OAAO,CAE1B,MACnB,kBACC,cAAc,YAAY,WAAW,cAAc,UAAU,MAChE;;;;;;;;;;;;;;;ACNH,MAAa,0BAGX,EAAE,UAAU,OAAO,qBACnB,SAASC,oCAAkB,KACxB;CACH,MAAM,iBAAiBC,qEAAuB,EAAE,mBAAmB,EAAE,OAAO;AAE5E,mCAAkC,gBAAgB,SAAS;AAI3D,gBAAe,OAAO,IAAI,OAAO,SAAgB;;;;;;;;;;;;;;ACbnD,MAAa,yBAGX,EAAE,UAAU,OAAO,qBACnB,SAASC,oCAAkB,KACxB;CACH,MAAM,iBAAiBC,qEAAuB,EAAE,mBAAmB,EAAE,OAAO;AAE5E,mCAAkC,gBAAgB,SAAS;AAI3D,gBAAe,OAAO,GAAG,OAAO,SAAgB;AAEhD,cAAa;AAEX,iBAAe,OAAO,IAAI,OAAO,SAAgB;;;;;;;;;AChCrD,MAAM,kBACJ;AAEF,MAAM,kBACJ;AAGF,MAAa,YAAY,2BAAoC;AAC3D,KAAI,OAAO,WAAW,eAAe,OAAO,cAAc,YACxD,QAAO;AAGT,QACE,gBAAgB,KAAK,UAAU,UAAU,IACzC,gBAAgB,KAAK,UAAU,UAAU,UAAU,GAAG,EAAE,CAAC,IACzD,OAAO,uBAAuB,IAC9B,UAAU;;AAId,MAAa,iBACX,OAAO,WAAW,eAAe,OAAO,cAAc,cAClD,QACA,aAAa,KAAK,UAAU,UAAU;;;;;;AAY5C,MAAa,UAAU,2BAAoC;AACzD,KAAI,OAAO,WAAW,eAAe,OAAO,cAAc,YACxD,QAAO;CAGT,MAAM,iBAAiB,0BAA0B,UAAU;AAE3D,QACE,OAAO,KAAK,UAAU,UAAU,IAC/B,MAAM,KAAK,UAAU,UAAU,IAAI,mBAAmB;;;;;mEC1CtCC,wBAAaC,0BAAe"}