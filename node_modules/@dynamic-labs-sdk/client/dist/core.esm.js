import { C as getDefaultClient, D as getCore, E as BaseError, O as name, S as DYNAMIC_SDK_API_VERSION, T as ClientNotFoundError, _ as isCookieEnabled, c as createApiClient, g as getBuffer, i as DYNAMIC_ICONIC_SPRITE_URL, k as version, m as APIError, o as getChainFromVerifiedCredentialChain, s as CHAINS_INFO_MAP, v as assertDefined, y as ValueMustBeDefinedError } from "./constants-hy8OYHwt.esm.js";
import { D as InvalidStorageSet, E as createStorage, O as createLocalStorageAdapter, T as createStorageKeySchema, _ as NoNetworkProvidersError, a as updateWalletProviderKeysForVerifiedCredentials, b as createDeferredPromise, c as createSignInMessageStatement, d as createVisit, f as hasExtension, i as getNetworksData, k as subscribeWithSelector, l as formatSignInMessage, m as consumeCaptchaToken, n as getNetworkProviders, o as verifyMessageSignatureOwnership, p as setCaptchaToken, r as getNetworkProviderBuilderRegistry, s as removeUnverifiedWalletAccount, t as getNetworkProviderFromNetworkId, u as setUnverifiedWalletAccounts, v as createLogger, x as FETCH_PROJECT_SETTINGS_TRACKER_KEY, y as CannotTrackError } from "./getNetworkProviderFromNetworkId-vL_E8aHC.esm.js";
import { C as InvalidWalletProviderKeyError, S as splitWalletProviderKey, b as formatWalletAccountId, c as getWalletProviders, f as getWalletProviderFromWalletAccount, g as NoWalletProviderFoundError, h as createRuntimeServiceAccessKey, m as getWalletProviderRegistry, n as getWalletProviderByKey, p as WalletProviderPriority, r as updateAuthFromVerifyResponse, t as getVerifiedCredentialForWalletAccount, u as emitWalletAccountsChangedEvent, v as formatWalletProviderKey, w as emitEvent, y as normalizeWalletNameWithChain } from "./getVerifiedCredentialForWalletAccount-c_lbXWMG.esm.js";
import "./isMfaRequiredForAction-BgevGq0s.esm.js";
import { n as consumeMfaTokenIfRequiredForAction, t as getSignedSessionId } from "./getSignedSessionId-BhFfSHeA.esm.js";
import { t as filterDuplicates } from "./filterDuplicates-C1MD6p_l.esm.js";
import { assertPackageVersion } from "@dynamic-labs-sdk/assert-package-version";
import * as z from "zod/mini";
import EventEmitter$1 from "eventemitter3";

//#region src/errors/ClientsDoNotMatchError.ts
var ClientsDoNotMatchError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "clients_do_not_match_error",
			docsUrl: null,
			name: "ClientsDoNotMatchError",
			shortMessage: "Clients do not match"
		});
	}
};

//#endregion
//#region src/errors/MethodNotImplementedError.ts
var MethodNotImplementedError = class extends BaseError {
	constructor(methodName) {
		super({
			cause: null,
			code: "method_not_implemented_error",
			docsUrl: null,
			name: "MethodNotImplementedError",
			shortMessage: `This method is not implemented: ${methodName}`
		});
	}
};

//#endregion
//#region src/errors/MultipleClientsFoundError.ts
var MultipleClientsFoundError = class extends BaseError {
	constructor() {
		super({
			cause: null,
			code: "multiple_clients_found_error",
			docsUrl: null,
			name: "MultipleClientsFoundError",
			shortMessage: "Multiple Dynamic clients have been initialized. Please provide the intended client for this action explicitly"
		});
	}
};

//#endregion
//#region src/modules/extension/registerExtension/registerExtension.ts
/**
* Registers an extension to the client.
*
* Other extensions can be aware of which extensions are present,
* and allows creating dependencies between extensions.
*
* @param client - The client instance.
* @param extensionKey - The key of the extension to register.
* @returns The client instance.
*/
const registerExtension = ({ extensionKey }, client) => {
	getCore(client).extensions.add(extensionKey);
};

//#endregion
//#region src/modules/initializeClient/waitForProjectSettings/waitForProjectSettings.ts
const waitForProjectSettings = async (client) => {
	const projectSettingsTracker = getCore(client).initTrack.getTracker(FETCH_PROJECT_SETTINGS_TRACKER_KEY);
	assertDefined(projectSettingsTracker, "Project settings tracker not found");
	await projectSettingsTracker.promise;
	assertDefined(client.projectSettings, "Project settings still not available after awaiting its tracker");
	return client.projectSettings;
};

//#endregion
//#region src/modules/wallets/networks/createBaseNetworkProvider/createBaseNetworkProvider.ts
const createBaseNetworkProvider = (chain, networkData) => ({
	blockExplorerUrls: networkData.blockExplorerUrls,
	chain,
	displayName: networkData.displayName,
	iconUrl: networkData.iconUrl,
	id: `${chain}-${networkData.networkId}`,
	nativeCurrency: networkData.nativeCurrency,
	networkId: networkData.networkId,
	rpcUrls: networkData.rpcUrls,
	testnet: networkData.testnet
});

//#endregion
//#region src/modules/wallets/networks/getNetworkDataForNetworkId/getNetworkDataForNetworkId.ts
const getNetworkDataForNetworkId = ({ networkId, chain }, client) => {
	return getNetworksData(client).find((networkData) => networkData.networkId === networkId && networkData.chain === chain);
};

//#endregion
//#region src/modules/wallets/networks/lastKnownNetworkRegistry/createLastKnownNetworkRegistry/schema.ts
const networkRegistryStorageKeySchema = createStorageKeySchema({
	key: "lastKnownNetworkRegistry",
	schema: z.record(z.string(), z.string())
});

//#endregion
//#region src/modules/wallets/networks/lastKnownNetworkRegistry/createLastKnownNetworkRegistry/createLastKnownNetworkRegistry.ts
/**
* Creates the registry that keeps tabs on which wallet provider is
* connected to which network.
*
* Reminder that this will not be used for chains that have an internal way to
* switch networks (ex EVM).
*/
const createLastKnownNetworkRegistry = (client) => {
	const core = getCore(client);
	const walletProviderKeyToNetworkId = /* @__PURE__ */ new Map();
	const getNetworkId = async ({ walletProviderKey }) => {
		if (walletProviderKeyToNetworkId.has(walletProviderKey)) return { networkId: walletProviderKeyToNetworkId.get(walletProviderKey) };
		const storageRecords = await core.storage.getItem(networkRegistryStorageKeySchema);
		if (storageRecords && storageRecords[walletProviderKey]) {
			const networkId = storageRecords[walletProviderKey];
			walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
			return { networkId };
		}
		const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);
		const networkProviders = getNetworkProviders(client);
		if (networkProviders.length === 0) throw new NoNetworkProvidersError();
		const defaultNetworkProvider = networkProviders.find((networkProvider) => networkProvider.chain === walletProvider.chain);
		assertDefined(defaultNetworkProvider, `No networks found for chain ${walletProvider.chain}`);
		walletProviderKeyToNetworkId.set(walletProviderKey, defaultNetworkProvider.networkId);
		return { networkId: defaultNetworkProvider.networkId };
	};
	const setNetworkId = async ({ networkId, walletProviderKey }) => {
		walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
		await core.storage.setItem(networkRegistryStorageKeySchema, Object.fromEntries(walletProviderKeyToNetworkId.entries()));
	};
	return {
		getNetworkId,
		setNetworkId
	};
};

//#endregion
//#region src/modules/wallets/networks/lastKnownNetworkRegistry/getLastKnownNetworkRegistry/getLastKnownNetworkRegistry.ts
const getLastKnownNetworkRegistry = createRuntimeServiceAccessKey("last-known-network-registry", (client) => createLastKnownNetworkRegistry(client));

//#endregion
//#region src/modules/wallets/utils/formatWalletProviderGroupKey/formatWalletProviderGroupKey.ts
const formatWalletProviderGroupKey = (walletName) => walletName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();

//#endregion
//#region src/modules/wallets/utils/getInjectedProviderFromWindow/getInjectedProviderFromWindow.ts
const getInjectedProviderFromWindow = (path) => {
	if (typeof window === "undefined") return null;
	const target = path.split(".").reduce((acc, key) => acc == null ? null : acc[key], window);
	if (typeof target !== "object" || target === null) return null;
	if (Array.isArray(target)) return target.length > 0 ? target[0] : null;
	const providersArray = target.providers;
	if (providersArray && Array.isArray(providersArray)) return providersArray.length > 0 ? providersArray[0] : null;
	return target;
};

//#endregion
//#region src/modules/wallets/walletProvider/defaultImplementations/getActiveNetworkIdFromLastKnownRegistry/getActiveNetworkIdFromLastKnownRegistry.ts
const getActiveNetworkIdFromLastKnownRegistry = async ({ client, walletProviderKey }) => {
	return getLastKnownNetworkRegistry(client).getNetworkId({ walletProviderKey });
};

//#endregion
//#region src/modules/wallets/walletProvider/defaultImplementations/switchActiveNetworkInLastKnownRegistry/switchActiveNetworkInLastKnownRegistry.ts
const switchActiveNetworkInLastKnownRegistry = async ({ client, networkId, walletProviderKey }) => {
	await getLastKnownNetworkRegistry(client).setNetworkId({
		networkId,
		walletProviderKey
	});
};

//#endregion
//#region src/modules/wallets/walletProvider/events/createWalletProviderEventEmitter/createWalletProviderEventEmitter.ts
/**
* Takes a callback that registers handlers for the external wallet provider.
* Returns both a getter of an eventEmitter that can be exposed via the wallet provider
* and a callback that will be used to destroy the listeners.
*/
const createWalletProviderEventEmitter = ({ removeEventListeners, setupEventListeners, supportedEvents = [
	"accountsChanged",
	"disconnected",
	"networkChanged"
] }) => {
	let eventEmitter;
	/** Value returned by setupEventListeners */
	let setupReturnValue;
	const handleAccountsChanged = (params) => {
		assertDefined(eventEmitter, "Event emitter not defined");
		eventEmitter.emit("accountsChanged", params);
	};
	const handleDisconnected = () => {
		assertDefined(eventEmitter, "Event emitter not defined");
		eventEmitter.emit("disconnected");
	};
	const handleNetworkChanged = (params) => {
		assertDefined(eventEmitter, "Event emitter not defined");
		eventEmitter.emit("networkChanged", params);
	};
	const cleanupEventEmitter = () => {
		if (!eventEmitter) return;
		removeEventListeners({
			handleAccountsChanged,
			handleDisconnected,
			handleNetworkChanged,
			setupReturnValue
		});
		eventEmitter = void 0;
	};
	const getEventEmitter = () => {
		if (!eventEmitter) {
			eventEmitter = new EventEmitter$1();
			setupReturnValue = setupEventListeners({
				handleAccountsChanged,
				handleDisconnected,
				handleNetworkChanged
			});
		}
		return Object.assign(eventEmitter, { supportedEvents });
	};
	return {
		cleanupEventEmitter,
		getEventEmitter
	};
};

//#endregion
//#region src/utils/bufferToBase64/bufferToBase64.ts
const bufferToBase64 = (buf) => {
	const binstr = Array.prototype.map.call(buf, (ch) => String.fromCharCode(ch)).join("");
	return getBuffer().from(binstr, "binary").toString("base64");
};

//#endregion
//#region src/exports/core.ts
assertPackageVersion(name, version);

//#endregion
export { APIError, CHAINS_INFO_MAP, CannotTrackError, ClientNotFoundError, ClientsDoNotMatchError, DYNAMIC_ICONIC_SPRITE_URL, DYNAMIC_SDK_API_VERSION, InvalidStorageSet, InvalidWalletProviderKeyError, MethodNotImplementedError, MultipleClientsFoundError, NoWalletProviderFoundError, ValueMustBeDefinedError, WalletProviderPriority, assertDefined, bufferToBase64, consumeCaptchaToken, consumeMfaTokenIfRequiredForAction, createApiClient, createBaseNetworkProvider, createDeferredPromise, createLocalStorageAdapter, createLogger, createRuntimeServiceAccessKey, createSignInMessageStatement, createStorage, createStorageKeySchema, createVisit, createWalletProviderEventEmitter, emitEvent, emitWalletAccountsChangedEvent, filterDuplicates, formatSignInMessage, formatWalletAccountId, formatWalletProviderGroupKey, formatWalletProviderKey, getActiveNetworkIdFromLastKnownRegistry, getBuffer, getChainFromVerifiedCredentialChain, getCore, getDefaultClient, getInjectedProviderFromWindow, getLastKnownNetworkRegistry, getNetworkDataForNetworkId, getNetworkProviderBuilderRegistry, getNetworkProviderFromNetworkId, getNetworkProviders, getSignedSessionId, getVerifiedCredentialForWalletAccount, getWalletProviderFromWalletAccount, getWalletProviderRegistry, getWalletProviders, hasExtension, isCookieEnabled, normalizeWalletNameWithChain, registerExtension, removeUnverifiedWalletAccount, setCaptchaToken, setUnverifiedWalletAccounts, splitWalletProviderKey, subscribeWithSelector, switchActiveNetworkInLastKnownRegistry, updateAuthFromVerifyResponse, updateWalletProviderKeysForVerifiedCredentials, verifyMessageSignatureOwnership, waitForProjectSettings };
//# sourceMappingURL=core.esm.js.map