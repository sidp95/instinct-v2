const require_getNetworkProviderFromNetworkId = require('./getNetworkProviderFromNetworkId-CTKZxd1T.cjs.js');
const require_constants = require('./constants-BbG0v26E.cjs.js');
let _dynamic_labs_sdk_api_core = require("@dynamic-labs/sdk-api-core");

//#region src/utils/setCookie/setCookie.ts
/**
* Sefelly sets the cookie in the browser.
*/
const setCookie = (cookie) => {
	document.cookie = cookie;
};

//#endregion
//#region src/modules/clientEvents/clientEvents.ts
/**
* Adds an event listener for Dynamic client events.
*
* This function allows you to listen for various events emitted by the Dynamic client,
* such as authentication state changes, wallet connections, and more.
*
* @param params.event - The event name to listen for.
* @param params.listener - The callback function to execute when the event is fired.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A function that can be called to remove the listener.
*/
const onEvent = ({ event, listener }, client = require_constants.getDefaultClient()) => {
	const { eventEmitter } = require_constants.getCore(client);
	eventEmitter.on(event, listener);
	return () => {
		eventEmitter.off(event, listener);
	};
};
/**
* Removes an event listener from Dynamic client events.
*
* This function unsubscribes a previously registered event listener
* from the specified Dynamic client event.
*
* @param params.event - The event name to remove the listener from.
* @param params.listener - The callback function to remove.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
*/
const offEvent = ({ event, listener }, client = require_constants.getDefaultClient()) => {
	const { eventEmitter } = require_constants.getCore(client);
	eventEmitter.off(event, listener);
};
/**
* Adds a one-time event listener for Dynamic client events.
*
* This function listens for an event that will automatically remove itself
* after being triggered once.
*
* @param params.event - The event name to listen for.
* @param params.listener - The callback function to execute when the event is fired.
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns A function that can be called to remove the listener before it fires.
*/
const onceEvent = ({ event, listener }, client = require_constants.getDefaultClient()) => {
	const { eventEmitter } = require_constants.getCore(client);
	eventEmitter.once(event, listener);
	return () => {
		eventEmitter.off(event, listener);
	};
};
/**
* Emits a Dynamic client event.
*
* This function triggers an event that will be received by all registered
* listeners for the specified event type.
*
* @param params.event - The event name to emit.
* @param params.args - The arguments to pass to event listeners.
* @param client - The Dynamic client instance.
*/
const emitEvent = ({ event, args }, client) => {
	const { eventEmitter } = require_constants.getCore(client);
	eventEmitter.emit(event, args);
};

//#endregion
//#region src/errors/InvalidWalletProviderKeyError.ts
var InvalidWalletProviderKeyError = class extends require_constants.BaseError {
	constructor(value) {
		super({
			cause: null,
			code: "invalid_wallet_provider_key",
			docsUrl: null,
			name: "InvalidWalletProviderKeyError",
			shortMessage: `Invalid wallet provider key: ${value}. Key must be in the format of <normalizedWalletNameWithChain>:<walletProviderType>[:<suffix>]`
		});
	}
};

//#endregion
//#region src/modules/wallets/walletProvider/splitWalletProviderKey/splitWalletProviderKey.ts
const splitWalletProviderKey = (walletProviderKey) => {
	const [normalizedWalletNameWithChain, walletProviderType, suffix, ...rest] = walletProviderKey.split(":");
	if (!normalizedWalletNameWithChain || !Object.values(_dynamic_labs_sdk_api_core.WalletProviderEnum).includes(walletProviderType) || rest.length > 0) throw new InvalidWalletProviderKeyError(walletProviderKey);
	return {
		normalizedWalletNameWithChain,
		suffix,
		walletProviderType
	};
};

//#endregion
//#region src/modules/wallets/utils/normalizeAddress/normalizeAddress.ts
const normalizeAddress = (address, chain) => {
	let normalizedAddress = address;
	if (normalizedAddress?.startsWith("0x")) normalizedAddress = normalizedAddress.slice(2);
	normalizedAddress = ["EVM", "FLOW"].includes(chain) ? normalizedAddress?.toLowerCase() : normalizedAddress;
	return normalizedAddress;
};

//#endregion
//#region src/modules/wallets/utils/formatWalletAccountId/formatWalletAccountId.ts
const formatWalletAccountId = ({ address, chain, walletProviderKey }) => {
	const { normalizedWalletNameWithChain } = splitWalletProviderKey(walletProviderKey);
	return `${normalizedWalletNameWithChain}:${normalizeAddress(address, chain)}`;
};

//#endregion
//#region src/modules/wallets/utils/convertUnverifiedWalletAccountToWalletAccount/convertUnverifiedWalletAccountToWalletAccount.ts
const convertUnverifiedWalletAccountToWalletAccount = ({ unverifiedWalletAccount }) => ({
	address: unverifiedWalletAccount.address,
	addressesWithTypes: unverifiedWalletAccount.addressesWithTypes,
	chain: unverifiedWalletAccount.chain,
	id: formatWalletAccountId({
		address: unverifiedWalletAccount.address,
		chain: unverifiedWalletAccount.chain,
		walletProviderKey: unverifiedWalletAccount.walletProviderKey
	}),
	lastSelectedAt: unverifiedWalletAccount.lastSelectedAt,
	verifiedCredentialId: null,
	walletProviderKey: unverifiedWalletAccount.walletProviderKey
});

//#endregion
//#region src/modules/wallets/utils/normalizeWalletNameWithChain/normalizeWalletNameWithChain.ts
/**
* Format the raw wallet name and chain to get the value we can use for
* verified credentials' `walletName` field.
*/
const normalizeWalletNameWithChain = ({ displayName, chain }) => {
	const sanitizedWalletName = displayName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
	const chainLowered = chain.toLocaleLowerCase();
	if (sanitizedWalletName.endsWith(chainLowered)) return sanitizedWalletName;
	return `${sanitizedWalletName}${chainLowered}`;
};

//#endregion
//#region src/modules/wallets/utils/formatWalletProviderKey/formatWalletProviderKey.ts
/**
* Assembles the wallet provider key from the wallet name, chain, and wallet provider type.
*
* The suffix is optional and can be used to add a uniquely identifying string to the key, which
* might be necessary for some wallet providers (like Wallet Connect).
*
* IMPORTANT: Do NOT add a suffix unless absolutely necessary, as it will cause the wallet account
* to not be able to find its wallet provider when connecting to a new device (it won't be possible
* to determine the full key just from the Verified Credential data).
*/
const formatWalletProviderKey = ({ suffix, chain, displayName, walletProviderType }) => {
	return `${normalizeWalletNameWithChain({
		chain,
		displayName
	})}:${walletProviderType}${suffix ? `:${suffix}` : ""}`;
};

//#endregion
//#region src/modules/wallets/walletProvider/walletProviderKeyMap/getWalletProviderKeyFromVerifiedCredential/getWalletProviderKeyFromVerifiedCredential.ts
const getWalletProviderKeyFromVerifiedCredential = ({ verifiedCredential }, client) => {
	const { walletProviderKeyMap } = require_constants.getCore(client).state.get();
	const storedWalletProviderKey = walletProviderKeyMap[verifiedCredential.id];
	if (storedWalletProviderKey) return { walletProviderKey: storedWalletProviderKey };
	/**
	* We fallback to comprising the wallet provider key from walletName and walletProvider.
	*
	* Some wallet provider types (like Wallet Connect) also use a special suffix for their wallet provider
	* keys, so this won't be enough for them.
	* Therefore, for those specific wallet providers, the wallet account will remain without a wallet provider
	* and will require reconnection.
	* Read walletProvider.types.ts for more info.
	*/
	require_constants.assertDefined(verifiedCredential.walletName, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletName`);
	require_constants.assertDefined(verifiedCredential.walletProvider, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletProvider`);
	require_constants.assertDefined(verifiedCredential.chain, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing chain`);
	return { walletProviderKey: formatWalletProviderKey({
		chain: require_constants.getChainFromVerifiedCredentialChain(verifiedCredential.chain),
		displayName: verifiedCredential.walletName,
		walletProviderType: verifiedCredential.walletProvider
	}) };
};

//#endregion
//#region src/modules/wallets/utils/convertVerifiedCredentialToWalletAccount/convertVerifiedCredentialToWalletAccount.ts
const convertVerifiedCredentialToWalletAccount = ({ verifiedCredential }, client) => {
	require_constants.assertDefined(verifiedCredential.address, "Missing address in verified credential");
	require_constants.assertDefined(verifiedCredential.chain, "Missing chain in verified credential");
	const chain = require_constants.getChainFromVerifiedCredentialChain(verifiedCredential.chain);
	const { walletProviderKey } = getWalletProviderKeyFromVerifiedCredential({ verifiedCredential }, client);
	const walletAccountId = formatWalletAccountId({
		address: verifiedCredential.address,
		chain,
		walletProviderKey
	});
	return {
		address: verifiedCredential.address,
		addressesWithTypes: verifiedCredential.walletAdditionalAddresses,
		chain,
		id: walletAccountId,
		lastSelectedAt: verifiedCredential.lastSelectedAt ?? null,
		verifiedCredentialId: verifiedCredential.id,
		walletProviderKey
	};
};

//#endregion
//#region src/modules/wallets/getWalletAccounts/getWalletAccountsFromState/getWalletAccountsFromState.ts
const getWalletAccountsFromState = ({ unverifiedWalletAccounts, user }, client) => {
	const walletAccountsMap = /* @__PURE__ */ new Map();
	/**
	* Handle the unverified wallet accounts before the user verified credentials
	* so the later verified wallet accounts can override the unverified wallet accounts
	*/
	unverifiedWalletAccounts.forEach((unverifiedWalletAccount) => {
		const walletAccount = convertUnverifiedWalletAccountToWalletAccount({ unverifiedWalletAccount });
		walletAccountsMap.set(walletAccount.id, walletAccount);
	});
	(user?.verifiedCredentials ?? []).filter((verified) => verified.format === _dynamic_labs_sdk_api_core.JwtVerifiedCredentialFormatEnum.Blockchain).forEach((verifiedWalletAccount) => {
		const walletAccount = convertVerifiedCredentialToWalletAccount({ verifiedCredential: verifiedWalletAccount }, client);
		walletAccountsMap.set(walletAccount.id, walletAccount);
	});
	return Array.from(walletAccountsMap.values());
};

//#endregion
//#region src/modules/wallets/getWalletAccounts/getWalletAccounts.ts
/**
* Retrieves all wallet accounts associated with the current session.
*
* This function returns both verified and unverified wallet accounts,
* combining data from user credentials and local unverified accounts.
* You can differentiate between verified and unverified wallet accounts by
* checking the `verifiedCredentialId` property.
*
* @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
* @returns An array of wallet accounts associated with the session.
*/
const getWalletAccounts = (client = require_constants.getDefaultClient()) => {
	const { unverifiedWalletAccounts, user } = require_constants.getCore(client).state.get();
	return getWalletAccountsFromState({
		unverifiedWalletAccounts,
		user
	}, client);
};

//#endregion
//#region src/errors/NoWalletProviderFoundError.ts
var NoWalletProviderFoundError = class extends require_constants.BaseError {
	constructor({ walletProviderKey }) {
		super({
			cause: null,
			code: "no_wallet_provider_found_error",
			docsUrl: null,
			name: "NoWalletProviderFoundError",
			shortMessage: `No wallet provider found with key: ${walletProviderKey}`
		});
	}
};

//#endregion
//#region src/services/runtimeServices/createRuntimeServiceAccessKey/createRuntimeServiceAccessKey.ts
/**
* Creates a service accessor function that manages service instantiation and caching.
* The returned function will either retrieve an existing service from the registry or
* create a new one using the provided builder function.
*
* @template - The type of service to be created/accessed
* @param key - Unique identifier for the service in the registry
* @param builder - Function that creates the service instance when called with a DynamicClient
*/
const createRuntimeServiceAccessKey = (key, builder) => (client) => {
	const { runtimeServices } = require_constants.getCore(client);
	const currentService = runtimeServices.getByKey(key);
	if (currentService) return currentService;
	const service = builder(client);
	runtimeServices.register(key, service);
	return service;
};

//#endregion
//#region src/modules/wallets/walletProviderRegistry/createWalletProviderRegistry/createWalletProviderRegistry.ts
/**
* Creates a new wallet provider registry that manages wallet providers with priority-based registration.
*
* @returns The wallet provider registry instance
*
* @example
* ```typescript
* const registry = createWalletProviderRegistry();
*
* registry.register({
*   priority: WalletProviderPriority.WALLET_SDK,
*   walletProvider: myWalletProvider
* });
*
* const provider = registry.getByKey('my-wallet-key');
* const providers = registry.listProviders();
* ```
*/
const createWalletProviderRegistry = (client) => {
	const registry = /* @__PURE__ */ new Map();
	return {
		getByKey: (key) => registry.get(key)?.walletProvider,
		listProviders: () => Array.from(registry.values()).map((v) => v.walletProvider),
		register: (args) => {
			const existingEntry = registry.get(args.walletProvider.key);
			if (existingEntry) {
				if (existingEntry.priority < args.priority) {
					registry.set(args.walletProvider.key, args);
					emitEvent({
						args: { walletProviderKey: args.walletProvider.key },
						event: "walletProviderChanged"
					}, client);
				}
			} else {
				registry.set(args.walletProvider.key, args);
				emitEvent({
					args: { walletProvider: args.walletProvider },
					event: "walletProviderRegistered"
				}, client);
				emitEvent({
					args: { walletProviderKey: args.walletProvider.key },
					event: "walletProviderChanged"
				}, client);
			}
		},
		unregister: (key) => {
			registry.delete(key);
			emitEvent({
				args: { walletProviderKey: key },
				event: "walletProviderUnregistered"
			}, client);
		}
	};
};

//#endregion
//#region src/modules/wallets/walletProviderRegistry/getWalletProviderRegistry/getWalletProviderRegistry.ts
/**
* This function provides access to a shared instance of the wallet provider registry.
*
* It ensures that the same registry instance is used throughout the client to maintaining
* consistency of registered wallet providers across different parts of the codebase.
*
* @returns The wallet provider registry instance
*
* @example
* ```typescript
* // Get the registry instance
* const registry = getWalletProviderRegistry();
*
* // Register a wallet provider
* registry.register({
*   priority: WalletProviderPriority.WALLET_SDK,
*   walletProvider: myWalletProvider
* });
*
* // Retrieve a specific provider
* const provider = registry.getByKey('metamaskevm');
* ```
*/
const getWalletProviderRegistry = createRuntimeServiceAccessKey("walletProviderRegistry", (client) => createWalletProviderRegistry(client));

//#endregion
//#region src/modules/wallets/walletProviderRegistry/walletProviderRegistry.types.ts
let WalletProviderPriority = /* @__PURE__ */ function(WalletProviderPriority$1) {
	/**
	* Highest priority should be used by wallet providers that implement
	* the most reliable wallet integration.
	* example: The SDK provided by the wallet provider.
	*/
	WalletProviderPriority$1[WalletProviderPriority$1["WALLET_SDK"] = 100] = "WALLET_SDK";
	/**
	* Medium priority should be used by wallet providers that implement
	* a wallet integration via some reliable standard.
	* example: A wallet provider that uses EIP6963 announcement.
	*/
	WalletProviderPriority$1[WalletProviderPriority$1["WALLET_SELF_ANNOUNCEMENT_STANDARD"] = 50] = "WALLET_SELF_ANNOUNCEMENT_STANDARD";
	/**
	* Low priority should be used by wallet providers that implement
	* a wallet integration on a less reliable standard.
	* example: A wallet provider that uses window.ethereum, where the
	* window key can be overridden by other extensions.
	*/
	WalletProviderPriority$1[WalletProviderPriority$1["WINDOW_INJECT"] = 20] = "WINDOW_INJECT";
	return WalletProviderPriority$1;
}({});

//#endregion
//#region src/modules/wallets/utils/getWalletProviderFromWalletAccount/getWalletProviderFromWalletAccount.ts
const getWalletProviderFromWalletAccount = ({ walletAccount }, client) => {
	const walletProvider = getWalletProviderRegistry(client).getByKey(walletAccount.walletProviderKey);
	if (!walletProvider) throw new NoWalletProviderFoundError({ walletProviderKey: walletAccount.walletProviderKey });
	return walletProvider;
};

//#endregion
//#region src/modules/auth/consts.ts
const DYNAMIC_AUTH_COOKIE_NAME = "DYNAMIC_JWT_TOKEN";

//#endregion
//#region src/modules/wallets/emitWalletAccountsChangedEvent/emitWalletAccountsChangedEvent.ts
/**
* Emits the `walletAccountsChanged` event.
*/
const emitWalletAccountsChangedEvent = (client) => {
	emitEvent({
		args: { walletAccounts: getWalletAccounts(client) },
		event: "walletAccountsChanged"
	}, client);
};

//#endregion
//#region src/modules/auth/updateAuthFromVerifyResponse/checkAndRaiseWalletAccountsChangedEvent/checkAndRaiseWalletAccountsChangedEvent.ts
const checkAndRaiseWalletAccountsChangedEvent = ({ previousState }, client) => {
	const core = require_constants.getCore(client);
	if (getWalletAccountsHash(previousState, client) !== getWalletAccountsHash(core.state.get(), client)) emitWalletAccountsChangedEvent(client);
};
const getWalletAccountsHash = (state, client) => getWalletAccountsFromState(state, client).map((walletAccount) => JSON.stringify(walletAccount)).sort().join("-");

//#endregion
//#region src/modules/wallets/getWalletProviders/getWalletProviders.ts
/**
* Get all available wallet providers to interact with internally.
*/
const getWalletProviders = (client) => {
	return getWalletProviderRegistry(client).listProviders();
};

//#endregion
//#region src/modules/waas/isWaasWalletProvider/isWaasWalletProvider.ts
const isWaasWalletProvider = (walletProvider) => {
	return walletProvider.key.includes(require_constants.DYNAMIC_WAAS_METADATA.normalizedWalletName);
};

//#endregion
//#region src/modules/waas/findWaasWalletProviderByChain/findWaasWalletProviderByChain.ts
const findWaasWalletProviderByChain = ({ chain }, client) => {
	const providers = getWalletProviders(client);
	const waasProviderKey = formatWalletProviderKey({
		chain,
		displayName: require_constants.DYNAMIC_WAAS_METADATA.displayName,
		walletProviderType: _dynamic_labs_sdk_api_core.WalletProviderEnum.EmbeddedWallet
	});
	const waasProvider = providers.find((provider) => provider.key === waasProviderKey && provider.chain === chain);
	if (!waasProvider || !isWaasWalletProvider(waasProvider)) return null;
	return waasProvider;
};

//#endregion
//#region src/modules/waas/isWaasWalletAccount/isWaasWalletAccount.ts
/**
* This function determines whether the provided wallet account is a Dynamic
* WaaS wallet account.
*
* @param params.walletAccount - The wallet account to check.
* @returns True if the wallet account is a WaaS wallet account, false otherwise.
*/
const isWaasWalletAccount = ({ walletAccount }) => {
	return walletAccount.walletProviderKey.includes(require_constants.DYNAMIC_WAAS_METADATA.normalizedWalletName);
};

//#endregion
//#region src/modules/waas/restoreUserSharesForAllWalletAccounts/restoreUserSharesForAllWalletAccounts.ts
const restoreUserSharesForAllWalletAccounts = async (client) => {
	const waasWalletAccounts = getWalletAccounts(client).filter((walletAccount) => isWaasWalletAccount({ walletAccount }));
	await Promise.all(waasWalletAccounts.map(async (walletAccount) => {
		const provider = findWaasWalletProviderByChain({ chain: walletAccount.chain }, client);
		/**
		* The environment might not have the embedded wallet extensions installed.
		* In that case there is no provider for the chain and we can skip restoring the user share.
		*/
		if (!provider) return;
		return provider.restoreUserShareForWalletAccount({ walletAccount });
	}));
};

//#endregion
//#region src/modules/auth/updateAuthFromVerifyResponse/updateAuthFromVerifyResponse.ts
const updateAuthFromVerifyResponse = ({ response }, client) => {
	const core = require_constants.getCore(client);
	const previousState = { ...core.state.get() };
	const { user, minifiedJwt, jwt, expiresAt, mfaToken } = response;
	const sessionExpiresAt = /* @__PURE__ */ new Date(expiresAt * 1e3);
	const newState = {
		legacyToken: jwt ?? null,
		sessionExpiresAt,
		token: minifiedJwt ?? null,
		user
	};
	if (mfaToken) newState.mfaToken = mfaToken;
	core.state.set(newState);
	/**
	* For customers using a sandbox environment with cookies enabled, we need to set the cookie
	* programmatically because Redcoast won't set the cookie via headers. We set the cookie programmatically
	* so customers can access the cookie from document.cookie consistently between sandbox and live environments.
	*/
	if (minifiedJwt && require_constants.isCookieEnabled(client)) setCookie(`${DYNAMIC_AUTH_COOKIE_NAME}=${minifiedJwt}; expires=${sessionExpiresAt.toUTCString()}; path=/; SameSite=Lax`);
	checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);
	if (!previousState.user && Boolean(newState.user)) restoreUserSharesForAllWalletAccounts(client);
};

//#endregion
//#region src/modules/wallets/getWalletProviderByKey/getWalletProviderByKey.ts
const getWalletProviderByKey = ({ walletProviderKey }, client) => {
	const walletProvider = getWalletProviders(client).find((walletProvider$1) => walletProvider$1.key === walletProviderKey);
	if (!walletProvider) throw new NoWalletProviderFoundError({ walletProviderKey });
	return walletProvider;
};

//#endregion
//#region src/modules/wallets/utils/getVerifiedCredentialForWalletAccount/getVerifiedCredentialForWalletAccount.ts
const getVerifiedCredentialForWalletAccount = ({ walletAccount }, client) => {
	return client.user?.verifiedCredentials.find((vc) => vc.id === walletAccount.verifiedCredentialId);
};

//#endregion
Object.defineProperty(exports, 'DYNAMIC_AUTH_COOKIE_NAME', {
  enumerable: true,
  get: function () {
    return DYNAMIC_AUTH_COOKIE_NAME;
  }
});
Object.defineProperty(exports, 'InvalidWalletProviderKeyError', {
  enumerable: true,
  get: function () {
    return InvalidWalletProviderKeyError;
  }
});
Object.defineProperty(exports, 'NoWalletProviderFoundError', {
  enumerable: true,
  get: function () {
    return NoWalletProviderFoundError;
  }
});
Object.defineProperty(exports, 'WalletProviderPriority', {
  enumerable: true,
  get: function () {
    return WalletProviderPriority;
  }
});
Object.defineProperty(exports, 'checkAndRaiseWalletAccountsChangedEvent', {
  enumerable: true,
  get: function () {
    return checkAndRaiseWalletAccountsChangedEvent;
  }
});
Object.defineProperty(exports, 'createRuntimeServiceAccessKey', {
  enumerable: true,
  get: function () {
    return createRuntimeServiceAccessKey;
  }
});
Object.defineProperty(exports, 'emitEvent', {
  enumerable: true,
  get: function () {
    return emitEvent;
  }
});
Object.defineProperty(exports, 'emitWalletAccountsChangedEvent', {
  enumerable: true,
  get: function () {
    return emitWalletAccountsChangedEvent;
  }
});
Object.defineProperty(exports, 'findWaasWalletProviderByChain', {
  enumerable: true,
  get: function () {
    return findWaasWalletProviderByChain;
  }
});
Object.defineProperty(exports, 'formatWalletAccountId', {
  enumerable: true,
  get: function () {
    return formatWalletAccountId;
  }
});
Object.defineProperty(exports, 'formatWalletProviderKey', {
  enumerable: true,
  get: function () {
    return formatWalletProviderKey;
  }
});
Object.defineProperty(exports, 'getVerifiedCredentialForWalletAccount', {
  enumerable: true,
  get: function () {
    return getVerifiedCredentialForWalletAccount;
  }
});
Object.defineProperty(exports, 'getWalletAccounts', {
  enumerable: true,
  get: function () {
    return getWalletAccounts;
  }
});
Object.defineProperty(exports, 'getWalletProviderByKey', {
  enumerable: true,
  get: function () {
    return getWalletProviderByKey;
  }
});
Object.defineProperty(exports, 'getWalletProviderFromWalletAccount', {
  enumerable: true,
  get: function () {
    return getWalletProviderFromWalletAccount;
  }
});
Object.defineProperty(exports, 'getWalletProviderRegistry', {
  enumerable: true,
  get: function () {
    return getWalletProviderRegistry;
  }
});
Object.defineProperty(exports, 'getWalletProviders', {
  enumerable: true,
  get: function () {
    return getWalletProviders;
  }
});
Object.defineProperty(exports, 'isWaasWalletAccount', {
  enumerable: true,
  get: function () {
    return isWaasWalletAccount;
  }
});
Object.defineProperty(exports, 'isWaasWalletProvider', {
  enumerable: true,
  get: function () {
    return isWaasWalletProvider;
  }
});
Object.defineProperty(exports, 'normalizeAddress', {
  enumerable: true,
  get: function () {
    return normalizeAddress;
  }
});
Object.defineProperty(exports, 'normalizeWalletNameWithChain', {
  enumerable: true,
  get: function () {
    return normalizeWalletNameWithChain;
  }
});
Object.defineProperty(exports, 'offEvent', {
  enumerable: true,
  get: function () {
    return offEvent;
  }
});
Object.defineProperty(exports, 'onEvent', {
  enumerable: true,
  get: function () {
    return onEvent;
  }
});
Object.defineProperty(exports, 'onceEvent', {
  enumerable: true,
  get: function () {
    return onceEvent;
  }
});
Object.defineProperty(exports, 'restoreUserSharesForAllWalletAccounts', {
  enumerable: true,
  get: function () {
    return restoreUserSharesForAllWalletAccounts;
  }
});
Object.defineProperty(exports, 'setCookie', {
  enumerable: true,
  get: function () {
    return setCookie;
  }
});
Object.defineProperty(exports, 'splitWalletProviderKey', {
  enumerable: true,
  get: function () {
    return splitWalletProviderKey;
  }
});
Object.defineProperty(exports, 'updateAuthFromVerifyResponse', {
  enumerable: true,
  get: function () {
    return updateAuthFromVerifyResponse;
  }
});
//# sourceMappingURL=getVerifiedCredentialForWalletAccount-DAb9lFwa.cjs.js.map