{"version":3,"file":"getNetworkProviderFromNetworkId-CTKZxd1T.cjs.js","names":["BaseError","item: StorageFormat<typeof value>","resolve: (value: T) => void","reject: (reason?: unknown) => void","BaseError","LOG_LEVELS: Record<LogLevel, number>","eventEmitter: LoggerEventEmitter","EventEmitter","minLevel: LogLevel","BaseError","BaseError","getDefaultClient","getCore","getDefaultClient","getCore","getDefaultClient","getCore","AuthModeEnum","getCore","createApiClient","getWalletProviderFromWalletAccount","normalizeWalletNameWithChain","connectRequest: ConnectRequest","getCore","filteredUnverifiedWalletAccounts: UnverifiedWalletAccount[]","suffixFields: string[]","getCore","getCore","getCore","createApiClient","normalizeWalletNameWithChain","getCore","CHAINS_INFO_MAP","getDefaultClient","getCore","createRuntimeServiceAccessKey","networkProvider"],"sources":["../src/utils/isEqualShallow/isEqualShallow.ts","../src/utils/observable/subscribeWithSelector/subscribeWithSelector.ts","../src/services/storage/createLocalStorageAdapter/createLocalStorageAdapter.ts","../src/errors/InvalidStorageSet.ts","../src/services/storage/createStorage/formatForStorage/isValidDateISOString/isValidDateISOString.ts","../src/services/storage/createStorage/formatForStorage/storageFormat.ts","../src/services/storage/createStorage/createStorage.ts","../src/services/storage/createStorageKeySchema/createStorageKeySchema.ts","../src/modules/initializeClient/consts.ts","../src/utils/deferredPromise/createDeferredPromise.ts","../src/errors/CannotTrackError.ts","../src/services/logger/createLogger/createLogger.ts","../src/errors/NoNetworkProvidersError.ts","../src/errors/WalletAlreadyLinkedToAnotherUserError.ts","../src/modules/captcha/isCaptchaRequired/isCaptchaRequired.ts","../src/modules/captcha/consumeCaptchaToken/consumeCaptchaToken.ts","../src/modules/captcha/setCaptchaToken/setCaptchaToken.ts","../src/modules/extension/hasExtension/hasExtension.ts","../src/modules/auth/createVisit/createVisit.ts","../src/modules/wallets/unverifiedWalletAccounts/setUnverifiedWalletAccounts/setUnverifiedWalletAccounts.ts","../src/modules/wallets/utils/formatSignInMessage/formatSignInMessage.ts","../src/modules/wallets/utils/getSignInMessage/createSignInMessageStatement/createSignInMessageStatement.ts","../src/modules/wallets/unverifiedWalletAccounts/removeUnverifiedWalletAccount/removeUnverifiedWalletAccount.ts","../src/utils/isError/isError.ts","../src/utils/isErrorWithCode/isErrorWithCode.ts","../src/modules/wallets/verifyMessageSignatureOwnership/verifyMessageSignatureOwnership.ts","../src/modules/wallets/walletProvider/walletProviderKeyMap/updateWalletProviderKeysForVerifiedCredentials/updateWalletProviderKeysForVerifiedCredentials.ts","../src/modules/wallets/networks/getSdkChainFromApiChainName/getSdkChainFromApiChainName.ts","../src/modules/wallets/networks/getNetworksData/getNetworksData.ts","../src/modules/wallets/networks/networkProviderBuilderRegistry/createNetworkProviderBuilderRegistry/createNetworkProviderBuilderRegistry.ts","../src/modules/wallets/networks/networkProviderBuilderRegistry/getNetworkProviderBuilderRegistry/getNetworkProviderBuilderRegistry.ts","../src/modules/wallets/networks/getNetworkProviders/getNetworkProviders.ts","../src/modules/wallets/networks/getNetworkProviderFromNetworkId/getNetworkProviderFromNetworkId.ts"],"sourcesContent":["/**\n * Shallow compare two objects.\n *\n * Source: https://github.com/pmndrs/zustand/blob/main/src/vanilla/shallow.ts\n */\nexport const isEqualShallow = <T>(objA: T, objB: T) => {\n  if (Object.is(objA, objB)) return true;\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return objA === objB;\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) return false;\n    }\n\n    return true;\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n\n    for (const value of objA) {\n      if (!objB.has(value)) return false;\n    }\n    return true;\n  }\n\n  const keysA = Object.keys(objA);\n\n  if (keysA.length !== Object.keys(objB).length) return false;\n\n  for (const keyA of keysA) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keyA as string) ||\n      !Object.is(objA[keyA as keyof T], objB[keyA as keyof T])\n    ) {\n      return false;\n    }\n  }\n\n  if (objA.constructor !== objB.constructor) return false;\n\n  return true;\n};\n","import { isEqualShallow } from '../../isEqualShallow';\nimport type { ObservableState } from '../observable.types';\n\n/**\n * Allows subscribing to a slice of the state.\n * The slice is a computation of the states.\n *\n * The callback will only be called when the slice has changed.\n * Change is determined by shallow comparison.\n *\n * Returns a function to unsubscribe the callback.\n */\nexport const subscribeWithSelector =\n  <T extends Record<string, unknown>, Slice>(\n    observable: ObservableState<T>,\n    selector: (value: T) => Slice\n  ) =>\n  (callback: (slice: Slice) => void) => {\n    let lastSlice = selector(observable.get());\n\n    return observable.subscribe((value) => {\n      const nextSlice = selector(value);\n\n      if (isEqualShallow(nextSlice, lastSlice)) return;\n\n      lastSlice = nextSlice;\n\n      callback(nextSlice);\n    });\n  };\n","/* eslint-disable no-restricted-globals -- this is the abstraction for localStorage */\nimport type { StorageAdapter } from '../storage.types';\n\n/**\n * Creates a localStorage adapter\n */\nexport const createLocalStorageAdapter = (): StorageAdapter => ({\n  getItem: async (key) => localStorage.getItem(key),\n  removeItem: async (key) => localStorage.removeItem(key),\n  setItem: async (key, value) => localStorage.setItem(key, value),\n});\n","import { BaseError } from './base';\n\ntype InvalidStorageSetParams = {\n  key: string;\n  value: string;\n};\n\nexport class InvalidStorageSet extends BaseError {\n  constructor({ key, value }: InvalidStorageSetParams) {\n    super({\n      cause: null,\n      code: 'invalid_storage_set',\n      docsUrl: null,\n      metaMessages: [`key: ${key}`, value],\n      name: 'InvalidStorageSet',\n      shortMessage: 'Tried to store a value that does not match the schema',\n    });\n  }\n}\n","/**\n * Returns whether the given string is a valid ISO date string.\n *\n * Does not support timezone offsets.\n */\nexport const isValidDateISOString = (value: string): boolean => {\n  const date = new Date(value);\n\n  return !isNaN(date.getTime()) && date.toISOString() === value;\n};\n","import type { StorageFormat } from '../../storage.types';\nimport { isValidDateISOString } from './isValidDateISOString';\n\nconst DATE_PREFIX = '__DATE__';\n\nexport const formatForStorage = (value: unknown) => {\n  const item: StorageFormat<typeof value> = { value };\n\n  return JSON.stringify(item, (_, entry) => {\n    // You might think that entry here would be a Date and one could simply do \"entry instanceof Date\",\n    // but actually it will be a string already (no idea why JSON.stringify does this)\n    if (isValidDateISOString(entry)) {\n      return `${DATE_PREFIX}${entry}`;\n    }\n\n    return entry;\n  });\n};\n\nexport const parseFromStorage = <T>(value: string): StorageFormat<T> | null => {\n  try {\n    const parsed = JSON.parse(value, (_, entry) => {\n      if (typeof entry === 'string' && entry.startsWith(DATE_PREFIX)) {\n        return new Date(entry.slice(DATE_PREFIX.length));\n      }\n\n      return entry;\n    }) as StorageFormat<T>;\n\n    return parsed;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (error) {\n    return null;\n  }\n};\n","import type { Storage, StorageAdapter } from '../storage.types';\nimport { InvalidStorageSet } from './../../../errors/InvalidStorageSet';\nimport { formatForStorage } from './formatForStorage';\nimport { parseFromStorage } from './formatForStorage/storageFormat';\n\ntype CreateWebStorageParams = {\n  prefix?: string;\n  storageAdapter: StorageAdapter;\n};\n\n/**\n * Creates a Storage service to interact with storage adapter\n */\nexport const createStorage = ({\n  prefix = '',\n  storageAdapter,\n}: CreateWebStorageParams): Storage => {\n  const getPrefixedKey = (key: string) => (prefix ? `${prefix}_${key}` : key);\n\n  return {\n    getItem: async (storageKeySchema) => {\n      const rawItem = await storageAdapter.getItem(\n        getPrefixedKey(storageKeySchema.key)\n      );\n\n      const parsedItem = rawItem ? parseFromStorage(rawItem) : null;\n\n      /**\n       * The item saved to localStorage may be malformed.\n       * In this case, we remove it and return null.\n       */\n      if (parsedItem !== null) {\n        const parsed = storageKeySchema.schema.safeParse(parsedItem.value);\n\n        if (parsed.success) {\n          return parsed.data;\n        }\n      }\n\n      /**\n       * The item saved to localStorage may be malformed.\n       * In this case, we remove it and return null.\n       */\n\n      await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));\n\n      return null;\n    },\n\n    removeItem: async (storageKeySchema) => {\n      await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));\n    },\n\n    setItem: async (storageKeySchema, value) => {\n      const parsed = storageKeySchema.schema.safeParse(value);\n\n      if (!parsed.success) {\n        throw new InvalidStorageSet({\n          key: storageKeySchema.key,\n          value: JSON.stringify(value),\n        });\n      }\n\n      const item = formatForStorage(parsed.data);\n\n      await storageAdapter.setItem(getPrefixedKey(storageKeySchema.key), item);\n    },\n  };\n};\n","import type * as z from 'zod/mini';\n\nimport type { StorageKeySchema } from '../storage.types';\n\nexport const createStorageKeySchema = <T>(params: {\n  key: string;\n  schema: z.ZodMiniType<T>;\n}): StorageKeySchema<T> => {\n  return params;\n};\n","export const REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY =\n  'refresh-user-state-from-cookie';\n\nexport const INITIALIZE_STORAGE_SYNC_TRACKER_KEY = 'initialize-storage-sync';\n\nexport const FETCH_PROJECT_SETTINGS_TRACKER_KEY = 'fetch-project-settings';\n\nexport const GENERATE_SESSION_KEYS_TRACKER_KEY = 'generate-session-keys';\n","import type { DeferredPromise } from './deferredPromise.types';\n\nexport const createDeferredPromise = <T>(): DeferredPromise<T> => {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n\n  return {\n    promise,\n    reject: (reason?: unknown) => reject?.(reason),\n    resolve: (value: T) => resolve?.(value),\n  };\n};\n","import { BaseError } from './base';\n\nexport class CannotTrackError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'cannot_track_error',\n      docsUrl: null,\n      name: 'CannotTrackError',\n      shortMessage: 'All track calls must be performed in the same node tick',\n    });\n  }\n}\n","import { EventEmitter } from 'eventemitter3';\n\nimport type { LogLevel, Logger, LoggerEventEmitter } from '../logger.types';\n\n/**\n * Configuration options for the logger\n */\ntype CreateLoggerOptions = {\n  level?: LogLevel;\n};\n\n/**\n * Log levels and their corresponding numeric values\n */\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  error: 3,\n  info: 1,\n  warn: 2,\n};\n\n// Assign to avoid lint errors\nconst defaultConsole = console;\n\n/**\n * Creates a logger instance with configurable log level and event emission capabilities.\n * @returns A logger instance with debug, info, warn, and error methods\n */\nexport const createLogger = (options: CreateLoggerOptions = {}): Logger => {\n  const eventEmitter: LoggerEventEmitter = new EventEmitter();\n\n  // Default to 'debug' if no level is provided\n  const minLevel: LogLevel = options.level ?? 'warn';\n\n  // Helper to decide if we should log based on current log level\n  const shouldLog = (level: LogLevel): boolean => {\n    return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n  };\n\n  // Helper to format the log message\n  const formatMessage = (level: LogLevel, message: string): string => {\n    const timestamp = new Date().toISOString();\n\n    return `[${timestamp}] ${level.toUpperCase()}: ${message}`;\n  };\n\n  // Unified logger function that checks the level and calls the appropriate console method\n  const log = (\n    level: LogLevel,\n    consoleMethod: (...data: unknown[]) => void,\n    message: string,\n    ...args: unknown[]\n  ) => {\n    eventEmitter.emit('log', level, message, ...args);\n\n    if (!shouldLog(level)) return;\n\n    consoleMethod(formatMessage(level, message), ...args);\n  };\n\n  return {\n    debug: (message, ...args) =>\n      log('debug', defaultConsole.debug, message, ...args),\n\n    error: (message, ...args) =>\n      log('error', defaultConsole.error, message, ...args),\n\n    info: (message, ...args) =>\n      log('info', defaultConsole.info, message, ...args),\n\n    off: eventEmitter.off.bind(eventEmitter),\n\n    on: eventEmitter.on.bind(eventEmitter),\n    warn: (message, ...args) =>\n      log('warn', defaultConsole.warn, message, ...args),\n  };\n};\n","import { BaseError } from './base';\n\nexport class NoNetworkProvidersError extends BaseError {\n  constructor() {\n    super({\n      cause: null,\n      code: 'no_network_providers',\n      docsUrl: null,\n      name: 'NoNetworkProvidersError',\n      shortMessage: 'No networks were registered in the client',\n    });\n  }\n}\n","import { BaseError, type BaseErrorParameters } from './base';\n\nexport class WalletAlreadyLinkedToAnotherUserError extends BaseError {\n  constructor({ cause }: Pick<BaseErrorParameters, 'cause'>) {\n    super({\n      cause,\n      code: 'wallet_already_linked_to_another_user_error',\n      docsUrl: null,\n      name: 'WalletAlreadyLinkedToAnotherUserError',\n      shortMessage: 'This wallet is already linked to another user',\n    });\n  }\n}\n","import { getDefaultClient } from '../../../client/defaultClient';\nimport { assertDefined } from '../../../utils/assertDefined';\n\nexport const isCaptchaRequired = (client = getDefaultClient()) => {\n  const projectSettings = client.projectSettings;\n\n  assertDefined(projectSettings, 'Project settings are not available');\n\n  return projectSettings.security.hCaptcha?.enabled ?? false;\n};\n","import { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types';\nimport { assertDefined } from '../../../utils/assertDefined';\nimport { isCaptchaRequired } from '../isCaptchaRequired';\n\n/**\n * Retrieves the current captcha token from the client state and sets it to null.\n */\nexport const consumeCaptchaToken = (\n  client: DynamicClient\n): string | undefined => {\n  const core = getCore(client);\n\n  const captchaToken = core.state.get().captchaToken;\n\n  if (isCaptchaRequired(client)) {\n    assertDefined(captchaToken, 'Captcha token is required');\n  }\n\n  core.state.set({\n    captchaToken: null,\n  });\n\n  return captchaToken ?? undefined;\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\n\ntype SetCaptchaTokenProps = {\n  captchaToken: string;\n};\n\n/**\n * Sets the given captcha token in the client state.\n *\n * @param params.captchaToken - The captcha token to set.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n */\nexport const setCaptchaToken = (\n  { captchaToken }: SetCaptchaTokenProps,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n\n  core.state.set({\n    captchaToken,\n  });\n};\n","import { getCore } from '../../../client/core/getCore';\nimport { getDefaultClient } from '../../../client/defaultClient';\n\ntype HasExtensionParams = {\n  extensionKey: string;\n};\n\n/**\n * Checks if a specific extension has been applied to the Dynamic client.\n *\n * Extensions add optional features to the Dynamic SDK,\n * such as EVM, Solana, or other chain support.\n *\n * @param params.extensionKey - The unique key identifying the extension to check for.\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns True if the extension is applied, false otherwise.\n */\nexport const hasExtension = (\n  { extensionKey }: HasExtensionParams,\n  client = getDefaultClient()\n) => {\n  const core = getCore(client);\n\n  return core.extensions.has(extensionKey);\n};\n","import {\n  AuthModeEnum,\n  type ChainEnum,\n  type ConnectRequest,\n} from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types';\nimport { createApiClient } from '../../apiClient';\nimport { getWalletProviderFromWalletAccount } from '../../wallets/utils/getWalletProviderFromWalletAccount';\nimport { normalizeWalletNameWithChain } from '../../wallets/utils/normalizeWalletNameWithChain';\nimport type { WalletAccount } from '../../wallets/walletAccount';\n\ntype CreateVisitParams = {\n  authMode?: AuthModeEnum;\n  walletAccount: WalletAccount;\n};\n\n/*  \n  In older SDK versions we used to have the concept of \"connect-only\" vs \"connect-and-sign\". \n  The only difference in backend is it stores some extra data for connect-only, \n  so we can just default to using it.\n*/\nexport const createVisit = async (\n  { walletAccount, authMode = AuthModeEnum.Only }: CreateVisitParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const walletProvider = getWalletProviderFromWalletAccount(\n    { walletAccount },\n    client\n  );\n\n  try {\n    const walletName = normalizeWalletNameWithChain({\n      chain: walletProvider.chain,\n      displayName: walletProvider.metadata.displayName,\n    });\n\n    const connectRequest: ConnectRequest = {\n      address: walletAccount.address,\n      authMode,\n      // eslint-disable-next-line custom-rules/ban-chain-enum\n      chain: walletProvider.chain as ChainEnum,\n      provider: walletProvider.walletProviderType,\n      walletName,\n    };\n\n    await apiClient.createVisit({\n      connectRequest,\n      environmentId: core.environmentId,\n    });\n  } catch (error) {\n    core.logger.error('Error creating visit', { error });\n  }\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport type { UnverifiedWalletAccount } from '../unverifiedWalletAccounts.types';\n\ntype SetUnverifiedWalletAccountsParams = {\n  unverifiedWalletAccountsToUpdate: UnverifiedWalletAccount[];\n};\n\n/**\n * Updates the unverified wallet account in the client state.\n * This will add new wallet accounts and override those with matching ids,\n * but will leave other preexisting wallet accounts unchanged.\n */\nexport const setUnverifiedWalletAccounts = (\n  { unverifiedWalletAccountsToUpdate }: SetUnverifiedWalletAccountsParams,\n  client: DynamicClient\n): void => {\n  if (unverifiedWalletAccountsToUpdate.length === 0) {\n    return;\n  }\n\n  const core = getCore(client);\n\n  const unverifiedWalletAccountsToUpdateIds =\n    unverifiedWalletAccountsToUpdate.map(({ id }) => id);\n\n  const filteredUnverifiedWalletAccounts: UnverifiedWalletAccount[] = core.state\n    .get()\n    .unverifiedWalletAccounts.filter(\n      (unverifiedWalletAccount) =>\n        !unverifiedWalletAccountsToUpdateIds.includes(\n          unverifiedWalletAccount.id\n        )\n    );\n\n  core.state.set({\n    unverifiedWalletAccounts: [\n      ...filteredUnverifiedWalletAccounts,\n      ...unverifiedWalletAccountsToUpdate,\n    ],\n  });\n};\n","type FormatSignInMessageParams = {\n  address: string;\n  blockchainName: string;\n  chainId?: string;\n  domain: string;\n  issuedAt?: string;\n  nonce: string;\n  requestId?: string;\n  resources?: string[];\n  statement?: string;\n  uri: string;\n};\n\n/**\n * Formats a sign in message to prove ownership of an address.\n */\nexport const formatSignInMessage = async ({\n  domain,\n  blockchainName,\n  address,\n  uri,\n  chainId,\n  nonce,\n  issuedAt,\n  requestId,\n  statement,\n  resources,\n}: FormatSignInMessageParams) => {\n  // This format follows the sign-in with ethereum (SIWE) standard,\n  // but we are using it also for non-ethereum wallets for now (eg. Solana)\n  // for more context on format and fields, please see:\n  // https://docs.login.xyz/general-information/siwe-overview/eip-4361\n  const header = `${domain} wants you to sign in with your ${blockchainName} account:`;\n  const prefix = [header, address].join('\\n');\n\n  // If there is a statement, we want to add a gap between the prefix and the statement\n  // two times '\\n', first to move statement to next line and second to add a gap between prefix and statement\n  const prefixWithStatementGap = statement ? '\\n\\n' : '\\n';\n  const prefixWithStatement = `${[prefix, statement].join(\n    prefixWithStatementGap\n  )}\\n`;\n\n  const suffixFields: string[] = [];\n  suffixFields.push(`URI: ${uri}`);\n  suffixFields.push('Version: 1');\n  if (chainId) {\n    suffixFields.push(`Chain ID: ${chainId}`);\n  }\n\n  suffixFields.push(`Nonce: ${nonce}`);\n\n  if (issuedAt) {\n    suffixFields.push(`Issued At: ${issuedAt}`);\n  }\n\n  if (requestId) {\n    suffixFields.push(`Request ID: ${requestId}`);\n  }\n\n  if (resources?.length) {\n    suffixFields.push(\n      `Resources:${resources.map((resource) => '\\n- ' + resource).join()}`\n    );\n  }\n\n  const suffix = suffixFields.join('\\n');\n\n  return [prefixWithStatement, suffix].join('\\n');\n};\n","import { getCore } from '../../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../../client/types';\n\nexport const createSignInMessageStatement = (client: DynamicClient) => {\n  const core = getCore(client);\n\n  const appName =\n    core.metadata?.name ?? client.projectSettings?.general.displayName;\n\n  return `Welcome to ${appName}. Signing is the only way we can truly know that you are the owner of the wallet you are connecting. Signing is a safe, gas-less transaction that does not in any way give ${appName} permission to perform any transactions with your wallet.`;\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../client/types';\nimport { checkAndRaiseWalletAccountsChangedEvent } from '../../../auth/updateAuthFromVerifyResponse/checkAndRaiseWalletAccountsChangedEvent';\nimport type { UnverifiedWalletAccount } from '../unverifiedWalletAccounts.types';\n\ntype RemoveUnverifiedWalletAccountParams = {\n  unverifiedWalletAccount: UnverifiedWalletAccount;\n};\n\n/**\n * Removes an unverified wallet account from the client's state.\n */\nexport const removeUnverifiedWalletAccount = (\n  { unverifiedWalletAccount }: RemoveUnverifiedWalletAccountParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  const previousState = core.state.get();\n\n  const { unverifiedWalletAccounts } = core.state.get();\n\n  const filteredUnverifiedWalletAccounts = unverifiedWalletAccounts.filter(\n    (account) => account.id !== unverifiedWalletAccount.id\n  );\n\n  core.state.set({\n    unverifiedWalletAccounts: filteredUnverifiedWalletAccounts,\n  });\n\n  /**\n   * We check before raising because the wallet account we are removing might still\n   * be present in wallet accounts due to having been moved to verified credentials.\n   */\n  checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);\n};\n","/**\n * Check if the given value is an Error object\n */\nexport const isError = (error: unknown): error is Error =>\n  error instanceof Error;\n","import { isError } from '../isError';\n\n/**\n * Check if the given value is an Error object with a specific code\n */\nexport const isErrorWithCode = <T extends string>(\n  error: unknown,\n  code: T\n): error is Error & { code: T } => {\n  if (!isError(error)) return false;\n\n  return 'code' in error && error.code === code;\n};\n","import type {\n  ChainEnum,\n  VerifyResponse,\n  WalletAddressType,\n  WalletProviderEnum,\n} from '@dynamic-labs/sdk-api-core';\n\nimport { getCore } from '../../../client/core/getCore';\nimport type { DynamicClient } from '../../../client/types';\nimport { isErrorWithCode } from '../../../utils/isErrorWithCode';\nimport { createApiClient } from '../../apiClient';\nimport { consumeCaptchaToken } from '../../captcha/consumeCaptchaToken';\nimport type { Chain } from '../../chain';\nimport { normalizeWalletNameWithChain } from '../utils/normalizeWalletNameWithChain';\nimport type { WalletAddressWithType } from '../walletAccount/walletAccount.types';\nimport { WalletAlreadyLinkedToAnotherUserError } from './../../../errors/WalletAlreadyLinkedToAnotherUserError';\n\ntype VerifyMessageSignatureOwnershipParams = {\n  addressesWithTypes?: WalletAddressWithType[];\n  chain: Chain;\n  isTransfer?: boolean;\n  messageToSign: string;\n  signature: string;\n  walletAddress: string;\n  walletDisplayName: string;\n  walletProviderType: WalletProviderEnum;\n};\n\n/**\n * Verifies a signed message by calling either the verifyLink, verifyTransfer or verify API function,\n * depending on whether the user is signing in, linking or transferring a wallet.\n *\n * Does NOT call updateAuthFromVerifyResponse, it should be called from the return of this function.\n */\nexport const verifyMessageSignatureOwnership = async (\n  {\n    messageToSign,\n    walletAddress,\n    addressesWithTypes,\n    signature,\n    chain,\n    isTransfer = false,\n    walletDisplayName,\n    walletProviderType,\n  }: VerifyMessageSignatureOwnershipParams,\n  client: DynamicClient\n): Promise<VerifyResponse> => {\n  const core = getCore(client);\n  const apiClient = createApiClient({}, client);\n\n  const walletName = normalizeWalletNameWithChain({\n    chain,\n    displayName: walletDisplayName,\n  });\n\n  let verifyApiFunction;\n\n  if (!client.user) {\n    verifyApiFunction = apiClient.verify.bind(apiClient);\n  } else if (isTransfer) {\n    verifyApiFunction = apiClient.verifyTransfer.bind(apiClient);\n  } else {\n    verifyApiFunction = apiClient.verifyLink.bind(apiClient);\n  }\n\n  try {\n    return await verifyApiFunction({\n      environmentId: core.environmentId,\n      verifyRequest: {\n        // mapping to handle typecasting for address type\n        additionalWalletAddresses: addressesWithTypes?.map((address) => ({\n          address: address.address,\n          publicKey: address.publicKey,\n          type: address.type as WalletAddressType,\n        })),\n        captchaToken: consumeCaptchaToken(client),\n        // eslint-disable-next-line custom-rules/ban-chain-enum\n        chain: chain as ChainEnum,\n        messageToSign,\n        publicWalletAddress: walletAddress,\n        signedMessage: signature,\n        walletName,\n        walletProvider: walletProviderType,\n      },\n    });\n  } catch (error) {\n    if (\n      isErrorWithCode(error, 'reassign_wallet_confirm') ||\n      isErrorWithCode(error, 'merge_accounts_confirmation')\n    ) {\n      throw new WalletAlreadyLinkedToAnotherUserError({\n        cause: error,\n      });\n    }\n\n    throw error;\n  }\n};\n","import { getCore } from '../../../../../client/core/getCore';\nimport type { DynamicClient } from '../../../../../client/types';\n\ntype updateWalletProviderKeysForVerifiedCredentialsParams = {\n  keysToUpdate: Record<string, string>;\n};\n\nexport const updateWalletProviderKeysForVerifiedCredentials = (\n  { keysToUpdate }: updateWalletProviderKeysForVerifiedCredentialsParams,\n  client: DynamicClient\n) => {\n  const core = getCore(client);\n\n  core.state.set({\n    walletProviderKeyMap: {\n      ...core.state.get().walletProviderKeyMap,\n      ...keysToUpdate,\n    },\n  });\n};\n","import type { Chain } from '../../../chain';\nimport { CHAINS_INFO_MAP } from '../../constants';\n\n/**\n * Maps the chain name from the API to the SDK chain name\n */\nexport const getSdkChainFromApiChainName = (\n  chainName: string\n): Chain | null => {\n  const chains = Object.keys(CHAINS_INFO_MAP) as Chain[];\n\n  const chain = chains.find(\n    (chain) => CHAINS_INFO_MAP[chain].apiChainName === chainName\n  );\n\n  return chain || null;\n};\n","import { getCore } from '../../../../client/core/getCore';\nimport { getDefaultClient } from '../../../../client/defaultClient';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport { getSdkChainFromApiChainName } from '../getSdkChainFromApiChainName';\nimport type { NetworkData } from '../networkProvider/networkProvider.types';\n\n/**\n * Retrieves all available network configurations from project settings.\n *\n * This function returns detailed configuration data for all networks enabled\n * in your Dynamic project, including RPC URLs, native currencies, and metadata.\n *\n * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.\n * @returns An array of network configuration data for all enabled networks.\n */\nexport const getNetworksData = (client = getDefaultClient()): NetworkData[] => {\n  const { state } = getCore(client);\n\n  const { projectSettings } = state.get();\n\n  assertDefined(projectSettings, 'projectSettings not found');\n\n  const networks = projectSettings.networks;\n\n  if (!networks) {\n    return [];\n  }\n\n  const networksData = networks\n    .map((network) => {\n      if (!network.chainName) return [];\n\n      const chain = getSdkChainFromApiChainName(network.chainName);\n\n      if (!network?.networks?.length || !chain) return [];\n\n      return network.networks.map((networkConfiguration) => ({\n        blockExplorerUrls: networkConfiguration.blockExplorerUrls,\n        chain,\n        cluster: networkConfiguration.cluster,\n        displayName:\n          networkConfiguration.vanityName || networkConfiguration.name,\n        genesisHash: networkConfiguration.genesisHash,\n        iconUrl: networkConfiguration.iconUrls[0],\n        nativeCurrency: {\n          decimals: networkConfiguration.nativeCurrency.decimals,\n          iconUrl: networkConfiguration.nativeCurrency.iconUrl,\n          name: networkConfiguration.nativeCurrency.name,\n          symbol: networkConfiguration.nativeCurrency.symbol,\n        },\n        networkId: networkConfiguration.networkId,\n        rpcUrls: {\n          http: [\n            ...(networkConfiguration.privateCustomerRpcUrls ?? []),\n            ...(networkConfiguration.rpcUrls ?? []),\n          ],\n        },\n        testnet: networkConfiguration.isTestnet ?? false,\n      }));\n    })\n    .flat();\n\n  return networksData;\n};\n","import type { Chain } from '../../../../chain';\nimport type {\n  NetworkProviderBuilder,\n  NetworkProviderBuilderRegistry,\n} from '../networkProviderBuilderRegistry.types';\n\nexport const createNetworkProviderBuilderRegistry =\n  (): NetworkProviderBuilderRegistry => {\n    const registry = new Map<Chain, NetworkProviderBuilder>();\n\n    return {\n      get: () => registry,\n      register: (networkProviderBuilder) => {\n        registry.set(networkProviderBuilder.chain, networkProviderBuilder);\n      },\n    };\n  };\n","import { createRuntimeServiceAccessKey } from '../../../../../services/runtimeServices';\nimport { createNetworkProviderBuilderRegistry } from '../createNetworkProviderBuilderRegistry';\n\nexport const getNetworkProviderBuilderRegistry = createRuntimeServiceAccessKey(\n  'networkProviderBuilderRegistry',\n  createNetworkProviderBuilderRegistry\n);\n","import type { DynamicClient } from '../../../../client/types';\nimport { getNetworksData } from '../getNetworksData';\nimport type { NetworkProvider } from '../networkProvider';\nimport { getNetworkProviderBuilderRegistry } from '../networkProviderBuilderRegistry';\n\n/**\n * Retrieves all registered network providers for enabled chains.\n */\nexport const getNetworkProviders = (\n  client: DynamicClient\n): NetworkProvider[] => {\n  const networkProviderBuilderRegistry =\n    getNetworkProviderBuilderRegistry(client);\n\n  const registeredNetworkProviderBuilders = Array.from(\n    networkProviderBuilderRegistry.get().values()\n  );\n\n  const networksData = getNetworksData(client);\n\n  const networkProviders = registeredNetworkProviderBuilders.map(\n    ({ builder, chain }) => {\n      const networksDataForChain = networksData.filter(\n        (networkData) => networkData.chain === chain\n      );\n\n      return networksDataForChain.map(builder);\n    }\n  );\n\n  return networkProviders.flat();\n};\n","import type { DynamicClient } from '../../../../client/types';\nimport { NoNetworkProvidersError } from '../../../../errors/NoNetworkProvidersError';\nimport { assertDefined } from '../../../../utils/assertDefined';\nimport type { Chain } from '../../../chain';\nimport { getNetworkProviders } from '../getNetworkProviders';\nimport type { NetworkProvider } from '../networkProvider/networkProvider.types';\n\ntype GetNetworkProviderFromNetworkIdProps = {\n  chain: Chain;\n  networkId: string;\n};\n\nexport const getNetworkProviderFromNetworkId = (\n  { networkId, chain }: GetNetworkProviderFromNetworkIdProps,\n  client: DynamicClient\n): NetworkProvider => {\n  const networkProviders = getNetworkProviders(client);\n\n  if (networkProviders.length === 0) {\n    throw new NoNetworkProvidersError();\n  }\n\n  const networkProvider = networkProviders.find(\n    (networkProvider) =>\n      networkProvider.networkId === networkId && networkProvider.chain === chain\n  );\n\n  assertDefined(\n    networkProvider,\n    `No network provider found for chain ${chain} with network id ${networkId}`\n  );\n\n  return networkProvider;\n};\n"],"mappings":"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"}