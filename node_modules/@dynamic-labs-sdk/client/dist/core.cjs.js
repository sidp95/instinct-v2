const require_getNetworkProviderFromNetworkId = require('./getNetworkProviderFromNetworkId-CTKZxd1T.cjs.js');
const require_constants = require('./constants-BbG0v26E.cjs.js');
const require_getVerifiedCredentialForWalletAccount = require('./getVerifiedCredentialForWalletAccount-DAb9lFwa.cjs.js');
require('./isMfaRequiredForAction-CAwdzRA9.cjs.js');
const require_getSignedSessionId = require('./getSignedSessionId-QJpJQ_Jz.cjs.js');
const require_filterDuplicates = require('./filterDuplicates-DPNky3ug.cjs.js');
let _dynamic_labs_sdk_assert_package_version = require("@dynamic-labs-sdk/assert-package-version");
let zod_mini = require("zod/mini");
zod_mini = require_getNetworkProviderFromNetworkId.__toESM(zod_mini);
let eventemitter3 = require("eventemitter3");
eventemitter3 = require_getNetworkProviderFromNetworkId.__toESM(eventemitter3);

//#region src/errors/ClientsDoNotMatchError.ts
var ClientsDoNotMatchError = class extends require_constants.BaseError {
	constructor() {
		super({
			cause: null,
			code: "clients_do_not_match_error",
			docsUrl: null,
			name: "ClientsDoNotMatchError",
			shortMessage: "Clients do not match"
		});
	}
};

//#endregion
//#region src/errors/MethodNotImplementedError.ts
var MethodNotImplementedError = class extends require_constants.BaseError {
	constructor(methodName) {
		super({
			cause: null,
			code: "method_not_implemented_error",
			docsUrl: null,
			name: "MethodNotImplementedError",
			shortMessage: `This method is not implemented: ${methodName}`
		});
	}
};

//#endregion
//#region src/errors/MultipleClientsFoundError.ts
var MultipleClientsFoundError = class extends require_constants.BaseError {
	constructor() {
		super({
			cause: null,
			code: "multiple_clients_found_error",
			docsUrl: null,
			name: "MultipleClientsFoundError",
			shortMessage: "Multiple Dynamic clients have been initialized. Please provide the intended client for this action explicitly"
		});
	}
};

//#endregion
//#region src/modules/extension/registerExtension/registerExtension.ts
/**
* Registers an extension to the client.
*
* Other extensions can be aware of which extensions are present,
* and allows creating dependencies between extensions.
*
* @param client - The client instance.
* @param extensionKey - The key of the extension to register.
* @returns The client instance.
*/
const registerExtension = ({ extensionKey }, client) => {
	require_constants.getCore(client).extensions.add(extensionKey);
};

//#endregion
//#region src/modules/initializeClient/waitForProjectSettings/waitForProjectSettings.ts
const waitForProjectSettings = async (client) => {
	const projectSettingsTracker = require_constants.getCore(client).initTrack.getTracker(require_getNetworkProviderFromNetworkId.FETCH_PROJECT_SETTINGS_TRACKER_KEY);
	require_constants.assertDefined(projectSettingsTracker, "Project settings tracker not found");
	await projectSettingsTracker.promise;
	require_constants.assertDefined(client.projectSettings, "Project settings still not available after awaiting its tracker");
	return client.projectSettings;
};

//#endregion
//#region src/modules/wallets/networks/createBaseNetworkProvider/createBaseNetworkProvider.ts
const createBaseNetworkProvider = (chain, networkData) => ({
	blockExplorerUrls: networkData.blockExplorerUrls,
	chain,
	displayName: networkData.displayName,
	iconUrl: networkData.iconUrl,
	id: `${chain}-${networkData.networkId}`,
	nativeCurrency: networkData.nativeCurrency,
	networkId: networkData.networkId,
	rpcUrls: networkData.rpcUrls,
	testnet: networkData.testnet
});

//#endregion
//#region src/modules/wallets/networks/getNetworkDataForNetworkId/getNetworkDataForNetworkId.ts
const getNetworkDataForNetworkId = ({ networkId, chain }, client) => {
	return require_getNetworkProviderFromNetworkId.getNetworksData(client).find((networkData) => networkData.networkId === networkId && networkData.chain === chain);
};

//#endregion
//#region src/modules/wallets/networks/lastKnownNetworkRegistry/createLastKnownNetworkRegistry/schema.ts
const networkRegistryStorageKeySchema = require_getNetworkProviderFromNetworkId.createStorageKeySchema({
	key: "lastKnownNetworkRegistry",
	schema: zod_mini.record(zod_mini.string(), zod_mini.string())
});

//#endregion
//#region src/modules/wallets/networks/lastKnownNetworkRegistry/createLastKnownNetworkRegistry/createLastKnownNetworkRegistry.ts
/**
* Creates the registry that keeps tabs on which wallet provider is
* connected to which network.
*
* Reminder that this will not be used for chains that have an internal way to
* switch networks (ex EVM).
*/
const createLastKnownNetworkRegistry = (client) => {
	const core = require_constants.getCore(client);
	const walletProviderKeyToNetworkId = /* @__PURE__ */ new Map();
	const getNetworkId = async ({ walletProviderKey }) => {
		if (walletProviderKeyToNetworkId.has(walletProviderKey)) return { networkId: walletProviderKeyToNetworkId.get(walletProviderKey) };
		const storageRecords = await core.storage.getItem(networkRegistryStorageKeySchema);
		if (storageRecords && storageRecords[walletProviderKey]) {
			const networkId = storageRecords[walletProviderKey];
			walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
			return { networkId };
		}
		const walletProvider = require_getVerifiedCredentialForWalletAccount.getWalletProviderByKey({ walletProviderKey }, client);
		const networkProviders = require_getNetworkProviderFromNetworkId.getNetworkProviders(client);
		if (networkProviders.length === 0) throw new require_getNetworkProviderFromNetworkId.NoNetworkProvidersError();
		const defaultNetworkProvider = networkProviders.find((networkProvider) => networkProvider.chain === walletProvider.chain);
		require_constants.assertDefined(defaultNetworkProvider, `No networks found for chain ${walletProvider.chain}`);
		walletProviderKeyToNetworkId.set(walletProviderKey, defaultNetworkProvider.networkId);
		return { networkId: defaultNetworkProvider.networkId };
	};
	const setNetworkId = async ({ networkId, walletProviderKey }) => {
		walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
		await core.storage.setItem(networkRegistryStorageKeySchema, Object.fromEntries(walletProviderKeyToNetworkId.entries()));
	};
	return {
		getNetworkId,
		setNetworkId
	};
};

//#endregion
//#region src/modules/wallets/networks/lastKnownNetworkRegistry/getLastKnownNetworkRegistry/getLastKnownNetworkRegistry.ts
const getLastKnownNetworkRegistry = require_getVerifiedCredentialForWalletAccount.createRuntimeServiceAccessKey("last-known-network-registry", (client) => createLastKnownNetworkRegistry(client));

//#endregion
//#region src/modules/wallets/utils/formatWalletProviderGroupKey/formatWalletProviderGroupKey.ts
const formatWalletProviderGroupKey = (walletName) => walletName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();

//#endregion
//#region src/modules/wallets/utils/getInjectedProviderFromWindow/getInjectedProviderFromWindow.ts
const getInjectedProviderFromWindow = (path) => {
	if (typeof window === "undefined") return null;
	const target = path.split(".").reduce((acc, key) => acc == null ? null : acc[key], window);
	if (typeof target !== "object" || target === null) return null;
	if (Array.isArray(target)) return target.length > 0 ? target[0] : null;
	const providersArray = target.providers;
	if (providersArray && Array.isArray(providersArray)) return providersArray.length > 0 ? providersArray[0] : null;
	return target;
};

//#endregion
//#region src/modules/wallets/walletProvider/defaultImplementations/getActiveNetworkIdFromLastKnownRegistry/getActiveNetworkIdFromLastKnownRegistry.ts
const getActiveNetworkIdFromLastKnownRegistry = async ({ client, walletProviderKey }) => {
	return getLastKnownNetworkRegistry(client).getNetworkId({ walletProviderKey });
};

//#endregion
//#region src/modules/wallets/walletProvider/defaultImplementations/switchActiveNetworkInLastKnownRegistry/switchActiveNetworkInLastKnownRegistry.ts
const switchActiveNetworkInLastKnownRegistry = async ({ client, networkId, walletProviderKey }) => {
	await getLastKnownNetworkRegistry(client).setNetworkId({
		networkId,
		walletProviderKey
	});
};

//#endregion
//#region src/modules/wallets/walletProvider/events/createWalletProviderEventEmitter/createWalletProviderEventEmitter.ts
/**
* Takes a callback that registers handlers for the external wallet provider.
* Returns both a getter of an eventEmitter that can be exposed via the wallet provider
* and a callback that will be used to destroy the listeners.
*/
const createWalletProviderEventEmitter = ({ removeEventListeners, setupEventListeners, supportedEvents = [
	"accountsChanged",
	"disconnected",
	"networkChanged"
] }) => {
	let eventEmitter;
	/** Value returned by setupEventListeners */
	let setupReturnValue;
	const handleAccountsChanged = (params) => {
		require_constants.assertDefined(eventEmitter, "Event emitter not defined");
		eventEmitter.emit("accountsChanged", params);
	};
	const handleDisconnected = () => {
		require_constants.assertDefined(eventEmitter, "Event emitter not defined");
		eventEmitter.emit("disconnected");
	};
	const handleNetworkChanged = (params) => {
		require_constants.assertDefined(eventEmitter, "Event emitter not defined");
		eventEmitter.emit("networkChanged", params);
	};
	const cleanupEventEmitter = () => {
		if (!eventEmitter) return;
		removeEventListeners({
			handleAccountsChanged,
			handleDisconnected,
			handleNetworkChanged,
			setupReturnValue
		});
		eventEmitter = void 0;
	};
	const getEventEmitter = () => {
		if (!eventEmitter) {
			eventEmitter = new eventemitter3.default();
			setupReturnValue = setupEventListeners({
				handleAccountsChanged,
				handleDisconnected,
				handleNetworkChanged
			});
		}
		return Object.assign(eventEmitter, { supportedEvents });
	};
	return {
		cleanupEventEmitter,
		getEventEmitter
	};
};

//#endregion
//#region src/utils/bufferToBase64/bufferToBase64.ts
const bufferToBase64 = (buf) => {
	const binstr = Array.prototype.map.call(buf, (ch) => String.fromCharCode(ch)).join("");
	return require_constants.getBuffer().from(binstr, "binary").toString("base64");
};

//#endregion
//#region src/exports/core.ts
(0, _dynamic_labs_sdk_assert_package_version.assertPackageVersion)(require_constants.name, require_constants.version);

//#endregion
exports.APIError = require_constants.APIError;
exports.CHAINS_INFO_MAP = require_constants.CHAINS_INFO_MAP;
exports.CannotTrackError = require_getNetworkProviderFromNetworkId.CannotTrackError;
exports.ClientNotFoundError = require_constants.ClientNotFoundError;
exports.ClientsDoNotMatchError = ClientsDoNotMatchError;
exports.DYNAMIC_ICONIC_SPRITE_URL = require_constants.DYNAMIC_ICONIC_SPRITE_URL;
exports.DYNAMIC_SDK_API_VERSION = require_constants.DYNAMIC_SDK_API_VERSION;
exports.InvalidStorageSet = require_getNetworkProviderFromNetworkId.InvalidStorageSet;
exports.InvalidWalletProviderKeyError = require_getVerifiedCredentialForWalletAccount.InvalidWalletProviderKeyError;
exports.MethodNotImplementedError = MethodNotImplementedError;
exports.MultipleClientsFoundError = MultipleClientsFoundError;
exports.NoWalletProviderFoundError = require_getVerifiedCredentialForWalletAccount.NoWalletProviderFoundError;
exports.ValueMustBeDefinedError = require_constants.ValueMustBeDefinedError;
exports.WalletProviderPriority = require_getVerifiedCredentialForWalletAccount.WalletProviderPriority;
exports.assertDefined = require_constants.assertDefined;
exports.bufferToBase64 = bufferToBase64;
exports.consumeCaptchaToken = require_getNetworkProviderFromNetworkId.consumeCaptchaToken;
exports.consumeMfaTokenIfRequiredForAction = require_getSignedSessionId.consumeMfaTokenIfRequiredForAction;
exports.createApiClient = require_constants.createApiClient;
exports.createBaseNetworkProvider = createBaseNetworkProvider;
exports.createDeferredPromise = require_getNetworkProviderFromNetworkId.createDeferredPromise;
exports.createLocalStorageAdapter = require_getNetworkProviderFromNetworkId.createLocalStorageAdapter;
exports.createLogger = require_getNetworkProviderFromNetworkId.createLogger;
exports.createRuntimeServiceAccessKey = require_getVerifiedCredentialForWalletAccount.createRuntimeServiceAccessKey;
exports.createSignInMessageStatement = require_getNetworkProviderFromNetworkId.createSignInMessageStatement;
exports.createStorage = require_getNetworkProviderFromNetworkId.createStorage;
exports.createStorageKeySchema = require_getNetworkProviderFromNetworkId.createStorageKeySchema;
exports.createVisit = require_getNetworkProviderFromNetworkId.createVisit;
exports.createWalletProviderEventEmitter = createWalletProviderEventEmitter;
exports.emitEvent = require_getVerifiedCredentialForWalletAccount.emitEvent;
exports.emitWalletAccountsChangedEvent = require_getVerifiedCredentialForWalletAccount.emitWalletAccountsChangedEvent;
exports.filterDuplicates = require_filterDuplicates.filterDuplicates;
exports.formatSignInMessage = require_getNetworkProviderFromNetworkId.formatSignInMessage;
exports.formatWalletAccountId = require_getVerifiedCredentialForWalletAccount.formatWalletAccountId;
exports.formatWalletProviderGroupKey = formatWalletProviderGroupKey;
exports.formatWalletProviderKey = require_getVerifiedCredentialForWalletAccount.formatWalletProviderKey;
exports.getActiveNetworkIdFromLastKnownRegistry = getActiveNetworkIdFromLastKnownRegistry;
exports.getBuffer = require_constants.getBuffer;
exports.getChainFromVerifiedCredentialChain = require_constants.getChainFromVerifiedCredentialChain;
exports.getCore = require_constants.getCore;
exports.getDefaultClient = require_constants.getDefaultClient;
exports.getInjectedProviderFromWindow = getInjectedProviderFromWindow;
exports.getLastKnownNetworkRegistry = getLastKnownNetworkRegistry;
exports.getNetworkDataForNetworkId = getNetworkDataForNetworkId;
exports.getNetworkProviderBuilderRegistry = require_getNetworkProviderFromNetworkId.getNetworkProviderBuilderRegistry;
exports.getNetworkProviderFromNetworkId = require_getNetworkProviderFromNetworkId.getNetworkProviderFromNetworkId;
exports.getNetworkProviders = require_getNetworkProviderFromNetworkId.getNetworkProviders;
exports.getSignedSessionId = require_getSignedSessionId.getSignedSessionId;
exports.getVerifiedCredentialForWalletAccount = require_getVerifiedCredentialForWalletAccount.getVerifiedCredentialForWalletAccount;
exports.getWalletProviderFromWalletAccount = require_getVerifiedCredentialForWalletAccount.getWalletProviderFromWalletAccount;
exports.getWalletProviderRegistry = require_getVerifiedCredentialForWalletAccount.getWalletProviderRegistry;
exports.getWalletProviders = require_getVerifiedCredentialForWalletAccount.getWalletProviders;
exports.hasExtension = require_getNetworkProviderFromNetworkId.hasExtension;
exports.isCookieEnabled = require_constants.isCookieEnabled;
exports.normalizeWalletNameWithChain = require_getVerifiedCredentialForWalletAccount.normalizeWalletNameWithChain;
exports.registerExtension = registerExtension;
exports.removeUnverifiedWalletAccount = require_getNetworkProviderFromNetworkId.removeUnverifiedWalletAccount;
exports.setCaptchaToken = require_getNetworkProviderFromNetworkId.setCaptchaToken;
exports.setUnverifiedWalletAccounts = require_getNetworkProviderFromNetworkId.setUnverifiedWalletAccounts;
exports.splitWalletProviderKey = require_getVerifiedCredentialForWalletAccount.splitWalletProviderKey;
exports.subscribeWithSelector = require_getNetworkProviderFromNetworkId.subscribeWithSelector;
exports.switchActiveNetworkInLastKnownRegistry = switchActiveNetworkInLastKnownRegistry;
exports.updateAuthFromVerifyResponse = require_getVerifiedCredentialForWalletAccount.updateAuthFromVerifyResponse;
exports.updateWalletProviderKeysForVerifiedCredentials = require_getNetworkProviderFromNetworkId.updateWalletProviderKeysForVerifiedCredentials;
exports.verifyMessageSignatureOwnership = require_getNetworkProviderFromNetworkId.verifyMessageSignatureOwnership;
exports.waitForProjectSettings = waitForProjectSettings;
//# sourceMappingURL=core.cjs.js.map