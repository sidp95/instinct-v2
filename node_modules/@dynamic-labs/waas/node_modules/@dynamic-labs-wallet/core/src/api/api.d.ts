import type { ForwardMPCClient } from '@dynamic-labs-wallet/forward-mpc-client';
import type { RoomTypeEnum, SignMessageEvmTransaction, SignMessageEvmUserOperation, SignMessageSvmTransaction } from '@dynamic-labs/sdk-api-core';
import { type BackupLocation } from '../constants.js';
import type { ThresholdSignatureScheme } from '../mpc/constants.js';
import { AuthMode, type BackupLocationWithExternalKeyShareId, type BitcoinConfig, type EncryptedDelegatedKeyShareEnvelope, type KeygenCompleteResponse, type OpenRoomResponse, type ReshareResponse, type TraceContext, type WaasWalletResponse } from '../types.js';
import { BaseClient } from './client.js';
export declare class DynamicApiClient extends BaseClient {
    constructor({ environmentId, authToken, backupServiceAuthToken, baseApiUrl, authMode, sdkVersion, forwardMPCClient, baseClientKeysharesRelayApiUrl, }: {
        environmentId: string;
        authToken?: string;
        backupServiceAuthToken?: string;
        baseApiUrl?: string;
        authMode?: AuthMode;
        sdkVersion?: string;
        forwardMPCClient?: ForwardMPCClient;
        baseClientKeysharesRelayApiUrl?: string;
    });
    getBackupRelayToken({ traceContext }: {
        traceContext?: TraceContext;
    }): Promise<any>;
    authenticateApiToken({ environmentId }: {
        environmentId: string;
    }): Promise<import("axios").AxiosResponse<any, any, {}>>;
    createWalletAccount({ chainName, clientKeygenIds, dynamicRequestId, thresholdSignatureScheme, skipLock, bitcoinConfig, onError, onCeremonyComplete, traceContext, }: {
        chainName: string;
        dynamicRequestId?: string;
        clientKeygenIds: string[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
        skipLock?: boolean;
        bitcoinConfig?: BitcoinConfig;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
        traceContext?: TraceContext;
    }): Promise<KeygenCompleteResponse>;
    signMessage({ dynamicRequestId, walletId, message, onError, isFormatted, mfaToken, roomId, context, forwardMPCClientEnabled, traceContext, bitcoinConfig, }: {
        dynamicRequestId?: string;
        walletId: string;
        message: string;
        onError?: (error: Error) => void;
        isFormatted?: boolean;
        mfaToken?: string;
        roomId?: string;
        context?: SignMessageEvmTransaction | SignMessageSvmTransaction | SignMessageEvmUserOperation;
        forwardMPCClientEnabled?: boolean;
        traceContext?: TraceContext;
        bitcoinConfig?: BitcoinConfig;
    }): Promise<OpenRoomResponse>;
    refreshWalletAccountShares({ dynamicRequestId, walletId, onError, mfaToken, traceContext, }: {
        dynamicRequestId?: string;
        walletId: string;
        onError?: (error: Error) => void;
        mfaToken?: string;
        traceContext?: TraceContext;
    }): Promise<{
        roomId: string;
        serverKeygenIds: string[];
    }>;
    reshare({ walletId, dynamicRequestId, clientKeygenIds, oldThresholdSignatureScheme, newThresholdSignatureScheme, delegateToProjectEnvironment, revokeDelegation, mfaToken, onError, traceContext, }: {
        dynamicRequestId?: string;
        walletId: string;
        clientKeygenIds: string[];
        oldThresholdSignatureScheme: ThresholdSignatureScheme;
        newThresholdSignatureScheme: ThresholdSignatureScheme;
        delegateToProjectEnvironment?: boolean;
        revokeDelegation?: boolean;
        mfaToken?: string;
        onError?: (error: Error) => void;
        traceContext?: TraceContext;
    }): Promise<ReshareResponse>;
    exportKey({ mfaToken, dynamicRequestId, walletId, exportId, bitcoinConfig, onError, traceContext, }: {
        mfaToken?: string;
        dynamicRequestId?: string;
        walletId: string;
        exportId: string;
        bitcoinConfig?: BitcoinConfig;
        onError?: (error: Error) => void;
        traceContext?: TraceContext;
    }): Promise<OpenRoomResponse>;
    getDelegatedEncryptionKey({ environmentId, traceContext, }: {
        environmentId: string;
        traceContext?: TraceContext;
    }): Promise<any>;
    publishDelegatedKeyShare({ walletId, encryptedKeyShare, signedSessionId, requiresSignedSessionId, dynamicRequestId, traceContext, }: {
        walletId: string;
        encryptedKeyShare: EncryptedDelegatedKeyShareEnvelope;
        dynamicRequestId: string;
        signedSessionId?: string;
        requiresSignedSessionId?: boolean;
        traceContext?: TraceContext;
    }): Promise<{
        data: any;
        status: number;
    }>;
    storeEncryptedBackupByWallet({ walletId, encryptedKeyShares, passwordEncrypted, signedSessionId, encryptionVersion, requiresSignedSessionId, dynamicRequestId, traceContext, }: {
        walletId: string;
        encryptedKeyShares: string[];
        passwordEncrypted: boolean;
        dynamicRequestId: string;
        signedSessionId?: string;
        encryptionVersion?: string;
        requiresSignedSessionId?: boolean;
        traceContext?: TraceContext;
    }): Promise<any>;
    markKeySharesAsBackedUp({ walletId, locations, dynamicRequestId, traceContext, }: {
        walletId: string;
        locations: BackupLocationWithExternalKeyShareId[];
        dynamicRequestId: string;
        traceContext?: TraceContext;
    }): Promise<{
        message: string;
        walletId: string;
        locationsWithKeyShares: {
            location: BackupLocation;
            keyShareId: string;
            externalKeyShareId?: string;
        }[];
    }>;
    recoverEncryptedBackupByWallet({ walletId, keyShareIds, signedSessionId, mfaToken, requiresSignedSessionId, traceContext, }: {
        walletId: string;
        keyShareIds?: string[];
        signedSessionId?: string;
        mfaToken?: string;
        requiresSignedSessionId?: boolean;
        traceContext?: TraceContext;
    }): Promise<any>;
    getAccessToken({ oauthAccountId, traceContext, }: {
        oauthAccountId: string;
        traceContext?: TraceContext;
    }): Promise<any>;
    importPrivateKey({ chainName, dynamicRequestId, clientKeygenIds, thresholdSignatureScheme, bitcoinConfig, onError, onCeremonyComplete, traceContext, legacyWalletId, }: {
        dynamicRequestId?: string;
        chainName: string;
        clientKeygenIds: string[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
        bitcoinConfig?: BitcoinConfig;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
        traceContext?: TraceContext;
        /** ID of the legacy embedded wallet being upgraded to v3 */
        legacyWalletId?: string;
    }): Promise<KeygenCompleteResponse>;
    getUser(dynamicRequestId: string, traceContext?: TraceContext): Promise<any>;
    refreshUser(traceContext?: TraceContext): Promise<any>;
    getEnvironmentSettings(traceContext?: TraceContext): Promise<any>;
    getWaasWalletById({ walletId, traceContext, }: {
        walletId: string;
        traceContext?: TraceContext;
    }): Promise<WaasWalletResponse>;
    /**
     * Fetch a single WaaS wallet by ID using the /sdk/{environmentId}/waas/{walletId} endpoint.
     * This endpoint returns user information with verified credentials filtered to only include the specified WaaS wallet.
     */
    getWaasWalletByAddress({ walletAddress, traceContext, }: {
        walletAddress: string;
        traceContext?: TraceContext;
    }): Promise<WaasWalletResponse>;
    delegatedSignMessage({ walletId, message, isFormatted, dynamicRequestId, onError, context, traceContext, }: {
        walletId: string;
        message: string;
        isFormatted?: boolean;
        dynamicRequestId: string;
        onError?: (error: Error) => void;
        context?: SignMessageEvmTransaction | SignMessageSvmTransaction | SignMessageEvmUserOperation;
        traceContext?: TraceContext;
    }): Promise<OpenRoomResponse>;
    createRooms({ walletId, roomType, roomCount, traceContext, }: {
        walletId: string;
        roomType?: RoomTypeEnum;
        roomCount?: number;
        traceContext?: TraceContext;
    }): Promise<any>;
    createRoomsWithoutWalletId({ roomType, thresholdSignatureScheme, roomCount, traceContext, }: {
        roomType: RoomTypeEnum;
        thresholdSignatureScheme: ThresholdSignatureScheme;
        roomCount?: number;
        traceContext?: TraceContext;
    }): Promise<any>;
}
//# sourceMappingURL=api.d.ts.map