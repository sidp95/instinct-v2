'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { DynamicWalletClient } from '@dynamic-labs-wallet/browser-wallet-client';
import { MFAAction } from '@dynamic-labs/sdk-api-core';
import { DynamicError } from '@dynamic-labs/utils';
import { version } from '../package.js';
import { DEFAULT_BASE_API_URL, DEFAULT_BASE_MPC_RELAY_API_URL } from '../utils/constants.js';
import { InstrumentationTimer } from '../utils/instrumentation.js';

// This class is common across all waas connectors
class WaasExportHandler {
    constructor() {
        this.iframeStamper = null;
    }
    setIframeStamper(iframe) {
        this.iframeStamper = iframe;
    }
    clear() {
        if (this.iframeStamper) {
            this.iframeStamper.remove();
            this.iframeStamper = null;
        }
    }
}
const withDynamicWaas = (BaseClass) => {
    class DynamicWaasMixin extends BaseClass {
        setGetAuthTokenFunction(getAuthToken) {
            this.getAuthToken = getAuthToken;
        }
        setWaasAuthMode(authMode) {
            this.authMode = authMode;
        }
        setGetMfaTokenFunction(getMfaToken) {
            this.getMfaToken = getMfaToken;
        }
        setEnvironmentId(environmentId) {
            this.environmentId = environmentId;
        }
        setBaseApiUrl(baseApiUrl) {
            this.baseApiUrl = baseApiUrl;
        }
        setBaseClientKeysharesRelayApiUrl(baseClientKeysharesRelayApiUrl) {
            this.baseClientKeysharesRelayApiUrl = baseClientKeysharesRelayApiUrl;
        }
        setRelayUrl(relayUrl) {
            this.relayUrl = relayUrl;
        }
        setGetSignedSessionIdFunction(getSignedSessionId) {
            this.getSignedSessionId = getSignedSessionId;
        }
        delegateKeyShares(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new Error('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new Error('Signed session ID is required');
                }
                const authToken = (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this);
                if (!authToken) {
                    throw new Error('Auth token is required');
                }
                return walletClient.delegateKeyShares({
                    accountAddress,
                    authToken,
                    password,
                    signedSessionId,
                });
            });
        }
        constructor(...args) {
            super(...args);
            this.name = 'Dynamic Waas';
            this.overrideKey = 'dynamicwaas';
            this.isEmbeddedWallet = true;
            this.authMode = 'header';
            // Initialize export handler
            this.__exportHandler = new WaasExportHandler();
            // Get the class name from the constructor
            const { connectedChain } = this;
            // Map class names to chain names
            const chainNameMap = {
                BTC: 'BTC',
                EVM: 'EVM',
                SOL: 'SVM',
                SUI: 'SUI',
                TON: 'TON',
            };
            const chainName = chainNameMap[connectedChain];
            if (!chainName) {
                throw new DynamicError(`Unsupported chain: ${connectedChain}`);
            }
            this.chainName = chainName;
        }
        createDynamicWaasClient(traceContext) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const authToken = (_a = this.getAuthToken) === null || _a === void 0 ? void 0 : _a.call(this);
                if (!authToken && this.authMode === 'header') {
                    throw new DynamicError('Auth token is required in non-cookie auth mode');
                }
                if (!this.environmentId) {
                    throw new DynamicError('Environment ID is required');
                }
                const client = new DynamicWalletClient({
                    authMode: (this.authMode || 'header'),
                    authToken: authToken || '',
                    baseApiUrl: this.baseApiUrl || DEFAULT_BASE_API_URL,
                    baseClientKeysharesRelayApiUrl: this.baseClientKeysharesRelayApiUrl,
                    baseMPCRelayApiUrl: this.relayUrl || DEFAULT_BASE_MPC_RELAY_API_URL,
                    chainName: this.chainName,
                    environmentId: this.environmentId,
                    sdkVersion: version,
                });
                this.instrumentAsync({
                    context: traceContext,
                    fn: () => __awaiter(this, void 0, void 0, function* () { return client.initialize(); }),
                    operation: 'createDynamicWaasClient',
                    resource: 'initialize',
                });
                return client;
            });
        }
        getWaasWalletClient(traceContext) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.dynamicWaasClient) {
                    this.dynamicWaasClient = yield this.createDynamicWaasClient(traceContext);
                }
                return this.dynamicWaasClient;
            });
        }
        // Common methods that are identical across all connectors
        createWalletAccount() {
            return __awaiter(this, arguments, void 0, function* ({ thresholdSignatureScheme = 'TWO_OF_TWO', password, bitcoinConfig, } = {}) {
                var _a, _b;
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                const createdWallet = yield walletClient.createWalletAccount({
                    authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
                    bitcoinConfig,
                    password,
                    signedSessionId,
                    thresholdSignatureScheme: thresholdSignatureScheme,
                });
                return createdWallet;
            });
        }
        importPrivateKey(_a) {
            return __awaiter(this, arguments, void 0, function* ({ privateKey, thresholdSignatureScheme = 'TWO_OF_TWO', publicAddressCheck, addressType, legacyWalletId, }) {
                var _b, _c;
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                yield walletClient.importPrivateKey({
                    addressType,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    legacyWalletId,
                    privateKey,
                    publicAddressCheck,
                    signedSessionId,
                    thresholdSignatureScheme: thresholdSignatureScheme,
                });
            });
        }
        exportPrivateKey() {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, displayContainer, password, } = {}) {
                var _a, _b, _c;
                const walletClient = yield this.getWaasWalletClient();
                const targetAccountAddress = accountAddress || (yield this.getActiveAccountAddress());
                if (!targetAccountAddress) {
                    throw new DynamicError('Account address is required');
                }
                if (!displayContainer) {
                    throw new DynamicError('Missing display container for export private key');
                }
                const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                this.__exportHandler.setIframeStamper(displayContainer);
                const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                    mfaAction: MFAAction.WalletWaasExport,
                }));
                yield walletClient.exportPrivateKey({
                    accountAddress: targetAccountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    displayContainer,
                    mfaToken,
                    password,
                    signedSessionId,
                });
            });
        }
        getExportHandler() {
            return this.__exportHandler;
        }
        exportClientKeyshares(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                yield walletClient.exportClientKeyshares({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    password,
                    signedSessionId,
                });
            });
        }
        backupKeySharesToGoogleDrive(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                return walletClient.backupKeySharesToGoogleDrive({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    password,
                    signedSessionId,
                });
            });
        }
        exportClientKeysharesFromGoogleDrive(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                return walletClient.exportClientKeysharesFromGoogleDrive({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    password,
                    signedSessionId,
                });
            });
        }
        backupKeySharesToICloud(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                return walletClient.backupKeySharesToICloud({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    password,
                    signedSessionId,
                });
            });
        }
        displayICloudSignIn(_a) {
            return __awaiter(this, arguments, void 0, function* ({ displayContainer, }) {
                const walletClient = yield this.getWaasWalletClient();
                return walletClient.displayICloudSignIn({
                    displayContainer,
                });
            });
        }
        hideICloudSignIn() {
            return __awaiter(this, void 0, void 0, function* () {
                const walletClient = yield this.getWaasWalletClient();
                return walletClient.hideICloudSignIn();
            });
        }
        isICloudAuthenticated() {
            return __awaiter(this, void 0, void 0, function* () {
                const walletClient = yield this.getWaasWalletClient();
                return walletClient.isICloudAuthenticated();
            });
        }
        refreshWalletAccountShares(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c, _d;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                const mfaToken = yield ((_c = this.getMfaToken) === null || _c === void 0 ? void 0 : _c.call(this, {
                    mfaAction: MFAAction.WalletWaasRefresh,
                }));
                return walletClient.refreshWalletAccountShares({
                    accountAddress,
                    authToken: (_d = this.getAuthToken) === null || _d === void 0 ? void 0 : _d.call(this),
                    mfaToken,
                    password,
                    signedSessionId,
                });
            });
        }
        reshareWalletAccountShares(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, thresholdSignatureScheme, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                const wallets = yield walletClient.getWallets();
                const wallet = wallets.find((w) => w.accountAddress === accountAddress);
                if (!wallet) {
                    throw new DynamicError('Wallet not found');
                }
                const oldThresholdSignatureScheme = wallet.thresholdSignatureScheme;
                return walletClient.reshare({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    newThresholdSignatureScheme: thresholdSignatureScheme,
                    oldThresholdSignatureScheme,
                    password,
                    signedSessionId,
                });
            });
        }
        revokeDelegation(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                return walletClient.revokeDelegation({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    password,
                    signedSessionId,
                });
            });
        }
        updatePassword(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, existingPassword, newPassword, }) {
                var _b, _c;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                return walletClient.updatePassword({
                    accountAddress,
                    authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                    existingPassword,
                    newPassword,
                    signedSessionId,
                });
            });
        }
        signRawMessage(_a) {
            return __awaiter(this, arguments, void 0, function* ({ accountAddress, message, password, }) {
                var _b, _c, _d;
                if (!accountAddress) {
                    throw new DynamicError('Account address is required');
                }
                if (message.length !== 64) {
                    throw new DynamicError('Message must be 64 characters long');
                }
                const walletClient = yield this.getWaasWalletClient();
                const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
                if (!signedSessionId) {
                    throw new DynamicError('Signed session ID is required');
                }
                const mfaToken = yield ((_c = this.getMfaToken) === null || _c === void 0 ? void 0 : _c.call(this, {
                    mfaAction: MFAAction.WalletWaasSign,
                }));
                return walletClient.signRawMessage({
                    accountAddress,
                    authToken: (_d = this.getAuthToken) === null || _d === void 0 ? void 0 : _d.call(this),
                    message,
                    mfaToken,
                    password,
                    signedSessionId,
                });
            });
        }
        endSession() {
            return __awaiter(this, void 0, void 0, function* () {
                const waasClient = yield this.getWaasWalletClient();
                if (!waasClient) {
                    return;
                }
                yield waasClient.cleanup();
                this.dynamicWaasClient = undefined;
            });
        }
        /**
         * Get connected accounts by fetching wallets from Waas client.
         */
        getConnectedAccounts() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const walletClient = yield this.getWaasWalletClient();
                    const wallets = yield walletClient.getWallets();
                    const addresses = wallets
                        .map((w) => w === null || w === void 0 ? void 0 : w.accountAddress)
                        .filter((a) => typeof a === 'string');
                    return addresses;
                }
                catch (error) {
                    // If fetching wallets fails, return empty array
                    this.logger.debug('[getConnectedAccounts] Failed to fetch wallets from Waas client', {
                        error,
                    });
                    return [];
                }
            });
        }
        generateTraceId() {
            // Generate a 128-bit trace ID
            // 128-bit = 16 bytes = 32 hexadecimal characters
            const bytes = new Uint8Array(16);
            crypto.getRandomValues(bytes);
            // Convert bytes to hexadecimal string
            return Array.from(bytes)
                .map((byte) => byte.toString(16).padStart(2, '0'))
                .join('');
        }
        /**
         * Helper method to instrument with automatic properties inclusion
         */
        instrument(message, context) {
            const defaultContext = {
                accountAddress: context.accountAddress || this.activeAccountAddress,
                environmentId: context.environmentId || this.environmentId,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                traceId: context.traceId || this.generateTraceId(),
            };
            this.logger.debug(message, Object.assign(Object.assign({}, defaultContext), context));
            this.logger.instrument(message, Object.assign(Object.assign({}, defaultContext), context));
        }
        instrumentAsync(_a) {
            return __awaiter(this, arguments, void 0, function* ({ operation, resource, fn, context, }) {
                const timing = new InstrumentationTimer(context === null || context === void 0 ? void 0 : context.startTime);
                if (context === null || context === void 0 ? void 0 : context.stepStartTime) {
                    timing.setStepStartTime(context.stepStartTime);
                }
                else {
                    timing.startStep();
                }
                this.instrument(`[${operation}] ${resource} - start`, Object.assign({ key: `${resource}-start`, operation, stepTime: timing.getStepElapsed(), time: timing.getElapsed() }, context));
                try {
                    const result = yield fn(timing);
                    this.instrument(`[${operation}] ${resource} - completed`, Object.assign({ key: `${resource}-completed`, operation, stepTime: timing.getStepElapsed(), time: timing.getElapsed() }, context));
                    return result;
                }
                catch (error) {
                    this.instrument(`[${operation}] ${resource} - failed`, Object.assign(Object.assign({ key: `${resource}-failed`, operation, stepTime: timing.getStepElapsed(), time: timing.getElapsed() }, context), { error }));
                    throw error;
                }
            });
        }
    }
    return DynamicWaasMixin;
};

export { WaasExportHandler, withDynamicWaas };
