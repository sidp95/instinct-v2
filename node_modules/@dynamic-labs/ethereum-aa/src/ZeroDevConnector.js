'use client'
import { __awaiter, __rest } from '../_virtual/_tslib.js';
import { KERNEL_V3_3, getEntryPoint as getEntryPoint$1 } from '@zerodev/sdk/constants';
import { custom, createWalletClient, toHex, formatEther } from 'viem';
import { getUserOperationHash } from 'viem/account-abstraction';
import { toAccount } from 'viem/accounts';
import { AccountAbstractionBaseConnector } from '@dynamic-labs/ethereum-aa-core';
import { EthereumWallet, isEthWalletConnector, chainsMap, confirmationTransport, unFormatTransaction, interceptTransport } from '@dynamic-labs/ethereum-core';
import { ZerodevBundlerProvider, WalletProviderEnum } from '@dynamic-labs/sdk-api-core';
import { parseEvmNetworks, StorageService, DynamicError, DeferredPromise, parseChainId, wrapMethodWithCallback, TransactionGasCannotBeSponsoredError, InsufficientFundsError } from '@dynamic-labs/utils';
import { eventListenerHandlers, getWalletProvider, isDynamicWaasConnector, isTurnkeyWalletConnector } from '@dynamic-labs/wallet-connector-core';
import { ZERO_DEV_LAST_USED_CHAIN_ID_KEY } from './constants.js';
import { logger } from './utils/logger.js';
import { PaymasterTypeEnum, createEcdsaKernelAccountClientWith7702, createEcdsaKernelAccountClient } from './utils/createEcdsaKernelAccountClient.js';
import { getEcdsaValidator } from './utils/getEcdsaValidator.js';
import { getEntryPoint } from './utils/getEntryPoint.js';
import { getKernelVersion } from './utils/getKernelVersion.js';
import { hasSmartAccount } from './utils/hasSmartAccount.js';

class ZeroDevConnector extends AccountAbstractionBaseConnector {
    constructor(opts) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        super(opts);
        // provider map maintains the kernel clients per chain
        this.providerMap = {};
        // eoa connector map maintains the eoa address and connector for each smart wallet address
        this.eoaConnectorMap = {};
        this.ChainWallet = EthereumWallet;
        this.connectedChain = 'EVM';
        this.supportedChains = ['ETH', 'EVM'];
        this.isEmbeddedWallet = true;
        this.providersFromApi = [];
        /**
         * Cache for prepared user operations indexed by transaction details.
         * The key is a concatenation of from-to-data to uniquely identify transactions.
         * Used to avoid re-preparing the same user operation multiple times.
         */
        this.userOperationCache = {};
        this.name = 'ZeroDev';
        this.overrideKey = 'zerodev';
        this.walletFallback = {
            brand: {
                alt: 'Smart Wallet',
                spriteId: 'smartwallet',
            },
            name: 'ZeroDev',
        };
        this.hasExistingSmartAccount = false;
        /**
         * Flag for EIP-7702 mode, enabled when EIP-7702 is enabled and no smart account exists
         */
        this.shouldUseEIP7702Mode = false;
        // Avoid double-disabling confirmation UI when sendUserOperation is invoked within onSendTransaction
        this.isInOnSendTransactionFlow = false;
        this._walletUiUtils = opts.walletUiUtils;
        this.providersConfig = (_a = opts.providersConfig) !== null && _a !== void 0 ? _a : {};
        this.is7702EnabledOnDashboard =
            (_c = (_b = opts.apiProviders.zerodev) === null || _b === void 0 ? void 0 : _b.enableEIP7702) !== null && _c !== void 0 ? _c : false;
        this.entryPoint = getEntryPoint((_d = opts.apiProviders.zerodev) === null || _d === void 0 ? void 0 : _d.entryPointVersion);
        this.bundlerProvider =
            (_g = (_f = (_e = opts.apiProviders.zerodev) === null || _e === void 0 ? void 0 : _e.zerodevBundlerProvider) !== null && _f !== void 0 ? _f : ZeroDevConnector.bundlerProviderDefault) !== null && _g !== void 0 ? _g : ZerodevBundlerProvider.Pimlico;
        this.bundlerRpc =
            (_j = (_h = opts.apiProviders.zerodev) === null || _h === void 0 ? void 0 : _h.zerodevBundlerRpcUrl) !== null && _j !== void 0 ? _j : ZeroDevConnector.bundlerRpcDefault;
        this.paymasterRpc =
            (_l = (_k = opts.apiProviders.zerodev) === null || _k === void 0 ? void 0 : _k.zerodevPaymasterRpcUrl) !== null && _l !== void 0 ? _l : ZeroDevConnector.paymasterRpcDefault;
        this.kernelDelegationAddress =
            (_o = (_m = opts.apiProviders.zerodev) === null || _m === void 0 ? void 0 : _m.zerodevKernelDelegationAddress) !== null && _o !== void 0 ? _o : ZeroDevConnector.kernelDelegationAddressDefault;
        this.apiKernelVersion = getKernelVersion((_p = opts.apiProviders.zerodev) === null || _p === void 0 ? void 0 : _p.kernelVersion, this.entryPoint);
        this.kernelVersion = getKernelVersion((_q = opts.apiProviders.zerodev) === null || _q === void 0 ? void 0 : _q.kernelVersion, this.entryPoint);
        this.enableKernelV3Migration =
            (_s = (_r = opts.apiProviders.zerodev) === null || _r === void 0 ? void 0 : _r.enableKernelV3Migration) !== null && _s !== void 0 ? _s : false;
        // this is the list of providers from the api that are used for multi-chain account abstraction
        this.providersFromApi =
            ((_t = opts.apiProviders.zerodev) === null || _t === void 0 ? void 0 : _t.multichainAccountAbstractionProviders) || [];
        const enabledZerodevNetworks = this.providersFromApi.map((provider) => provider.chain);
        this.evmNetworks = parseEvmNetworks(opts.evmNetworks).filter((network) => enabledZerodevNetworks.includes(network.chainId.toString()));
        const [defaultProvider] = this.providersFromApi;
        this.clientId = defaultProvider === null || defaultProvider === void 0 ? void 0 : defaultProvider.clientId;
        if (!this.clientId) {
            throw new Error('Missing ZeroDev project ID provided. Add your ZeroDev project id to your project configuration via the Dynamic Labs dashboard.');
        }
        this.defaultChainId = defaultProvider === null || defaultProvider === void 0 ? void 0 : defaultProvider.chain;
        this.ecdsaProviderType = (_u = opts.apiProviders.zerodev) === null || _u === void 0 ? void 0 : _u.ecdsaProviderType;
    }
    confirmTransactionStatus() {
        throw new Error('confirmTransactionStatus not implemented in ZeroDevConnector');
    }
    get currentNetworkProvider() {
        // check if the last used chain id is in the provider map
        if (this.providerMap[this.lastUsedChainId]) {
            return this.providerMap[this.lastUsedChainId];
        }
        // if not, check if the default chain id is in the provider map
        if (this.defaultChainId) {
            return this.providerMap[this.defaultChainId];
        }
        // if no chain id is found, return undefined
        return undefined;
    }
    get lastUsedChainId() {
        var _a;
        const storedChainId = StorageService.getItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY);
        // returning string of unknown if no chain id is found to result in undefined provider lookup
        return (_a = storedChainId !== null && storedChainId !== void 0 ? storedChainId : this.defaultChainId) !== null && _a !== void 0 ? _a : 'unknown';
    }
    get kernelClient() {
        var _a;
        return (_a = this.currentNetworkProvider) === null || _a === void 0 ? void 0 : _a.kernelClient;
    }
    get kernelClientWithSponsorship() {
        var _a;
        return (_a = this.currentNetworkProvider) === null || _a === void 0 ? void 0 : _a.kernelClientWithSponsorship;
    }
    supportsNetworkSwitching() {
        return (Object.keys(this.providerMap).length > 1 && this.evmNetworks.length > 1);
    }
    getPublicRpcForChain(chainId) {
        var _a, _b;
        const network = this.evmNetworks.find((n) => n.chainId.toString() === chainId);
        const privateCustomerRpc = (_a = network === null || network === void 0 ? void 0 : network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0];
        const publicRpc = (_b = network === null || network === void 0 ? void 0 : network.rpcUrls) === null || _b === void 0 ? void 0 : _b[0];
        return privateCustomerRpc || publicRpc;
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!this.supportsNetworkSwitching())
                return;
            if (!networkChainId)
                return;
            const chainId = networkChainId.toString();
            if (!this.providerMap[chainId]) {
                throw new Error(`No provider found for chainId: ${chainId}`);
            }
            StorageService.setItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY, chainId);
            const { handleChainChange } = eventListenerHandlers(this);
            handleChainChange(chainId);
            this.userOperationCache = {};
        });
    }
    getAccountAbstractionProvider({ withSponsorship, } = {}) {
        if (withSponsorship && this.kernelClientWithSponsorship) {
            return this.kernelClientWithSponsorship;
        }
        return this.kernelClient;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            StorageService.removeItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY);
        });
    }
    initialize(_a) {
        return __awaiter(this, arguments, void 0, function* ({ smartWalletAddress, eoaAddress, eoaConnector, properties, shouldSetEoaConnector, verifiedCredentials, }) {
            yield this.registerEoa(Object.assign({ eoaAddress,
                eoaConnector,
                shouldSetEoaConnector,
                smartWalletAddress,
                verifiedCredentials }, properties));
        });
    }
    registerEoa(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { smartWalletAddress, eoaAddress, eoaConnector, verifiedCredentials, shouldSetEoaConnector = false } = _a, properties = __rest(_a, ["smartWalletAddress", "eoaAddress", "eoaConnector", "verifiedCredentials", "shouldSetEoaConnector"]);
            if (!eoaConnector) {
                throw new DynamicError('No EOA connector');
            }
            this.determineSmartAccountStatus(eoaConnector, verifiedCredentials);
            if (this.shouldUseEIP7702Mode) {
                // In EIP-7702, addresses must match
                if (smartWalletAddress !== eoaAddress) {
                    throw new Error('In EIP-7702 mode, smart wallet and EOA addresses must be the same');
                }
                this.eoaConnectorMap[smartWalletAddress] = {
                    eoaAddress,
                    eoaConnector,
                    properties,
                };
                yield this.setEoaConnector({
                    connector: eoaConnector,
                    eoaAddress,
                    properties,
                });
            }
            else {
                // Existing implementation for regular ZeroDev
                this.eoaConnectorMap[smartWalletAddress] = {
                    eoaAddress,
                    eoaConnector,
                    properties,
                };
                if (shouldSetEoaConnector) {
                    yield this.setEoaConnector({
                        connector: eoaConnector,
                        eoaAddress,
                        properties,
                    });
                }
            }
        });
    }
    determineSmartAccountStatus(eoaConnector, verifiedCredentials) {
        if (getWalletProvider(eoaConnector) !== WalletProviderEnum.EmbeddedWallet) {
            return;
        }
        this.hasExistingSmartAccount = hasSmartAccount(verifiedCredentials);
        this.shouldUseEIP7702Mode =
            this.is7702EnabledOnDashboard && !this.hasExistingSmartAccount;
    }
    setEoaConnector(_a) {
        return __awaiter(this, arguments, void 0, function* ({ eoaAddress, connector, properties, }) {
            var _b, _c;
            if (!connector) {
                logger.error('No EOA connector provided');
                return;
            }
            this.kernelClientDeferredPromise = this.kernelClientDeferredPromise
                ? this.kernelClientDeferredPromise
                : new DeferredPromise();
            this.eoaConnector = connector;
            this.eoaAddress = eoaAddress;
            if (properties) {
                this.ecdsaProviderType =
                    (_b = properties.ecdsaProviderType) !== null && _b !== void 0 ? _b : this.ecdsaProviderType;
                this.entryPoint = properties.entryPointVersion
                    ? getEntryPoint(properties.entryPointVersion)
                    : this.entryPoint;
                this.kernelVersion = properties.entryPointVersion
                    ? getKernelVersion(properties.kernelVersion, this.entryPoint)
                    : this.kernelVersion;
                this.enableKernelV3Migration =
                    (_c = properties.enableKernelV3Migration) !== null && _c !== void 0 ? _c : this.enableKernelV3Migration;
            }
            if (isEthWalletConnector(this.eoaConnector) &&
                !this.eoaConnector.getActiveAccount()) {
                yield this.eoaConnector.getConnectedAccounts();
            }
            const signer = yield this.eoaConnector.getSigner();
            yield this.generateProviderMap(signer);
            this.kernelClientDeferredPromise.resolve();
        });
    }
    warnIfProjectChainNotEnabled(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let chainIdToCheck = chainId;
            if (!chainIdToCheck) {
                const client = yield this.getPublicClient();
                chainIdToCheck = (_a = client === null || client === void 0 ? void 0 : client.chain) === null || _a === void 0 ? void 0 : _a.id;
            }
            const isProjectChainEnabled = this.evmNetworks.some((network) => network.chainId === chainIdToCheck);
            if (!isProjectChainEnabled) {
                logger.error(`Please make sure to enable (${chainIdToCheck}) in the Dynamic dashboard (https://app.dynamic.xyz/dashboard/chains-and-networks#evm).`);
            }
        });
    }
    /**
     * Generates a map of kernel clients for each chain in the providers list
     * Each chain gets two clients: one without sponsorship and one with sponsorship
     *
     * @param signer - The wallet client to use for signing transactions
     */
    generateProviderMap(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            const providerMap = {};
            yield Promise.all(this.providersFromApi.map((provider) => __awaiter(this, void 0, void 0, function* () {
                const { chain, clientId } = provider;
                const [kernelClient, kernelClientWithSponsorship] = yield Promise.all([
                    this.getOrCreateKernelClient({
                        chainId: chain,
                        paymaster: PaymasterTypeEnum.NONE,
                        projectId: clientId,
                        signer,
                    }),
                    this.getOrCreateKernelClient({
                        chainId: chain,
                        paymaster: PaymasterTypeEnum.SPONSOR,
                        projectId: clientId,
                        signer,
                    }),
                ]);
                providerMap[chain] = {
                    kernelClient,
                    kernelClientWithSponsorship,
                    signerAddress: signer.account.address,
                };
                yield this.warnIfProjectChainNotEnabled(parseChainId(chain));
            })));
            // Filter out duplicate chains and store the provider map
            const uniqueChainProviderMap = Object.entries(providerMap).reduce((acc, [chain, providers]) => {
                if (!acc[chain]) {
                    acc[chain] = providers;
                }
                return acc;
            }, {});
            this.providerMap = uniqueChainProviderMap;
        });
    }
    createKernelClient(_a) {
        return __awaiter(this, arguments, void 0, function* ({ chainId, projectId, signer, paymaster, paymasterRpcOverride, bundlerRpcOverride, }) {
            const { eoaConnector } = this;
            if (!eoaConnector)
                throw new DynamicError('No EOA connector');
            const chain = chainsMap[chainId];
            let kernelClient;
            const params = {
                apiKernelVersion: this.apiKernelVersion,
                bundlerRpc: bundlerRpcOverride !== null && bundlerRpcOverride !== void 0 ? bundlerRpcOverride : this.bundlerRpc,
                chain,
                enableKernelV3Migration: this.enableKernelV3Migration,
                entryPoint: this.entryPoint,
                kernelVersion: this.kernelVersion,
                paymaster,
                paymasterRpc: paymasterRpcOverride !== null && paymasterRpcOverride !== void 0 ? paymasterRpcOverride : this.paymasterRpc,
                projectId,
                provider: this.bundlerProvider,
                publicClientRpc: this.getPublicRpcForChain(chainId),
                signer,
            };
            if (this.shouldUseEIP7702Mode) {
                kernelClient = yield createEcdsaKernelAccountClientWith7702(Object.assign(Object.assign({}, params), { kernelVersion: KERNEL_V3_3 }));
            }
            else {
                kernelClient = yield createEcdsaKernelAccountClient(Object.assign(Object.assign({}, params), { ecdsaValidator: getEcdsaValidator(this.ecdsaProviderType) }));
            }
            wrapMethodWithCallback(kernelClient, 'sendUserOperation', (original, ...args) => {
                if (!this.isInOnSendTransactionFlow) {
                    this._walletUiUtils.disabledConfirmationOnce();
                }
                return original(...args);
            });
            return kernelClient;
        });
    }
    getOrCreateKernelClient(_a) {
        return __awaiter(this, arguments, void 0, function* ({ chainId, projectId, signer, paymaster, }) {
            if (chainId &&
                this.providerMap[chainId] &&
                this.providerMap[chainId].signerAddress === signer.account.address) {
                return paymaster === PaymasterTypeEnum.SPONSOR
                    ? this.providerMap[chainId].kernelClientWithSponsorship
                    : this.providerMap[chainId].kernelClient;
            }
            return this.createKernelClient({
                chainId,
                paymaster,
                projectId,
                signer,
            });
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (this.shouldUseEIP7702Mode) {
                return this.eoaAddress;
            }
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return (_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account) === null || _c === void 0 ? void 0 : _c.address;
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return ((_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account) === null || _c === void 0 ? void 0 : _c.address)
                ? [yield this.kernelClient.account.address]
                : [];
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return Number(this.lastUsedChainId);
        });
    }
    getCapabilities() {
        return __awaiter(this, void 0, void 0, function* () {
            const capabilities = {};
            this.evmNetworks.forEach((network) => {
                capabilities[parseChainId(network.chainId)] = {
                    atomic: {
                        status: 'ready',
                    },
                    paymasterService: {
                        supported: true,
                    },
                };
            });
            return capabilities;
        });
    }
    sendCalls(callParams) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            const { calls, capabilities, chain } = callParams;
            const paymasterUrl = (chain === null || chain === void 0 ? void 0 : chain.id)
                ? (_b = (_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities[chain.id]) === null || _a === void 0 ? void 0 : _a.paymasterService) === null || _b === void 0 ? void 0 : _b.url
                : undefined;
            const signer = yield this.eoaConnector.getSigner();
            signer.account = toAccount(this.eoaAddress);
            const chainId = (_d = (_c = chain === null || chain === void 0 ? void 0 : chain.id) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : this.lastUsedChainId;
            const clientId = (_e = this.providersFromApi.find((provider) => provider.chain === chainId)) === null || _e === void 0 ? void 0 : _e.clientId;
            if (!clientId) {
                throw new DynamicError('No client id for chain id: ' + chainId);
            }
            const shouldSponsor = Boolean(ZeroDevConnector.defaultToKernelWithSponsorship || paymasterUrl);
            const client = yield this.createKernelClient({
                chainId,
                paymaster: shouldSponsor
                    ? PaymasterTypeEnum.SPONSOR
                    : PaymasterTypeEnum.NONE,
                paymasterRpcOverride: paymasterUrl,
                projectId: clientId,
                signer,
            });
            if (!client) {
                throw new DynamicError('No kernel client');
            }
            const callData = yield client.account.encodeCalls(calls);
            const hash = yield client.sendUserOperation({
                callData,
            });
            return client.waitForUserOperationReceipt({ hash });
        });
    }
    getTransport(provider) {
        const transportWithConfirmationModal = confirmationTransport({
            getAccounts: () => __awaiter(this, void 0, void 0, function* () { return [provider.account.address]; }),
            onPersonalSign: (_a) => __awaiter(this, [_a], void 0, function* ({ message }) {
                this._walletUiUtils.disabledConfirmationOnce();
                return this.internalSignMessage(message);
            }),
            onSendTransaction: (_b) => __awaiter(this, [_b], void 0, function* ({ transaction }) {
                this.isInOnSendTransactionFlow = true;
                try {
                    const effectiveProvider = this.isGasSponsorshipDisabled()
                        ? provider
                        : this.kernelClientWithSponsorship;
                    if (!effectiveProvider) {
                        throw new DynamicError('No provider');
                    }
                    const unformattedTransaction = unFormatTransaction(transaction);
                    const key = `${unformattedTransaction.from}-${unformattedTransaction.to}-${unformattedTransaction.data}`;
                    const cachedTransaction = this.userOperationCache[key];
                    const isWaasEOAConnector = this.eoaConnector && isDynamicWaasConnector(this.eoaConnector);
                    let response;
                    if (isWaasEOAConnector) {
                        const userOperation = (cachedTransaction === null || cachedTransaction === void 0 ? void 0 : cachedTransaction.userOperation) ||
                            (yield this.getCurrentUserOperation(unformattedTransaction))
                                .userOperation;
                        response = yield this.signAndSendUserOperationWithWaas(effectiveProvider, userOperation);
                    }
                    else if (cachedTransaction) {
                        this._walletUiUtils.disabledConfirmationOnce();
                        const signedTransaction = yield effectiveProvider.signUserOperation(cachedTransaction.userOperation);
                        response = yield effectiveProvider.sendUserOperation(signedTransaction);
                    }
                    else {
                        response = yield effectiveProvider.sendTransaction(unformattedTransaction);
                    }
                    this.userOperationCache = {};
                    return response;
                }
                catch (err) {
                    logger.debug(err);
                    if (TransactionGasCannotBeSponsoredError.isErrorMessage(err)) {
                        throw new TransactionGasCannotBeSponsoredError();
                    }
                    if (InsufficientFundsError.isErrorMessage(err)) {
                        throw new InsufficientFundsError();
                    }
                    throw err;
                }
                finally {
                    this.isInOnSendTransactionFlow = false;
                }
            }),
            onSignTransaction: (_c) => __awaiter(this, [_c], void 0, function* ({ transaction }) {
                this._walletUiUtils.disabledConfirmationOnce();
                if (!this.eoaConnector) {
                    throw new DynamicError('signTransaction requires an EOA connector to be available');
                }
                if (!this.eoaAddress) {
                    throw new DynamicError('No EOA address');
                }
                let localAccount;
                if (isDynamicWaasConnector(this.eoaConnector)) {
                    localAccount = yield this.eoaConnector.getViemAccount({
                        accountAddress: this.eoaAddress,
                    });
                }
                else if (isTurnkeyWalletConnector(this.eoaConnector)) {
                    localAccount = yield this.eoaConnector.getAccount();
                }
                else {
                    throw new DynamicError('signTransaction is only supported with Dynamic embedded wallets');
                }
                const tx = unFormatTransaction(transaction);
                const publicClient = yield this.getPublicClient();
                if (!publicClient) {
                    throw new DynamicError('Public client not available');
                }
                const preparedTx = yield publicClient.prepareTransactionRequest(Object.assign(Object.assign({}, tx), { account: this.eoaAddress }));
                return localAccount.signTransaction(preparedTx);
            }),
            onSignTypedData: (_d) => __awaiter(this, [_d], void 0, function* ({ message }) {
                this._walletUiUtils.disabledConfirmationOnce();
                const signTypedData = JSON.parse(message);
                return provider.signTypedData({
                    domain: signTypedData.domain,
                    message: signTypedData.message,
                    primaryType: signTypedData.primaryType,
                    types: signTypedData.types,
                });
            }),
            provider: provider.client,
            transport: custom(provider.client, this.providersConfig.httpTransportConfig),
            // TODO: remove this. We should not be passing references to wallet connectors
            walletConnector: this,
            walletUiUtils: this._walletUiUtils,
        });
        const transportWithEip5792Support = interceptTransport({
            onGetCapabilities: () => __awaiter(this, void 0, void 0, function* () { return this.getCapabilities(); }),
            onSendCalls: (_e) => __awaiter(this, [_e], void 0, function* ({ callParams }) {
                const result = yield this.sendCalls(callParams);
                return { id: result.userOpHash };
            }),
            transport: transportWithConfirmationModal,
        });
        return transportWithEip5792Support;
    }
    getWalletClient(chainId) {
        const provider = this.kernelClient;
        if (!provider)
            return undefined;
        const transport = this.getTransport(provider);
        const walletClient = createWalletClient({
            account: toAccount(provider.account.address),
            chain: chainId ? chainsMap[chainId] : provider.chain,
            transport,
        });
        return walletClient;
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const publicClient = (_a = this.kernelClient) === null || _a === void 0 ? void 0 : _a.client;
            if (!publicClient)
                return undefined;
            return publicClient;
        });
    }
    formatUserOperation(params, withAuthorization) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const kernelAccount = (_a = this.getAccountAbstractionProvider()) === null || _a === void 0 ? void 0 : _a.account;
            const entryPoint = kernelAccount === null || kernelAccount === void 0 ? void 0 : kernelAccount.entryPoint;
            const isV6 = (entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.address.toLowerCase()) ===
                getEntryPoint$1('0.6').address.toLowerCase();
            const factoryArgs = yield (kernelAccount === null || kernelAccount === void 0 ? void 0 : kernelAccount.getFactoryArgs());
            // we need the initCode in order to simulate the transaction
            // when the contract is not yet deployed
            const initCode = (factoryArgs === null || factoryArgs === void 0 ? void 0 : factoryArgs.factory) && (factoryArgs === null || factoryArgs === void 0 ? void 0 : factoryArgs.factoryData)
                ? '0x' +
                    factoryArgs.factory.slice(2).toLowerCase() +
                    factoryArgs.factoryData.slice(2).toLowerCase()
                : '0x';
            if (isV6) {
                return {
                    callData: params.callData,
                    callGasLimit: toHex(params.callGasLimit),
                    initCode,
                    maxFeePerGas: toHex(params.maxFeePerGas),
                    maxPriorityFeePerGas: toHex(params.maxPriorityFeePerGas),
                    nonce: toHex(params.nonce),
                    paymasterAndData: params.paymasterAndData.toLowerCase(),
                    preVerificationGas: toHex(params.preVerificationGas),
                    sender: params.sender,
                    signature: '0x',
                    verificationGasLimit: toHex(params.verificationGasLimit),
                };
            }
            const accountGasLimits = '0x' +
                toHex(params.verificationGasLimit).slice(2).padStart(32, '0') +
                toHex(params.callGasLimit).slice(2).padStart(32, '0');
            const preVerificationGas = toHex(params.preVerificationGas);
            const gasFees = '0x' +
                toHex(params.maxPriorityFeePerGas).slice(2).padStart(32, '0') +
                toHex(params.maxFeePerGas).slice(2).padStart(32, '0');
            const paymasterAndData = params.paymaster
                ? '0x' +
                    params.paymaster.slice(2).toLowerCase() +
                    toHex(params.paymasterVerificationGasLimit).slice(2).padStart(32, '0') + // Make sure it's 32 chars
                    toHex(params.paymasterPostOpGasLimit).slice(2).padStart(32, '0') + // Make sure it's 32 chars
                    params.paymasterData.slice(2) // Include full paymaster data
                : '0x';
            const response = Object.assign({ accountGasLimits: accountGasLimits, callData: params.callData, gasFees: gasFees, initCode, nonce: toHex(params.nonce), paymasterAndData: paymasterAndData.toLowerCase(), preVerificationGas: preVerificationGas, sender: params.sender, signature: '0x' }, (withAuthorization &&
                params.authorization && {
                eip7702Auth: Object.assign(Object.assign({}, params.authorization), { chainId: toHex(params.authorization.chainId), nonce: toHex(params.authorization.nonce), yParity: toHex(params.authorization.yParity) }),
            }));
            return response;
        });
    }
    signAndSendUserOperationWithWaas(provider, userOperation) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainId = Number(this.lastUsedChainId);
            const hash = getUserOperationHash({
                chainId: chainId,
                entryPointAddress: this.entryPoint.address,
                entryPointVersion: this.entryPoint.version,
                userOperation,
            });
            // At this point we know eoaConnector is a WAAS connector
            const signature = yield this.eoaConnector.signMessageWithContext({
                context: {
                    evmUserOperation: {
                        chainId,
                        entryPoint: this.entryPoint.address,
                        operation: userOperation,
                    },
                },
                message: { raw: hash },
            });
            return provider.sendUserOperation(Object.assign(Object.assign({}, userOperation), { signature: signature }));
        });
    }
    getCurrentUserOperation(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const key = `${transaction.from}-${transaction.to}-${transaction.data}`;
            if (this.userOperationCache[key]) {
                return this.userOperationCache[key];
            }
            try {
                const { kernelClientWithSponsorship } = this;
                if (!kernelClientWithSponsorship) {
                    throw new DynamicError('No kernel client with sponsorship found');
                }
                const value = BigInt((_a = transaction.value) !== null && _a !== void 0 ? _a : 0);
                const callData = yield kernelClientWithSponsorship.account.encodeCalls([
                    {
                        data: transaction.data ? transaction.data : '0x',
                        to: transaction.to,
                        value,
                    },
                ]);
                let sponsorResult;
                let unsponsoredResult;
                try {
                    sponsorResult = yield kernelClientWithSponsorship.prepareUserOperation({
                        callData,
                    });
                }
                catch (err) {
                    logger.debug('[ZeroDevConnector] Sponsored UserOp Attempt Failed:', err);
                    unsponsoredResult = yield ((_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.prepareUserOperation({
                        callData,
                    }));
                }
                // Cache the result
                this.userOperationCache[key] = {
                    sponsored: (sponsorResult === null || sponsorResult === void 0 ? void 0 : sponsorResult.paymasterAndData) !== '0x',
                    userOperation: sponsorResult !== null && sponsorResult !== void 0 ? sponsorResult : unsponsoredResult,
                };
                if ((sponsorResult === null || sponsorResult === void 0 ? void 0 : sponsorResult.paymasterAndData) === '0x')
                    return { sponsored: false, userOperation: sponsorResult };
                return sponsorResult
                    ? { sponsored: true, userOperation: sponsorResult }
                    : { sponsored: false, userOperation: unsponsoredResult };
            }
            catch (err) {
                logger.debug('[ZeroDevConnector] Error in getCurrentUserOperation:', err);
                return { sponsored: false, userOperation: undefined };
            }
        });
    }
    canSponsorTransactionGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sponsored } = yield this.getCurrentUserOperation(transaction);
            if (!sponsored) {
                return false;
            }
            return sponsored;
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const publicClient = (_a = this.kernelClient) === null || _a === void 0 ? void 0 : _a.client;
            if (!publicClient)
                throw new DynamicError('No RPC client');
            return formatEther(yield publicClient.getBalance({
                address: address,
            }));
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalSignMessage(messageToSign);
        });
    }
    signMessageForChain(messageToSign, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const client = (_a = this.providerMap[chainId]) === null || _a === void 0 ? void 0 : _a.kernelClient;
            if (!client) {
                throw new DynamicError(`Provider for Chain ID ${chainId} not available. Please make sure that Chain ID ${chainId} is enabled in both the Dynamic dashboard and the ZeroDev dashboard.`);
            }
            return client.signMessage({ message: messageToSign });
        });
    }
    internalSignMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.kernelClient) {
                throw new DynamicError('Error fetching signer');
            }
            if (!this.shouldUseEIP7702Mode) {
                return this.kernelClient.signMessage({ message: messageToSign });
            }
            const isDeployed = yield ((_a = this.kernelClient.account) === null || _a === void 0 ? void 0 : _a.isDeployed());
            if (!isDeployed) {
                return (yield ((_b = this.eoaConnector) === null || _b === void 0 ? void 0 : _b.signMessage(messageToSign)));
            }
            return this.kernelClient.signMessage({ message: messageToSign });
        });
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const eoa = this.eoaConnectorMap[expectedAddress];
            if (!eoa) {
                throw new DynamicError('No EOA connector');
            }
            const { eoaAddress, eoaConnector, properties } = eoa;
            yield eoaConnector.validateActiveWallet(eoaAddress);
            yield this.setEoaConnector({
                connector: eoaConnector,
                eoaAddress,
                properties,
            });
        });
    }
    isAtomicSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[ZeroDevConnector] isAtomicSupported - is supported', {
                chainId,
            });
            return true;
        });
    }
    isPaymasterServiceSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[ZeroDevConnector] isPaymasterServiceSupported - is supported', {
                chainId,
            });
            return true;
        });
    }
}

export { ZeroDevConnector };
