import { EntryPointType, KERNEL_VERSION_TYPE } from '@zerodev/sdk/types';
import { Account, PublicClient, Transport, WalletClient } from 'viem';
import { EntryPointVersion } from 'viem/account-abstraction';
import { type Chain as ViemChain } from 'viem/chains';
import { AccountAbstractionBaseConnector } from '@dynamic-labs/ethereum-aa-core';
import { EthereumWallet, RegisterEvmProvidersConfig } from '@dynamic-labs/ethereum-core';
import { EcdsaValidatorOptions, JwtVerifiedCredential, ProviderEntryPointVersionEnum, ProviderKernelVersionEnum, ProviderMultichainAccountAbstractionProviders, SmartWalletProperties, ZerodevBundlerProvider } from '@dynamic-labs/sdk-api-core';
import { TransactionReceipt } from '@dynamic-labs/types';
import { Chain, InternalWalletConnector, IZeroDevConnector } from '@dynamic-labs/wallet-connector-core';
import type { KernelClient, ZeroDevConnectorProps } from './types';
export declare class ZeroDevConnector extends AccountAbstractionBaseConnector implements IZeroDevConnector {
    clientId: string;
    eoaConnector: InternalWalletConnector | undefined;
    eoaAddress: string | undefined;
    private providerMap;
    private eoaConnectorMap;
    ChainWallet: typeof EthereumWallet;
    connectedChain: Chain;
    supportedChains: Chain[];
    providersConfig: RegisterEvmProvidersConfig;
    isEmbeddedWallet: boolean;
    entryPoint: EntryPointType<EntryPointVersion>;
    kernelVersion: KERNEL_VERSION_TYPE;
    apiKernelVersion: KERNEL_VERSION_TYPE;
    enableKernelV3Migration: boolean;
    ecdsaProviderType: string | undefined;
    defaultChainId: string | undefined;
    providersFromApi: ProviderMultichainAccountAbstractionProviders[];
    bundlerProvider: ZerodevBundlerProvider;
    bundlerRpc: string | undefined;
    paymasterRpc: string | undefined;
    kernelDelegationAddress: `0x${string}` | undefined;
    static bundlerProviderDefault: ZerodevBundlerProvider | undefined;
    static bundlerRpcDefault: string | undefined;
    static paymasterRpcDefault: string | undefined;
    static kernelDelegationAddressDefault: `0x${string}` | undefined;
    static defaultToKernelWithSponsorship: boolean | undefined;
    /**
     * Deferred promise that resolves when the ZeroDev provider is set.
     * This is used to make sure that the provider is set before any other method is called.
     * This is needed because the provider is set asynchronously.
     */
    private kernelClientDeferredPromise;
    /**
     * Cache for prepared user operations indexed by transaction details.
     * The key is a concatenation of from-to-data to uniquely identify transactions.
     * Used to avoid re-preparing the same user operation multiple times.
     */
    private userOperationCache;
    name: string;
    overrideKey: string;
    walletFallback: {
        brand: {
            alt: string;
            spriteId: string;
        };
        name: string;
    };
    is7702EnabledOnDashboard: boolean;
    private hasExistingSmartAccount;
    /**
     * Flag for EIP-7702 mode, enabled when EIP-7702 is enabled and no smart account exists
     */
    private shouldUseEIP7702Mode;
    private isInOnSendTransactionFlow;
    constructor(opts: ZeroDevConnectorProps);
    confirmTransactionStatus(): Promise<TransactionReceipt>;
    get currentNetworkProvider(): {
        signerAddress: string;
        kernelClient: KernelClient;
        kernelClientWithSponsorship: KernelClient;
    } | undefined;
    get lastUsedChainId(): string;
    get kernelClient(): KernelClient | undefined;
    get kernelClientWithSponsorship(): KernelClient | undefined;
    supportsNetworkSwitching(): boolean;
    private getPublicRpcForChain;
    switchNetwork({ networkChainId, }: {
        networkChainId?: number | string;
    }): Promise<void>;
    getAccountAbstractionProvider<T = KernelClient | undefined>({ withSponsorship, }?: {
        withSponsorship?: boolean;
    }): T;
    endSession(): Promise<void>;
    initialize({ smartWalletAddress, eoaAddress, eoaConnector, properties, shouldSetEoaConnector, verifiedCredentials, }: {
        smartWalletAddress: string;
        eoaAddress: string;
        eoaConnector: InternalWalletConnector;
        shouldSetEoaConnector: boolean;
        properties?: SmartWalletProperties;
        verifiedCredentials: JwtVerifiedCredential[];
    }): Promise<void>;
    registerEoa({ smartWalletAddress, eoaAddress, eoaConnector, verifiedCredentials, shouldSetEoaConnector, ...properties }: {
        smartWalletAddress: string;
        eoaAddress: string;
        eoaConnector: InternalWalletConnector;
        verifiedCredentials: JwtVerifiedCredential[];
        shouldSetEoaConnector: boolean;
        ecdsaProviderType?: EcdsaValidatorOptions;
        kernelVersion?: ProviderKernelVersionEnum;
        entryPointVersion?: ProviderEntryPointVersionEnum;
    }): Promise<void>;
    private determineSmartAccountStatus;
    private setEoaConnector;
    private warnIfProjectChainNotEnabled;
    /**
     * Generates a map of kernel clients for each chain in the providers list
     * Each chain gets two clients: one without sponsorship and one with sponsorship
     *
     * @param signer - The wallet client to use for signing transactions
     */
    private generateProviderMap;
    private createKernelClient;
    private getOrCreateKernelClient;
    getAddress(): Promise<string | undefined>;
    getConnectedAccounts(): Promise<string[]>;
    getNetwork(): Promise<number | undefined>;
    private getCapabilities;
    private sendCalls;
    private getTransport;
    getWalletClient(chainId?: string): WalletClient<Transport, ViemChain, Account> | undefined;
    getPublicClient(): Promise<PublicClient<Transport, ViemChain> | undefined>;
    formatUserOperation(params: any, withAuthorization?: boolean): Promise<any>;
    private signAndSendUserOperationWithWaas;
    getCurrentUserOperation(transaction: {
        from: string;
        to?: string;
        value?: bigint;
        data?: string;
    }): Promise<{
        userOperation: any;
        sponsored: boolean;
    }>;
    canSponsorTransactionGas(transaction: {
        from: string;
        to?: string;
        value?: bigint;
        data?: string;
    }): Promise<boolean>;
    getBalance(address: string): Promise<string | undefined>;
    signMessage(messageToSign: string): Promise<string | undefined>;
    signMessageForChain(messageToSign: string, chainId: string): Promise<string | undefined>;
    private internalSignMessage;
    validateActiveWallet(expectedAddress: string): Promise<void>;
    isAtomicSupported(chainId?: number): Promise<boolean>;
    isPaymasterServiceSupported(chainId?: number): Promise<boolean>;
}
