'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var ecdsaValidator = require('@zerodev/ecdsa-validator');
var accounts = require('@zerodev/sdk/accounts');
var actions = require('@zerodev/sdk/actions');
var clients = require('@zerodev/sdk/clients');
var viem = require('viem');

exports.PaymasterTypeEnum = void 0;
(function (PaymasterTypeEnum) {
    PaymasterTypeEnum["NONE"] = "NONE";
    PaymasterTypeEnum["SPONSOR"] = "SPONSOR";
})(exports.PaymasterTypeEnum || (exports.PaymasterTypeEnum = {}));
const getZeroDevBundlerRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/bundler/${projectId}`;
    if (provider) {
        rpc += `?bundlerProvider=${provider}`;
    }
    return rpc;
};
const getZeroDevPaymasterRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/paymaster/${projectId}`;
    if (provider) {
        rpc += `?paymasterProvider=${provider}`;
    }
    return rpc;
};
const isERC20 = (value) => viem.isAddress(value);
const createPublicAndPaymasterClients = (bundlerRpc, paymasterRpc, chain, publicClientRpc) => {
    const publicClient = viem.createPublicClient({
        chain,
        transport: publicClientRpc ? viem.http(publicClientRpc) : viem.http(bundlerRpc),
    });
    const zerodevPaymaster = clients.createZeroDevPaymasterClient({
        chain,
        transport: viem.http(paymasterRpc),
    });
    return { publicClient, zerodevPaymaster };
};
const createPaymasterHandler = (paymaster, zerodevPaymaster) => {
    if (paymaster === exports.PaymasterTypeEnum.NONE)
        return undefined;
    return {
        getPaymasterData: (userOperation) => {
            const _userOperation = userOperation;
            if (isERC20(paymaster)) {
                return zerodevPaymaster.sponsorUserOperation({
                    gasToken: paymaster,
                    userOperation: _userOperation,
                });
            }
            return zerodevPaymaster.sponsorUserOperation({
                userOperation: _userOperation,
            });
        },
    };
};
const createKernelClientConfig = (account, bundlerRpc, chain, publicClient, paymaster) => ({
    account,
    bundlerTransport: viem.http(bundlerRpc),
    chain,
    client: publicClient,
    paymaster,
    userOperation: {
        estimateFeesPerGas: (_a) => _tslib.__awaiter(void 0, [_a], void 0, function* ({ bundlerClient }) { return actions.getUserOperationGasPrice(bundlerClient); }),
    },
});
const createEcdsaKernelAccountClient = (_b) => _tslib.__awaiter(void 0, [_b], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, paymaster = exports.PaymasterTypeEnum.SPONSOR, entryPoint, kernelVersion, ecdsaValidator: ecdsaValidator$1, enableKernelV3Migration, publicClientRpc, apiKernelVersion, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain, publicClientRpc);
    const validator = yield ecdsaValidator$1(publicClient, {
        entryPoint,
        kernelVersion,
        signer,
    });
    const account = yield accounts.createKernelAccount(publicClient, {
        entryPoint,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    let selectedAccount = account;
    if (enableKernelV3Migration) {
        selectedAccount = yield ecdsaValidator.createEcdsaKernelMigrationAccount(publicClient, {
            entryPoint,
            migrationVersion: {
                from: kernelVersion,
                to: apiKernelVersion,
            },
            signer,
        });
    }
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const clientConfig = createKernelClientConfig(selectedAccount, resolvedBundlerRpc, chain, publicClient, paymasterHandler);
    return clients.createKernelAccountClient(clientConfig);
});
const createEcdsaKernelAccountClientWith7702 = (_c) => _tslib.__awaiter(void 0, [_c], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, paymaster = exports.PaymasterTypeEnum.SPONSOR, entryPoint, kernelVersion, publicClientRpc, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain, publicClientRpc);
    const account = yield accounts.createKernelAccount(publicClient, {
        eip7702Account: signer,
        entryPoint,
        kernelVersion,
    });
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const kernelClient = clients.createKernelAccountClient({
        account,
        bundlerTransport: viem.http(resolvedBundlerRpc),
        chain,
        client: publicClient,
        paymaster: paymasterHandler,
        userOperation: {
            estimateFeesPerGas: (_d) => _tslib.__awaiter(void 0, [_d], void 0, function* ({ bundlerClient }) { return actions.getUserOperationGasPrice(bundlerClient); }),
        },
    });
    return kernelClient;
});

exports.createEcdsaKernelAccountClient = createEcdsaKernelAccountClient;
exports.createEcdsaKernelAccountClientWith7702 = createEcdsaKernelAccountClientWith7702;
exports.getZeroDevBundlerRPC = getZeroDevBundlerRPC;
exports.getZeroDevPaymasterRPC = getZeroDevPaymasterRPC;
