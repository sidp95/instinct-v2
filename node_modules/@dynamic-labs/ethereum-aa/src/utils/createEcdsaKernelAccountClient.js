'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { createEcdsaKernelMigrationAccount } from '@zerodev/ecdsa-validator';
import { createKernelAccount } from '@zerodev/sdk/accounts';
import { getUserOperationGasPrice } from '@zerodev/sdk/actions';
import { createKernelAccountClient, createZeroDevPaymasterClient } from '@zerodev/sdk/clients';
import { http, createPublicClient, isAddress } from 'viem';

var PaymasterTypeEnum;
(function (PaymasterTypeEnum) {
    PaymasterTypeEnum["NONE"] = "NONE";
    PaymasterTypeEnum["SPONSOR"] = "SPONSOR";
})(PaymasterTypeEnum || (PaymasterTypeEnum = {}));
const getZeroDevBundlerRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/bundler/${projectId}`;
    if (provider) {
        rpc += `?bundlerProvider=${provider}`;
    }
    return rpc;
};
const getZeroDevPaymasterRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/paymaster/${projectId}`;
    if (provider) {
        rpc += `?paymasterProvider=${provider}`;
    }
    return rpc;
};
const isERC20 = (value) => isAddress(value);
const createPublicAndPaymasterClients = (bundlerRpc, paymasterRpc, chain, publicClientRpc) => {
    const publicClient = createPublicClient({
        chain,
        transport: publicClientRpc ? http(publicClientRpc) : http(bundlerRpc),
    });
    const zerodevPaymaster = createZeroDevPaymasterClient({
        chain,
        transport: http(paymasterRpc),
    });
    return { publicClient, zerodevPaymaster };
};
const createPaymasterHandler = (paymaster, zerodevPaymaster) => {
    if (paymaster === PaymasterTypeEnum.NONE)
        return undefined;
    return {
        getPaymasterData: (userOperation) => {
            const _userOperation = userOperation;
            if (isERC20(paymaster)) {
                return zerodevPaymaster.sponsorUserOperation({
                    gasToken: paymaster,
                    userOperation: _userOperation,
                });
            }
            return zerodevPaymaster.sponsorUserOperation({
                userOperation: _userOperation,
            });
        },
    };
};
const createKernelClientConfig = (account, bundlerRpc, chain, publicClient, paymaster) => ({
    account,
    bundlerTransport: http(bundlerRpc),
    chain,
    client: publicClient,
    paymaster,
    userOperation: {
        estimateFeesPerGas: (_a) => __awaiter(void 0, [_a], void 0, function* ({ bundlerClient }) { return getUserOperationGasPrice(bundlerClient); }),
    },
});
const createEcdsaKernelAccountClient = (_b) => __awaiter(void 0, [_b], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, paymaster = PaymasterTypeEnum.SPONSOR, entryPoint, kernelVersion, ecdsaValidator, enableKernelV3Migration, publicClientRpc, apiKernelVersion, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain, publicClientRpc);
    const validator = yield ecdsaValidator(publicClient, {
        entryPoint,
        kernelVersion,
        signer,
    });
    const account = yield createKernelAccount(publicClient, {
        entryPoint,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    let selectedAccount = account;
    if (enableKernelV3Migration) {
        selectedAccount = yield createEcdsaKernelMigrationAccount(publicClient, {
            entryPoint,
            migrationVersion: {
                from: kernelVersion,
                to: apiKernelVersion,
            },
            signer,
        });
    }
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const clientConfig = createKernelClientConfig(selectedAccount, resolvedBundlerRpc, chain, publicClient, paymasterHandler);
    return createKernelAccountClient(clientConfig);
});
const createEcdsaKernelAccountClientWith7702 = (_c) => __awaiter(void 0, [_c], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, paymaster = PaymasterTypeEnum.SPONSOR, entryPoint, kernelVersion, publicClientRpc, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain, publicClientRpc);
    const account = yield createKernelAccount(publicClient, {
        eip7702Account: signer,
        entryPoint,
        kernelVersion,
    });
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const kernelClient = createKernelAccountClient({
        account,
        bundlerTransport: http(resolvedBundlerRpc),
        chain,
        client: publicClient,
        paymaster: paymasterHandler,
        userOperation: {
            estimateFeesPerGas: (_d) => __awaiter(void 0, [_d], void 0, function* ({ bundlerClient }) { return getUserOperationGasPrice(bundlerClient); }),
        },
    });
    return kernelClient;
});

export { PaymasterTypeEnum, createEcdsaKernelAccountClient, createEcdsaKernelAccountClientWith7702, getZeroDevBundlerRPC, getZeroDevPaymasterRPC };
