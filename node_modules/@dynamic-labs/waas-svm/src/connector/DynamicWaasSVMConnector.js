'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { Transaction, PublicKey } from '@solana/web3.js';
import { MFAAction } from '@dynamic-labs/sdk-api-core';
import { SolanaWalletConnector, SolanaUiTransaction } from '@dynamic-labs/solana-core';
import { DynamicError } from '@dynamic-labs/utils';
import { withDynamicWaas } from '@dynamic-labs/waas';
import { isSameAddress } from '@dynamic-labs/wallet-connector-core';
import { logger } from '../../utils/logger.js';
import { DynamicWaasSVMSigner } from '../signer/DynamicWaasSVMSigner.js';
import { Logger } from '@dynamic-labs/logger';

class DynamicWaasSVMConnector extends withDynamicWaas(SolanaWalletConnector) {
    connect() {
        throw new Error('Method not implemented.');
    }
    constructor(props) {
        super(props);
        this.name = 'Dynamic Waas';
        this.overrideKey = 'dynamicwaas';
        this.isEmbeddedWallet = true;
        this.logger = logger;
        this.walletUiUtils = props.walletUiUtils;
    }
    /**
     * Override setEnvironmentId to ensure it's set on the global logger
     */
    setEnvironmentId(environmentId) {
        super.setEnvironmentId(environmentId);
        Logger.setEnvironmentId(environmentId);
    }
    setActiveAccountAddress(accountAddress) {
        this.activeAccountAddress = accountAddress;
    }
    getActiveAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.activeAccountAddress;
        });
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const targetWallet = yield walletClient.getWallet({
                accountAddress: expectedAddress,
                authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
                signedSessionId,
            });
            if (!targetWallet) {
                throw new DynamicError('Account not found');
            }
            const isWalletActive = isSameAddress(targetWallet.accountAddress, this.activeAccountAddress || '', this.connectedChain);
            if (!isWalletActive) {
                this.activeAccountAddress = targetWallet.accountAddress;
            }
        });
    }
    internalSignMessage(message_1) {
        return __awaiter(this, arguments, void 0, function* (message, { parentTraceId, startTime, } = {}) {
            var _a, _b, _c;
            const traceId = parentTraceId || this.generateTraceId();
            const effectiveStartTime = startTime || Date.now();
            const walletClient = yield this.instrumentAsync({
                context: { chainName: 'SVM', startTime: effectiveStartTime, traceId },
                fn: () => __awaiter(this, void 0, void 0, function* () { return this.getWaasWalletClient(); }),
                operation: 'internalSignMessage',
                resource: 'getWaasWalletClient',
            });
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const accountAddress = this.activeAccountAddress;
            const authToken = (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this);
            const signedMessage = yield this.instrumentAsync({
                context: { chainName: 'SVM', startTime: effectiveStartTime, traceId },
                fn: () => __awaiter(this, void 0, void 0, function* () {
                    return walletClient.signMessage({
                        accountAddress,
                        authToken,
                        message,
                        mfaToken,
                        signedSessionId,
                        traceContext: {
                            startTime: effectiveStartTime,
                            traceId,
                        },
                    });
                }),
                operation: 'internalSignMessage',
                resource: 'walletClient.signMessage',
            });
            return signedMessage;
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const traceId = this.generateTraceId();
            const startTime = Date.now();
            this.instrument('[signMessage] start', {
                key: 'signMessage-start',
                startTime,
                time: 0,
                traceId,
            });
            const signedMessage = yield this.walletUiUtils.signMessage({
                handler: () => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignMessage(message, {
                        parentTraceId: traceId,
                        startTime,
                    });
                }),
                message,
                walletConnector: this,
            });
            this.instrument('[signMessage] completed', {
                key: 'signMessage-completed',
                startTime,
                time: Date.now() - startTime,
                traceId,
            });
            return signedMessage;
        });
    }
    internalSignTransaction(transaction_1) {
        return __awaiter(this, arguments, void 0, function* (transaction, { parentTraceId, startTime, } = {}) {
            var _a, _b;
            const traceId = parentTraceId || this.generateTraceId();
            const effectiveStartTime = startTime || Date.now();
            const walletClient = yield this.instrumentAsync({
                context: { chainName: 'SVM', startTime: effectiveStartTime, traceId },
                fn: () => __awaiter(this, void 0, void 0, function* () { return this.getWaasWalletClient(); }),
                operation: 'internalSignTransaction',
                resource: 'getWaasWalletClient',
            });
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const messageBytes = transaction instanceof Transaction
                ? transaction.serializeMessage()
                : transaction.message.serialize();
            const messageToSign = Buffer.from(messageBytes).toString('hex');
            const chainId = yield this.getNetwork(true);
            const senderAddress = this.activeAccountAddress;
            const signature = yield this.instrumentAsync({
                context: { chainName: 'SVM', startTime: effectiveStartTime, traceId },
                fn: () => __awaiter(this, void 0, void 0, function* () {
                    var _c;
                    return walletClient.signTransaction({
                        authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                        chainId,
                        mfaToken,
                        senderAddress,
                        signedSessionId,
                        traceContext: {
                            startTime: effectiveStartTime,
                            traceId,
                        },
                        transaction: messageToSign,
                    });
                }),
                operation: 'internalSignTransaction',
                resource: 'signTransaction',
            });
            transaction.addSignature(new PublicKey(this.activeAccountAddress), Buffer.from(signature, 'hex'));
            try {
                transaction.serialize({
                    requireAllSignatures: false,
                    verifySignatures: true,
                });
            }
            catch (err) {
                logger.warn('[internalSignTransaction] Error signing transaction', err);
            }
            return transaction;
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const traceId = this.generateTraceId();
            const startTime = Date.now();
            this.instrument('[signTransaction] start', {
                key: 'signTransaction-start',
                startTime,
                time: 0,
                traceId,
            });
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from: this.activeAccountAddress,
                multipleTransactions: [transaction],
                onSubmit: () => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignTransaction(transaction, {
                        parentTraceId: traceId,
                        startTime,
                    });
                }),
            });
            const signedTransaction = yield this.walletUiUtils.signTransaction(this, uiTransaction);
            this.instrument('[signTransaction] completed', {
                key: 'signTransaction-completed',
                startTime,
                time: Date.now() - startTime,
                traceId,
            });
            return signedTransaction;
        });
    }
    internalSignAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const signedTransactions = [];
            for (const transaction of transactions) {
                const signedTx = yield this.internalSignTransaction(transaction);
                signedTransactions.push(signedTx);
            }
            return signedTransactions;
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const traceId = this.generateTraceId();
            const startTime = Date.now();
            this.instrument('[signAllTransactions] start', {
                key: 'signAllTransactions-start',
                startTime,
                time: 0,
                traceId,
            });
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from: this.activeAccountAddress,
                multipleTransactions: transactions,
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignAllTransactions(transactions); }),
            });
            const signedTransactions = yield this.walletUiUtils.signTransaction(this, uiTransaction);
            this.instrument('[signAllTransactions] completed', {
                key: 'signAllTransactions-completed',
                startTime,
                time: Date.now() - startTime,
                traceId,
            });
            return signedTransactions;
        });
    }
    internalSignAndSendTransaction(transaction_1, options_1) {
        return __awaiter(this, arguments, void 0, function* (transaction, options, { parentTraceId, startTime, } = {}) {
            const traceId = parentTraceId || this.generateTraceId();
            const effectiveStartTime = startTime || Date.now();
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const connection = this.getWalletClient();
            const signedTransaction = yield this.instrumentAsync({
                context: { chainName: 'SVM', startTime: effectiveStartTime, traceId },
                fn: () => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignTransaction(transaction, {
                        parentTraceId: traceId,
                        startTime: effectiveStartTime,
                    });
                }),
                operation: 'internalSignAndSendTransaction',
                resource: 'internalSignTransaction',
            });
            const signature = yield this.instrumentAsync({
                context: {
                    chainName: 'SVM',
                    rpcUrl: connection.rpcEndpoint,
                    startTime: effectiveStartTime,
                    traceId,
                },
                fn: () => __awaiter(this, void 0, void 0, function* () {
                    return connection.sendRawTransaction(signedTransaction.serialize({
                        requireAllSignatures: false,
                        verifySignatures: true,
                    }), options);
                }),
                operation: 'internalSignAndSendTransaction',
                resource: 'sendRawTransaction',
            });
            // Listen for transaction confirmation with timeout
            const confirmationStartTime = Date.now();
            return new Promise((resolve, reject) => {
                var _a;
                const timeout = setTimeout(() => {
                    const timeoutTotalElapsed = Date.now() - confirmationStartTime;
                    this.instrument(`[internalSignAndSendTransaction] Transaction timed out - total: ${timeoutTotalElapsed}ms`, {
                        key: 'internalSignAndSendTransaction-transactionTimedOut',
                        rpcUrl: connection.rpcEndpoint,
                        time: timeoutTotalElapsed,
                        traceId,
                    });
                    reject(new Error('Transaction timed out'));
                }, 60000);
                connection.onSignature(signature, (result) => {
                    clearTimeout(timeout);
                    const confirmationEndTime = Date.now();
                    const confirmationStepElapsed = confirmationEndTime - confirmationStartTime;
                    const confirmationTotalElapsed = confirmationEndTime - effectiveStartTime;
                    if (result.err) {
                        logger.error(`[internalSignAndSendTransaction] Transaction failed - total: ${confirmationTotalElapsed}ms, step: ${confirmationStepElapsed}ms`, {
                            accountAddress: this.activeAccountAddress,
                            error: result.err,
                            key: 'internalSignAndSendTransaction-transactionFailed',
                            rpcUrl: connection.rpcEndpoint,
                            stepTime: confirmationStepElapsed,
                            time: confirmationTotalElapsed,
                            traceId,
                        });
                        reject(new Error(`Transaction failed: ${result.err}`));
                    }
                    else {
                        this.instrument(`[internalSignAndSendTransaction] Transaction confirmed - total: ${confirmationTotalElapsed}ms, step: ${confirmationStepElapsed}ms`, {
                            key: 'internalSignAndSendTransaction-transactionSuccess',
                            rpcUrl: connection.rpcEndpoint,
                            stepTime: confirmationStepElapsed,
                            time: confirmationTotalElapsed,
                            traceId,
                        });
                        resolve(signature);
                    }
                }, (_a = options === null || options === void 0 ? void 0 : options.preflightCommitment) !== null && _a !== void 0 ? _a : 'confirmed');
            });
        });
    }
    signAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const traceId = this.generateTraceId();
            const startTime = Date.now();
            this.instrument('[signAndSendTransaction] start', {
                key: 'signAndSendTransaction-start',
                options,
                startTime,
                time: 0,
                traceId,
            });
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from: this.activeAccountAddress,
                multipleTransactions: [transaction],
                onSubmit: () => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignAndSendTransaction(transaction, options, {
                        parentTraceId: traceId,
                        startTime,
                    });
                }),
            });
            const result = yield this.walletUiUtils.sendTransaction(this, uiTransaction);
            this.instrument('[signAndSendTransaction] completed', {
                key: 'signAndSendTransaction-completed',
                startTime,
                time: Date.now() - startTime,
                traceId,
            });
            return result;
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return new DynamicWaasSVMSigner({
                walletConnector: this,
            });
        });
    }
    getWalletClientByAddress({ accountAddress, }) {
        this.setActiveAccountAddress(accountAddress);
        return this.getWalletClient();
    }
    // Chain-specific override for exportClientKeyshares - SVM needs to handle optional account address
    exportClientKeyshares(_a) {
        const _super = Object.create(null, {
            exportClientKeyshares: { get: () => super.exportClientKeyshares }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
            const targetAccountAddress = accountAddress || this.activeAccountAddress;
            if (!targetAccountAddress) {
                throw new Error('Account address is required');
            }
            const traceId = this.generateTraceId();
            const startTime = Date.now();
            this.instrument('[exportClientKeyshares] start', {
                key: 'exportClientKeyshares-start',
                startTime,
                time: 0,
                traceId,
            });
            const result = yield _super.exportClientKeyshares.call(this, {
                accountAddress: targetAccountAddress,
                password,
            });
            this.instrument('[exportClientKeyshares] completed', {
                key: 'exportClientKeyshares-completed',
                startTime,
                time: Date.now() - startTime,
                traceId,
            });
            return result;
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const transaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    if (!transaction)
                        return undefined;
                    return this.internalSignAndSendTransaction(transaction);
                }),
            });
            return transaction;
        });
    }
    endSession() {
        const _super = Object.create(null, {
            endSession: { get: () => super.endSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.endSession.call(this);
        });
    }
    signMessageWithContext() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
}
Object.defineProperty(DynamicWaasSVMConnector, 'key', {
    value: 'dynamicwaas',
    writable: false,
});

export { DynamicWaasSVMConnector };
