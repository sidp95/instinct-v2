'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var web3_js = require('@solana/web3.js');
var utils$1 = require('@walletconnect/utils');
var bs58 = require('bs58');
var EventEmitter = require('eventemitter3');
var solanaCore = require('@dynamic-labs/solana-core');
var utils = require('@dynamic-labs/utils');
var walletConnect = require('@dynamic-labs/wallet-connect');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var logger = require('../../utils/logger.cjs');
var createSolanaSignerForWalletConnect = require('./createSolanaSignerForWalletConnect/createSolanaSignerForWalletConnect.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

const WC_SOLANA_CURRENT_CHAIN_KEY = 'dynamic-wc2-solana-current-chain';
class SolanaWalletConnectConnector extends solanaCore.SolanaWalletConnector {
    constructor(opts) {
        super(opts);
        this.activeAccountEmitter = new EventEmitter__default["default"]();
        this.isInitialized = false;
        this.canConnectViaQrCode = true;
        this.isWalletConnect = true;
        this.canHandleMultipleConnections = false;
        /**
         * Set to false to prevent merging wallet book chains with connector-specific chains.
         *
         * Solana WalletConnect connectors (e.g., Trust Wallet Solana connector) have a walletKey
         * like 'trust' that matches the wallet book entry for the Trust Wallet brand. The wallet
         * book entry indicates Trust supports both EVM and SOL chains globally. However, THIS
         * specific connector instance only supports SOL.
         *
         * If we merge wallet book chains, a Solana-only connector would incorrectly include ETH/EVM
         * in its supported chains, causing it to pass the filter when only ETH is enabled (even
         * though Solana is disabled). By setting this to false, we ensure that only the connector's
         * specific supported chains (['SOL']) are used for filtering, so Solana connectors are
         * correctly filtered out when Solana is disabled.
         */
        this.mergeWalletBookChains = false;
        this.name = opts.walletName;
        const storedChainId = utils.StorageService.getItem(WC_SOLANA_CURRENT_CHAIN_KEY);
        if (storedChainId) {
            this.setNetworkId(storedChainId);
        }
        if (opts.overrideKey) {
            this.overrideKey = opts.overrideKey;
        }
        if (!opts.projectId) {
            throw new utils.DynamicError('WalletConnect project ID is required');
        }
    }
    get deepLinkPreference() {
        var _a;
        return (_a = this.constructorProps.deepLinkPreference) !== null && _a !== void 0 ? _a : 'native';
    }
    /**
     * Accesses the sign client singleton instance, and throws if it is not
     * immediately available.
     */
    get signClient() {
        if (!SolanaWalletConnectConnector.signClientReference) {
            throw new utils.DynamicError('Failed to access sign client for Wallet Connect Solana: Sign client not initialized');
        }
        return SolanaWalletConnectConnector.signClientReference;
    }
    getAvailableMethods() {
        var _a, _b;
        if (!this.session) {
            return [];
        }
        return (_b = (_a = this.session.namespaces.solana) === null || _a === void 0 ? void 0 : _a.methods) !== null && _b !== void 0 ? _b : [];
    }
    getSupportedNetworks() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.session) {
                return this.solNetworks.map((network) => network.chainId.toString());
            }
            const sessionChains = (_b = (_a = this.session.namespaces.solana) === null || _a === void 0 ? void 0 : _a.chains) !== null && _b !== void 0 ? _b : [];
            return this.solNetworks
                .filter((network) => sessionChains.includes(`solana:${network.genesisHash}`))
                .map((network) => network.chainId.toString());
        });
    }
    getActiveAddress() {
        var _a, _b;
        if (!this.session) {
            logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] getActiveAddress - no session, returning undefined');
            return undefined;
        }
        logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] getActiveAddress - session', this.session);
        return (_b = (_a = this.session.namespaces.solana) === null || _a === void 0 ? void 0 : _a.accounts) === null || _b === void 0 ? void 0 : _b[0].split(':')[2];
    }
    listenToActiveAccountChange(listener) {
        this.activeAccountEmitter.on('activeAccountDidChange', listener);
        return () => {
            this.activeAccountEmitter.off('activeAccountDidChange', listener);
        };
    }
    isSendBalanceUnsupported() {
        // If there is no session, we assume the wallet supports send balance
        // If we didn't, the send TX button would turn disabled on a refresh
        if (!this.session) {
            return false;
        }
        const supportedMethods = this.getAvailableMethods();
        return (!supportedMethods.includes('solana_signAndSendTransaction') &&
            !supportedMethods.includes('solana_signTransaction'));
    }
    createUiTransaction(from) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            if (this.isSendBalanceUnsupported()) {
                throw new utils.DynamicError('Wallet does not support signing transactions. Please connect to a wallet that supports signing transactions.');
            }
            const transaction = new solanaCore.SolanaUiTransaction({
                connection: this.getWalletClient(),
                from,
                onSubmit: (transaction) => _tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    if (!transaction)
                        return;
                    const blockhash = yield this.getWalletClient().getLatestBlockhash();
                    if ('version' in transaction) {
                        transaction.message.recentBlockhash =
                            blockhash.blockhash;
                    }
                    else {
                        // Use the 'from' parameter which is the validated active wallet address
                        transaction.recentBlockhash = blockhash.blockhash;
                        transaction.feePayer =
                            (_a = transaction.feePayer) !== null && _a !== void 0 ? _a : new web3_js.PublicKey(from);
                    }
                    return yield this.signAndSendTransaction(transaction);
                }),
            });
            return transaction;
        });
    }
    getSigner() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return createSolanaSignerForWalletConnect.createSolanaSignerForWalletConnect({ walletConnector: this });
        });
    }
    connect() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            throw new Error('Connect method not implemented.');
        });
    }
    static globalInit(args) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            SolanaWalletConnectConnector.signClientPromise = walletConnect.getSignClientSingleton({
                appIcon: (_a = args.appLogoUrl) !== null && _a !== void 0 ? _a : '',
                appName: (_b = args.appName) !== null && _b !== void 0 ? _b : '',
                projectId: args.projectId,
            });
            SolanaWalletConnectConnector.signClientReference =
                yield SolanaWalletConnectConnector.signClientPromise;
            SolanaWalletConnectConnector.signClientReference.on('session_event', (event) => {
                SolanaWalletConnectConnector.sessionEventListeners.forEach((listener) => {
                    listener(event);
                });
            });
        });
    }
    static testOnly__reset() {
        SolanaWalletConnectConnector.signClientPromise = undefined;
        SolanaWalletConnectConnector.signClientReference = undefined;
        SolanaWalletConnectConnector.sessionEventListeners = [];
    }
    init() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (this.isInitialized) {
                return;
            }
            logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] init called');
            this.isInitialized = true;
            // Check if WalletConnect is enabled in project settings
            const isWalletConnectEnabled = (_d = (_c = (_b = (_a = this.constructorProps.settings) === null || _a === void 0 ? void 0 : _a.sdk) === null || _b === void 0 ? void 0 : _b.walletConnect) === null || _c === void 0 ? void 0 : _c.v2Enabled) !== null && _d !== void 0 ? _d : false;
            if (!isWalletConnectEnabled) {
                logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] skipping init - WalletConnect is not enabled in project settings');
                return;
            }
            if (SolanaWalletConnectConnector.signClientPromise) {
                yield SolanaWalletConnectConnector.signClientPromise;
                this.setupWCEventListeners();
                return;
            }
            yield SolanaWalletConnectConnector.globalInit(this.constructorProps);
            this.setupWCEventListeners();
        });
    }
    handleSessionEvent({ params: { event }, topic }) {
        var _a, _b;
        // Ignore events for wallets other than the one we are connected to
        if (!this.session || topic !== this.session.topic) {
            return;
        }
        if (event.name === 'chainChanged') {
            const chainParam = event.data;
            let chainId = chainParam;
            // Handle potentially CAIP-2 format
            if (typeof chainParam === 'string' && chainParam.startsWith('solana:')) {
                const chainHash = chainParam.split(':')[1];
                chainId =
                    (_b = (_a = this.solNetworks
                        .find((network) => network.genesisHash === chainHash)) === null || _a === void 0 ? void 0 : _a.networkId.toString()) !== null && _b !== void 0 ? _b : chainParam;
            }
            logger.logger.debug('[SolanaWalletConnect] onChainChange', { chainId });
            if (chainId === this.getNetworkId()) {
                logger.logger.debug(`[SolanaWalletConnect] onChainChange - ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
                return;
            }
            // This will already emit an event so no need to call this.emit('chainChange', { chain: chainId });
            this.switchNetwork({ networkChainId: parseInt(String(chainId)) });
            return;
        }
        if (event.name === 'accountsChanged') {
            const accountsParam = event.data;
            const accounts = utils.filterDuplicates(accountsParam.map((account) => {
                // Handle potentially CAIP-10 format
                if (account.startsWith('solana:')) {
                    return account.split(':')[2];
                }
                return account;
            }));
            logger.logger.debug('[SolanaWalletConnect] onAccountChanged', { accounts });
            this.emit('accountChange', { accounts });
            return;
        }
        if (event.name === 'disconnected') {
            logger.logger.debug('[SolanaWalletConnect] onDisconnect');
            this.emit('disconnect');
            this.endSession();
            return;
        }
    }
    setupWCEventListeners() {
        SolanaWalletConnectConnector.sessionEventListeners.push((event) => this.handleSessionEvent(event));
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.debug('[SolanaWalletConnect] endSession');
            this.connectionUri = undefined;
            if (!this.session) {
                return;
            }
            yield this.signClient.disconnect({
                reason: utils$1.SDK_ERRORS.USER_DISCONNECTED,
                topic: this.session.topic,
            });
            this.session = undefined;
        });
    }
    displayUri(connectionOpts) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.connectionUri) {
                return;
            }
            logger.logger.debug('[SolanaWalletConnect] handleDisplayURI', this.connectionUri);
            yield walletConnectorCore.performPlatformSpecificConnectionMethod(this.connectionUri, this.metadata.deepLinks, {
                onDesktopUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDesktopUri,
                onDisplayUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDisplayUri,
            }, this.deepLinkPreference);
        });
    }
    getAddress(opts) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            logger.logger.debug('[SolanaWalletConnect] getAddress', opts);
            if (this.session) {
                return this.getActiveAddress();
            }
            /**
             * In mobile/Safari, if the user just navigates back after the deeplink prompt the connection
             * is not rejected, so the previous connection URI is still valid and we can use it to handle the connection
             */
            if (this.connectionUri) {
                logger.logger.debug('[SolanaWalletConnect] getAddress - connecting to WalletConnect with existing connection URI');
                yield this.displayUri(opts);
                return;
            }
            logger.logger.logVerboseTroubleshootingMessage('[WalletConnectConnector] getAddress', {
                inAppBrowserUrl: (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl,
                isMobile: utils.isMobile(),
                mobileExperience: this.mobileExperience,
            });
            const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
            if (didOpenInAppBrowser) {
                return;
            }
            logger.logger.debug('[SolanaWalletConnect] getAddress - connecting to WalletConnect');
            const chains = this.solNetworks.map((network) => `solana:${network.genesisHash}`);
            // Await for the promise in case this gets called right as the window is loaded
            // and the sign client is still initializing
            const signClient = yield SolanaWalletConnectConnector.signClientPromise;
            if (!signClient) {
                throw new utils.DynamicError('Failed to access sign client for Wallet Connect Solana: Sign client not initialized');
            }
            try {
                const { approval, uri } = yield signClient.connect({
                    optionalNamespaces: {
                        solana: {
                            chains,
                            events: ['chainChanged', 'accountsChanged', 'disconnected'],
                            methods: [
                                'solana_signMessage',
                                'solana_signTransaction',
                                'solana_requestAccounts',
                                'solana_getAccounts',
                                'solana_signAllTransactions',
                                'solana_signAndSendTransaction',
                            ],
                        },
                    },
                });
                logger.logger.debug('[SolanaWalletConnect] getAddress - connection URI', uri);
                this.connectionUri = uri;
                yield this.displayUri(opts);
                this.session = yield approval();
                const activeAddress = this.getActiveAddress();
                this.activeAccountEmitter.emit('activeAccountDidChange', activeAddress);
                return activeAddress;
            }
            finally {
                this.connectionUri = undefined;
            }
        });
    }
    signClientRequest(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ method, params, }) {
            var _b, _c;
            if (!this.session) {
                throw new utils.DynamicError('Session not initialized. Please connect to a wallet first.');
            }
            const chainHash = (_c = (_b = this.getSelectedNetwork()) === null || _b === void 0 ? void 0 : _b.genesisHash) !== null && _c !== void 0 ? _c : this.solNetworks[0].genesisHash;
            const chainId = `solana:${chainHash}`;
            try {
                const requestPromise = this.signClient.request({
                    chainId,
                    request: {
                        method,
                        params,
                    },
                    topic: this.session.topic,
                });
                this.deepLinkIfApplicable({ method });
                return yield requestPromise;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                // If they are throwing a generic error, lets end session to ensure the user will be prompted to reconnect
                // on the next attempt. This should fix the issue.
                // Yes their error message has a typo on "occured"
                if (error.message === 'An error has occured. Please, try again.') {
                    yield this.endSession();
                    throw new utils.DynamicError('Wallet connection lost. Please, try again.');
                }
                throw error;
            }
        });
    }
    deepLinkIfApplicable(params) {
        const methodsThatRequireDeepLink = [
            'solana_signMessage',
            'solana_signTransaction',
            'solana_signAllTransactions',
            'solana_signAndSendTransaction',
        ];
        const deepLink = this.getDeepLink();
        if (utils.isMobile() &&
            deepLink &&
            methodsThatRequireDeepLink.includes(params.method)) {
            utils.PlatformService.openURL(deepLink);
        }
    }
    signMessage(messageToSign, options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] signMessage', messageToSign, options);
            const encodedMessage = new TextEncoder().encode(messageToSign);
            const decodedSignature = yield this.signEncodedMessage(encodedMessage, options);
            return utils.bufferToBase64(decodedSignature);
        });
    }
    signEncodedMessage(encodedMessage, options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] signEncodedMessage', encodedMessage, options);
            if (options === null || options === void 0 ? void 0 : options.address) {
                yield this.validateActiveWallet(options.address);
            }
            const activeAddress = this.getActiveAddress();
            if (!activeAddress) {
                throw new utils.DynamicError('No active address found');
            }
            const { signature } = yield this.signClientRequest({
                method: 'solana_signMessage',
                params: {
                    message: bs58__default["default"].encode(encodedMessage),
                    pubkey: new web3_js.PublicKey(activeAddress).toBase58(),
                },
            });
            return bs58__default["default"].decode(signature);
        });
    }
    serializeTransaction(transaction) {
        const serialized = transaction.serialize({
            requireAllSignatures: false,
            verifySignatures: false,
        });
        return Buffer.from(new Uint8Array(serialized)).toString('base64');
    }
    signTransaction(transaction) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const activeAddress = this.getActiveAddress();
            if (!activeAddress) {
                throw new utils.DynamicError('Active account address is required');
            }
            logger.logger.debug('[SolanaWalletConnect] Signing transaction', {
                activeAddress,
                isVersioned: 'version' in transaction,
                transaction,
            });
            const serializedTransaction = this.serializeTransaction(transaction);
            logger.logger.debug('[SolanaWalletConnect] Sending to wallet for signing', {
                serializedLength: serializedTransaction.length,
            });
            const { signature } = yield this.signClientRequest({
                method: 'solana_signTransaction',
                params: { transaction: serializedTransaction },
            });
            logger.logger.debug('[SolanaWalletConnect] Received transaction signature from wallet', { signature });
            // WalletConnect returns signatures as base58-encoded strings even though it expects base64 input
            const signatureBytes = bs58__default["default"].decode(signature);
            transaction.addSignature(new web3_js.PublicKey(activeAddress), signatureBytes);
            return transaction;
        });
    }
    signAllTransactions(transactions) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const serializedTransactions = transactions.map(this.serializeTransaction);
            const { transactions: signedTransactions } = yield this.signClientRequest({
                method: 'solana_signAllTransactions',
                params: { transactions: serializedTransactions },
            });
            return signedTransactions.map((signedTransaction, index) => {
                const originalTransaction = transactions[index];
                const decodedTransaction = new Uint8Array(Buffer.from(signedTransaction, 'base64'));
                if (solanaCore.isVersionedTransaction(originalTransaction)) {
                    return web3_js.VersionedTransaction.deserialize(decodedTransaction);
                }
                return web3_js.Transaction.from(decodedTransaction);
            });
        });
    }
    signAndSendTransaction(transaction, options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const supportedMethods = this.getAvailableMethods();
            // Try to use signAndSendTransaction if supported
            if (supportedMethods.includes('solana_signAndSendTransaction')) {
                const serializedTransaction = this.serializeTransaction(transaction);
                const { signature } = yield this.signClientRequest({
                    method: 'solana_signAndSendTransaction',
                    params: { sendOptions: options, transaction: serializedTransaction },
                });
                return signature;
            }
            // Fallback: use signTransaction + sendRawTransaction
            if (supportedMethods.includes('solana_signTransaction')) {
                logger.logger.debug('[SolanaWalletConnect] Using fallback: signTransaction + sendRawTransaction');
                const signedTransaction = yield this.signTransaction(transaction);
                const isSigned = solanaCore.isTxAlreadySigned(signedTransaction);
                logger.logger.debug('[SolanaWalletConnect] Transaction signed, checking signatures', {
                    hasSignatures: 'signatures' in signedTransaction &&
                        signedTransaction.signatures.length > 0,
                    isSigned,
                    signaturesLength: 'signatures' in signedTransaction
                        ? signedTransaction.signatures.length
                        : 'N/A',
                });
                if (!isSigned) {
                    throw new utils.DynamicError('Transaction returned from wallet was not properly signed. The wallet may have rejected the signing request.');
                }
                // When sending a signed transaction, serialize it without flags
                // (requireAllSignatures and verifySignatures are only for unsigned transactions)
                const serialized = signedTransaction.serialize();
                logger.logger.debug('[SolanaWalletConnect] Transaction serialized', {
                    serializedLength: serialized.length,
                });
                const signature = yield this.getWalletClient().sendRawTransaction(serialized, options);
                logger.logger.debug('[SolanaWalletConnect] Transaction sent successfully', {
                    signature,
                });
                return signature;
            }
            throw new utils.DynamicError('Wallet does not support signing and sending transactions. Please connect to a wallet that supports at least solana_signTransaction.');
        });
    }
    getDeepLink() {
        const deepLink = walletConnectorCore.getDeepLink({
            deepLinks: this.metadata.deepLinks,
            mode: 'regular',
            preference: this.deepLinkPreference,
        });
        logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] getDeepLink - deepLink', deepLink);
        if (!deepLink) {
            return;
        }
        if (this.session) {
            // we need to include the session topic here because it helps the wallet
            // auto redirect back to the dapp after signing
            return `${deepLink}?sessionTopic=${this.session.topic}`;
        }
        return deepLink;
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            /**
             * Each session has a single account (it might be on multiple chains hence the array),
             * but that account is stored as a CAIP-10 string, so we need to parse it to get the address
             */
            const account = this.getActiveAddress();
            if (!account) {
                logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] getConnectedAccounts - no activeAccounts, returning empty array');
                return [];
            }
            logger.logger.logVerboseTroubleshootingMessage('[SolanaWalletConnect] getConnectedAccounts - activeAccounts', [account]);
            return [account];
        });
    }
    getConnectionUri() {
        return this.connectionUri;
    }
    validateActiveWallet(expectedAddress) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.debug('[SolanaWalletConnect] validateActiveWallet - validating wallet', expectedAddress);
            const [activeAddress] = yield this.getConnectedAccounts();
            const isWalletActive = walletConnectorCore.isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (isWalletActive) {
                logger.logger.debug('[SolanaWalletConnect] validateActiveWallet - wallet is active');
                return;
            }
            return this.handleWalletNotActive({
                activeAddress,
                expectedAddress,
            });
        });
    }
}
SolanaWalletConnectConnector.sessionEventListeners = [];

exports.SolanaWalletConnectConnector = SolanaWalletConnectConnector;
