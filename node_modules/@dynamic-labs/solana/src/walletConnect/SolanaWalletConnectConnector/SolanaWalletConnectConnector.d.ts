import { SendOptions, Transaction, VersionedTransaction } from '@solana/web3.js';
import SignClient from '@walletconnect/sign-client';
import type { SessionTypes, SignClientTypes } from '@walletconnect/types';
import { ISolanaSigner, SolanaWalletConnector, SolanaWalletConnectorOpts } from '@dynamic-labs/solana-core';
import { DeepLinkVariant, GetAddressOpts, ISendBalanceWalletConnector, IWalletConnectConnector } from '@dynamic-labs/wallet-connector-core';
import { IUITransaction } from '@dynamic-labs/types';
export type SolanaWalletConnectConnectorOpts = SolanaWalletConnectorOpts & {
    projectId?: string;
    walletName: string;
    deepLinkPreference?: DeepLinkVariant;
    appLogoUrl?: string;
    appName?: string;
    overrideKey?: string;
};
type SessionEventArgs = SignClientTypes.BaseEventArgs<{
    event: {
        name: string;
        data: any;
    };
    chainId: string;
}>;
export declare class SolanaWalletConnectConnector extends SolanaWalletConnector implements IWalletConnectConnector, ISendBalanceWalletConnector {
    name: string;
    static signClientReference: SignClient | undefined;
    static signClientPromise: Promise<SignClient> | undefined;
    static sessionEventListeners: ((args: SessionEventArgs) => void)[];
    /**
     * When a WalletConnect connection is initiated, we store the connection URI
     * so we can use it to handle the URI for wallet app connection and still have
     * it if we need it again before the connection is established (for instance,
     * when a user navigates back to the dapp after a deeplink and then attempts to deeplink again)
     */
    private connectionUri;
    session: SessionTypes.Struct | undefined;
    private activeAccountEmitter;
    isInitialized: boolean;
    canConnectViaQrCode: boolean;
    isWalletConnect: boolean;
    canHandleMultipleConnections: boolean;
    /**
     * Set to false to prevent merging wallet book chains with connector-specific chains.
     *
     * Solana WalletConnect connectors (e.g., Trust Wallet Solana connector) have a walletKey
     * like 'trust' that matches the wallet book entry for the Trust Wallet brand. The wallet
     * book entry indicates Trust supports both EVM and SOL chains globally. However, THIS
     * specific connector instance only supports SOL.
     *
     * If we merge wallet book chains, a Solana-only connector would incorrectly include ETH/EVM
     * in its supported chains, causing it to pass the filter when only ETH is enabled (even
     * though Solana is disabled). By setting this to false, we ensure that only the connector's
     * specific supported chains (['SOL']) are used for filtering, so Solana connectors are
     * correctly filtered out when Solana is disabled.
     */
    mergeWalletBookChains: boolean;
    constructor(opts: SolanaWalletConnectConnectorOpts);
    get deepLinkPreference(): DeepLinkVariant;
    /**
     * Accesses the sign client singleton instance, and throws if it is not
     * immediately available.
     */
    get signClient(): SignClient;
    getAvailableMethods(): string[];
    getSupportedNetworks(): Promise<string[]>;
    getActiveAddress(): string | undefined;
    listenToActiveAccountChange(listener: (account: string) => void): VoidFunction;
    isSendBalanceUnsupported(): boolean;
    createUiTransaction(from: string): Promise<IUITransaction>;
    getSigner(): Promise<ISolanaSigner>;
    connect(): Promise<void>;
    static globalInit(args: {
        appLogoUrl: string;
        appName: string;
        projectId: string;
    }): Promise<void>;
    static testOnly__reset(): void;
    init(): Promise<void>;
    handleSessionEvent({ params: { event }, topic }: SessionEventArgs): void;
    private setupWCEventListeners;
    endSession(): Promise<void>;
    private displayUri;
    getAddress(opts?: GetAddressOpts): Promise<string | undefined>;
    private signClientRequest;
    private deepLinkIfApplicable;
    signMessage(messageToSign: string, options?: {
        address?: string;
    }): Promise<string | undefined>;
    signEncodedMessage(encodedMessage: Uint8Array, options?: {
        address?: string;
    }): Promise<Uint8Array>;
    private serializeTransaction;
    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T>;
    signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]>;
    signAndSendTransaction<T extends Transaction | VersionedTransaction>(transaction: T, options?: SendOptions): Promise<string>;
    getDeepLink(): string | undefined;
    getConnectedAccounts(): Promise<string[]>;
    getConnectionUri(): string | undefined;
    validateActiveWallet(expectedAddress: string): Promise<void>;
}
export {};
