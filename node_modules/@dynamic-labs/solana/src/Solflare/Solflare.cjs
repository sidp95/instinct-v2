'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var utils = require('@dynamic-labs/utils');
var walletBook = require('@dynamic-labs/wallet-book');
var InjectedWalletBase = require('../injected/InjectedWalletBase/InjectedWalletBase.cjs');

class Solflare extends InjectedWalletBase.InjectedWalletBase {
    constructor(props) {
        super(props);
        this.name = 'Solflare';
        this.overrideKey = 'solflare';
        this.walletConnectWalletBookEntry = walletBook.findWalletBookWallet(props.walletBook, this.key);
    }
    getMobileOrInstalledWallet() {
        // Dont use WC on mobile
        if (utils.isMobile()) {
            return this;
        }
        return super.getMobileOrInstalledWallet();
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            /**
             * It should redirect to in-app browser if on mobile and if not in the in-app browser,
             * this checks if it is not in the in-app browser by checking if the provider is not available.
             */
            if (utils.isMobile() && !this.isInstalledOnBrowser()) {
                const mobileDeepLinks = (_a = this.metadata.deepLinks) === null || _a === void 0 ? void 0 : _a.mobile;
                utils.handleMobileWalletRedirect({
                    nativeLink: (mobileDeepLinks === null || mobileDeepLinks === void 0 ? void 0 : mobileDeepLinks.native) || 'solflare://ul/v1/browse',
                    universalLink: (mobileDeepLinks === null || mobileDeepLinks === void 0 ? void 0 : mobileDeepLinks.universal) || 'https://solflare.com/ul/v1/browse',
                });
                return;
            }
            return (_b = this.solProviderHelper) === null || _b === void 0 ? void 0 : _b.getAddress();
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const walletAddress = yield this.getAddress();
            if (!walletAddress) {
                return undefined;
            }
            const provider = yield this.getSigner();
            if (!provider) {
                return undefined;
            }
            const encodedMessage = new TextEncoder().encode(messageToSign);
            const isSignedMessage = (value) => value.signature !== undefined;
            yield provider.connect();
            /**
             * TODO: Remove the sleep once problem is fixed on Solflare's extension.
             * Tracked in DYN-442
             */
            yield new Promise((resolve) => {
                setTimeout(resolve, 100);
            });
            const rawMessage = yield provider.signMessage(encodedMessage, 'utf8');
            return isSignedMessage(rawMessage)
                ? utils.bufferToBase64(rawMessage.signature)
                : undefined;
        });
    }
}
Object.defineProperty(Solflare, 'key', {
    value: 'solflare',
    writable: false,
});

exports.Solflare = Solflare;
