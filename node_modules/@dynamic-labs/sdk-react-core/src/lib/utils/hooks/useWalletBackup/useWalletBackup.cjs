'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
require('@dynamic-labs-sdk/client/core');
require('../../../client/client.cjs');
require('@dynamic-labs-sdk/client');
require('../../../config/ApiEndpoint.cjs');
require('@dynamic-labs/iconic');
require('@dynamic-labs/wallet-connector-core');
require('react/jsx-runtime');
var ViewContext = require('../../../context/ViewContext/ViewContext.cjs');
var logger = require('../../../shared/logger.cjs');
require('@dynamic-labs/wallet-book');
require('@dynamic-labs/utils');
require('../../constants/colors.cjs');
var values = require('../../constants/values.cjs');
require('../../../shared/consts/index.cjs');
var errors = require('../../constants/errors.cjs');
require('@dynamic-labs/multi-wallet');
require('react-international-phone');
require('../../../store/state/nonce/nonce.cjs');
require('@dynamic-labs/locale');
require('../../../store/state/dynamicContextProps/dynamicContextProps.cjs');
require('../../../store/state/primaryWalletId/primaryWalletId.cjs');
require('../../../store/state/connectedWalletsInfo/connectedWalletsInfo.cjs');
require('../../functions/getWaasAddressTypeLabel/getWaasAddressTypeLabel.cjs');
require('../../../events/dynamicEvents.cjs');
var useUser = require('../../../client/extension/user/useUser/useUser.cjs');
var useProjectSettings = require('../../../client/extension/projectSettings/useProjectSettings/useProjectSettings.cjs');
require('../../../context/DynamicContext/DynamicContext.cjs');
require('../../../store/state/loadingAndLifecycle/loadingAndLifecycle.cjs');
require('../../../context/CaptchaContext/CaptchaContext.cjs');
require('../../../context/ErrorContext/ErrorContext.cjs');
require('../../../context/AccessDeniedContext/AccessDeniedContext.cjs');
require('../../../context/AccountExistsContext/AccountExistsContext.cjs');
require('../../../context/UserWalletsContext/UserWalletsContext.cjs');
require('../../../store/state/authMode/authMode.cjs');
require('../../../context/VerificationContext/VerificationContext.cjs');
require('react-dom');
require('../../functions/compareChains/compareChains.cjs');
require('../../../views/Passkey/utils/findPrimaryEmbeddedChain/findPrimaryEmbeddedChain.cjs');
require('../../../context/ThemeContext/ThemeContext.cjs');
require('../useUserUpdateRequest/useUpdateUser/userFieldsSchema.cjs');
require('bs58');
var useSocialAccounts = require('../useSocialAccounts/useSocialAccounts.cjs');
require('yup');
require('../../../context/MockContext/MockContext.cjs');
require('../../../views/CollectUserDataView/useFields.cjs');
require('../../../context/FieldsStateContext/FieldsStateContext.cjs');
require('../../../context/UserFieldEditorContext/UserFieldEditorContext.cjs');
require('@dynamic-labs/rpc-providers');
require('../../../store/state/walletOptions/walletOptions.cjs');
require('react-i18next');
require('../../../components/Accordion/components/AccordionItem/AccordionItem.cjs');
require('../../../components/Alert/Alert.cjs');
require('../../../context/WalletContext/WalletContext.cjs');
require('../../../components/ShadowDOM/ShadowDOM.cjs');
require('../../../components/IconButton/IconButton.cjs');
require('../../../components/InlineWidget/InlineWidget.cjs');
require('../../../components/Input/Input.cjs');
require('../../../components/IsBrowser/IsBrowser.cjs');
require('../../../components/MenuList/Dropdown/Dropdown.cjs');
require('../../../components/OverlayCard/OverlayCard.cjs');
require('../../../components/Transition/ZoomTransition/ZoomTransition.cjs');
require('../../../components/Transition/SlideInUpTransition/SlideInUpTransition.cjs');
require('../../../components/Transition/OpacityTransition/OpacityTransition.cjs');
require('../../../components/PasskeyCreatedSuccessBanner/PasskeyCreatedSuccessBanner.cjs');
require('../../../components/Popper/Popper/Popper.cjs');
require('../../../components/Popper/PopperContext/PopperContext.cjs');
require('react-focus-lock');
require('qrcode');
require('formik');
require('../useSubdomainCheck/useSubdomainCheck.cjs');
require('../../../context/WalletGroupContext/WalletGroupContext.cjs');
var types = require('./types.cjs');
var cloudProviders = require('./cloudProviders.cjs');
require('../../../context/IpConfigurationContext/IpConfigurationContext.cjs');
require('../../../context/SocialRedirectContext/SocialRedirectContext.cjs');
require('../../../context/ConnectWithOtpContext/ConnectWithOtpContext.cjs');
require('../../../widgets/DynamicBridgeWidget/views/WalletsView/components/SecondaryWallets/SecondaryWallets.cjs');
require('@hcaptcha/react-hcaptcha');
require('../../../context/LoadingContext/LoadingContext.cjs');
require('../../../widgets/DynamicWidget/context/DynamicWidgetContext.cjs');
require('../../../widgets/DynamicWidget/helpers/convertExchangeKeyAndProviderEnum.cjs');
require('../../../views/ExchangeWhitelistWarning/ExchangeWhitelistWarning.cjs');
require('../../../context/ErrorContext/hooks/useErrorText/useErrorText.cjs');
require('../../../context/FooterAnimationContext/index.cjs');
require('@dynamic-labs/types');
require('../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/constants.cjs');
require('../../../views/MfaChooseDeviceView/useGetMfaOptions/useGetMfaOptions.cjs');
require('../../../context/PasskeyContext/PasskeyContext.cjs');
require('../../../context/OnrampContext/OnrampContext.cjs');
var useRefreshUser = require('../useRefreshUser/useRefreshUser.cjs');
var useDynamicWaas = require('../useDynamicWaas/useDynamicWaas.cjs');
require('../../../store/state/sendBalances.cjs');
require('../../../store/state/connectorsInitializing/connectorsInitializing.cjs');
require('../../../components/OverlayCardBase/OverlayCardTarget/OverlayCardTarget.cjs');
require('../../../widgets/DynamicWidget/components/DynamicWidgetHeader/DynamicWidgetHeader.cjs');
require('../../../views/TransactionConfirmationView/TransactionConfirmationView.cjs');
require('../../../widgets/DynamicWidget/components/PasskeyCard/PasskeyCard.cjs');
require('../../../widgets/DynamicWidget/views/CryptoComOnramp/CryptoComOnramp.cjs');
require('../../../../index.cjs');
require('../../../widgets/DynamicWidget/views/ReceiveWalletFunds/ReceiveWalletFunds.cjs');
require('../../../store/state/tokenBalances.cjs');
require('../../../store/state/multichainBalances.cjs');
require('../../../shared/utils/functions/getInitialUrl/getInitialUrl.cjs');
var useInternalDynamicContext = require('../../../context/DynamicContext/useDynamicContext/useInternalDynamicContext/useInternalDynamicContext.cjs');

const CLOUD_BACKUP_LOCATIONS = [
    sdkApiCore.WaasBackupOptionsEnum.GoogleDrive,
    sdkApiCore.WaasBackupOptionsEnum.ICloud,
];
const isWalletBackedUp = (cred) => {
    var _a;
    const keyShares = (_a = cred.walletProperties) === null || _a === void 0 ? void 0 : _a.keyShares;
    if (!keyShares || !Array.isArray(keyShares))
        return false;
    return keyShares.some((keyShare) => keyShare &&
        typeof keyShare === 'object' &&
        'backupLocation' in keyShare &&
        CLOUD_BACKUP_LOCATIONS.includes(keyShare.backupLocation));
};
const useWalletBackup = () => {
    var _a, _b;
    const { setShowAuthFlow } = useInternalDynamicContext.useInternalDynamicContext();
    const { pushView } = ViewContext.useViewContext();
    const user = useUser.useUser();
    const projectSettings = useProjectSettings.useProjectSettings();
    const refresh = useRefreshUser.useRefreshUser();
    const { getWaasWalletConnector, getWaasWalletsByCredentials } = useDynamicWaas.useDynamicWaas();
    const { linkSocialAccount, isLinked } = useSocialAccounts.useSocialAccounts();
    const backupOptions = (_b = (_a = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _a === void 0 ? void 0 : _a.waas) === null || _b === void 0 ? void 0 : _b.backupOptions;
    const isGoogleLinked = React.useMemo(() => isLinked(sdkApiCore.ProviderEnum.Google), [isLinked]);
    const [backupState, setBackupState] = React.useState({
        currentIndex: 0,
        failedIndex: null,
        hasError: false,
        isComplete: false,
        isProcessing: false,
        totalWallets: 0,
    });
    const timeoutRef = React.useRef(null);
    React.useEffect(() => () => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
    }, []);
    const getWalletsBackupStatus = React.useCallback(() => getWaasWalletsByCredentials().map((cred) => ({
        address: cred.address,
        chain: values.VerifiedCredentialNameToChainEnum[cred.chain],
        status: isWalletBackedUp(cred) ? 'backed-up' : 'pending',
    })), [getWaasWalletsByCredentials]);
    const getWalletsToBackup = React.useCallback(() => getWalletsBackupStatus()
        .filter((wallet) => wallet.status === 'pending')
        .map(({ address, chain }) => ({ address, chain })), [getWalletsBackupStatus]);
    const areAllWalletsBackedUp = React.useMemo(() => {
        const statuses = getWalletsBackupStatus();
        return (statuses.length > 0 && statuses.every((w) => w.status === 'backed-up'));
    }, [getWalletsBackupStatus]);
    const ensureGoogleLinked = React.useCallback(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _c;
        if (isGoogleLinked) {
            return true;
        }
        try {
            yield linkSocialAccount(sdkApiCore.ProviderEnum.Google, {
                forcePopup: true,
                showWidgetAfterConnection: false,
            });
            const updatedUser = yield refresh();
            const isGoogleLinkedAfterRefresh = (_c = updatedUser === null || updatedUser === void 0 ? void 0 : updatedUser.verifiedCredentials) === null || _c === void 0 ? void 0 : _c.some((cred) => cred.format === 'oauth' && cred.oauthProvider === sdkApiCore.ProviderEnum.Google);
            return Boolean(isGoogleLinkedAfterRefresh);
        }
        catch (error) {
            logger.logger.warn('Error linking Google account for backup', { error });
            return false;
        }
    }), [isGoogleLinked, linkSocialAccount, refresh]);
    const showICloudAuth = React.useCallback((displayContainer, walletChain) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        try {
            const waasConnector = getWaasWalletConnector(walletChain);
            if (!waasConnector) {
                logger.logger.warn('No WaaS connector found for showing iCloud auth', {
                    chain: walletChain,
                });
                return false;
            }
            yield waasConnector.displayICloudSignIn({ displayContainer });
            return true;
        }
        catch (error) {
            logger.logger.warn('Error showing iCloud auth', { error });
            return false;
        }
    }), [getWaasWalletConnector]);
    const checkICloudAuth = React.useCallback((walletChain) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        try {
            const waasConnector = getWaasWalletConnector(walletChain);
            if (!waasConnector) {
                logger.logger.warn('No WaaS connector found for checking iCloud auth', {
                    chain: walletChain,
                });
                return false;
            }
            return yield waasConnector.isICloudAuthenticated();
        }
        catch (error) {
            logger.logger.warn('Error checking iCloud auth', { error });
            return false;
        }
    }), [getWaasWalletConnector]);
    const hideICloudAuth = React.useCallback((walletChain) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        try {
            const waasConnector = getWaasWalletConnector(walletChain);
            if (!waasConnector) {
                logger.logger.warn('No WaaS connector found for hiding iCloud auth', {
                    chain: walletChain,
                });
                return;
            }
            yield waasConnector.hideICloudSignIn();
        }
        catch (error) {
            logger.logger.warn('Error hiding iCloud auth', { error });
        }
    }), [getWaasWalletConnector]);
    const backupWallet = React.useCallback((walletToBackup_1, ...args_1) => _tslib.__awaiter(void 0, [walletToBackup_1, ...args_1], void 0, function* (walletToBackup, provider = types.CloudBackupProvider.GoogleDrive, displayContainer) {
        try {
            const waasConnector = getWaasWalletConnector(walletToBackup.chain);
            if (!waasConnector) {
                logger.logger.warn('No WaaS connector found for wallet', {
                    address: walletToBackup.address,
                });
                return false;
            }
            if (provider === types.CloudBackupProvider.GoogleDrive) {
                yield waasConnector.backupKeySharesToGoogleDrive({
                    accountAddress: walletToBackup.address,
                });
            }
            else if (provider === types.CloudBackupProvider.ICloud) {
                yield waasConnector.backupKeySharesToICloud({
                    accountAddress: walletToBackup.address,
                });
            }
            return true;
        }
        catch (error) {
            logger.logger.warn('Error backing up wallet', {
                address: walletToBackup.address,
                error,
            });
            return false;
        }
    }), [getWaasWalletConnector]);
    const backupAllWallets = React.useCallback((wallets_1, ...args_2) => _tslib.__awaiter(void 0, [wallets_1, ...args_2], void 0, function* (wallets, provider = types.CloudBackupProvider.GoogleDrive, displayContainer) {
        const walletsToProcess = wallets !== null && wallets !== void 0 ? wallets : getWalletsToBackup();
        for (const wallet of walletsToProcess) {
            yield backupWallet(wallet, provider, displayContainer);
        }
        yield refresh();
    }), [getWalletsToBackup, backupWallet, refresh]);
    const startBackup = React.useCallback((onComplete_1, ...args_3) => _tslib.__awaiter(void 0, [onComplete_1, ...args_3], void 0, function* (onComplete, fromIndex = 0, provider = types.CloudBackupProvider.GoogleDrive, displayContainer) {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
        const walletsToBackup = getWalletsToBackup();
        if (walletsToBackup.length === 0) {
            onComplete === null || onComplete === void 0 ? void 0 : onComplete();
            return;
        }
        setBackupState((prev) => (Object.assign(Object.assign({}, prev), { failedIndex: null, hasError: false, isProcessing: true, totalWallets: walletsToBackup.length })));
        for (let i = fromIndex; i < walletsToBackup.length; i++) {
            setBackupState((prev) => (Object.assign(Object.assign({}, prev), { currentIndex: i + 1 })));
            const success = yield backupWallet(walletsToBackup[i], provider, displayContainer);
            if (!success) {
                setBackupState((prev) => (Object.assign(Object.assign({}, prev), { failedIndex: i, hasError: true, isProcessing: false })));
                return;
            }
        }
        yield refresh();
        setBackupState((prev) => (Object.assign(Object.assign({}, prev), { isComplete: true, isProcessing: false })));
        if (onComplete) {
            timeoutRef.current = setTimeout(onComplete, 1000);
        }
    }), [getWalletsToBackup, backupWallet, refresh]);
    const initBackupProcess = React.useCallback(() => {
        if (!user) {
            throw new Error(errors.USER_NOT_LOGGED_IN);
        }
        setShowAuthFlow(true, {
            ignoreIfIsEmbeddedWidget: false,
            performMultiWalletChecks: false,
        });
        pushView('waas-backup-progress-view');
    }, [setShowAuthFlow, pushView, user]);
    const ensureProviderLinked = React.useCallback((provider) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        const config = cloudProviders.CLOUD_PROVIDER_CONFIGS[provider];
        if (config.requiresOAuth && config.oauthProvider) {
            return ensureGoogleLinked();
        }
        return true;
    }), [ensureGoogleLinked]);
    const isProviderLinked = React.useCallback((provider) => {
        const config = cloudProviders.CLOUD_PROVIDER_CONFIGS[provider];
        if (config.requiresOAuth) {
            return isGoogleLinked;
        }
        return true;
    }, [isGoogleLinked]);
    const backupToCloudProvider = React.useCallback((options, walletToBackup) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        try {
            const { provider, password } = options;
            const waasConnector = getWaasWalletConnector(walletToBackup.chain);
            if (!waasConnector) {
                logger.logger.warn('No WaaS connector found for wallet', {
                    address: walletToBackup.address,
                });
                return false;
            }
            if (provider === types.CloudBackupProvider.GoogleDrive) {
                yield waasConnector.backupKeySharesToGoogleDrive({
                    accountAddress: walletToBackup.address,
                    password,
                });
            }
            else if (provider === types.CloudBackupProvider.ICloud) {
                yield waasConnector.backupKeySharesToICloud({
                    accountAddress: walletToBackup.address,
                    password,
                });
            }
            return true;
        }
        catch (error) {
            logger.logger.warn('Error backing up to cloud provider', { error, options });
            return false;
        }
    }), [getWaasWalletConnector]);
    const getSupportedProviders = React.useCallback(() => cloudProviders.getSupportedProviders(backupOptions), [backupOptions]);
    return {
        areAllWalletsBackedUp,
        backupAllWallets,
        backupState,
        backupToCloudProvider,
        backupWallet,
        checkICloudAuth,
        ensureGoogleLinked,
        ensureProviderLinked,
        getSupportedProviders,
        getWalletsBackupStatus,
        getWalletsToBackup,
        hideICloudAuth,
        initBackupProcess,
        isGoogleLinked,
        isProviderLinked,
        showICloudAuth,
        startBackup,
    };
};
const useBackupWallets = (onComplete, provider = types.CloudBackupProvider.GoogleDrive, displayContainer) => {
    const { backupState, startBackup } = useWalletBackup();
    const hasStartedRef = React.useRef(false);
    const onCompleteRef = React.useRef(onComplete);
    onCompleteRef.current = onComplete;
    const config = cloudProviders.CLOUD_PROVIDER_CONFIGS[provider];
    const start = React.useCallback(() => {
        if (hasStartedRef.current)
            return;
        if (config.requiresIframe && !displayContainer) {
            throw new Error(`${config.name} backup requires iframe to be ready`);
        }
        hasStartedRef.current = true;
        startBackup(() => onCompleteRef.current(), 0, provider, displayContainer);
    }, [startBackup, provider, displayContainer, config]);
    const retry = React.useCallback(() => {
        var _a;
        hasStartedRef.current = false;
        const fromIndex = (_a = backupState.failedIndex) !== null && _a !== void 0 ? _a : 0;
        hasStartedRef.current = true;
        startBackup(() => onCompleteRef.current(), fromIndex, provider, displayContainer);
    }, [startBackup, backupState.failedIndex, provider, displayContainer]);
    // Auto-start for non-iframe providers (Google Drive)
    // iCloud requires displayContainer to be ready first
    React.useEffect(() => {
        if (hasStartedRef.current)
            return;
        if (config.requiresIframe)
            return;
        start();
    }, [config.requiresIframe, start]);
    return Object.assign(Object.assign({}, backupState), { retry, start });
};
const useDownloadKeyShares = (onComplete) => {
    const { getWaasWalletConnector, getWaasWalletsByCredentials } = useDynamicWaas.useDynamicWaas();
    const [downloadState, setDownloadState] = React.useState({
        currentIndex: 0,
        failedIndex: null,
        hasError: false,
        isComplete: false,
        isProcessing: false,
        totalWallets: 0,
    });
    const hasStartedRef = React.useRef(false);
    const onCompleteRef = React.useRef(onComplete);
    onCompleteRef.current = onComplete;
    const walletsToDownload = React.useMemo(() => getWaasWalletsByCredentials().map((cred) => ({
        address: cred.address,
        chain: values.VerifiedCredentialNameToChainEnum[cred.chain],
    })), [getWaasWalletsByCredentials]);
    const downloadKeyShare = React.useCallback((walletToDownload) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        try {
            const waasConnector = getWaasWalletConnector(walletToDownload.chain);
            if (!waasConnector) {
                logger.logger.warn('No WaaS connector found for wallet', {
                    address: walletToDownload.address,
                });
                return false;
            }
            yield waasConnector.exportClientKeyshares({
                accountAddress: walletToDownload.address,
            });
            return true;
        }
        catch (error) {
            logger.logger.warn('Error downloading key share', {
                address: walletToDownload.address,
                error,
            });
            return false;
        }
    }), [getWaasWalletConnector]);
    const startDownload = React.useCallback((...args_1) => _tslib.__awaiter(void 0, [...args_1], void 0, function* (fromIndex = 0) {
        if (hasStartedRef.current || walletsToDownload.length === 0)
            return;
        hasStartedRef.current = true;
        setDownloadState((prev) => (Object.assign(Object.assign({}, prev), { currentIndex: fromIndex, failedIndex: null, hasError: false, isComplete: false, isProcessing: true, totalWallets: walletsToDownload.length })));
        for (let i = fromIndex; i < walletsToDownload.length; i++) {
            setDownloadState((prev) => (Object.assign(Object.assign({}, prev), { currentIndex: i + 1 })));
            const success = yield downloadKeyShare(walletsToDownload[i]);
            if (!success) {
                setDownloadState((prev) => (Object.assign(Object.assign({}, prev), { failedIndex: i, hasError: true, isProcessing: false })));
                hasStartedRef.current = false;
                return;
            }
        }
        setDownloadState((prev) => (Object.assign(Object.assign({}, prev), { isComplete: true, isProcessing: false })));
        hasStartedRef.current = false;
        if (onCompleteRef.current) {
            const count = walletsToDownload.length;
            setTimeout(() => { var _a; return (_a = onCompleteRef.current) === null || _a === void 0 ? void 0 : _a.call(onCompleteRef, count); }, 500);
        }
    }), [walletsToDownload, downloadKeyShare]);
    const retry = React.useCallback(() => {
        var _a;
        const fromIndex = (_a = downloadState.failedIndex) !== null && _a !== void 0 ? _a : 0;
        startDownload(fromIndex);
    }, [startDownload, downloadState.failedIndex]);
    return Object.assign(Object.assign({}, downloadState), { retry, startDownload: () => startDownload(0) });
};

exports.isWalletBackedUp = isWalletBackedUp;
exports.useBackupWallets = useBackupWallets;
exports.useDownloadKeyShares = useDownloadKeyShares;
exports.useWalletBackup = useWalletBackup;
