'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var utils = require('@dynamic-labs/utils');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var dynamicEvents = require('../../../events/dynamicEvents.cjs');
require('@dynamic-labs-sdk/client/core');
require('../../../client/client.cjs');
require('@dynamic-labs-sdk/client');
require('../../../config/ApiEndpoint.cjs');
require('@dynamic-labs/iconic');
require('react/jsx-runtime');
require('../../../context/ViewContext/ViewContext.cjs');
require('../../../shared/logger.cjs');
require('@dynamic-labs/wallet-book');
require('../../constants/colors.cjs');
var values = require('../../constants/values.cjs');
require('../../../shared/consts/index.cjs');
require('@dynamic-labs/multi-wallet');
require('react-international-phone');
require('../../../store/state/nonce/nonce.cjs');
var updatePrimaryWalletId = require('../../functions/updatePrimaryWalletId/updatePrimaryWalletId.cjs');
require('../../../store/state/connectedWalletsInfo/connectedWalletsInfo.cjs');
var dynamicContextProps = require('../../../store/state/dynamicContextProps/dynamicContextProps.cjs');
require('../../../store/state/primaryWalletId/primaryWalletId.cjs');
require('@dynamic-labs/locale');
var wallets = require('../../../data/api/wallets/wallets.cjs');
require('../../functions/getWaasAddressTypeLabel/getWaasAddressTypeLabel.cjs');
var convertSdkUserToUserProfile = require('../../../client/extension/user/convertSdkUserToUserProfile/convertSdkUserToUserProfile.cjs');
var useUser = require('../../../client/extension/user/useUser/useUser.cjs');
var useProjectSettings = require('../../../client/extension/projectSettings/useProjectSettings/useProjectSettings.cjs');
var isCookieEnabled = require('../../../client/extension/functions/isCookieEnabled/isCookieEnabled.cjs');
var getMinAuthToken = require('../../../client/extension/functions/getMinAuthToken/getMinAuthToken.cjs');
require('../../../context/DynamicContext/DynamicContext.cjs');
require('../../../store/state/loadingAndLifecycle/loadingAndLifecycle.cjs');
require('../../../context/CaptchaContext/CaptchaContext.cjs');
require('../../../context/ErrorContext/ErrorContext.cjs');
require('../../../context/AccessDeniedContext/AccessDeniedContext.cjs');
require('../../../context/AccountExistsContext/AccountExistsContext.cjs');
var UserWalletsContext = require('../../../context/UserWalletsContext/UserWalletsContext.cjs');
require('../../../store/state/authMode/authMode.cjs');
require('../../../context/VerificationContext/VerificationContext.cjs');
require('react-dom');
var smartWallet = require('../useWalletConnectors/utils/smartWallet/smartWallet.cjs');
require('../../../views/Passkey/utils/findPrimaryEmbeddedChain/findPrimaryEmbeddedChain.cjs');
require('../../../context/ThemeContext/ThemeContext.cjs');
var compareChains = require('../../functions/compareChains/compareChains.cjs');
require('../useUserUpdateRequest/useUpdateUser/userFieldsSchema.cjs');
require('bs58');
require('@dynamic-labs/types');
require('../../../context/SocialRedirectContext/SocialRedirectContext.cjs');
require('../../../context/LoadingContext/LoadingContext.cjs');
require('../../../context/WalletContext/WalletContext.cjs');
var getNewVerifiedCredentialsFromDiff = require('../../functions/getNewVerifiedCredentialsFromDiff/getNewVerifiedCredentialsFromDiff.cjs');
require('../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/constants.cjs');
require('yup');
require('../../../context/MockContext/MockContext.cjs');
require('../../../views/CollectUserDataView/useFields.cjs');
require('../../../context/FieldsStateContext/FieldsStateContext.cjs');
require('../../../context/UserFieldEditorContext/UserFieldEditorContext.cjs');
require('@dynamic-labs/rpc-providers');
var walletOptions = require('../../../store/state/walletOptions/walletOptions.cjs');
require('react-i18next');
require('../../../components/Accordion/components/AccordionItem/AccordionItem.cjs');
require('../../../components/Alert/Alert.cjs');
require('../../../components/ShadowDOM/ShadowDOM.cjs');
require('../../../components/IconButton/IconButton.cjs');
require('../../../components/InlineWidget/InlineWidget.cjs');
require('../../../components/Input/Input.cjs');
require('../../../components/IsBrowser/IsBrowser.cjs');
require('../../../components/MenuList/Dropdown/Dropdown.cjs');
require('../../../components/OverlayCard/OverlayCard.cjs');
require('../../../components/Transition/ZoomTransition/ZoomTransition.cjs');
require('../../../components/Transition/SlideInUpTransition/SlideInUpTransition.cjs');
require('../../../components/Transition/OpacityTransition/OpacityTransition.cjs');
require('../../../components/PasskeyCreatedSuccessBanner/PasskeyCreatedSuccessBanner.cjs');
require('../../../components/Popper/Popper/Popper.cjs');
require('../../../components/Popper/PopperContext/PopperContext.cjs');
require('react-focus-lock');
require('qrcode');
require('formik');
require('../useSubdomainCheck/useSubdomainCheck.cjs');
require('../../../context/WalletGroupContext/WalletGroupContext.cjs');
require('../useWalletBackup/useWalletBackup.cjs');
require('../useWalletBackup/types.cjs');
require('../useWalletBackup/cloudProviders.cjs');
require('../../../context/IpConfigurationContext/IpConfigurationContext.cjs');
require('../../../context/ConnectWithOtpContext/ConnectWithOtpContext.cjs');
require('../../../widgets/DynamicBridgeWidget/views/WalletsView/components/SecondaryWallets/SecondaryWallets.cjs');
require('@hcaptcha/react-hcaptcha');
require('../../../widgets/DynamicWidget/context/DynamicWidgetContext.cjs');
require('../../../widgets/DynamicWidget/helpers/convertExchangeKeyAndProviderEnum.cjs');
require('../../../views/ExchangeWhitelistWarning/ExchangeWhitelistWarning.cjs');
require('../../../context/ErrorContext/hooks/useErrorText/useErrorText.cjs');
require('../../../context/FooterAnimationContext/index.cjs');
require('../../../views/MfaChooseDeviceView/useGetMfaOptions/useGetMfaOptions.cjs');
require('../../../context/PasskeyContext/PasskeyContext.cjs');
require('../../../context/OnrampContext/OnrampContext.cjs');
var useRefreshUser = require('../useRefreshUser/useRefreshUser.cjs');
var apiUrl = require('../../constants/waas/apiUrl.cjs');
var useClientSessionKeys = require('../useClientSessionKeys/useClientSessionKeys.cjs');
var useGetMfaToken = require('../useGetMfaToken/useGetMfaToken.cjs');
var constants = require('./constants.cjs');
var normalizeWalletRequirements = require('./normalizeWalletRequirements.cjs');
require('../../../store/state/sendBalances.cjs');
require('../../../store/state/connectorsInitializing/connectorsInitializing.cjs');
require('../../../components/OverlayCardBase/OverlayCardTarget/OverlayCardTarget.cjs');
require('../../../widgets/DynamicWidget/components/DynamicWidgetHeader/DynamicWidgetHeader.cjs');
require('../../../views/TransactionConfirmationView/TransactionConfirmationView.cjs');
require('../../../widgets/DynamicWidget/components/PasskeyCard/PasskeyCard.cjs');
require('../../../widgets/DynamicWidget/views/CryptoComOnramp/CryptoComOnramp.cjs');
require('../../../../index.cjs');
require('../../../widgets/DynamicWidget/views/ReceiveWalletFunds/ReceiveWalletFunds.cjs');
require('../../../store/state/tokenBalances.cjs');
require('../../../store/state/multichainBalances.cjs');
require('../../../shared/utils/functions/getInitialUrl/getInitialUrl.cjs');
var useInternalDynamicContext = require('../../../context/DynamicContext/useDynamicContext/useInternalDynamicContext/useInternalDynamicContext.cjs');

const dynamicWaasKey = 'dynamicwaas';
const configWaasWalletConnector = ({ walletConnector, environmentId, apiBaseUrl, relayUrl, baseClientKeysharesRelayApiUrl, authMode = 'header', getSignedSessionId, getMfaToken, }) => {
    var _a;
    walletConnector.setEnvironmentId(environmentId);
    walletConnector.setBaseApiUrl((_a = (apiBaseUrl || apiUrl.DEFAULT_WAAS_API_URL)) === null || _a === void 0 ? void 0 : _a.replace('/api/v0', ''));
    if (authMode === 'cookie') {
        walletConnector.setWaasAuthMode('cookie');
        walletConnector.setGetAuthTokenFunction(() => '');
    }
    else {
        walletConnector.setWaasAuthMode('header');
        walletConnector.setGetAuthTokenFunction(getMinAuthToken.getMinAuthToken);
    }
    walletConnector.setGetSignedSessionIdFunction(getSignedSessionId);
    walletConnector.setRelayUrl(relayUrl);
    walletConnector.setGetMfaTokenFunction(getMfaToken);
    walletConnector.setBaseClientKeysharesRelayApiUrl(baseClientKeysharesRelayApiUrl);
    return walletConnector;
};
const useDynamicWaas = () => {
    var _a, _b, _c, _d, _e, _f;
    const { setShowAuthFlow, primaryWallet } = useInternalDynamicContext.useInternalDynamicContext();
    const { addedWalletsIds, userWallets } = UserWalletsContext.useInternalUserWallets();
    const user = useUser.useUser();
    const apiBaseUrl = dynamicContextProps.useApiBaseUrl();
    const projectSettings = useProjectSettings.useProjectSettings();
    const environmentId = dynamicContextProps.useEnvironmentId();
    const walletConnectorOptions = walletOptions.useWalletConnectorOptions();
    const refresh = useRefreshUser.useRefreshUser();
    const relayUrl = (_b = (_a = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _a === void 0 ? void 0 : _a.waas) === null || _b === void 0 ? void 0 : _b.relayUrl;
    const baseClientKeysharesRelayApiUrl = (_d = (_c = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk) === null || _c === void 0 ? void 0 : _c.waas) === null || _d === void 0 ? void 0 : _d.customKeyshareRelayBaseUrl;
    const embeddedWalletSettings = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk.embeddedWallets;
    const enabledChains = (_e = embeddedWalletSettings === null || embeddedWalletSettings === void 0 ? void 0 : embeddedWalletSettings.chainConfigurations) === null || _e === void 0 ? void 0 : _e.filter((c) => c.enabled);
    const primaryChain = enabledChains === null || enabledChains === void 0 ? void 0 : enabledChains.find((chain) => chain.primary);
    const enabledChainNames = enabledChains === null || enabledChains === void 0 ? void 0 : enabledChains.map((chain) => chain.name);
    const automaticEmbeddedWalletCreationEnabled = embeddedWalletSettings === null || embeddedWalletSettings === void 0 ? void 0 : embeddedWalletSettings.automaticEmbeddedWalletCreation;
    const automaticEmbeddedWalletCreationForExternalEnabled = embeddedWalletSettings === null || embeddedWalletSettings === void 0 ? void 0 : embeddedWalletSettings.automaticEmbeddedWalletCreationForExternal;
    const defaultWalletVersion = embeddedWalletSettings === null || embeddedWalletSettings === void 0 ? void 0 : embeddedWalletSettings.defaultWalletVersion;
    const dynamicWaasIsEnabled = defaultWalletVersion === sdkApiCore.EmbeddedWalletVersionEnum.V3;
    const authToken = getMinAuthToken.getMinAuthToken();
    const { getSignedSessionId } = useClientSessionKeys.useClientSessionKeys();
    const getMfaToken = useGetMfaToken.useGetMfaToken();
    const isCookieAuthEnabled = projectSettings && isCookieEnabled.isCookieEnabled();
    const isUpgrading = React.useRef(false);
    const getWaasWalletConnector = React.useCallback((chainName) => {
        var _a;
        if (!isCookieAuthEnabled && !authToken) {
            return undefined;
        }
        if (!walletConnectorOptions.length || !environmentId)
            return undefined;
        const walletConnector = (_a = walletConnectorOptions.find((option) => option.key.includes(dynamicWaasKey) &&
            option.walletConnector.connectedChain === chainName)) === null || _a === void 0 ? void 0 : _a.walletConnector;
        if (!walletConnector) {
            throw new utils.DynamicError(constants.DYNAMIC_WAAS_CONNECTOR_NOT_FOUND_ERROR);
        }
        const configuredWalletConnector = configWaasWalletConnector({
            apiBaseUrl: apiBaseUrl || apiUrl.DEFAULT_WAAS_API_URL,
            authMode: isCookieAuthEnabled ? 'cookie' : 'header',
            baseClientKeysharesRelayApiUrl,
            environmentId,
            getMfaToken,
            getSignedSessionId,
            relayUrl: relayUrl !== null && relayUrl !== void 0 ? relayUrl : '',
            walletConnector,
        });
        return configuredWalletConnector;
    }, [
        isCookieAuthEnabled,
        authToken,
        walletConnectorOptions,
        environmentId,
        apiBaseUrl,
        getMfaToken,
        getSignedSessionId,
        relayUrl,
        baseClientKeysharesRelayApiUrl,
    ]);
    const shouldInitializeWaas = React.useMemo(() => {
        var _a;
        const isUserAuthenticated = Boolean((user === null || user === void 0 ? void 0 : user.id) && (user === null || user === void 0 ? void 0 : user.sessionId));
        const userHasVerifiedCredentials = Boolean((_a = user === null || user === void 0 ? void 0 : user.verifiedCredentials) === null || _a === void 0 ? void 0 : _a.length);
        const isChainsEnabled = Boolean(enabledChainNames === null || enabledChainNames === void 0 ? void 0 : enabledChainNames.length);
        const isWalletConnectorOptionsEnabled = Boolean(walletConnectorOptions.length);
        return (isUserAuthenticated &&
            userHasVerifiedCredentials &&
            dynamicWaasIsEnabled &&
            isChainsEnabled &&
            isWalletConnectorOptionsEnabled);
    }, [
        user === null || user === void 0 ? void 0 : user.id,
        user === null || user === void 0 ? void 0 : user.sessionId,
        (_f = user === null || user === void 0 ? void 0 : user.verifiedCredentials) === null || _f === void 0 ? void 0 : _f.length,
        dynamicWaasIsEnabled,
        enabledChainNames === null || enabledChainNames === void 0 ? void 0 : enabledChainNames.length,
        walletConnectorOptions.length,
    ]);
    const initializeWaas = React.useCallback(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        if (!shouldInitializeWaas || !user)
            return;
        try {
            const initializationStart = new Date().getTime();
            const sessionSignature = yield getSignedSessionId();
            yield Promise.all((enabledChainNames || []).map((chain) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
                const walletConnector = getWaasWalletConnector(chain);
                if (!walletConnector)
                    return;
                // Filter for waas wallets on this chain
                const waasWallets = user.verifiedCredentials.filter((credential) => {
                    var _a;
                    return credential.walletName === 'dynamicwaas' &&
                        credential.address &&
                        values.VerifiedCredentialNameToChainEnum[(_a = credential.chain) !== null && _a !== void 0 ? _a : ''] ===
                            walletConnector.connectedChain;
                });
                try {
                    // Initialize waas iframe
                    const client = yield walletConnector.getWaasWalletClient();
                    walletConnectorCore.logger.debug('[useDynamicWaas] initialized waas iframe');
                    const iframeInitializationEnd = new Date().getTime();
                    const iframeLoadingTime = iframeInitializationEnd - initializationStart;
                    walletConnectorCore.logger.instrument('Waas iframe initialized', {
                        chain,
                        end: iframeInitializationEnd,
                        environmentId: user.projectEnvironmentId,
                        key: 'waasIframeInitialized',
                        start: initializationStart,
                        time: iframeLoadingTime,
                        userId: user === null || user === void 0 ? void 0 : user.id,
                    });
                    // If user has waas wallets, restore keyshares to the iframe
                    if (waasWallets.length > 0) {
                        yield Promise.all(waasWallets
                            .filter((wallet) => wallet.address)
                            .map((wallet) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
                            try {
                                walletConnectorCore.logger.debug('[useDynamicWaas] restoring wallet keyshare', {
                                    chain: wallet.chain,
                                    sessionId: user.sessionId,
                                    userId: user.id,
                                    walletAddress: wallet.address,
                                });
                                const keyshareRestorationStart = new Date().getTime();
                                yield client.getWallet({
                                    accountAddress: wallet.address,
                                    signedSessionId: sessionSignature,
                                    walletOperation: 'SIGN_MESSAGE',
                                });
                                const keyshareRestorationEnd = new Date().getTime();
                                const keyshareRestorationTime = keyshareRestorationEnd - keyshareRestorationStart;
                                const totalElapsedTime = keyshareRestorationEnd - initializationStart;
                                walletConnectorCore.logger.instrument('Waas wallet keyshare restored', {
                                    accountAddress: wallet.address,
                                    chain,
                                    end: keyshareRestorationEnd,
                                    environmentId: user.projectEnvironmentId,
                                    key: 'waasWalletKeyshareRestored',
                                    keyshareRestorationTime: keyshareRestorationTime,
                                    start: initializationStart,
                                    time: totalElapsedTime,
                                    userId: user === null || user === void 0 ? void 0 : user.id,
                                });
                            }
                            catch (error) {
                                walletConnectorCore.logger.warn('[useDynamicWaas] Error restoring wallet keyshare', {
                                    chain,
                                    error,
                                    sessionId: user.sessionId,
                                    userId: user.id,
                                    walletAddress: wallet.address,
                                });
                            }
                        })));
                    }
                }
                catch (error) {
                    walletConnectorCore.logger.error('Error initializing waas wallet client', {
                        chain,
                        error,
                        sessionId: user.sessionId,
                        userId: user.id,
                    });
                }
            })));
        }
        catch (error) {
            walletConnectorCore.logger.error('Error initializing waas', {
                error,
                sessionId: user.sessionId,
                userId: user.id,
            });
        }
    }), [
        enabledChainNames,
        getSignedSessionId,
        getWaasWalletConnector,
        shouldInitializeWaas,
        user,
    ]);
    // If no chain names are provided, filter out chains that already have a wallet
    // and make a wallet for each enabled chain
    const createWalletAccount = React.useCallback((requirementsOrChainNames, password, bitcoinConfig) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        if (isUpgrading.current) {
            return;
        }
        if (!(enabledChainNames === null || enabledChainNames === void 0 ? void 0 : enabledChainNames.length)) {
            throw new utils.DynamicError(constants.NO_ENABLED_CHAINS_ERROR);
        }
        // Convert legacy ChainEnum[] format to WalletCreationRequirement[]
        const requirements = normalizeWalletRequirements.normalizeWalletRequirements(requirementsOrChainNames, bitcoinConfig);
        // Validate all chains are enabled
        const validateChains = (reqs) => {
            const allChains = reqs.map((req) => req.chain);
            const invalidChains = allChains.filter((chain) => !enabledChainNames.includes(chain));
            if (invalidChains.length > 0) {
                throw new utils.DynamicError(`${constants.INVALID_CHAINS_ERROR}: ${invalidChains.join(', ')}`);
            }
        };
        validateChains(requirements);
        const previousVerifiedCredentials = (user === null || user === void 0 ? void 0 : user.verifiedCredentials) || [];
        const results = yield Promise.allSettled(requirements.map((requirement) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            const walletConnector = getWaasWalletConnector(requirement.chain);
            if (!walletConnector)
                throw new Error('No connector');
            const requirementBitcoinConfig = requirement.chain === sdkApiCore.ChainEnum.Btc
                ? requirement.bitcoinConfig
                : undefined;
            const createWalletAccountParams = Object.assign({ password, thresholdSignatureScheme: 'TWO_OF_TWO' }, (requirementBitcoinConfig && {
                bitcoinConfig: requirementBitcoinConfig,
            }));
            const account = yield walletConnector.createWalletAccount(createWalletAccountParams);
            return Object.assign(Object.assign({}, account), { chainName: requirement.chain });
        })));
        const processCreationResults = (settledResults, reqs) => {
            const failedChains = [];
            const errors = [];
            settledResults.forEach((result, i) => {
                if (result.status === 'rejected') {
                    const requirement = reqs[i];
                    failedChains.push(requirement.chain);
                    const errorMessage = result.reason instanceof Error
                        ? result.reason.message
                        : String(result.reason);
                    errors.push(`${requirement.chain}: ${errorMessage}`);
                }
            });
            if (failedChains.length > 0) {
                refresh();
                throw new utils.DynamicError(`${constants.WALLET_CREATION_FAILED_ERROR}: ${failedChains.join(', ')}. Errors: ${errors.join('; ')}`);
            }
            return settledResults.map((r) => r.status === 'fulfilled' ? r.value : undefined);
        };
        const createdWalletAccounts = processCreationResults(results, requirements);
        const primaryWalletAccount = createdWalletAccounts === null || createdWalletAccounts === void 0 ? void 0 : createdWalletAccounts.find((wallet) => (wallet === null || wallet === void 0 ? void 0 : wallet.chainName) === (primaryChain === null || primaryChain === void 0 ? void 0 : primaryChain.name));
        const refreshedUser = yield refresh();
        if (refreshedUser) {
            // Add new wallet IDs to trigger walletAdded events
            const newWalletVerifiedCredentials = getNewVerifiedCredentialsFromDiff.getNewVerifiedCredentialsFromDiff(previousVerifiedCredentials, refreshedUser.verifiedCredentials).filter(({ format }) => format === sdkApiCore.JwtVerifiedCredentialFormatEnum.Blockchain);
            const emitWalletCreatedEvents = (walletCredentials) => {
                walletCredentials.forEach((walletVerifiedCredential) => {
                    var _a, _b, _c;
                    try {
                        const chain = values.VerifiedCredentialNameToChainEnum[(_a = walletVerifiedCredential === null || walletVerifiedCredential === void 0 ? void 0 : walletVerifiedCredential.chain) !== null && _a !== void 0 ? _a : ''];
                        const walletConnector = getWaasWalletConnector(chain);
                        if (!walletConnector)
                            return;
                        const wallet = walletConnector.createWallet({
                            address: (_b = walletVerifiedCredential.address) !== null && _b !== void 0 ? _b : '',
                            chain,
                            connector: walletConnector,
                            id: walletVerifiedCredential.id,
                            isAuthenticated: true,
                            key: (_c = walletVerifiedCredential.walletName) !== null && _c !== void 0 ? _c : '',
                        });
                        dynamicEvents.dynamicEvents.emit('embeddedWalletCreated', wallet, walletVerifiedCredential, user ? convertSdkUserToUserProfile.convertSdkUserToUserProfile(user) : undefined);
                    }
                    catch (error) {
                        walletConnectorCore.logger.error(error);
                    }
                });
            };
            emitWalletCreatedEvents(newWalletVerifiedCredentials);
            const newWalletIds = newWalletVerifiedCredentials.map(({ id }) => id);
            addedWalletsIds.current = addedWalletsIds.current.concat(newWalletIds);
            const updatePrimaryWalletIfNeeded = (primaryAccount, refreshed) => {
                if (!primaryAccount)
                    return;
                const createdPrimaryWallet = refreshed.verifiedCredentials.find((wallet) => {
                    var _a, _b, _c;
                    return ((_a = wallet.walletName) === null || _a === void 0 ? void 0 : _a.includes(dynamicWaasKey)) &&
                        ((_b = wallet.address) === null || _b === void 0 ? void 0 : _b.toLowerCase()) ===
                            ((_c = primaryAccount.accountAddress) === null || _c === void 0 ? void 0 : _c.toLowerCase());
                });
                if (!createdPrimaryWallet)
                    return;
                const hasExistingBlockchainWallet = previousVerifiedCredentials.find((vc) => vc.format === 'blockchain');
                if (hasExistingBlockchainWallet)
                    return;
                const smartWalletAccount = smartWallet.findSmartWallet(createdPrimaryWallet, refreshed.verifiedCredentials);
                const walletIdToUse = (smartWalletAccount === null || smartWalletAccount === void 0 ? void 0 : smartWalletAccount.id) || createdPrimaryWallet.id;
                updatePrimaryWalletId.updatePrimaryWalletId(walletIdToUse);
            };
            updatePrimaryWalletIfNeeded(primaryWalletAccount, refreshedUser);
        }
        setShowAuthFlow(false, { performMultiWalletChecks: false }); // close email otp pin modal
        return createdWalletAccounts;
    }), [
        getWaasWalletConnector,
        primaryChain,
        enabledChainNames,
        setShowAuthFlow,
        user,
        refresh,
        addedWalletsIds,
    ]);
    const needsAutoCreateWalletChains = React.useMemo(() => {
        var _a;
        if (!user ||
            !dynamicWaasIsEnabled ||
            !automaticEmbeddedWalletCreationEnabled) {
            return [];
        }
        // check if user have any wallet (V1, V2, or V3/dynamicwaas) for this chain
        const hasEmbeddedWalletForChain = (chain) => {
            var _a, _b;
            return (_b = (_a = user === null || user === void 0 ? void 0 : user.verifiedCredentials) === null || _a === void 0 ? void 0 : _a.some((wallet) => wallet.chain &&
                compareChains.compareChains(wallet.chain, chain) &&
                wallet.walletProvider === sdkApiCore.WalletProviderEnum.EmbeddedWallet)) !== null && _b !== void 0 ? _b : false;
        };
        // If user has an external wallet, only create if automaticEmbeddedWalletCreationForExternalEnabled is true
        const hasExternalWallet = (_a = user === null || user === void 0 ? void 0 : user.verifiedCredentials) === null || _a === void 0 ? void 0 : _a.some((vc) => vc.format === sdkApiCore.JwtVerifiedCredentialFormatEnum.Blockchain &&
            vc.walletProvider !== sdkApiCore.WalletProviderEnum.EmbeddedWallet);
        const shouldCreateDynamicWaasWallet = hasExternalWallet
            ? automaticEmbeddedWalletCreationForExternalEnabled
            : true;
        if (!shouldCreateDynamicWaasWallet) {
            return [];
        }
        const requirements = [];
        // Handle BTC separately - only create native_segwit wallet if BTC is enabled and user doesn't have a BTC wallet
        if (enabledChainNames === null || enabledChainNames === void 0 ? void 0 : enabledChainNames.includes(sdkApiCore.ChainEnum.Btc)) {
            if (!hasEmbeddedWalletForChain(sdkApiCore.ChainEnum.Btc)) {
                requirements.push({
                    bitcoinConfig: { addressType: 'native_segwit' },
                    chain: sdkApiCore.ChainEnum.Btc,
                });
            }
        }
        // For other chains, check if user does NOT have a V3 wallet and does NOT have a V1/V2 wallet
        const otherMissingChains = enabledChainNames === null || enabledChainNames === void 0 ? void 0 : enabledChainNames.filter((chain) => chain !== sdkApiCore.ChainEnum.Btc && !hasEmbeddedWalletForChain(chain));
        // Add other missing chains without address type requirements
        otherMissingChains === null || otherMissingChains === void 0 ? void 0 : otherMissingChains.forEach((chain) => {
            requirements.push({ chain: chain });
        });
        return requirements;
    }, [
        user,
        dynamicWaasIsEnabled,
        automaticEmbeddedWalletCreationEnabled,
        automaticEmbeddedWalletCreationForExternalEnabled,
        enabledChainNames,
    ]);
    const importPrivateKey = (_g) => _tslib.__awaiter(void 0, [_g], void 0, function* ({ chainName, privateKey, addressType, legacyWalletId, }) {
        const walletConnector = getWaasWalletConnector(chainName);
        if (!walletConnector)
            return;
        yield walletConnector.importPrivateKey({
            addressType,
            chainName,
            legacyWalletId,
            privateKey,
        });
        yield refresh();
    });
    const upgradeToDynamicWaas = React.useCallback((_h) => _tslib.__awaiter(void 0, [_h], void 0, function* ({ privateKey, wallet, }) {
        isUpgrading.current = true;
        if (!primaryWallet) {
            throw new utils.DynamicError('Primary wallet not found');
        }
        const chainName = wallet.chain;
        const walletId = wallet.id;
        const walletConnector = getWaasWalletConnector(chainName);
        if (!walletConnector) {
            throw new utils.DynamicError('Wallet connector not found');
        }
        let softDeleteSucceeded = false;
        // 7702 wallets have a -zerodev suffix because it's a credential created on the fly
        const normalizedWalletId = (walletId === null || walletId === void 0 ? void 0 : walletId.replace('-zerodev', '')) || walletId;
        try {
            yield wallets.softDeleteEmbeddedWallet({
                environmentId,
                walletId: normalizedWalletId,
            });
            softDeleteSucceeded = true;
            yield walletConnector.importPrivateKey({
                chainName,
                legacyWalletId: normalizedWalletId,
                privateKey,
                publicAddressCheck: wallet.address,
            });
            isUpgrading.current = false;
        }
        catch (error) {
            // If soft delete succeeded but import failed, try to restore the wallet
            if (softDeleteSucceeded) {
                yield wallets.restoreEmbeddedWallet({
                    environmentId,
                    walletId: normalizedWalletId,
                });
                yield refresh();
            }
            isUpgrading.current = false;
            if (error instanceof utils.DynamicError) {
                throw error;
            }
            const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';
            if (errorMessage.includes('Public address mismatch')) {
                throw new utils.DynamicError('Public address mismatch. Ensure the private key is copied correctly.');
            }
            throw new utils.DynamicError('Upgrade failed, please try again.');
        }
    }), [environmentId, getWaasWalletConnector, primaryWallet, refresh]);
    /**
     * Returns WaaS wallet instances from `userWallets` filtered by `key === 'dynamicwaas'`.
     *
     * Note: This returns runtime wallet instances which may not include all WaaS wallets.
     * For example, an EVM WaaS wallet used as a signer for a smart wallet (e.g., ZeroDev)
     * may appear in `userWallets` with a different key (e.g., 'zerodev') rather than 'dynamicwaas'.
     *
     * Use `getWaasWalletsByCredentials` if you need to identify all WaaS wallets regardless
     * of how they're represented at runtime.
     */
    const getWaasWallets = React.useCallback(() => userWallets.filter((w) => w.key === 'dynamicwaas'), [userWallets]);
    /**
     * Returns all WaaS wallet credentials based on `verifiedCredentials` (the backend source of truth).
     *
     * Unlike `getWaasWallets`, this method identifies WaaS wallets by their credential's
     * `walletName === 'dynamicwaas'`, which is reliable regardless of how the wallet is
     * instantiated at runtime. This is useful for operations like backup and key share export
     * where you need to identify all WaaS wallets, including those used as signers for
     * smart wallets (e.g., ZeroDev, EIP-7702).
     *
     * @returns Array of WaaS wallet credentials with valid address and chain.
     */
    const getWaasWalletsByCredentials = React.useCallback(() => {
        if (!(user === null || user === void 0 ? void 0 : user.verifiedCredentials))
            return [];
        return user.verifiedCredentials.filter((cred) => cred.walletName === 'dynamicwaas' &&
            cred.address &&
            cred.chain &&
            values.VerifiedCredentialNameToChainEnum[cred.chain]);
    }, [user === null || user === void 0 ? void 0 : user.verifiedCredentials]);
    const processSignOnWalletSettings = React.useCallback(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _j;
        if (!(user === null || user === void 0 ? void 0 : user.verifiedCredentials)) {
            return;
        }
        const waasWallets = user.verifiedCredentials.filter((vc) => { var _a; return vc.walletName === 'dynamicwaas' && ((_a = vc.walletProperties) === null || _a === void 0 ? void 0 : _a.settings); });
        for (const wallet of waasWallets) {
            try {
                const settings = (_j = wallet.walletProperties) === null || _j === void 0 ? void 0 : _j.settings;
                const { address, chain } = wallet;
                if (!settings || !address || !chain) {
                    continue;
                }
                const { shouldRefreshOnNextSignOn, reshareOnNextSignOn, revokeOnNextSignOn, } = settings;
                const chainName = values.VerifiedCredentialNameToChainEnum[chain];
                const walletConnector = getWaasWalletConnector(chainName);
                if (!walletConnector) {
                    continue;
                }
                if (revokeOnNextSignOn) {
                    yield walletConnector.revokeDelegation({
                        accountAddress: address,
                    });
                }
                if (shouldRefreshOnNextSignOn) {
                    yield walletConnector.refreshWalletAccountShares({
                        accountAddress: address,
                    });
                }
                if (reshareOnNextSignOn) {
                    yield walletConnector.reshareWalletAccountShares({
                        accountAddress: address,
                        thresholdSignatureScheme: reshareOnNextSignOn,
                    });
                }
            }
            catch (error) {
                walletConnectorCore.logger.error('Failed to process wallet settings:', {
                    error,
                    wallet,
                });
            }
        }
        yield refresh();
    }), [user, getWaasWalletConnector, refresh]);
    const needsSettingsProcessing = React.useMemo(() => {
        if (!(user === null || user === void 0 ? void 0 : user.verifiedCredentials) || !dynamicWaasIsEnabled) {
            return false;
        }
        return user.verifiedCredentials.some((vc) => {
            var _a;
            return vc.walletName === 'dynamicwaas' &&
                ((_a = vc.walletProperties) === null || _a === void 0 ? void 0 : _a.settings) &&
                (vc.walletProperties.settings.shouldRefreshOnNextSignOn ||
                    vc.walletProperties.settings.reshareOnNextSignOn ||
                    vc.walletProperties.settings.revokeOnNextSignOn);
        });
    }, [user, dynamicWaasIsEnabled]);
    return {
        createWalletAccount,
        dynamicWaasIsEnabled,
        getWaasWalletConnector,
        getWaasWallets,
        getWaasWalletsByCredentials,
        importPrivateKey,
        initializeWaas,
        needsAutoCreateWalletChains,
        needsSettingsProcessing,
        processSignOnWalletSettings,
        shouldInitializeWaas,
        upgradeToDynamicWaas,
    };
};

exports.configWaasWalletConnector = configWaasWalletConnector;
exports.useDynamicWaas = useDynamicWaas;
