import {
  AuthStorageEnum,
  Configuration,
  JwtVerifiedCredentialFormatEnum,
  ProviderEnum,
  SDKApi,
  WalletProviderEnum
} from "./chunk-VYCGVLXH.js";
import {
  require_buffer
} from "./chunk-E2DP5LJY.js";
import {
  require_react
} from "./chunk-BUSDCBXK.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-MVEJMUOB.js";

// node_modules/@dynamic-labs/logger/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@dynamic-labs/logger/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter6;
    }
  }
});

// node_modules/@dynamic-labs/utils/node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "node_modules/@dynamic-labs/utils/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter6;
    }
  }
});

// node_modules/@dynamic-labs/wallet-book/node_modules/eventemitter3/index.js
var require_eventemitter33 = __commonJS({
  "node_modules/@dynamic-labs/wallet-book/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter6;
    }
  }
});

// node_modules/@dynamic-labs/wallet-connector-core/node_modules/eventemitter3/index.js
var require_eventemitter34 = __commonJS({
  "node_modules/@dynamic-labs/wallet-connector-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter6;
    }
  }
});

// node_modules/@dynamic-labs-sdk/client/node_modules/eventemitter3/index.js
var require_eventemitter35 = __commonJS({
  "node_modules/@dynamic-labs-sdk/client/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter6;
    }
  }
});

// node_modules/@dynamic-labs/logger/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/logger/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@dynamic-labs/logger/src/utils/deepMerge.js
var deepMerge = (obj1, obj2) => {
  if (typeof obj1 !== "object" || typeof obj2 !== "object") {
    return obj2;
  }
  const result = Object.assign({}, obj1);
  for (const key in obj2) {
    if (Object.prototype.hasOwnProperty.call(obj2, key)) {
      if (typeof obj2[key] === "object" && Object.prototype.hasOwnProperty.call(obj1, key) && typeof obj1[key] === "object") {
        result[key] = deepMerge(obj1[key], obj2[key]);
      } else {
        result[key] = obj2[key];
      }
    }
  }
  return result;
};

// node_modules/@dynamic-labs/logger/src/MetaData/MetaData.js
var MetaData = class _MetaData {
  constructor(meta = {}) {
    this.meta = {};
    this.meta = meta;
  }
  /**
   * Sets a value in the metadata using dot notation for nested keys.
   * @param {string} key - The key in dot notation (e.g., "a.b.c").
   * @param {unknown} value - The value to set.
   */
  set(key, value) {
    const data = {};
    key.split(".").reduce((acc, k, i, arr) => {
      if (i === arr.length - 1) {
        acc[k] = value;
      } else {
        if (!acc[k]) {
          acc[k] = {};
        }
        return acc[k];
      }
    }, data);
    this.meta = deepMerge(this.meta, data);
  }
  /**
   * Retrieves the current metadata.
   * @returns {TMetaData} The metadata.
   */
  get() {
    return this.meta;
  }
  /**
   * Clears the metadata.
   */
  clear() {
    this.meta = {};
  }
  /**
   * Merges another MetaData instance into another MetaData instance.
   * @param {MetaData} meta - The MetaData instance to merge.
   * @returns {MetaData} A new MetaData instance with merged metadata.
   */
  merge(meta) {
    return new _MetaData(deepMerge(this.get(), meta.get()));
  }
};

// node_modules/@dynamic-labs/logger/src/types.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["MUTE"] = 99] = "MUTE";
})(LogLevel || (LogLevel = {}));

// node_modules/@dynamic-labs/logger/src/utils/createCircularReferenceReplacer.js
var createCircularReferenceReplacer = () => {
  const seen = /* @__PURE__ */ new WeakSet();
  return (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value))
        return;
      seen.add(value);
    }
    return value;
  };
};

// node_modules/@dynamic-labs/logger/src/utils/mapLogLevel.js
var mapLogLevel = (level) => {
  if (level in LogLevel && typeof level === "string") {
    return LogLevel[level];
  } else if (level in LogLevel && typeof level === "number") {
    return level;
  } else {
    throw new Error(`Invalid log level: ${level}`);
  }
};

// node_modules/@dynamic-labs/logger/src/utils/processArgs.js
var processArgs = (message) => {
  const objectArgs = message.args.filter((arg) => typeof arg === "object");
  const remainingArgs = message.args.filter((arg) => typeof arg !== "object" || arg instanceof Error).map((arg) => {
    var _a5;
    return (_a5 = arg === null || arg === void 0 ? void 0 : arg.toString) === null || _a5 === void 0 ? void 0 : _a5.call(arg);
  });
  return { objectArgs, remainingArgs };
};

// node_modules/@dynamic-labs/logger/src/utils/getStack.js
var getStack = (constructorOpt) => {
  const err = {};
  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, constructorOpt);
    return err.stack;
  }
  const { stack } = new Error();
  if (stack && constructorOpt) {
    return stack.split("\n").slice(2).join("\n");
  }
  return stack;
};

// node_modules/@dynamic-labs/logger/src/index.js
var LOGGER_GLOBAL_STATE_KEY = Symbol.for("__DYNAMIC_LOGGER_GLOBAL_STATE__");
var globalState = globalThis[LOGGER_GLOBAL_STATE_KEY] || {
  events: new eventemitter3_default(),
  keys: { emitErrors: true },
  logLevel: void 0,
  metaData: new MetaData(),
  troubleshootModeEnabled: false
};
globalThis[LOGGER_GLOBAL_STATE_KEY] = globalState;
var IGNORE_MESSAGES = ["Failed to send logs to server"];
var messageQueue = [];
var Logger = class _Logger {
  static get troubleshootModeEnabled() {
    return globalState.troubleshootModeEnabled;
  }
  static set troubleshootModeEnabled(val) {
    globalState.troubleshootModeEnabled = val;
  }
  constructor(name2, level) {
    this.name = name2;
    this._level = void 0;
    this.metaData = new MetaData();
    this._level = level;
    if (typeof window !== "undefined" && window.localStorage !== void 0) {
      _Logger.troubleshootModeEnabled = _Logger.troubleshootModeEnabled || window.localStorage.getItem("dynamic_enableTroubleshootMode") === "true";
      window.enableTroubleshootMode = () => {
        window.localStorage.setItem("dynamic_enableTroubleshootMode", "true");
        _Logger.troubleshootModeEnabled = true;
      };
      window.disableTroubleshootMode = () => {
        window.localStorage.removeItem("dynamic_enableTroubleshootMode");
        _Logger.troubleshootModeEnabled = false;
      };
    }
  }
  static setEmitErrors(emit) {
    if (emit !== void 0) {
      globalState.keys.emitErrors = emit;
    }
  }
  static setEnvironmentId(environmentId) {
    if (environmentId !== void 0) {
      globalState.keys.environmentId = environmentId;
    }
  }
  getNameArray(name2) {
    return Array.isArray(name2) ? name2 : [name2];
  }
  createLogger(name2, level) {
    return new _Logger([...this.getNameArray(this.name), ...this.getNameArray(name2)], level !== null && level !== void 0 ? level : this.level);
  }
  get logLevel() {
    return LogLevel[this.level];
  }
  setLogLevel(level) {
    this._level = mapLogLevel(level);
  }
  static setLogLevel(level) {
    globalState.logLevel = mapLogLevel(level);
  }
  static resetLogLevel() {
    globalState.logLevel = void 0;
  }
  get level() {
    var _a5;
    if (globalState.logLevel && !this._level) {
      return globalState.logLevel;
    }
    if (this._level === void 0 && typeof process !== "undefined" && ((_a5 = process.env) === null || _a5 === void 0 ? void 0 : _a5["NODE_ENV"]) !== "production") {
      return LogLevel.DEBUG;
    }
    if (this._level === void 0) {
      return LogLevel.WARN;
    }
    return this._level;
  }
  formatMessage(level, message) {
    var _a5;
    if (message instanceof Error) {
      message = message.stack;
    } else if (
      // Handle Error-Like Objects
      message instanceof Object && Object.prototype.hasOwnProperty.call(message, "stack")
    ) {
      message = message.stack;
    } else if (message instanceof Object) {
      message = JSON.stringify(message, createCircularReferenceReplacer());
    }
    const names = (Array.isArray(this.name) ? this.name : [this.name]).map((name2) => `[${name2}]`);
    return `${names.join("")} [${(_a5 = LogLevel[level]) !== null && _a5 !== void 0 ? _a5 : "TROUBLESHOOTING"}]: ${message}`;
  }
  captureAndSend(level, message, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (globalState.keys.emitErrors && !IGNORE_MESSAGES.includes(message === null || message === void 0 ? void 0 : message.toString()) && typeof window !== "undefined") {
        this.emitHttpLogs(level, message, { args });
      }
    });
  }
  emitHttpLogs(level, message, { args = [], transformMeta = (meta) => meta }) {
    const stack = getStack(this.emitHttpLogs);
    messageQueue.push({ args, level, message, stack });
    if (messageQueue.length === 1) {
      queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {
        const currentBatch = messageQueue.splice(0, messageQueue.length);
        const messages = [];
        currentBatch.forEach((msg) => {
          var _a5, _b, _c, _d, _e, _f;
          const body = {};
          const { objectArgs, remainingArgs } = processArgs(msg);
          Object.assign(body, ...objectArgs);
          Object.assign(body, {
            level: LogLevel[msg.level],
            message: [msg.message, ...remainingArgs].join(" "),
            meta: transformMeta(globalState.metaData.merge(this.metaData).get()),
            stack: msg.stack,
            url: {
              hostname: (_a5 = window.location) === null || _a5 === void 0 ? void 0 : _a5.hostname,
              origin: (_b = window.location) === null || _b === void 0 ? void 0 : _b.origin,
              pathname: (_c = window.location) === null || _c === void 0 ? void 0 : _c.pathname,
              port: (_d = window.location) === null || _d === void 0 ? void 0 : _d.port,
              protocol: (_e = window.location) === null || _e === void 0 ? void 0 : _e.protocol
            },
            userAgent: (_f = window.navigator) === null || _f === void 0 ? void 0 : _f.userAgent
          });
          messages.push(body);
        });
        try {
          if (!globalState.keys.environmentId) {
            throw new Error("Environment ID not set");
          }
          yield fetch(`https://logs.dynamicauth.com/api/v1/${globalState.keys.environmentId}`, {
            body: JSON.stringify(messages),
            headers: {
              "Content-Type": "application/json"
            },
            method: "POST",
            mode: "cors",
            referrerPolicy: "origin-when-cross-origin"
          });
        } catch (error79) {
          this.debug("Failed to send logs to server", error79);
        }
      }));
    }
  }
  /**
   * Emits an INFO type message to the backend for analysis and debugging
   */
  instrument(message, options) {
    return this.emitHttpLogs(LogLevel.INFO, message, {
      args: [options],
      // Don't send any meta to avoid storing PII
      transformMeta: () => void 0
    });
  }
  log(level, message, ...args) {
    const enableTroubleshootMode = typeof window !== "undefined" && _Logger.troubleshootModeEnabled;
    if (!enableTroubleshootMode && (level < this.level || level === LogLevel.MUTE)) {
      return;
    }
    globalState.events.emit("log", level, message, ...args);
    const fmtMsg = this.formatMessage(level, message);
    switch (level) {
      case LogLevel.WARN:
        console.warn(fmtMsg, ...args);
        break;
      case LogLevel.ERROR:
        console.error(fmtMsg, ...args);
        break;
      default:
        console.log(fmtMsg, ...args);
    }
    if (level === LogLevel.ERROR) {
      this.captureAndSend(level, message, ...args);
    }
  }
  logVerboseTroubleshootingMessage(message, ...args) {
    this.log(-1, message, ...args);
  }
  debug(message, ...args) {
    this.log(LogLevel.DEBUG, message, ...args);
  }
  info(message, ...args) {
    this.log(LogLevel.INFO, message, ...args);
  }
  warn(message, ...args) {
    this.log(LogLevel.WARN, message, ...args);
  }
  error(message, ...args) {
    this.log(LogLevel.ERROR, message, ...args);
  }
};
Logger.globalMetaData = globalState.metaData;
Logger.events = globalState.events;

// node_modules/@dynamic-labs/assert-package-version/src/lib/assertPackageVersion/assertPackageVersion.js
var packageVersions = {};
var logger = new Logger("@dynamic-labs/assert-package-version");
var versionCheckTimeout = null;
var assertPackageVersion = (packageName, version10) => {
  packageVersions[packageName] = version10;
  if (versionCheckTimeout) {
    clearTimeout(versionCheckTimeout);
    versionCheckTimeout = null;
  }
  const timeout = 100;
  versionCheckTimeout = setTimeout(() => {
    const versions = Object.values(packageVersions);
    const [firstVersion] = versions;
    const allSameVersion = versions.every((v) => v === firstVersion);
    if (!allSameVersion) {
      const targetVersion = packageVersions["@dynamic-labs/sdk-react-core"] || firstVersion;
      const errorMessage = getErrorMessage(targetVersion);
      logger.error(new Error(errorMessage));
    }
    versionCheckTimeout = null;
  }, timeout);
};
var getErrorMessage = (targetVersion) => {
  const affectedPackages = Object.entries(packageVersions).filter(([, v]) => v !== targetVersion).map(([pkgName, installedVersion]) => `- \`${pkgName}\` (installed: **${installedVersion}**, required: **${targetVersion}**)`).join("\n");
  const errorMessage = `
ðŸš¨ Version Mismatch Error

One or more \`@dynamic-labs\` packages are installed with mismatched versions. All \`@dynamic-labs\` packages must be on the same version to work correctly.

Affected Packages:
${affectedPackages}

ðŸ’¡ To fix this issue, update all @dynamic-labs/* packages to version \`${targetVersion}\` in your package.json
ðŸ’¡ Tip: You can use the \`npx dynamic-doctor run\` command to check for other issues with your project setup.
`;
  return errorMessage.trim();
};

// node_modules/@dynamic-labs/utils/src/tracing/tracing.js
var formatTrace = (trace) => `
--- ${trace.scope} : ${trace.timestamp.toISOString()} ---
${trace.payload.join("\n")}
`.trim();
var createTracing = () => {
  const traces = [];
  return {
    /**
     * Formats an object as a pretty-printed JSON string
     * @param object - The object to format
     * @returns JSON string representation of the object
     */
    formatObject: (object3) => JSON.stringify(object3, null, 2),
    /**
     * Logs an event to the trace collection
     * @param scope - The scope/category of the event
     * @param args - String messages to include in the trace
     */
    logEvent: (scope, ...args) => {
      traces.push({
        payload: args,
        scope,
        timestamp: /* @__PURE__ */ new Date()
      });
    },
    /**
     * Formats and returns traces filtered by scope
     * @param scopes - Optional array of scopes to filter traces
     * @returns Formatted trace output as a string
     */
    packScopes: (scopes) => traces.filter((trace) => scopes ? scopes.includes(trace.scope) : true).map(formatTrace).join("\n\n")
  };
};
var tracing = createTracing();

// node_modules/@dynamic-labs/utils/package.js
var version = "4.57.1";

// node_modules/@dynamic-labs/utils/src/bufferToBase64/bufferPolyfill.js
var import_buffer = __toESM(require_buffer(), 1);
if (typeof window !== "undefined") {
  window.global = globalThis;
  if (!window.Buffer && typeof window.Buffer === "undefined") {
    Object.assign(window, { Buffer: import_buffer.Buffer });
  }
}

// node_modules/@dynamic-labs/utils/src/bufferToBase64/bufferToBase64.js
var bufferToBase64 = (buf) => {
  const binstr = Array.prototype.map.call(buf, (ch) => String.fromCharCode(ch)).join("");
  return Buffer.from(binstr, "binary").toString("base64");
};

// node_modules/@dynamic-labs/utils/src/logger/logger.js
var logger2 = new Logger("utils");

// node_modules/@dynamic-labs/utils/src/ceil/ceil.js
var ceil = (value, precision = 0) => {
  const multiplier = Math.pow(10, precision);
  return Math.ceil(value * multiplier) / multiplier;
};

// node_modules/@dynamic-labs/utils/src/DeferredPromise/DeferredPromise.js
var DeferredPromise = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// node_modules/@dynamic-labs/utils/src/errors/CustomError.js
var CustomError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = void 0;
    this.code = code;
    Object.setPrototypeOf(this, this.constructor.prototype);
  }
  toJSON() {
    return {
      code: this.code,
      error: this.message
    };
  }
};

// node_modules/@dynamic-labs/utils/src/errors/DynamicError.js
var DynamicError = class extends CustomError {
};

// node_modules/@dynamic-labs/utils/src/errors/AccessBlockedError.js
var AccessBlockedError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/AccountExistsError.js
var AccountExistsError = class extends DynamicError {
  constructor(errorMessage, errorPayload) {
    super(errorMessage);
    this.errorMessage = errorMessage;
    this.errorPayload = errorPayload;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/ChainalysisError.js
var ChainalysisError = class extends DynamicError {
  constructor(walletPublicKey) {
    super("This address is not approved for access");
    this.walletPublicKey = walletPublicKey;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/CustomFieldNotUniqueError.js
var CustomFieldNotUniqueError = class extends DynamicError {
  constructor() {
    super("Custom Field for user must be unique within the environment", "custom_field_data_not_unique");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailAlreadyExistsError.js
var EmailAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Email already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailVerificationError.js
var EmailVerificationError = class extends DynamicError {
  constructor(message, code) {
    super(message, code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmbeddedWalletException.js
var EmbeddedWalletException = class extends DynamicError {
  constructor(message) {
    super(message);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmbeddedWalletExistsError.js
var EmbeddedWalletExistsError = class extends DynamicError {
  constructor(code) {
    super("EmbeddedWalletExistsError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/ErrorCode.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["UNKNOWN"] = 0] = "UNKNOWN";
  ErrorCode2[ErrorCode2["DEFAULT"] = 1] = "DEFAULT";
  ErrorCode2[ErrorCode2["USER_REJECTED"] = 2] = "USER_REJECTED";
  ErrorCode2[ErrorCode2["MESSAGE_SIGNATURE_DENIED"] = 3] = "MESSAGE_SIGNATURE_DENIED";
  ErrorCode2[ErrorCode2["WALLET_LOCKED"] = 4] = "WALLET_LOCKED";
  ErrorCode2[ErrorCode2["INVALID_PARAMETERS"] = 5] = "INVALID_PARAMETERS";
  ErrorCode2[ErrorCode2["INTERNAL_ERROR"] = 6] = "INTERNAL_ERROR";
  ErrorCode2[ErrorCode2["ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE"] = 7] = "ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE";
  ErrorCode2[ErrorCode2["CONNECTION_REJECTED"] = 8] = "CONNECTION_REJECTED";
  ErrorCode2[ErrorCode2["MISSING_PUBLIC_ADDRESS"] = 9] = "MISSING_PUBLIC_ADDRESS";
  ErrorCode2[ErrorCode2["CONNECTION_PROPOSAL_EXPIRED"] = 10] = "CONNECTION_PROPOSAL_EXPIRED";
  ErrorCode2[ErrorCode2["SEI_NOT_ENABLED_IN_KEPLR_WALLET"] = 11] = "SEI_NOT_ENABLED_IN_KEPLR_WALLET";
})(ErrorCode || (ErrorCode = {}));

// node_modules/@dynamic-labs/utils/src/errors/GateBlockedError.js
var GateBlockedError = class extends DynamicError {
  constructor(walletPublicKey) {
    super("This address is blocked by the gate");
    this.walletPublicKey = walletPublicKey;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/GetAddressCancelledError.js
var GetAddressCancelledError = class extends CustomError {
  constructor() {
    super("Get address call was cancelled");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InsufficientFundsError.js
var InsufficientFundsError = class _InsufficientFundsError extends DynamicError {
  constructor() {
    super(_InsufficientFundsError.message);
  }
  static isInstance(err) {
    var _a5;
    const error79 = ((_a5 = err === null || err === void 0 ? void 0 : err.walk) === null || _a5 === void 0 ? void 0 : _a5.call(err)) || err;
    return error79 instanceof _InsufficientFundsError;
  }
  static isErrorMessage(err) {
    var _a5;
    const errorWithMessage = err;
    return ((_a5 = errorWithMessage === null || errorWithMessage === void 0 ? void 0 : errorWithMessage.message) === null || _a5 === void 0 ? void 0 : _a5.includes("AA21 didn't pay prefund")) || false;
  }
};
InsufficientFundsError.message = "Insufficient funds.";

// node_modules/@dynamic-labs/utils/src/errors/InvalidEmbeddedWalletSessionKeyError.js
var InvalidEmbeddedWalletSessionKeyError = class extends DynamicError {
  constructor(error79) {
    super(error79 !== null && error79 !== void 0 ? error79 : "Invalid embedded wallet session key.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InvalidPhoneNumberError.js
var InvalidPhoneNumberError = class extends DynamicError {
  constructor(error79) {
    super(error79 !== null && error79 !== void 0 ? error79 : "Invalid phone number.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InvalidPrimaryWalletOrConnectorError.js
var InvalidPrimaryWalletOrConnectorError = class extends DynamicError {
  constructor(code) {
    super("Primary wallet is not properly set or the wallet connector is missing from DynamicContextProvider settings.", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MergeAccountsConfirmationError.js
var MergeAccountsConfirmationError = class extends DynamicError {
  constructor({ code, mergeConflicts, walletAddress }) {
    super("MergeAccountsConfirmationError", code);
    this.mergeConflicts = mergeConflicts;
    this.walletAddress = walletAddress;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MetaMaskError.js
var metaMaskErrorMap = {
  4001: ErrorCode.USER_REJECTED
};

// node_modules/@dynamic-labs/utils/src/errors/MissingEnvironmentIdError.js
var MissingEnvironmentIdError = class extends DynamicError {
  constructor() {
    super("You are missing the environmentId field in yours DynamicContextProvider settings prop");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MissingPublicAddressError.js
var MissingPublicAddressError = class extends DynamicError {
  constructor() {
    super("Missing public address", "missing-public-address");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/NoAccessError.js
var NoAccessError = class extends DynamicError {
  constructor({ walletPublicKey, email: email3, phoneNumber, socialProvider, socialUsername }) {
    super("User does not have access");
    this.email = email3;
    this.walletPublicKey = walletPublicKey;
    this.phoneNumber = phoneNumber;
    this.socialProvider = socialProvider;
    this.socialUsername = socialUsername;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/NotSupportedError.js
var NotSupportedError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/RequestChannelNotHandledError.js
var RequestChannelNotHandledError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/_virtual/_tslib.js
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

// node_modules/@dynamic-labs/utils/src/errors/ResponseError.js
var ResponseError = class _ResponseError extends CustomError {
  constructor({ message, cause, jsonData }) {
    const messageError = `
    Message: ${message !== null && message !== void 0 ? message : "Unknown"}
    URL: ${cause.url}
    Status: ${cause.status}
    Status Text: ${cause.statusText}
    Type: ${cause.type}
    Redirect: ${cause.redirected}

    Json data:${jsonData ? "\n" + JSON.stringify(jsonData, null, 2) : " No data"}
    `.trim();
    super(messageError);
    this.jsonData = jsonData;
    this.response = cause;
    this.cause = cause;
  }
  get json() {
    return this.jsonData;
  }
  static fromResponse(_a5) {
    return __awaiter2(this, arguments, void 0, function* ({ cause, message }) {
      const jsonData = yield cause.json();
      return new _ResponseError({
        cause,
        jsonData,
        message
      });
    });
  }
};

// node_modules/@dynamic-labs/utils/src/errors/SandboxMaximumThresholdReachedError.js
var SandboxMaximumThresholdReachedError = class extends DynamicError {
  constructor(errorMessage) {
    super(errorMessage);
    this.errorMessage = errorMessage;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/SmsVerificationError.js
var SmsVerificationError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/SocialAccountAlreadyExistsError.js
var SocialAccountAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Social account already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/TooManyEmailVerificationsError.js
var TooManyEmailVerificationsError = class extends DynamicError {
  constructor() {
    super("Too many email verification attempts.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/TransactionGasCannotBeSponsoredError.js
var TransactionGasCannotBeSponsoredError = class _TransactionGasCannotBeSponsoredError extends DynamicError {
  constructor() {
    super(_TransactionGasCannotBeSponsoredError.message);
  }
  static isInstance(err) {
    var _a5;
    const error79 = ((_a5 = err === null || err === void 0 ? void 0 : err.walk) === null || _a5 === void 0 ? void 0 : _a5.call(err)) || err;
    return error79 instanceof _TransactionGasCannotBeSponsoredError;
  }
  static isErrorMessage(err) {
    var _a5;
    const errorWithMessage = err;
    return ((_a5 = errorWithMessage === null || errorWithMessage === void 0 ? void 0 : errorWithMessage.message) === null || _a5 === void 0 ? void 0 : _a5.includes("userOp did not match any gas sponsoring policies")) || false;
  }
};
TransactionGasCannotBeSponsoredError.message = "Transaction gas cannot be sponsored.";

// node_modules/@dynamic-labs/utils/src/errors/UserHasAccountWithEmailError.js
var UserHasAccountWithEmailError = class extends DynamicError {
  constructor(error79) {
    super(error79);
    this.error = error79;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UsernameAlreadyExistsError.js
var UsernameAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Username already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UserRejectedRequestError.js
var UserRejectedRequestError = class extends DynamicError {
  constructor() {
    super("User rejected request", "user_rejected_request");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UserRejectedTransactionError.js
var UserRejectedTransactionError = class extends DynamicError {
  constructor() {
    super("user rejected transaction");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/VerificationDataCollectionError.js
var VerificationDataCollectionError = class extends DynamicError {
  constructor(message) {
    super("Failed to get verification data: " + message);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletAddressMismatchError.js
var WalletAddressMismatchError = class extends DynamicError {
  constructor(message, { activeAddress, expectedAddress, walletName }) {
    super(message, "wallet_address_mismatch_error");
    this.expectedAddress = expectedAddress;
    this.activeAddress = activeAddress;
    this.walletName = walletName;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletNotDeployedError.js
var WalletNotDeployedError = class extends DynamicError {
  constructor() {
    super("Wallet has not been deployed", "wallet_not_deployed");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletUsedError.js
var WalletUsedError = class extends DynamicError {
  constructor(code) {
    super("WalletUsedError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/trimEnd/trimEnd.js
var trimEnd = (text, char = "") => {
  let endIndex = text.length - 1;
  while (endIndex >= 0 && text[endIndex] === char) {
    endIndex--;
  }
  return text.slice(0, endIndex + 1);
};

// node_modules/@dynamic-labs/utils/src/formatNumberText/formatNumberText.js
var formatNumberText = (value, { precision = 0 } = {}) => {
  if (!precision) {
    return value;
  }
  const floatValue = parseFloat(value);
  const formattedAtPrecision = ceil(floatValue, precision).toFixed(precision);
  const [integerPart, decimalPart] = formattedAtPrecision.split(".");
  const decimalPartTrimmed = trimEnd(decimalPart, "0");
  return `${integerPart}.${decimalPartTrimmed || "0"}`;
};

// node_modules/@dynamic-labs/utils/src/getProvidersFromWindow/getProvidersFromWindow.js
var getProvidersFromWindow = (path) => {
  const splitPath = path.split(".");
  let result = window;
  const foundProviders = [];
  for (const [index, p] of Object.entries(splitPath)) {
    result = result[p];
    if (typeof result !== "object" || result === null) {
      return [];
    }
    if (Number(index) === splitPath.length - 1) {
      if (Array.isArray(result)) {
        result.forEach((p2) => foundProviders.push(p2));
      } else {
        if (result.providers) {
          result.providers.forEach((p2) => foundProviders.push(p2));
        } else {
          foundProviders.push(result);
        }
      }
    }
  }
  return foundProviders;
};

// node_modules/tldts-core/dist/es6/src/domain.js
function shareSameDomainSuffix(hostname3, vhost) {
  if (hostname3.endsWith(vhost)) {
    return hostname3.length === vhost.length || hostname3[hostname3.length - vhost.length - 1] === ".";
  }
  return false;
}
function extractDomainWithSuffix(hostname3, publicSuffix) {
  const publicSuffixIndex = hostname3.length - publicSuffix.length - 2;
  const lastDotBeforeSuffixIndex = hostname3.lastIndexOf(".", publicSuffixIndex);
  if (lastDotBeforeSuffixIndex === -1) {
    return hostname3;
  }
  return hostname3.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain(suffix, hostname3, options) {
  if (options.validHosts !== null) {
    const validHosts = options.validHosts;
    for (const vhost of validHosts) {
      if (
        /*@__INLINE__*/
        shareSameDomainSuffix(hostname3, vhost)
      ) {
        return vhost;
      }
    }
  }
  let numberOfLeadingDots = 0;
  if (hostname3.startsWith(".")) {
    while (numberOfLeadingDots < hostname3.length && hostname3[numberOfLeadingDots] === ".") {
      numberOfLeadingDots += 1;
    }
  }
  if (suffix.length === hostname3.length - numberOfLeadingDots) {
    return null;
  }
  return (
    /*@__INLINE__*/
    extractDomainWithSuffix(hostname3, suffix)
  );
}

// node_modules/tldts-core/dist/es6/src/domain-without-suffix.js
function getDomainWithoutSuffix(domain3, suffix) {
  return domain3.slice(0, -suffix.length - 1);
}

// node_modules/tldts-core/dist/es6/src/extract-hostname.js
function extractHostname(url, urlIsValidHostname) {
  let start = 0;
  let end = url.length;
  let hasUpper = false;
  if (!urlIsValidHostname) {
    if (url.startsWith("data:")) {
      return null;
    }
    while (start < url.length && url.charCodeAt(start) <= 32) {
      start += 1;
    }
    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
      end -= 1;
    }
    if (url.charCodeAt(start) === 47 && url.charCodeAt(start + 1) === 47) {
      start += 2;
    } else {
      const indexOfProtocol = url.indexOf(":/", start);
      if (indexOfProtocol !== -1) {
        const protocolSize = indexOfProtocol - start;
        const c0 = url.charCodeAt(start);
        const c1 = url.charCodeAt(start + 1);
        const c2 = url.charCodeAt(start + 2);
        const c3 = url.charCodeAt(start + 3);
        const c4 = url.charCodeAt(start + 4);
        if (protocolSize === 5 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112 && c4 === 115) {
        } else if (protocolSize === 4 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112) {
        } else if (protocolSize === 3 && c0 === 119 && c1 === 115 && c2 === 115) {
        } else if (protocolSize === 2 && c0 === 119 && c1 === 115) {
        } else {
          for (let i = start; i < indexOfProtocol; i += 1) {
            const lowerCaseCode = url.charCodeAt(i) | 32;
            if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || // [a, z]
            lowerCaseCode >= 48 && lowerCaseCode <= 57 || // [0, 9]
            lowerCaseCode === 46 || // '.'
            lowerCaseCode === 45 || // '-'
            lowerCaseCode === 43)) {
              return null;
            }
          }
        }
        start = indexOfProtocol + 2;
        while (url.charCodeAt(start) === 47) {
          start += 1;
        }
      }
    }
    let indexOfIdentifier = -1;
    let indexOfClosingBracket = -1;
    let indexOfPort = -1;
    for (let i = start; i < end; i += 1) {
      const code = url.charCodeAt(i);
      if (code === 35 || // '#'
      code === 47 || // '/'
      code === 63) {
        end = i;
        break;
      } else if (code === 64) {
        indexOfIdentifier = i;
      } else if (code === 93) {
        indexOfClosingBracket = i;
      } else if (code === 58) {
        indexOfPort = i;
      } else if (code >= 65 && code <= 90) {
        hasUpper = true;
      }
    }
    if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
      start = indexOfIdentifier + 1;
    }
    if (url.charCodeAt(start) === 91) {
      if (indexOfClosingBracket !== -1) {
        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
      }
      return null;
    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
      end = indexOfPort;
    }
  }
  while (end > start + 1 && url.charCodeAt(end - 1) === 46) {
    end -= 1;
  }
  const hostname3 = start !== 0 || end !== url.length ? url.slice(start, end) : url;
  if (hasUpper) {
    return hostname3.toLowerCase();
  }
  return hostname3;
}

// node_modules/tldts-core/dist/es6/src/is-ip.js
function isProbablyIpv4(hostname3) {
  if (hostname3.length < 7) {
    return false;
  }
  if (hostname3.length > 15) {
    return false;
  }
  let numberOfDots = 0;
  for (let i = 0; i < hostname3.length; i += 1) {
    const code = hostname3.charCodeAt(i);
    if (code === 46) {
      numberOfDots += 1;
    } else if (code < 48 || code > 57) {
      return false;
    }
  }
  return numberOfDots === 3 && hostname3.charCodeAt(0) !== 46 && hostname3.charCodeAt(hostname3.length - 1) !== 46;
}
function isProbablyIpv6(hostname3) {
  if (hostname3.length < 3) {
    return false;
  }
  let start = hostname3.startsWith("[") ? 1 : 0;
  let end = hostname3.length;
  if (hostname3[end - 1] === "]") {
    end -= 1;
  }
  if (end - start > 39) {
    return false;
  }
  let hasColon = false;
  for (; start < end; start += 1) {
    const code = hostname3.charCodeAt(start);
    if (code === 58) {
      hasColon = true;
    } else if (!(code >= 48 && code <= 57 || // 0-9
    code >= 97 && code <= 102 || // a-f
    code >= 65 && code <= 90)) {
      return false;
    }
  }
  return hasColon;
}
function isIp(hostname3) {
  return isProbablyIpv6(hostname3) || isProbablyIpv4(hostname3);
}

// node_modules/tldts-core/dist/es6/src/is-valid.js
function isValidAscii(code) {
  return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function is_valid_default(hostname3) {
  if (hostname3.length > 255) {
    return false;
  }
  if (hostname3.length === 0) {
    return false;
  }
  if (
    /*@__INLINE__*/
    !isValidAscii(hostname3.charCodeAt(0)) && hostname3.charCodeAt(0) !== 46 && // '.' (dot)
    hostname3.charCodeAt(0) !== 95
  ) {
    return false;
  }
  let lastDotIndex = -1;
  let lastCharCode = -1;
  const len = hostname3.length;
  for (let i = 0; i < len; i += 1) {
    const code = hostname3.charCodeAt(i);
    if (code === 46) {
      if (
        // Check that previous label is < 63 bytes long (64 = 63 + '.')
        i - lastDotIndex > 64 || // Check that previous character was not already a '.'
        lastCharCode === 46 || // Check that the previous label does not end with a '-' (dash)
        lastCharCode === 45 || // Check that the previous label does not end with a '_' (underscore)
        lastCharCode === 95
      ) {
        return false;
      }
      lastDotIndex = i;
    } else if (!/*@__INLINE__*/
    (isValidAscii(code) || code === 45 || code === 95)) {
      return false;
    }
    lastCharCode = code;
  }
  return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 && // Check that the last character is an allowed trailing label character.
    // Since we already checked that the char is a valid hostname character,
    // we only need to check that it's different from '-'.
    lastCharCode !== 45
  );
}

// node_modules/tldts-core/dist/es6/src/options.js
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname: extractHostname2 = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
  return {
    allowIcannDomains,
    allowPrivateDomains,
    detectIp,
    extractHostname: extractHostname2,
    mixedInputs,
    validHosts,
    validateHostname
  };
}
var DEFAULT_OPTIONS = (
  /*@__INLINE__*/
  setDefaultsImpl({})
);
function setDefaults(options) {
  if (options === void 0) {
    return DEFAULT_OPTIONS;
  }
  return (
    /*@__INLINE__*/
    setDefaultsImpl(options)
  );
}

// node_modules/tldts-core/dist/es6/src/subdomain.js
function getSubdomain(hostname3, domain3) {
  if (domain3.length === hostname3.length) {
    return "";
  }
  return hostname3.slice(0, -domain3.length - 1);
}

// node_modules/tldts-core/dist/es6/src/factory.js
function getEmptyResult() {
  return {
    domain: null,
    domainWithoutSuffix: null,
    hostname: null,
    isIcann: null,
    isIp: null,
    isPrivate: null,
    publicSuffix: null,
    subdomain: null
  };
}
function parseImpl(url, step, suffixLookup2, partialOptions, result) {
  const options = (
    /*@__INLINE__*/
    setDefaults(partialOptions)
  );
  if (typeof url !== "string") {
    return result;
  }
  if (!options.extractHostname) {
    result.hostname = url;
  } else if (options.mixedInputs) {
    result.hostname = extractHostname(url, is_valid_default(url));
  } else {
    result.hostname = extractHostname(url, false);
  }
  if (step === 0 || result.hostname === null) {
    return result;
  }
  if (options.detectIp) {
    result.isIp = isIp(result.hostname);
    if (result.isIp) {
      return result;
    }
  }
  if (options.validateHostname && options.extractHostname && !is_valid_default(result.hostname)) {
    result.hostname = null;
    return result;
  }
  suffixLookup2(result.hostname, options, result);
  if (step === 2 || result.publicSuffix === null) {
    return result;
  }
  result.domain = getDomain(result.publicSuffix, result.hostname, options);
  if (step === 3 || result.domain === null) {
    return result;
  }
  result.subdomain = getSubdomain(result.hostname, result.domain);
  if (step === 4) {
    return result;
  }
  result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
  return result;
}

// node_modules/tldts-core/dist/es6/src/lookup/fast-path.js
function fast_path_default(hostname3, options, out) {
  if (!options.allowPrivateDomains && hostname3.length > 3) {
    const last2 = hostname3.length - 1;
    const c3 = hostname3.charCodeAt(last2);
    const c2 = hostname3.charCodeAt(last2 - 1);
    const c1 = hostname3.charCodeAt(last2 - 2);
    const c0 = hostname3.charCodeAt(last2 - 3);
    if (c3 === 109 && c2 === 111 && c1 === 99 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "com";
      return true;
    } else if (c3 === 103 && c2 === 114 && c1 === 111 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "org";
      return true;
    } else if (c3 === 117 && c2 === 100 && c1 === 101 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "edu";
      return true;
    } else if (c3 === 118 && c2 === 111 && c1 === 103 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "gov";
      return true;
    } else if (c3 === 116 && c2 === 101 && c1 === 110 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "net";
      return true;
    } else if (c3 === 101 && c2 === 100 && c1 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "de";
      return true;
    }
  }
  return false;
}

// node_modules/tldts/dist/es6/src/data/trie.js
var exceptions = /* @__PURE__ */ (function() {
  const _0 = [1, {}], _1 = [0, { "city": _0 }];
  const exceptions2 = [0, { "ck": [0, { "www": _0 }], "jp": [0, { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 }] }];
  return exceptions2;
})();
var rules = /* @__PURE__ */ (function() {
  const _2 = [1, {}], _3 = [2, {}], _4 = [1, { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2 }], _5 = [0, { "*": _3 }], _6 = [1, { "blogspot": _3 }], _7 = [1, { "gov": _2 }], _8 = [0, { "*": _2 }], _9 = [0, { "cloud": _3 }], _10 = [1, { "co": _3 }], _11 = [2, { "nodes": _3 }], _12 = [0, { "s3": _3 }], _13 = [0, { "direct": _3 }], _14 = [2, { "id": _3 }], _15 = [0, { "webview-assets": _3 }], _16 = [0, { "vfs": _3, "webview-assets": _3 }], _17 = [0, { "aws-cloud9": _15, "cloud9": _16 }], _18 = [0, { "dualstack": _12, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], _19 = [0, { "dualstack": _12, "s3": _3, "s3-website": _3, "aws-cloud9": _15, "cloud9": _16 }], _20 = [0, { "dualstack": _12, "aws-cloud9": _15, "cloud9": _16 }], _21 = [0, { "apps": _3 }], _22 = [0, { "paas": _3 }], _23 = [0, { "app": _3 }], _24 = [2, { "eu": _3 }], _25 = [0, { "site": _3 }], _26 = [0, { "pages": _3 }], _27 = [1, { "com": _2, "edu": _2, "net": _2, "org": _2 }], _28 = [0, { "j": _3 }], _29 = [0, { "jelastic": _3 }], _30 = [0, { "user": _3 }], _31 = [1, { "ybo": _3 }], _32 = [0, { "cust": _3, "reservd": _3 }], _33 = [0, { "cust": _3 }], _34 = [1, { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 }], _35 = [1, { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 }], _36 = [1, { "gov": _2, "blogspot": _3 }], _37 = [1, { "framer": _3 }], _38 = [1, { "barsy": _3 }], _39 = [0, { "forgot": _3 }], _40 = [1, { "gs": _2 }], _41 = [0, { "nes": _2 }], _42 = [1, { "k12": _2, "cc": _2, "lib": _2 }], _43 = [1, { "cc": _2, "lib": _2 }];
  const rules2 = [0, { "ac": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3 }], "ad": [1, { "nom": _2 }], "ae": [1, { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "aero": [1, { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 }], "af": _4, "ag": [1, { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 }], "ai": [1, { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3 }], "al": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 }], "am": [1, { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3, "neko": _3, "nyaa": _3 }], "ao": [1, { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 }], "aq": _2, "ar": [1, { "bet": _2, "com": _6, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 }], "arpa": [1, { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 }], "as": _7, "asia": [1, { "cloudns": _3 }], "at": [1, { "ac": [1, { "sth": _2 }], "co": _6, "gv": _2, "or": _2, "funkfeuer": [0, { "wien": _3 }], "futurecms": [0, { "*": _3, "ex": _5, "in": _5 }], "futurehosting": _3, "futuremailing": _3, "ortsinfo": [0, { "ex": _5, "kunden": _5 }], "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "au": [1, { "com": [1, { "blogspot": _3, "cloudlets": [0, { "mel": _3 }], "myspreadshop": _3 }], "net": _2, "org": _2, "edu": [1, { "act": _2, "catholic": _2, "nsw": [1, { "schools": _2 }], "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "gov": [1, { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "aw": [1, { "com": _2 }], "ax": [1, { "be": _3, "cat": _3, "es": _3, "eu": _3, "gg": _3, "mc": _3, "us": _3, "xy": _3 }], "az": [1, { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 }], "ba": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "rs": _3, "blogspot": _3 }], "bb": [1, { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 }], "bd": _8, "be": [1, { "ac": _2, "webhosting": _3, "blogspot": _3, "interhostsolutions": _9, "kuleuven": [0, { "ezproxy": _3 }], "123website": _3, "myspreadshop": _3, "transurl": _5 }], "bf": _7, "bg": [1, { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 }], "bh": _4, "bi": [1, { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 }], "biz": [1, { "activetrail": _3, "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 }], "bj": [1, { "africa": _2, "agro": _2, "architectes": _2, "assur": _2, "avocats": _2, "co": _2, "com": _2, "eco": _2, "econo": _2, "edu": _2, "info": _2, "loisirs": _2, "money": _2, "net": _2, "org": _2, "ote": _2, "resto": _2, "restaurant": _2, "tourism": _2, "univ": _2, "blogspot": _3 }], "bm": _4, "bn": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 }], "bo": [1, { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 }], "br": [1, { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": [1, { "blogspot": _3, "simplesite": _3 }], "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": [1, { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 }], "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": [1, { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 }], "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 }], "bs": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 }], "bt": _4, "bv": _2, "bw": [1, { "co": _2, "org": _2 }], "by": [1, { "gov": _2, "mil": _2, "com": _6, "of": _2, "mycloud": _3, "mediatech": _3 }], "bz": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "gsj": _3 }], "ca": [1, { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3 }], "cat": _2, "cc": [1, { "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": [0, { "instances": _3 }] }], "cd": _7, "cf": _6, "cg": _2, "ch": [1, { "square7": _3, "blogspot": _3, "flow": [0, { "ae": [0, { "alp1": _3 }], "appengine": _3 }], "linkyard-cloud": _3, "dnsking": _3, "gotdns": _3, "123website": _3, "myspreadshop": _3, "firenet": [0, { "*": _3, "svc": _5 }], "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "ci": [1, { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aÃ©roport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _3, "nl": _3 }], "ck": _8, "cl": [1, { "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "cm": [1, { "co": _2, "com": _2, "gov": _2, "net": _2 }], "cn": [1, { "ac": _2, "com": [1, { "amazonaws": [0, { "compute": _5, "cn-north-1": _12, "eb": [0, { "cn-north-1": _3, "cn-northwest-1": _3 }], "elb": _5 }] }], "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "å…¬å¸": _2, "xn--io0a7i": _2, "ç½‘ç»œ": _2, "xn--od0alg": _2, "ç¶²çµ¡": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "canva-apps": _3, "instantcloud": _3, "quickconnect": _13 }], "co": [1, { "arts": _2, "com": _6, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "firewalledreplit": _14, "repl": _14, "supabase": _3 }], "com": [1, { "devcdnaccesso": _5, "adobeaemcloud": [2, { "dev": _5 }], "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": [0, { "compute": _5, "compute-1": _5, "us-east-1": [2, { "dualstack": _12, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "ap-northeast-1": _18, "ap-northeast-2": _19, "ap-south-1": _19, "ap-southeast-1": _20, "ap-southeast-2": _20, "ca-central-1": _19, "eu-central-1": _19, "eu-west-1": _18, "eu-west-2": _19, "eu-west-3": _19, "s3": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-west-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "sa-east-1": _20, "us-east-2": [0, { "dualstack": _12, "s3": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "us-west-2": [0, { "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "af-south-1": _17, "ap-east-1": _17, "ap-northeast-3": _17, "eu-north-1": _17, "eu-south-1": _17, "me-south-1": _17, "us-west-1": _17, "elb": _5 }], "elasticbeanstalk": [2, { "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 }], "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "betainabox": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "canva-apps": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "ar": _3, "hu": _3, "kr": _3, "no": _3, "qc": _3, "uy": _3, "africa": _3, "gr": _3, "co": _3, "jdevcloud": _3, "wpdevcloud": _3, "cloudcontrolled": _3, "cloudcontrolapp": _3, "cf-ipfs": _3, "cloudflare-ipfs": _3, "trycloudflare": _3, "customer-oci": [0, { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 }], "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "builtwithdark": _3, "datadetect": [0, { "demo": _3, "instance": _3 }], "ddns5": _3, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "mydrobo": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "digitaloceanspaces": _5, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": [0, { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 }], "onfabrica": _3, "fbsbx": _21, "fastly-edge": _3, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": [2, { "r": _5 }], "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "publishproxy": _3, "withgoogle": _3, "withyoutube": _3, "blogspot": _3, "awsmppl": _3, "herokuapp": _3, "herokussl": _3, "impertrixcdn": _3, "impertrix": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "amscompute": _3, "dopaas": _3, "hosted-by-previder": _22, "hosteur": [0, { "rag-cloud": _3, "rag-cloud-ch": _3 }], "ik-server": [0, { "jcloud": _3, "jcloud-ver-jpc": _3 }], "jelastic": [0, { "demo": _3 }], "kilatiron": _3, "massivegrid": _22, "wafaicloud": [0, { "jed": _3, "lon": _3, "ryd": _3 }], "joyent": [0, { "cns": _5 }], "ktistory": _3, "lpusercontent": _3, "lmpm": _23, "linode": [0, { "members": _3, "nodebalancer": _5 }], "linodeobjects": _5, "linodeusercontent": [0, { "ip": _3 }], "barsycenter": _3, "barsyonline": _3, "mazeplay": _3, "miniserver": _3, "meteorapp": _24, "hostedpi": _3, "mythic-beasts": [0, { "customer": _3, "caracal": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 }], "nospamproxy": _9, "4u": _3, "nfshost": _3, "001www": _3, "ddnslive": _3, "myiphost": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "serveexchange": _3, "servehumour": _3, "servep2p": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "3utilities": _3, "ddnsking": _3, "myvnc": _3, "servebeer": _3, "servecounterstrike": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "serveirc": _3, "servemp3": _3, "servepics": _3, "servequake": _3, "observableusercontent": [0, { "static": _3 }], "simplesite": _3, "orsites": _3, "operaunite": _3, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagefrontapp": _3, "pagexl": _3, "paywhirl": _5, "gotpantheon": _3, "platter-app": _3, "pleskns": _3, "postman-echo": _3, "prgmr": [0, { "xen": _3 }], "pythonanywhere": _24, "qualifioapp": _3, "ladesk": _3, "qbuser": _3, "qa2": _3, "dev-myqnapcloud": _3, "alpha-myqnapcloud": _3, "myqnapcloud": _3, "quipelements": _5, "rackmaze": _3, "rhcloud": _3, "render": _23, "onrender": _3, "180r": _3, "dojin": _3, "sakuratan": _3, "sakuraweb": _3, "x0": _3, "code": [0, { "builder": _5, "dev-builder": _5, "stg-builder": _5 }], "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "bounty-full": [2, { "alpha": _3, "beta": _3 }], "streamlitapp": _3, "try-snowplow": _3, "stackhero-network": _3, "playstation-cloud": _3, "myspreadshop": _3, "stdlib": [0, { "api": _3 }], "temp-dns": _3, "dsmynas": _3, "familyds": _3, "mytabit": _3, "tb-hosting": _25, "reservd": _3, "thingdustdata": _3, "bloxcms": _3, "townnews-staging": _3, "typeform": [0, { "pro": _3 }], "hk": _3, "it": _3, "vultrobjects": _5, "wafflecell": _3, "reserve-online": _3, "hotelwithflight": _3, "remotewd": _3, "wiardweb": _26, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": [2, { "js": _3 }], "wixsite": _3, "xnbay": [2, { "u2": _3, "u2-local": _3 }], "yolasite": _3 }], "coop": _2, "cr": [1, { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 }], "cu": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 }], "cv": [1, { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 }], "cw": _27, "cx": [1, { "gov": _2, "ath": _3, "info": _3 }], "cy": [1, { "ac": _2, "biz": _2, "com": [1, { "blogspot": _3, "scaleforce": _28 }], "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 }], "cz": [1, { "co": _3, "realm": _3, "e4": _3, "blogspot": _3, "metacentrum": [0, { "cloud": _5, "custom": _3 }], "muni": [0, { "cloud": [0, { "flt": _3, "usr": _3 }] }] }], "de": [1, { "bplaced": _3, "square7": _3, "com": _3, "cosidns": [0, { "dyn": _3 }], "dynamisches-dns": _3, "dnsupdater": _3, "internet-dns": _3, "l-o-g-i-n": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "ddnss": [2, { "dyn": _3, "dyndns": _3 }], "dyndns1": _3, "dyn-ip24": _3, "home-webserver": [2, { "dyn": _3 }], "myhome-server": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "gÃ¼nstigbestellen": _3, "xn--gnstigliefern-wob": _3, "gÃ¼nstigliefern": _3, "hs-heilbronn": [0, { "it": _26 }], "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": [0, { "customer": _3 }], "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtualuser": _3, "virtual-user": _3, "community-pro": _3, "diskussionsbereich": _3 }], "dj": _2, "dk": [1, { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "dm": _4, "do": [1, { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 }], "dz": [1, { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 }], "ec": [1, { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 }], "edu": [1, { "rit": [0, { "git-pages": _3 }] }], "ee": [1, { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _6, "pri": _2, "aip": _2, "org": _2, "fie": _2 }], "eg": [1, { "com": _6, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 }], "er": _8, "es": [1, { "com": _6, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 }], "et": [1, { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 }], "eu": [1, { "airkitapps": _3, "mycd": _3, "cloudns": _3, "dogado": _29, "barsy": _3, "wellbeingzone": _3, "spdns": _3, "transurl": _5, "diskstation": _3 }], "fi": [1, { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "hÃ¤kkinen": _3, "iki": _3, "cloudplatform": [0, { "fi": _3 }], "datacenter": [0, { "demo": _3, "paas": _3 }], "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 }], "fj": [1, { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "fk": _8, "fm": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 }], "fo": _2, "fr": [1, { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "avoues": _2, "cci": _2, "greta": _2, "huissier-justice": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "aeroport": _3, "avocat": _3, "chambagri": _3, "chirurgiens-dentistes": _3, "experts-comptables": _3, "medecin": _3, "notaires": _3, "pharmacien": _3, "port": _3, "veterinaire": _3, "myspreadshop": _3, "ynh": _3 }], "ga": _2, "gb": _2, "gd": [1, { "edu": _2, "gov": _2 }], "ge": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 }], "gf": _2, "gg": [1, { "co": _2, "net": _2, "org": _2, "kaas": _3, "cya": _3, "panel": [2, { "daemon": _3 }] }], "gh": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 }], "gi": [1, { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 }], "gl": [1, { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3, "xx": _3 }], "gm": _2, "gn": [1, { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 }], "gov": _2, "gp": [1, { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _3 }], "gq": _2, "gr": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "simplesite": _3 }], "gs": _2, "gt": [1, { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "blog": _3, "de": _3, "to": _3 }], "gu": [1, { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 }], "gw": _2, "gy": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "be": _3 }], "hk": [1, { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "å…¬å¸": _2, "xn--wcvs22d": _2, "æ•™è‚²": _2, "xn--lcvr32d": _2, "æ•Žè‚²": _2, "xn--mxtq1m": _2, "æ”¿åºœ": _2, "xn--gmqw5a": _2, "å€‹äºº": _2, "xn--ciqpn": _2, "ä¸ªäºº": _2, "xn--gmq050i": _2, "ç®‡äºº": _2, "xn--zf0avx": _2, "ç¶²ç»œ": _2, "xn--io0a7i": _2, "ç½‘ç»œ": _2, "xn--mk0axi": _2, "ç»„ç¹”": _2, "xn--od0alg": _2, "ç¶²çµ¡": _2, "xn--od0aq3b": _2, "ç½‘çµ¡": _2, "xn--tn0ag": _2, "ç»„ç»‡": _2, "xn--uc0atv": _2, "çµ„ç¹”": _2, "xn--uc0ay4a": _2, "çµ„ç»‡": _2, "blogspot": _3, "secaas": _3, "ltd": _3, "inc": _3 }], "hm": _2, "hn": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "cc": _3 }], "hr": [1, { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _3, "free": _3 }], "ht": [1, { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 }], "hu": [1, { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 }], "id": [1, { "ac": _2, "biz": _2, "co": _6, "desa": _2, "go": _2, "mil": _2, "my": [1, { "rss": _5 }], "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2, "flap": _3, "forte": _3 }], "ie": [1, { "gov": _2, "blogspot": _3, "myspreadshop": _3 }], "il": [1, { "ac": _2, "co": [1, { "ravpage": _3, "blogspot": _3, "tabitorder": _3, "mytabit": _3 }], "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 }], "xn--4dbrk0ce": [1, { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 }], "×™×©×¨××œ": [1, { "××§×“×ž×™×”": _2, "×™×©×•×‘": _2, "×¦×”×œ": _2, "×ž×ž×©×œ": _2 }], "im": [1, { "ac": _2, "co": [1, { "ltd": _2, "plc": _2 }], "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _3 }], "in": [1, { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "web": _3, "cloudns": _3, "blogspot": _3, "barsy": _3, "supabase": _3 }], "info": [1, { "cloudns": _3, "dynamic-dns": _3, "dyndns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "forumz": _3, "nsupdate": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "dnsupdate": _3, "v-info": _3 }], "int": [1, { "eu": _2 }], "io": [1, { "2038": _3, "com": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "backplaneapp": _3, "banzaicloud": [0, { "app": _3, "backyards": _5 }], "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "browsersafetymark": _3, "bigv": [0, { "uk0": _3 }], "cleverapps": _3, "dappnode": [0, { "dyndns": _3 }], "dedyn": _3, "drud": _3, "definima": _3, "fh-muenster": _3, "shw": _3, "forgerock": [0, { "id": _3 }], "ghost": _3, "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "moonscale": _5, "beebyte": _22, "beebyteapp": [0, { "sekd1": _3 }], "jele": _3, "unispace": [0, { "cloud-fr1": _3 }], "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": [2, { "ap": _3, "au": _3, "eu": _3, "in": _3, "jp": _3, "sa": _3, "us": _3 }], "nodeart": [0, { "stage": _3 }], "nid": _3, "pantheonsite": _3, "dyn53": _3, "pstmn": [2, { "mock": _3 }], "protonet": _3, "qoto": _3, "qcx": [2, { "sys": _5 }], "vaporcloud": _3, "vbrplsbx": [0, { "g": _3 }], "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": [0, { "devices": _3 }], "hzc": _3, "sandcats": _3, "shiftcrypto": _3, "shiftedit": _3, "mo-siemens": _3, "musician": _3, "lair": _21, "stolos": _5, "spacekit": _3, "utwente": _3, "s5y": _5, "edugit": _3, "telebit": _3, "thingdust": [0, { "dev": _32, "disrec": _32, "prod": _33, "testing": _32 }], "tickets": _3, "upli": _3, "wedeploy": _3, "editorx": _3, "wixstudio": _3, "basicserver": _3, "virtualserver": _3 }], "iq": _34, "ir": [1, { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "Ø§ÛŒØ±Ø§Ù†": _2, "xn--mgba3a4fra": _2, "Ø§ÙŠØ±Ø§Ù†": _2 }], "is": [1, { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _3, "blogspot": _3 }], "it": [1, { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-sÃ¼d-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-sÃ¼dtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-sÃ¼d-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-sÃ¼dtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosÃ¼d-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosÃ¼dtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsÃ¼d-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsÃ¼dtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "vallÃ©e-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "vallÃ©e-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "vallÃ©eaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "vallÃ©edaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-sÃ¼dtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-sÃ¼dtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-sÃ¼dtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forlÃ¬": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforlÃ¬": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forlÃ¬-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlÃ¬cesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "sÃ¼dtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": [0, { "jc": _3 }], "tim": [0, { "open": [0, { "jelastic": _9 }] }], "16-b": _3, "32-b": _3, "64-b": _3, "123homepage": _3, "myspreadshop": _3, "syncloud": _3 }], "je": [1, { "co": _2, "net": _2, "org": _2, "of": _3 }], "jm": _8, "jo": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 }], "jobs": _2, "jp": [1, { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": [1, { "aseinet": _30, "gehirn": _3, "ivory": _3, "mail-box": _3, "mints": _3, "mokuren": _3, "opal": _3, "sakura": _3, "sumomo": _3, "topaz": _3 }], "or": _2, "aichi": [1, { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 }], "akita": [1, { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 }], "aomori": [1, { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 }], "chiba": [1, { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 }], "ehime": [1, { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 }], "fukui": [1, { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 }], "fukuoka": [1, { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 }], "fukushima": [1, { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 }], "gifu": [1, { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 }], "gunma": [1, { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 }], "hiroshima": [1, { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 }], "hokkaido": [1, { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 }], "hyogo": [1, { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 }], "ibaraki": [1, { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 }], "ishikawa": [1, { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 }], "iwate": [1, { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 }], "kagawa": [1, { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 }], "kagoshima": [1, { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 }], "kanagawa": [1, { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 }], "kochi": [1, { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 }], "kumamoto": [1, { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 }], "kyoto": [1, { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 }], "mie": [1, { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 }], "miyagi": [1, { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 }], "miyazaki": [1, { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 }], "nagano": [1, { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 }], "nagasaki": [1, { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 }], "nara": [1, { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 }], "niigata": [1, { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 }], "oita": [1, { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 }], "okayama": [1, { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 }], "okinawa": [1, { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 }], "osaka": [1, { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 }], "saga": [1, { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 }], "saitama": [1, { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 }], "shiga": [1, { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 }], "shimane": [1, { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 }], "shizuoka": [1, { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 }], "tochigi": [1, { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 }], "tokushima": [1, { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 }], "tokyo": [1, { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 }], "tottori": [1, { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 }], "toyama": [1, { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 }], "wakayama": [1, { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 }], "yamagata": [1, { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 }], "yamaguchi": [1, { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 }], "yamanashi": [1, { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 }], "xn--4pvxs": _2, "æ ƒæœ¨": _2, "xn--vgu402c": _2, "æ„›çŸ¥": _2, "xn--c3s14m": _2, "æ„›åª›": _2, "xn--f6qx53a": _2, "å…µåº«": _2, "xn--8pvr4u": _2, "ç†Šæœ¬": _2, "xn--uist22h": _2, "èŒ¨åŸŽ": _2, "xn--djrs72d6uy": _2, "åŒ—æµ·é“": _2, "xn--mkru45i": _2, "åƒè‘‰": _2, "xn--0trq7p7nn": _2, "å’Œæ­Œå±±": _2, "xn--8ltr62k": _2, "é•·å´Ž": _2, "xn--2m4a15e": _2, "é•·é‡Ž": _2, "xn--efvn9s": _2, "æ–°æ½Ÿ": _2, "xn--32vp30h": _2, "é’æ£®": _2, "xn--4it797k": _2, "é™å²¡": _2, "xn--1lqs71d": _2, "æ±äº¬": _2, "xn--5rtp49c": _2, "çŸ³å·": _2, "xn--5js045d": _2, "åŸ¼çŽ‰": _2, "xn--ehqz56n": _2, "ä¸‰é‡": _2, "xn--1lqs03n": _2, "äº¬éƒ½": _2, "xn--qqqt11m": _2, "ä½è³€": _2, "xn--kbrq7o": _2, "å¤§åˆ†": _2, "xn--pssu33l": _2, "å¤§é˜ª": _2, "xn--ntsq17g": _2, "å¥ˆè‰¯": _2, "xn--uisz3g": _2, "å®®åŸŽ": _2, "xn--6btw5a": _2, "å®®å´Ž": _2, "xn--1ctwo": _2, "å¯Œå±±": _2, "xn--6orx2r": _2, "å±±å£": _2, "xn--rht61e": _2, "å±±å½¢": _2, "xn--rht27z": _2, "å±±æ¢¨": _2, "xn--djty4k": _2, "å²©æ‰‹": _2, "xn--nit225k": _2, "å²é˜œ": _2, "xn--rht3d": _2, "å²¡å±±": _2, "xn--klty5x": _2, "å³¶æ ¹": _2, "xn--kltx9a": _2, "åºƒå³¶": _2, "xn--kltp7d": _2, "å¾³å³¶": _2, "xn--uuwu58a": _2, "æ²–ç¸„": _2, "xn--zbx025d": _2, "æ»‹è³€": _2, "xn--ntso0iqx3a": _2, "ç¥žå¥ˆå·": _2, "xn--elqq16h": _2, "ç¦äº•": _2, "xn--4it168d": _2, "ç¦å²¡": _2, "xn--klt787d": _2, "ç¦å³¶": _2, "xn--rny31h": _2, "ç§‹ç”°": _2, "xn--7t0a264c": _2, "ç¾¤é¦¬": _2, "xn--5rtq34k": _2, "é¦™å·": _2, "xn--k7yn95e": _2, "é«˜çŸ¥": _2, "xn--tor131o": _2, "é³¥å–": _2, "xn--d5qv7z876c": _2, "é¹¿å…å³¶": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3, "2-d": _3, "bona": _3, "crap": _3, "daynight": _3, "eek": _3, "flop": _3, "halfmoon": _3, "jeez": _3, "matrix": _3, "mimoza": _3, "netgamers": _3, "nyanta": _3, "o0o0": _3, "rdy": _3, "rgr": _3, "rulez": _3, "sakurastorage": [0, { "isk01": _12, "isk02": _12 }], "saloon": _3, "sblo": _3, "skr": _3, "tank": _3, "uh-oh": _3, "undo": _3, "webaccel": [0, { "rs": _3, "user": _3 }], "websozai": _3, "xii": _3 }], "ke": [1, { "ac": _2, "co": _6, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 }], "kg": [1, { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _3, "io": _3, "jp": _3, "tv": _3, "uk": _3, "us": _3 }], "kh": _8, "ki": _35, "km": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 }], "kn": [1, { "net": _2, "org": _2, "edu": _2, "gov": _2 }], "kp": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 }], "kr": [1, { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 }], "kw": [1, { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 }], "ky": _27, "kz": [1, { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3, "kazteleport": [0, { "upaas": _3 }] }], "la": [1, { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3, "c": _3 }], "lb": _4, "lc": [1, { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 }], "li": [1, { "blogspot": _3, "caa": _3 }], "lk": [1, { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 }], "lr": _4, "ls": [1, { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _3 }], "lt": _36, "lu": [1, { "blogspot": _3, "123website": _3 }], "lv": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 }], "ly": [1, { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 }], "ma": [1, { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 }], "mc": [1, { "tm": _2, "asso": _2 }], "md": [1, { "blogspot": _3, "at": _3, "de": _3, "jp": _3, "to": _3 }], "me": [1, { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "daplie": [2, { "localhost": _3 }], "edgestack": _3, "filegear": _3, "filegear-au": _3, "filegear-de": _3, "filegear-gb": _3, "filegear-ie": _3, "filegear-jp": _3, "filegear-sg": _3, "glitch": _3, "ravendb": _3, "lohmus": _3, "barsy": _3, "mcpe": _3, "mcdir": _3, "soundcast": _3, "tcp4": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "transip": _25, "wedeploy": _3, "yombo": _3, "nohost": _3 }], "mg": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 }], "mh": _2, "mil": _2, "mk": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 }], "ml": [1, { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 }], "mm": _8, "mn": [1, { "gov": _2, "edu": _2, "org": _2, "nyc": _3 }], "mo": _4, "mobi": [1, { "barsy": _3, "dscloud": _3 }], "mp": [1, { "ju": _3 }], "mq": _2, "mr": _36, "ms": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 }], "mt": [1, { "com": _6, "edu": _2, "net": _2, "org": _2 }], "mu": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 }], "museum": _2, "mv": [1, { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "mw": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 }], "mx": [1, { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 }], "my": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 }], "mz": [1, { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "na": [1, { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 }], "name": [1, { "her": _39, "his": _39 }], "nc": [1, { "asso": _2, "nom": _2 }], "ne": _2, "net": [1, { "adobeaemcloud": _3, "adobeio-static": _3, "adobeioruntime": _3, "akadns": _3, "akamai": _3, "akamai-staging": _3, "akamaiedge": _3, "akamaiedge-staging": _3, "akamaihd": _3, "akamaihd-staging": _3, "akamaiorigin": _3, "akamaiorigin-staging": _3, "akamaized": _3, "akamaized-staging": _3, "edgekey": _3, "edgekey-staging": _3, "edgesuite": _3, "edgesuite-staging": _3, "alwaysdata": _3, "myamaze": _3, "cloudfront": _3, "t3l3p0rt": _3, "appudo": _3, "atlassian-dev": [0, { "prod": [0, { "cdn": _3 }] }], "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "in": _3, "clickrising": _3, "cloudaccess": _3, "cdn77-ssl": _3, "cdn77": [0, { "r": _3 }], "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "bitbridge": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "definima": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": [2, { "u": _3 }], "fastlylb": [2, { "map": _3 }], "fastly": [0, { "freetls": _3, "map": _3, "prod": [0, { "a": _3, "global": _3 }], "ssl": [0, { "a": _3, "b": _3, "global": _3 }] }], "edgeapp": _3, "flynnhosting": _3, "cdn-edges": _3, "heteml": _3, "cloudfunctions": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "ipifony": _3, "iobb": _3, "cloudjiffy": [2, { "fra1-de": _3, "west1-us": _3 }], "elastx": [0, { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 }], "faststacks": _3, "massivegrid": [0, { "paas": [0, { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 }] }], "saveincloud": [0, { "jelastic": _3, "nordeste-idc": _3 }], "scaleforce": _28, "tsukaeru": _29, "kinghost": _3, "uni5": _3, "krellian": _3, "barsy": _3, "memset": _3, "azurewebsites": _3, "azure-mobile": _3, "cloudapp": _3, "azurestaticapps": [2, { "1": _3, "2": _3, "3": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 }], "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "bounceme": _3, "ddns": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "cloudycluster": _3, "ovh": [0, { "webpaas": _5, "hosting": _5 }], "bar0": _3, "bar1": _3, "bar2": _3, "rackmaze": _3, "squares": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "vps-host": [2, { "jelastic": [0, { "atl": _3, "njs": _3, "ric": _3 }] }], "myspreadshop": _3, "srcf": [0, { "soc": _3, "user": _3 }], "supabase": _3, "dsmynas": _3, "familyds": _3, "tailscale": [0, { "beta": _3 }], "ts": _3, "torproject": [2, { "pages": _3 }], "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": [2, { "storage": _3, "website": _3 }], "za": _3 }], "nf": [1, { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 }], "ng": [1, { "com": _6, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3 }], "ni": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 }], "nl": [1, { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 }], "no": [1, { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _40, "ah": _40, "bu": _40, "fm": _40, "hl": _40, "hm": _40, "jan-mayen": _40, "mr": _40, "nl": _40, "nt": _40, "of": _40, "ol": _40, "oslo": _40, "rl": _40, "sf": _40, "st": _40, "svalbard": _40, "tm": _40, "tr": _40, "va": _40, "vf": _40, "akrehamn": _2, "xn--krehamn-dxa": _2, "Ã¥krehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "Ã¥lgÃ¥rd": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brÃ¸nnÃ¸ysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drÃ¸bak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "florÃ¸": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hÃ¸nefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jÃ¸rpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevÃ¥g": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjÃ¸ndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjÃ¸en": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osÃ¸yro": _2, "raholt": _2, "xn--rholt-mra": _2, "rÃ¥holt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjÃ¸en": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjÃ¸rdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "Ã¥fjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "Ã¥l": _2, "alesund": _2, "xn--lesund-hua": _2, "Ã¥lesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "Ã¡ltÃ¡": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "Ã¡laheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "Ã¥mli": _2, "amot": _2, "xn--mot-tla": _2, "Ã¥mot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andÃ¸y": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "Ã¥rdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "Ã¥s": _2, "aseral": _2, "xn--seral-lra": _2, "Ã¥seral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "askÃ¸y": _2, "asnes": _2, "xn--snes-poa": _2, "Ã¥snes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-hÃ¸land": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "averÃ¸y": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "bÃ¡lÃ¡t": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "bÃ¡hccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bÃ¡jddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "bÃ¡idÃ¡r": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevÃ¥g": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalvÃ¡hki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarkÃ¸y": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bodÃ¸": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bÃ¥dÃ¥ddjÃ¥": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brÃ¸nnÃ¸y": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "bÃ¦rum": _2, "telemark": [0, { "bo": _2, "xn--b-5ga": _2, "bÃ¸": _2 }], "nordland": [0, { "bo": _2, "xn--b-5ga": _2, "bÃ¸": _2, "heroy": _2, "xn--hery-ira": _2, "herÃ¸y": _2 }], "bievat": _2, "xn--bievt-0qa": _2, "bievÃ¡t": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bÃ¸mlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "bÃ¥tsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "bÃ¡hcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyrÃ¸y": _2, "donna": _2, "xn--dnna-gra": _2, "dÃ¸nna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "evenÃ¡Å¡Å¡i": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finnÃ¸y": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "flÃ¥": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "frÃ¦na": _2, "froya": _2, "xn--frya-hra": _2, "frÃ¸ya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "fÃ¸rde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "gÃ¡Å‹gaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskÃ¥l": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjÃ¸vik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "krÃ¥anghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hÃ¡bmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hÃ¡pmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hÃ¡mmÃ¡rfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "Ã¡kÅ‹oluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": [0, { "heroy": _2, "sande": _2 }], "xn--mre-og-romsdal-qqb": [0, { "xn--hery-ira": _2, "sande": _2 }], "mÃ¸re-og-romsdal": [0, { "herÃ¸y": _2, "sande": _2 }], "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobÃ¸l": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtÃ¥len": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hÃ¦gebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "hÃ¸yanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "hÃ¸ylandet": _2, "ha": _2, "xn--h-2fa": _2, "hÃ¥": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "inderÃ¸y": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jÃ¸lster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "kÃ¡rÃ¡Å¡johka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gÃ¡lsÃ¡": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmÃ¸y": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klÃ¦bu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "kragerÃ¸": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krÃ¸dsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "rÃ¡hkkerÃ¡vju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsÃ¸y": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvÃ¦fjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvÃ¦nangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "nÃ¡vuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kÃ¥fjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "gÃ¡ivuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabÃ¡t": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leaÅ‹gaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "lindÃ¥s": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "lÃ¡hppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lurÃ¸y": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lÃ¦rdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "lÃ¸dingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lÃ¸renskog": _2, "loten": _2, "xn--lten-gra": _2, "lÃ¸ten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "mÃ¥sÃ¸y": _2, "muosat": _2, "xn--muost-0qa": _2, "muosÃ¡t": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "melÃ¸y": _2, "meraker": _2, "xn--merker-kua": _2, "merÃ¥ker": _2, "moareke": _2, "xn--moreke-jua": _2, "moÃ¥reke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "mÃ¥lselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "mÃ¡latvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nÃ¥Ã¥mesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _41, "buskerud": _41, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjÃ¡rga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjÃ¡rga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "rÃ¡isa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nÃ¦rÃ¸y": _2, "notteroy": _2, "xn--nttery-byae": _2, "nÃ¸tterÃ¸y": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "Ã¸ksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegÃ¥rd": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "Ã¸rland": _2, "orskog": _2, "xn--rskog-uua": _2, "Ã¸rskog": _2, "orsta": _2, "xn--rsta-fra": _2, "Ã¸rsta": _2, "hedmark": [0, { "os": _2, "valer": _2, "xn--vler-qoa": _2, "vÃ¥ler": _2 }], "hordaland": [0, { "os": _2 }], "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "osterÃ¸y": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "Ã¸stre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "Ã¸vre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "Ã¸yer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "Ã¸ygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "Ã¸ystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsÃ¡Å‹gu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "radÃ¸y": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesÃ¸y": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risÃ¸r": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rÃ¦lingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rÃ¸dÃ¸y": _2, "romskog": _2, "xn--rmskog-bya": _2, "rÃ¸mskog": _2, "roros": _2, "xn--rros-gra": _2, "rÃ¸ros": _2, "rost": _2, "xn--rst-0na": _2, "rÃ¸st": _2, "royken": _2, "xn--ryken-vua": _2, "rÃ¸yken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "rÃ¸yrvik": _2, "rade": _2, "xn--rde-ula": _2, "rÃ¥de": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "sÃ¡lÃ¡t": _2, "xn--slat-5na": _2, "sÃ¡lat": _2, "samnanger": _2, "vestfold": [0, { "sande": _2 }], "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandÃ¸y": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervÃ¸y": _2, "skierva": _2, "xn--skierv-uta": _2, "skiervÃ¡": _2, "skjak": _2, "xn--skjk-soa": _2, "skjÃ¥k": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "skÃ¥nland": _2, "skanit": _2, "xn--sknit-yqa": _2, "skÃ¡nit": _2, "smola": _2, "xn--smla-hra": _2, "smÃ¸la": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snÃ¥sa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snÃ¥ase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjÃ¸rdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "sÃ¸gne": _2, "somna": _2, "xn--smna-gra": _2, "sÃ¸mna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "sÃ¸ndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sÃ¸r-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sÃ¸r-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sÃ¸r-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sÃ¸r-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mÃ¡tta-vÃ¡rjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "sÃ¸rfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "sÃ¸rreisa": _2, "sorum": _2, "xn--srum-gra": _2, "sÃ¸rum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjÃ¸me": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "tranÃ¸y": _2, "tromso": _2, "xn--troms-zua": _2, "tromsÃ¸": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "trÃ¦na": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trÃ¸gstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvÃ¦r": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tÃ¸nsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vadsÃ¸": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "ÄÃ¡hcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vardÃ¸": _2, "varggat": _2, "xn--vrggt-xqad": _2, "vÃ¡rggÃ¡t": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegÃ¥rshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvÃ¥gÃ¸y": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "vÃ¦rÃ¸y": _2, "vagan": _2, "xn--vgan-qoa": _2, "vÃ¥gan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vÃ¥gsÃ¸y": _2, "vaga": _2, "xn--vg-yiab": _2, "vÃ¥gÃ¥": _2, "ostfold": [0, { "valer": _2 }], "xn--stfold-9xa": [0, { "xn--vler-qoa": _2 }], "Ã¸stfold": [0, { "vÃ¥ler": _2 }], "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "np": _8, "nr": _35, "nu": [1, { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 }], "nz": [1, { "ac": _2, "co": _6, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "mÄori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2 }], "om": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 }], "onion": _2, "org": [1, { "altervista": _3, "amune": [0, { "tele": _3 }], "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "ae": _3, "us": _3, "certmgr": _3, "cdn77": [0, { "c": _3, "rsc": _3 }], "cdn77-secure": [0, { "origin": [0, { "ssl": _3 }] }], "cloudns": _3, "duckdns": _3, "tunk": _3, "dyndns": [2, { "go": _3, "home": _3 }], "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "ddnss": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "eu": [2, { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "mc": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "paris": _3, "pl": _3, "pt": _3, "q-a": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 }], "twmail": _3, "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": [0, { "cloud": _3, "os": _23, "stg": [0, { "os": _23 }] }], "freedesktop": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "mozilla-iot": _3, "bmoattachments": _3, "dynserv": _3, "now-dns": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "mlbfan": _3, "mysecuritycamera": _3, "nflfan": _3, "read-books": _3, "ufcfan": _3, "hopto": _3, "myftp": _3, "no-ip": _3, "zapto": _3, "httpbin": _3, "pubtls": _3, "jpn": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _12, "tuxfamily": _3, "diskstation": _3, "hk": _3, "wmflabs": _3, "toolforge": _3, "wmcloud": _3, "za": _3 }], "pa": [1, { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 }], "pe": [1, { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 }], "pf": [1, { "com": _2, "org": _2, "edu": _2 }], "pg": _8, "ph": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 }], "pk": [1, { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 }], "pl": [1, { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": [1, { "ap": _2, "griw": _2, "ic": _2, "is": _2, "kmpsp": _2, "konsulat": _2, "kppsp": _2, "kwp": _2, "kwpsp": _2, "mup": _2, "mw": _2, "oia": _2, "oirm": _2, "oke": _2, "oow": _2, "oschr": _2, "oum": _2, "pa": _2, "pinb": _2, "piw": _2, "po": _2, "pr": _2, "psp": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "sdn": _2, "sko": _2, "so": _2, "sr": _2, "starostwo": _2, "ug": _2, "ugim": _2, "um": _2, "umig": _2, "upow": _2, "uppo": _2, "us": _2, "uw": _2, "uzs": _2, "wif": _2, "wiih": _2, "winb": _2, "wios": _2, "witd": _2, "wiw": _2, "wkz": _2, "wsa": _2, "wskr": _2, "wsse": _2, "wuoz": _2, "wzmiuw": _2, "zp": _2, "zpisdn": _2 }], "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _3, "ecommerce-shop": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "simplesite": _3, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3 }], "pm": [1, { "own": _3, "name": _3 }], "pn": [1, { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 }], "post": _2, "pr": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 }], "pro": [1, { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _3, "dnstrace": [0, { "bci": _3 }], "barsy": _3 }], "ps": [1, { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 }], "pt": [1, { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 }], "pw": [1, { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 }], "py": [1, { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "qa": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 }], "re": [1, { "asso": _2, "com": _2, "nom": _2, "blogspot": _3 }], "ro": [1, { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 }], "rs": [1, { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": [0, { "shop": _3 }], "blogspot": _3, "ua": _3, "ox": _3 }], "ru": [1, { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "regruhosting": _29, "myjino": [2, { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 }], "cldmail": [0, { "hb": _3 }], "mcdir": [2, { "vps": _3 }], "mcpre": _3, "net": _3, "org": _3, "pp": _3, "123sait": _3, "lk3": _3, "ras": _3 }], "rw": [1, { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "sa": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 }], "sb": _4, "sc": _4, "sd": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 }], "se": [1, { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3, "paba": [0, { "su": _3 }] }], "sg": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _3, "enscaled": _3 }], "sh": [1, { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "bip": _3, "hashbang": _3, "platform": [0, { "bc": _3, "ent": _3, "eu": _3, "us": _3 }], "now": _3, "vxl": _3, "wedeploy": _3 }], "si": [1, { "gitapp": _3, "gitpage": _3, "blogspot": _3 }], "sj": _2, "sk": _6, "sl": _4, "sm": _2, "sn": [1, { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 }], "so": [1, { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _3 }], "sr": _2, "ss": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 }], "st": [1, { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "kirara": _3, "noho": _3 }], "su": [1, { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 }], "sv": [1, { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 }], "sx": _7, "sy": _34, "sz": [1, { "co": _2, "ac": _2, "org": _2 }], "tc": [1, { "ch": _3, "me": _3, "we": _3 }], "td": _6, "tel": _2, "tf": [1, { "sch": _3 }], "tg": _2, "th": [1, { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 }], "tj": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 }], "tk": _2, "tl": _7, "tm": [1, { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 }], "tn": [1, { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 }], "to": [1, { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "rdv": _3, "x0": _3, "vpnplus": _3, "quickconnect": _13, "nyan": _3 }], "tr": [1, { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _6, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _7 }], "tt": [1, { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 }], "tv": [1, { "dyndns": _3, "better-than": _3, "on-the-web": _3, "worse-than": _3, "from": _3, "sakura": _3 }], "tw": [1, { "edu": _2, "gov": _2, "mil": _2, "com": [1, { "mymailer": _3 }], "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "ç¶²è·¯": _2, "xn--uc0atv": _2, "çµ„ç¹”": _2, "xn--czrw28b": _2, "å•†æ¥­": _2, "url": _3, "blogspot": _3 }], "tz": [1, { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 }], "ua": [1, { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "kropyvnytskyi": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "luhansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "uzhhorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zakarpattia": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "ie": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 }], "ug": [1, { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 }], "uk": [1, { "ac": _2, "co": [1, { "bytemark": [0, { "dh": _3, "vm": _3 }], "blogspot": _3, "layershift": _28, "barsy": _3, "barsyonline": _3, "retrosnub": _33, "nh-serv": _3, "no-ip": _3, "wellbeingzone": _3, "adimo": _3, "myspreadshop": _3 }], "gov": [1, { "campaign": _3, "service": _3, "api": _3, "homeoffice": _3 }], "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": [1, { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 }], "plc": _2, "police": _2, "sch": _8, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3 }], "us": [1, { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _42, "al": _42, "ar": _42, "as": _42, "az": _42, "ca": _42, "co": _42, "ct": _42, "dc": _42, "de": [1, { "cc": _2, "lib": _3 }], "fl": _42, "ga": _42, "gu": _42, "hi": _43, "ia": _42, "id": _42, "il": _42, "in": _42, "ks": _42, "ky": _42, "la": _42, "ma": [1, { "k12": [1, { "pvt": _2, "chtr": _2, "paroch": _2 }], "cc": _2, "lib": _2 }], "md": _42, "me": _42, "mi": [1, { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 }], "mn": _42, "mo": _42, "ms": _42, "mt": _42, "nc": _42, "nd": _43, "ne": _42, "nh": _42, "nj": _42, "nm": _42, "nv": _42, "ny": _42, "oh": _42, "ok": _42, "or": _42, "pa": _42, "pr": _42, "ri": _43, "sc": _42, "sd": _43, "tn": _42, "tx": _42, "ut": _42, "vi": _42, "vt": _42, "va": _42, "wa": _42, "wi": _42, "wv": [1, { "cc": _2 }], "wy": _42, "graphox": _3, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "enscaled": [0, { "phx": _3 }], "mircloud": _3, "freeddns": _3, "golffan": _3, "noip": _3, "pointto": _3, "platterp": _3 }], "uy": [1, { "com": _6, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 }], "uz": [1, { "co": _2, "com": _2, "net": _2, "org": _2 }], "va": _2, "vc": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": [2, { "d": _3 }], "0e": _3 }], "ve": [1, { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 }], "vg": [1, { "at": _3 }], "vi": [1, { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 }], "vn": [1, { "ac": _2, "ai": _2, "biz": _2, "com": _2, "edu": _2, "gov": _2, "health": _2, "id": _2, "info": _2, "int": _2, "io": _2, "name": _2, "net": _2, "org": _2, "pro": _2, "angiang": _2, "bacgiang": _2, "backan": _2, "baclieu": _2, "bacninh": _2, "baria-vungtau": _2, "bentre": _2, "binhdinh": _2, "binhduong": _2, "binhphuoc": _2, "binhthuan": _2, "camau": _2, "cantho": _2, "caobang": _2, "daklak": _2, "daknong": _2, "danang": _2, "dienbien": _2, "dongnai": _2, "dongthap": _2, "gialai": _2, "hagiang": _2, "haiduong": _2, "haiphong": _2, "hanam": _2, "hanoi": _2, "hatinh": _2, "haugiang": _2, "hoabinh": _2, "hungyen": _2, "khanhhoa": _2, "kiengiang": _2, "kontum": _2, "laichau": _2, "lamdong": _2, "langson": _2, "laocai": _2, "longan": _2, "namdinh": _2, "nghean": _2, "ninhbinh": _2, "ninhthuan": _2, "phutho": _2, "phuyen": _2, "quangbinh": _2, "quangnam": _2, "quangngai": _2, "quangninh": _2, "quangtri": _2, "soctrang": _2, "sonla": _2, "tayninh": _2, "thaibinh": _2, "thainguyen": _2, "thanhhoa": _2, "thanhphohochiminh": _2, "thuathienhue": _2, "tiengiang": _2, "travinh": _2, "tuyenquang": _2, "vinhlong": _2, "vinhphuc": _2, "yenbai": _2, "blogspot": _3 }], "vu": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "cn": _3, "blog": _3, "dev": _3, "me": _3 }], "wf": [1, { "biz": _3, "sch": _3 }], "ws": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 }], "yt": [1, { "org": _3 }], "xn--mgbaam7a8h": _2, "Ø§Ù…Ø§Ø±Ø§Øª": _2, "xn--y9a3aq": _2, "Õ°Õ¡Õµ": _2, "xn--54b7fta0cc": _2, "à¦¬à¦¾à¦‚à¦²à¦¾": _2, "xn--90ae": _2, "Ð±Ð³": _2, "xn--mgbcpq6gpa1a": _2, "Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†": _2, "xn--90ais": _2, "Ð±ÐµÐ»": _2, "xn--fiqs8s": _2, "ä¸­å›½": _2, "xn--fiqz9s": _2, "ä¸­åœ‹": _2, "xn--lgbbat1ad8j": _2, "Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±": _2, "xn--wgbh1c": _2, "Ù…ØµØ±": _2, "xn--e1a4c": _2, "ÐµÑŽ": _2, "xn--qxa6a": _2, "ÎµÏ…": _2, "xn--mgbah1a3hjkrd": _2, "Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§": _2, "xn--node": _2, "áƒ’áƒ”": _2, "xn--qxam": _2, "ÎµÎ»": _2, "xn--j6w193g": [1, { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 }], "é¦™æ¸¯": [1, { "å…¬å¸": _2, "æ•™è‚²": _2, "æ”¿åºœ": _2, "å€‹äºº": _2, "ç¶²çµ¡": _2, "çµ„ç¹”": _2 }], "xn--2scrj9c": _2, "à²­à²¾à²°à²¤": _2, "xn--3hcrj9c": _2, "à¬­à¬¾à¬°à¬¤": _2, "xn--45br5cyl": _2, "à¦­à¦¾à§°à¦¤": _2, "xn--h2breg3eve": _2, "à¤­à¤¾à¤°à¤¤à¤®à¥": _2, "xn--h2brj9c8c": _2, "à¤­à¤¾à¤°à¥‹à¤¤": _2, "xn--mgbgu82a": _2, "Ú€Ø§Ø±Øª": _2, "xn--rvc1e0am3e": _2, "à´­à´¾à´°à´¤à´‚": _2, "xn--h2brj9c": _2, "à¤­à¤¾à¤°à¤¤": _2, "xn--mgbbh1a": _2, "Ø¨Ø§Ø±Øª": _2, "xn--mgbbh1a71e": _2, "Ø¨Ú¾Ø§Ø±Øª": _2, "xn--fpcrj9c3d": _2, "à°­à°¾à°°à°¤à±": _2, "xn--gecrj9c": _2, "àª­àª¾àª°àª¤": _2, "xn--s9brj9c": _2, "à¨­à¨¾à¨°à¨¤": _2, "xn--45brj9c": _2, "à¦­à¦¾à¦°à¦¤": _2, "xn--xkc2dl3a5ee0h": _2, "à®‡à®¨à¯à®¤à®¿à®¯à®¾": _2, "xn--mgba3a4f16a": _2, "Ø§ÛŒØ±Ø§Ù†": _2, "xn--mgba3a4fra": _2, "Ø§ÙŠØ±Ø§Ù†": _2, "xn--mgbtx2b": _2, "Ø¹Ø±Ø§Ù‚": _2, "xn--mgbayh7gpa": _2, "Ø§Ù„Ø§Ø±Ø¯Ù†": _2, "xn--3e0b707e": _2, "í•œêµ­": _2, "xn--80ao21a": _2, "Ò›Ð°Ð·": _2, "xn--q7ce6a": _2, "àº¥àº²àº§": _2, "xn--fzc2c9e2c": _2, "à¶½à¶‚à¶šà·": _2, "xn--xkc2al3hye2a": _2, "à®‡à®²à®™à¯à®•à¯ˆ": _2, "xn--mgbc0a9azcg": _2, "Ø§Ù„Ù…ØºØ±Ø¨": _2, "xn--d1alf": _2, "Ð¼ÐºÐ´": _2, "xn--l1acc": _2, "Ð¼Ð¾Ð½": _2, "xn--mix891f": _2, "æ¾³é–€": _2, "xn--mix082f": _2, "æ¾³é—¨": _2, "xn--mgbx4cd0ab": _2, "Ù…Ù„ÙŠØ³ÙŠØ§": _2, "xn--mgb9awbf": _2, "Ø¹Ù…Ø§Ù†": _2, "xn--mgbai9azgqp6j": _2, "Ù¾Ø§Ú©Ø³ØªØ§Ù†": _2, "xn--mgbai9a5eva00b": _2, "Ù¾Ø§ÙƒØ³ØªØ§Ù†": _2, "xn--ygbi2ammx": _2, "ÙÙ„Ø³Ø·ÙŠÙ†": _2, "xn--90a3ac": [1, { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 }], "ÑÑ€Ð±": [1, { "Ð¿Ñ€": _2, "Ð¾Ñ€Ð³": _2, "Ð¾Ð±Ñ€": _2, "Ð¾Ð´": _2, "ÑƒÐ¿Ñ€": _2, "Ð°Ðº": _2 }], "xn--p1ai": _2, "Ñ€Ñ„": _2, "xn--wgbl6a": _2, "Ù‚Ø·Ø±": _2, "xn--mgberp4a5d4ar": _2, "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©": _2, "xn--mgberp4a5d4a87g": _2, "Ø§Ù„Ø³Ø¹ÙˆØ¯ÛŒØ©": _2, "xn--mgbqly7c0a67fbc": _2, "Ø§Ù„Ø³Ø¹ÙˆØ¯ÛŒÛƒ": _2, "xn--mgbqly7cvafr": _2, "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠÙ‡": _2, "xn--mgbpl2fh": _2, "Ø³ÙˆØ¯Ø§Ù†": _2, "xn--yfro4i67o": _2, "æ–°åŠ å¡": _2, "xn--clchc0ea0b2g2a9gcd": _2, "à®šà®¿à®™à¯à®•à®ªà¯à®ªà¯‚à®°à¯": _2, "xn--ogbpf8fl": _2, "Ø³ÙˆØ±ÙŠØ©": _2, "xn--mgbtf8fl": _2, "Ø³ÙˆØ±ÙŠØ§": _2, "xn--o3cw4h": [1, { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 }], "à¹„à¸—à¸¢": [1, { "à¸¨à¸¶à¸à¸©à¸²": _2, "à¸˜à¸¸à¸£à¸à¸´à¸ˆ": _2, "à¸£à¸±à¸à¸šà¸²à¸¥": _2, "à¸—à¸«à¸²à¸£": _2, "à¹€à¸™à¹‡à¸•": _2, "à¸­à¸‡à¸„à¹Œà¸à¸£": _2 }], "xn--pgbs0dh": _2, "ØªÙˆÙ†Ø³": _2, "xn--kpry57d": _2, "å°ç£": _2, "xn--kprw13d": _2, "å°æ¹¾": _2, "xn--nnx388a": _2, "è‡ºç£": _2, "xn--j1amh": _2, "ÑƒÐºÑ€": _2, "xn--mgb2ddes": _2, "Ø§Ù„ÙŠÙ…Ù†": _2, "xxx": _2, "ye": _34, "za": [0, { "ac": _2, "agric": _2, "alt": _2, "co": _6, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 }], "zm": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 }], "zw": [1, { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 }], "aaa": _2, "aarp": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": [1, { "official": _3 }], "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": [1, { "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "edgecompute": _3, "fireweb": _3, "onflashdrive": _3, "framer": _3, "run": [2, { "a": _3 }], "web": _3, "hasura": _3, "loginline": _3, "messerli": _3, "netlify": _3, "ngrok": _3, "ngrok-free": _3, "developer": _5, "noop": _3, "northflank": _5, "snowflake": [2, { "privatelink": _3 }], "streamlit": _3, "storipress": _3, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3 }], "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": [1, { "aus": _3, "nz": _3 }], "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": _2, "builders": [1, { "cloudsite": _3 }], "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": [1, { "nabu": [0, { "ui": _3 }] }], "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": [1, { "banzai": _5, "elementor": _3, "encoway": [0, { "eu": _3 }], "statics": _5, "ravendb": _3, "axarnet": [0, { "es-1": _3 }], "diadem": _3, "jelastic": [0, { "vip": _3 }], "jele": _3, "jenv-aruba": [0, { "aruba": [0, { "eur": [0, { "it1": _3 }] }], "it1": _3 }], "keliweb": [2, { "cs": _3 }], "oxa": [2, { "tn": _3, "uk": _3 }], "primetel": [2, { "uk": _3 }], "reclaim": [0, { "ca": _3, "uk": _3, "us": _3 }], "trendhosting": [0, { "ch": _3, "de": _3 }], "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": [0, { "baremetal": [0, { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 }], "fr-par": [0, { "fnc": [2, { "functions": _3 }], "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 }], "instances": [0, { "priv": _3, "pub": _3 }], "k8s": _3, "nl-ams": [0, { "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 }], "pl-waw": [0, { "k8s": _11, "s3": _3, "s3-website": _3 }], "scalebook": _3, "smartlabeling": _3 }], "sensiosite": _5, "trafficplex": _3, "urown": _3, "voorloper": _3 }], "club": [1, { "cloudns": _3, "jele": _3, "barsy": _3 }], "clubmed": _2, "coach": _2, "codes": [1, { "owo": _5 }], "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": [1, { "nog": _3, "ravendb": _3, "myforum": _3 }], "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cool": [1, { "elementor": _3, "de": _3 }], "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": [1, { "bss": _3 }], "dev": [1, { "autocode": _3, "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "r2": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "fly": _3, "githubpreview": _3, "gateway": _5, "iserv": _3, "localcert": [0, { "user": _5 }], "loginline": _3, "mediatech": _3, "ngrok": _3, "ngrok-free": _3, "platter-app": _3, "shiftcrypto": _3, "vercel": _3, "webhare": _5 }], "dhl": _2, "diamonds": _2, "diet": _2, "digital": [1, { "cloudapps": [2, { "london": _3 }] }], "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": [1, { "dapps": [0, { "*": _3, "bzz": _5 }] }], "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": [1, { "compute": _5 }], "etisalat": _2, "eurovision": _2, "eus": [1, { "party": _30 }], "events": [1, { "koobin": _3, "co": _3 }], "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _31, "family": _2, "fan": _2, "fans": _2, "farm": [1, { "storj": _3 }], "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": [1, { "cnpy": _3 }], "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": [1, { "cloud": _3, "translate": _3, "usercontent": _5 }], "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": [1, { "discourse": _3 }], "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": [1, { "hra": _3 }], "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": [1, { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "pcloud": _3, "half": _3 }], "hosting": [1, { "opencraft": _3 }], "hot": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": [1, { "co": _3, "edu": _3 }], "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "land": [1, { "static": [2, { "dev": _3, "sites": _3 }] }], "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "link": [1, { "cyon": _3, "mypep": _3, "dweb": _5 }], "lipsy": _2, "live": [1, { "hlx": _3 }], "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "lol": [1, { "omg": _3 }], "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": [1, { "router": _3 }], "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _37, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": _38, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": _2, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "nab": _2, "nagoya": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": [1, { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 }], "neustar": _2, "new": _2, "news": [1, { "noticeable": _3 }], "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": [1, { "onred": [2, { "staging": _3 }], "service": _3, "homelink": _3 }], "ong": _2, "onl": _2, "online": [1, { "eero": _3, "eero-stage": _3, "barsy": _3 }], "ooo": _2, "open": _2, "oracle": _2, "orange": [1, { "tech": _3 }], "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": [1, { "nerdpol": _3 }], "page": [1, { "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "pdns": _3, "plesk": _3, "prvcy": _3, "rocky": _3, "magnet": _3 }], "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _31, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _37, "physio": _2, "pics": _2, "pictet": _2, "pictures": [1, { "1337": _3 }], "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": [1, { "ngrok": _3 }], "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": [1, { "indie": _3 }], "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _38, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _31, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": [1, { "clan": _3 }], "rocher": _2, "rocks": [1, { "myddns": _3, "lima-city": _3, "webspace": _3 }], "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": [1, { "hs": _3, "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3, "wix": _3 }], "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _31, "scot": [1, { "edu": _3, "gov": [2, { "service": _3 }] }], "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": [1, { "loginline": _3 }], "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": [1, { "base": _3, "hoplix": _3, "barsy": _3 }], "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "silk": _2, "sina": _2, "singles": _2, "site": [1, { "cloudera": _5, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "jele": _3, "lelux": _3, "loginline": _3, "barsy": _3, "mintere": _3, "omniwe": _3, "opensocial": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3 }], "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": [1, { "diher": _5 }], "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": [1, { "myfast": _3, "uber": _3, "xs4all": _3 }], "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": [1, { "sellfy": _3, "shopware": _3, "storebase": _3 }], "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _38, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": [1, { "knightpoint": _3 }], "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": [1, { "discourse": _3, "jelastic": _3 }], "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": [1, { "prequalifyme": _3 }], "tokyo": _2, "tools": _2, "top": [1, { "now-dns": _3, "ntdll": _3 }], "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _31, "trading": _2, "training": _2, "travel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _37, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _37, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "à¤•à¥‰à¤®": _2, "xn--1ck2e1b": _2, "ã‚»ãƒ¼ãƒ«": _2, "xn--1qqw23a": _2, "ä½›å±±": _2, "xn--30rr7y": _2, "æ…ˆå–„": _2, "xn--3bst00m": _2, "é›†å›¢": _2, "xn--3ds443g": _2, "åœ¨çº¿": _2, "xn--3pxu8k": _2, "ç‚¹çœ‹": _2, "xn--42c2d9a": _2, "à¸„à¸­à¸¡": _2, "xn--45q11c": _2, "å…«å¦": _2, "xn--4gbrim": _2, "Ù…ÙˆÙ‚Ø¹": _2, "xn--55qw42g": _2, "å…¬ç›Š": _2, "xn--55qx5d": _2, "å…¬å¸": _2, "xn--5su34j936bgsg": _2, "é¦™æ ¼é‡Œæ‹‰": _2, "xn--5tzm5g": _2, "ç½‘ç«™": _2, "xn--6frz82g": _2, "ç§»åŠ¨": _2, "xn--6qq986b3xl": _2, "æˆ‘çˆ±ä½ ": _2, "xn--80adxhks": _2, "Ð¼Ð¾ÑÐºÐ²Ð°": _2, "xn--80aqecdr1a": _2, "ÐºÐ°Ñ‚Ð¾Ð»Ð¸Ðº": _2, "xn--80asehdb": _2, "Ð¾Ð½Ð»Ð°Ð¹Ð½": _2, "xn--80aswg": _2, "ÑÐ°Ð¹Ñ‚": _2, "xn--8y0a063a": _2, "è”é€š": _2, "xn--9dbq2a": _2, "×§×•×": _2, "xn--9et52u": _2, "æ—¶å°š": _2, "xn--9krt00a": _2, "å¾®åš": _2, "xn--b4w605ferd": _2, "æ·¡é©¬é”¡": _2, "xn--bck1b9a5dre4c": _2, "ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³": _2, "xn--c1avg": _2, "Ð¾Ñ€Ð³": _2, "xn--c2br7g": _2, "à¤¨à¥‡à¤Ÿ": _2, "xn--cck2b3b": _2, "ã‚¹ãƒˆã‚¢": _2, "xn--cckwcxetd": _2, "ã‚¢ãƒžã‚¾ãƒ³": _2, "xn--cg4bki": _2, "ì‚¼ì„±": _2, "xn--czr694b": _2, "å•†æ ‡": _2, "xn--czrs0t": _2, "å•†åº—": _2, "xn--czru2d": _2, "å•†åŸŽ": _2, "xn--d1acj3b": _2, "Ð´ÐµÑ‚Ð¸": _2, "xn--eckvdtc9d": _2, "ãƒã‚¤ãƒ³ãƒˆ": _2, "xn--efvy88h": _2, "æ–°é—»": _2, "xn--fct429k": _2, "å®¶é›»": _2, "xn--fhbei": _2, "ÙƒÙˆÙ…": _2, "xn--fiq228c5hs": _2, "ä¸­æ–‡ç½‘": _2, "xn--fiq64b": _2, "ä¸­ä¿¡": _2, "xn--fjq720a": _2, "å¨±ä¹": _2, "xn--flw351e": _2, "è°·æ­Œ": _2, "xn--fzys8d69uvgm": _2, "é›»è¨Šç›ˆç§‘": _2, "xn--g2xx48c": _2, "è´­ç‰©": _2, "xn--gckr3f0f": _2, "ã‚¯ãƒ©ã‚¦ãƒ‰": _2, "xn--gk3at1e": _2, "é€šè²©": _2, "xn--hxt814e": _2, "ç½‘åº—": _2, "xn--i1b6b1a6a2e": _2, "à¤¸à¤‚à¤—à¤ à¤¨": _2, "xn--imr513n": _2, "é¤åŽ…": _2, "xn--io0a7i": _2, "ç½‘ç»œ": _2, "xn--j1aef": _2, "ÐºÐ¾Ð¼": _2, "xn--jlq480n2rg": _2, "äºšé©¬é€Š": _2, "xn--jvr189m": _2, "é£Ÿå“": _2, "xn--kcrx77d1x4a": _2, "é£žåˆ©æµ¦": _2, "xn--kput3i": _2, "æ‰‹æœº": _2, "xn--mgba3a3ejt": _2, "Ø§Ø±Ø§Ù…ÙƒÙˆ": _2, "xn--mgba7c0bbn0a": _2, "Ø§Ù„Ø¹Ù„ÙŠØ§Ù†": _2, "xn--mgbaakc7dvf": _2, "Ø§ØªØµØ§Ù„Ø§Øª": _2, "xn--mgbab2bd": _2, "Ø¨Ø§Ø²Ø§Ø±": _2, "xn--mgbca7dzdo": _2, "Ø§Ø¨ÙˆØ¸Ø¨ÙŠ": _2, "xn--mgbi4ecexp": _2, "ÙƒØ§Ø«ÙˆÙ„ÙŠÙƒ": _2, "xn--mgbt3dhd": _2, "Ù‡Ù…Ø±Ø§Ù‡": _2, "xn--mk1bu44c": _2, "ë‹·ì»´": _2, "xn--mxtq1m": _2, "æ”¿åºœ": _2, "xn--ngbc5azd": _2, "Ø´Ø¨ÙƒØ©": _2, "xn--ngbe9e0a": _2, "Ø¨ÙŠØªÙƒ": _2, "xn--ngbrx": _2, "Ø¹Ø±Ø¨": _2, "xn--nqv7f": _2, "æœºæž„": _2, "xn--nqv7fs00ema": _2, "ç»„ç»‡æœºæž„": _2, "xn--nyqy26a": _2, "å¥åº·": _2, "xn--otu796d": _2, "æ‹›è˜": _2, "xn--p1acf": [1, { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 }], "Ñ€ÑƒÑ": [1, { "Ð±Ð¸Ð·": _3, "ÐºÐ¾Ð¼": _3, "ÐºÑ€Ñ‹Ð¼": _3, "Ð¼Ð¸Ñ€": _3, "Ð¼ÑÐº": _3, "Ð¾Ñ€Ð³": _3, "ÑÐ°Ð¼Ð°Ñ€Ð°": _3, "ÑÐ¾Ñ‡Ð¸": _3, "ÑÐ¿Ð±": _3, "Ñ": _3 }], "xn--pssy2u": _2, "å¤§æ‹¿": _2, "xn--q9jyb4c": _2, "ã¿ã‚“ãª": _2, "xn--qcka1pmc": _2, "ã‚°ãƒ¼ã‚°ãƒ«": _2, "xn--rhqv96g": _2, "ä¸–ç•Œ": _2, "xn--rovu88b": _2, "æ›¸ç±": _2, "xn--ses554g": _2, "ç½‘å€": _2, "xn--t60b56a": _2, "ë‹·ë„·": _2, "xn--tckwe": _2, "ã‚³ãƒ ": _2, "xn--tiq49xqyj": _2, "å¤©ä¸»æ•™": _2, "xn--unup4y": _2, "æ¸¸æˆ": _2, "xn--vermgensberater-ctb": _2, "vermÃ¶gensberater": _2, "xn--vermgensberatung-pwb": _2, "vermÃ¶gensberatung": _2, "xn--vhquv": _2, "ä¼ä¸š": _2, "xn--vuq861b": _2, "ä¿¡æ¯": _2, "xn--w4r85el8fhu5dnra": _2, "å˜‰é‡Œå¤§é…’åº—": _2, "xn--w4rs40l": _2, "å˜‰é‡Œ": _2, "xn--xhq521b": _2, "å¹¿ä¸œ": _2, "xn--zfr164b": _2, "æ”¿åŠ¡": _2, "xyz": [1, { "blogsite": _3, "localzone": _3, "crafting": _3, "zapto": _3, "telebit": _5 }], "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": [1, { "cloud66": _3, "hs": _3, "triton": _5, "lima": _3 }], "zuerich": _2 }];
  return rules2;
})();

// node_modules/tldts/dist/es6/src/suffix-trie.js
function lookupInTrie(parts, trie, index, allowedMask) {
  let result = null;
  let node = trie;
  while (node !== void 0) {
    if ((node[0] & allowedMask) !== 0) {
      result = {
        index: index + 1,
        isIcann: node[0] === 1,
        isPrivate: node[0] === 2
      };
    }
    if (index === -1) {
      break;
    }
    const succ = node[1];
    node = Object.prototype.hasOwnProperty.call(succ, parts[index]) ? succ[parts[index]] : succ["*"];
    index -= 1;
  }
  return result;
}
function suffixLookup(hostname3, options, out) {
  var _a5;
  if (fast_path_default(hostname3, options, out)) {
    return;
  }
  const hostnameParts = hostname3.split(".");
  const allowedMask = (options.allowPrivateDomains ? 2 : 0) | (options.allowIcannDomains ? 1 : 0);
  const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
  if (exceptionMatch !== null) {
    out.isIcann = exceptionMatch.isIcann;
    out.isPrivate = exceptionMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join(".");
    return;
  }
  const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
  if (rulesMatch !== null) {
    out.isIcann = rulesMatch.isIcann;
    out.isPrivate = rulesMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(rulesMatch.index).join(".");
    return;
  }
  out.isIcann = false;
  out.isPrivate = false;
  out.publicSuffix = (_a5 = hostnameParts[hostnameParts.length - 1]) !== null && _a5 !== void 0 ? _a5 : null;
}

// node_modules/tldts/dist/es6/index.js
var RESULT = getEmptyResult();
function parse(url, options = {}) {
  return parseImpl(url, 5, suffixLookup, options, getEmptyResult());
}

// node_modules/@dynamic-labs/utils/src/services/PlatformService/createBrowserPlatformService/createBrowserPlatformService.js
var createBrowserPlatformService = (window2) => ({
  downloadFile: (fileName, file) => __awaiter2(void 0, void 0, void 0, function* () {
    const element = document.createElement("a");
    element.href = URL.createObjectURL(file);
    element.download = fileName;
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    URL.revokeObjectURL(element.href);
  }),
  getDisplayOrigin: () => window2.location.origin,
  getHost: () => window2.location.host,
  getHostname: () => window2.location.hostname,
  getOrigin: () => window2.location.origin,
  getTLD: (domain3) => {
    const data = parse(domain3 || window2.location.hostname, {
      allowPrivateDomains: true
    });
    return data.domain || void 0;
  },
  getUrl: () => new URL(window2.location.href),
  isNativeMobile: false,
  openURL: (url_1, ...args_1) => __awaiter2(void 0, [url_1, ...args_1], void 0, function* (url, target = "self", features = "") {
    if (target === "blank") {
      window2.open(url, "_blank", features);
    } else {
      window2.location.assign(url);
    }
  })
});

// node_modules/@dynamic-labs/utils/src/services/PlatformService/PlatformService.js
var _a;
var _PlatformService_implementation;
var PlatformService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a, _a, "f", _PlatformService_implementation)) {
      return createBrowserPlatformService(window);
    }
    return __classPrivateFieldGet(_a, _a, "f", _PlatformService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a, _a, implementation, "f", _PlatformService_implementation);
  }
  /**
   * Indicates if the current platform is a native mobile app
   * like react-native or flutter.
   */
  static get isNativeMobile() {
    return _a.implementation.isNativeMobile;
  }
  /**
   * Gets the origin of the current location.
   *
   * @example window.location.origin
   */
  static get getOrigin() {
    return _a.implementation.getOrigin;
  }
  /**
   * Gets the origin to be displayed in the UI.
   *
   * @example window.location.origin
   */
  static get getDisplayOrigin() {
    return _a.implementation.getDisplayOrigin;
  }
  /**
   * Gets the host of the current location.
   *
   * @example window.location.host
   */
  static get getHost() {
    return _a.implementation.getHost;
  }
  /**
   * Gets the hostname of the current location.
   *
   * @example window.location.hostname
   */
  static get getHostname() {
    return _a.implementation.getHostname;
  }
  /**
   * Gets the current URL.
   *
   * @example new URL(window.location.href)
   */
  static get getUrl() {
    return _a.implementation.getUrl;
  }
  static getTLD(domain3) {
    return _a.implementation.getTLD(domain3);
  }
  /**
   * Opens a URL. If possible, should avoid new windows.
   */
  static get openURL() {
    return _a.implementation.openURL;
  }
  /**
   * Downloads a file with the given filename and content.
   */
  static get downloadFile() {
    return _a.implementation.downloadFile;
  }
  /**
   * Registers a listener for URL updates.
   * This is primarily used in native mobile environments where deep links
   * can update the current URL asynchronously.
   *
   * @returns A function to unsubscribe the listener, or undefined if not supported.
   */
  static onUrlUpdate(listener) {
    var _b, _c;
    return (_c = (_b = _a.implementation).onUrlUpdate) === null || _c === void 0 ? void 0 : _c.call(_b, listener);
  }
};
_a = PlatformService;
_PlatformService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/utils/src/getTLD/getTLD.js
var getTLD = () => PlatformService.getTLD();

// node_modules/@dynamic-labs/utils/src/isMobile/isMobile.js
var userAgentRegex1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ios|ipad|playbook|silk/i;
var userAgentRegex2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
var isMobile = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return userAgentRegex1.test(navigator.userAgent) || userAgentRegex2.test(navigator.userAgent.substring(0, 4)) || isIPad(maxTouchPointsOverride) || isIPhone();
};
var isIPhone = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : /iPhone|ios/.test(navigator.userAgent);
var isIPhone8OrEarlier = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : iPhoneLegacyRegex.some(({ regex }) => regex.test(navigator.userAgent));
var isIPad = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  const maxTouchPoints = maxTouchPointsOverride || navigator.maxTouchPoints;
  return /iPad/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && maxTouchPoints === 5;
};
var isIOS = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return isIPhone() || isIPad(maxTouchPointsOverride);
};
var isAndroid = () => isMobile() && !isIOS();
var isLegacySafari = () => {
  if (typeof window === "undefined" || !window.CSS || typeof window.CSS.supports !== "function") {
    return false;
  }
  const cssValue = "aspect-ratio: 1 / 1";
  return !CSS.supports(cssValue);
};
var isSamsungBrowser = () => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return navigator.userAgent.includes("SamsungBrowser");
};
var isSafariBrowser = () => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  const { userAgent } = navigator;
  const isSafari = userAgent.includes("Safari") && !userAgent.includes("Chrome") && !userAgent.includes("Chromium");
  return isSafari;
};
var iPhoneLegacyRegex = [
  {
    model: "iPhone 5",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]12|5)$/
  },
  {
    model: "iPhone 5C",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]34)$/
  },
  {
    model: "iPhone 5S",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?6[C,_]12|5S)$/
  },
  {
    model: "iPhone 6 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]1|1C2%257enohPi|6PLUS)$/
  },
  {
    model: "iPhone 6",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]2|6)$/
  },
  {
    model: "iPhone 6s Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]2|6SPLUS)$/
  },
  {
    model: "iPhone 6s",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]1|iPhone[ /]6s|6S)$/
  },
  {
    model: "iPhone SE",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]4|SE)$/
  },
  {
    model: "iPhone 7",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]13|iphone7|7)$/
  },
  {
    model: "iPhone 7 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]24|7PLUS)$/
  },
  {
    model: "iPhone 8",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]14|8)$/
  },
  {
    model: "iPhone 8 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]25|8PLUS)$/
  }
];
var getAndroidVersion = () => {
  if (typeof navigator === "undefined") {
    return;
  }
  const androidVersionMatch = navigator.userAgent.match(/Android (\d+(\.\d+)?)/);
  if (!androidVersionMatch) {
    return;
  }
  const androidVersion = parseFloat(androidVersionMatch[1]);
  return androidVersion;
};

// node_modules/@dynamic-labs/utils/src/handleMobileWalletRedirect/handleMobileWalletRedirect.js
var handleMobileWalletRedirect = ({ nativeLink, universalLink }) => {
  const url = encodeURIComponent(PlatformService.getUrl().href);
  const ref = encodeURIComponent(PlatformService.getOrigin());
  if (isSamsungBrowser()) {
    PlatformService.openURL(`${nativeLink}/${url}?ref=${ref}`);
  } else {
    PlatformService.openURL(`${universalLink}/${url}?ref=${ref}`);
  }
};

// node_modules/@dynamic-labs/utils/src/isLedgerAddressViaVerifiedCredentials/isLedgerAddressViaVerifiedCredentials.js
var isLedgerAddressViaVerifiedCredentials = (address, verifiedCredentials) => {
  const ledgerWallets = verifiedCredentials.filter((v) => {
    var _a5;
    return ((_a5 = v.walletProperties) === null || _a5 === void 0 ? void 0 : _a5.hardwareWallet) === "ledger";
  }).map((v) => v.address);
  return ledgerWallets.includes(address);
};

// node_modules/@dynamic-labs/utils/src/isString/isString.js
var isString = (value) => typeof value === "string";

// node_modules/@dynamic-labs/utils/src/pipe/pipe.js
var pipe = (initialFunc) => {
  const funcs = [initialFunc];
  const executeFn = (input) => funcs.reduce((acc, func) => func(acc), input);
  const pipe3 = (newFunc) => {
    funcs.push(newFunc);
    return Object.assign((input) => executeFn(input), {
      pipe: pipe3
    });
  };
  return Object.assign(executeFn, { pipe: pipe3 });
};

// node_modules/@dynamic-labs/utils/src/sleep/sleep.js
function sleep(timeoutMs, valueToResolve) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(valueToResolve), timeoutMs);
  });
}

// node_modules/@dynamic-labs/utils/src/retryableFn/retryableFn.js
var FALLBACK_UNDEFINED = "FALLBACK_UNDEFINED";
var retryableFn = (fn_1, ...args_1) => __awaiter2(void 0, [fn_1, ...args_1], void 0, function* (fn, options = {}) {
  const { maxRetries = 3, currentRetry = 0, timeoutMs = 100, fallbackValue = new Error("Max retries reached"), retryStrategy = "timeout-only", retryIntervalMs = 0 } = options;
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error("Timeout"));
    }, timeoutMs);
  });
  try {
    const result = yield Promise.race([fn(), timeoutPromise]);
    return result;
  } catch (err) {
    if (currentRetry >= maxRetries) {
      if (fallbackValue instanceof Error) {
        throw fallbackValue;
      } else if (fallbackValue === FALLBACK_UNDEFINED) {
        return void 0;
      }
      return fallbackValue;
    }
    const isTimeout = (err === null || err === void 0 ? void 0 : err.message) === "Timeout";
    const shouldRetry = retryStrategy === "timeout-and-rejection" || retryStrategy === "timeout-only" && isTimeout || retryStrategy === "rejection-only" && !isTimeout;
    if (!shouldRetry) {
      if (fallbackValue instanceof Error) {
        throw err;
      } else if (fallbackValue === FALLBACK_UNDEFINED) {
        return void 0;
      }
      return fallbackValue;
    }
    if (retryIntervalMs)
      yield sleep(retryIntervalMs);
    return retryableFn(fn, {
      currentRetry: currentRetry + 1,
      fallbackValue,
      maxRetries,
      retryIntervalMs,
      retryStrategy,
      timeoutMs
    });
  }
});

// node_modules/@dynamic-labs/utils/src/sanitizeName/sanitizeName.js
var sanitizeName = (name2) => name2.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();

// node_modules/@dynamic-labs/utils/src/filterDuplicates/filterDuplicates.js
var filterDuplicates = (array3) => Array.from(new Set(array3));

// node_modules/@dynamic-labs/utils/src/cloneObjectWithOverrides/cloneObjectWithOverrides.js
var cloneObjectWithOverrides = (original, overrides = {}) => {
  var _a5, _b;
  const descriptors = Object.getOwnPropertyDescriptors(original);
  const clone3 = Object.create(Object.getPrototypeOf(original));
  for (const [key, value] of Object.entries(overrides)) {
    Object.defineProperty(clone3, key, {
      // Make it writable if necessary
      configurable: true,
      // Allow future modifications
      enumerable: (_b = (_a5 = descriptors[key]) === null || _a5 === void 0 ? void 0 : _a5.enumerable) !== null && _b !== void 0 ? _b : true,
      value,
      writable: true
      // Preserve enumerability
    });
  }
  const overridesKeys = Object.keys(overrides);
  for (const [key, descriptor] of Object.entries(descriptors)) {
    if (!overridesKeys.includes(key)) {
      Object.defineProperty(clone3, key, descriptor);
    }
  }
  return clone3;
};

// node_modules/@dynamic-labs/utils/src/get/get.js
var get = (obj, path) => {
  try {
    const keys = path.match(/[^.[\]"']+/g) || [];
    return keys.reduce((acc, key) => acc[key], obj);
  } catch (error79) {
    return void 0;
  }
};

// node_modules/@dynamic-labs/utils/src/hexToString/hexToString.js
var hexToString = (hexString) => {
  const normalizedHexString = hexString.startsWith("0x") ? hexString.substring(2) : hexString;
  let text = "";
  const length = normalizedHexString.length - normalizedHexString.length % 2;
  for (let i = 0; i < length; i += 2) {
    const hexCode = normalizedHexString.substring(i, i + 2);
    const decimal = parseInt(hexCode, 16);
    text += String.fromCharCode(decimal);
  }
  return text;
};

// node_modules/@dynamic-labs/utils/src/isHex/isHex.js
var isHex = (str) => {
  if (typeof str !== "string") {
    throw new Error("Input must be a string");
  }
  const normalizedStr = str.startsWith("0x") ? str.substring(2) : str;
  const regex = /^[0-9a-fA-F]+$/;
  return regex.test(normalizedStr);
};

// node_modules/@dynamic-labs/utils/src/runSafe/runSafe.js
var runSafe = (callback) => __awaiter2(void 0, void 0, void 0, function* () {
  try {
    const resolved = yield callback();
    return [resolved, void 0];
  } catch (error79) {
    return [void 0, error79];
  }
});

// node_modules/@dynamic-labs/utils/src/template/template.js
var template = (templateText) => {
  return (data) => templateText.replace(/{{(\w+?)}}/g, (match, key) => key in data ? data[key] : match);
};

// node_modules/@dynamic-labs/utils/src/consts/phantomRedirect.js
var PHANTOM_REDIRECT_CONNECTION_TYPE_KEY = "phantom-redirect-connection-type";

// node_modules/@dynamic-labs/utils/node_modules/eventemitter3/index.mjs
var import_index2 = __toESM(require_eventemitter32(), 1);
var eventemitter3_default2 = import_index2.default;

// node_modules/@dynamic-labs/utils/src/services/PlatformEventsService/createBrowserPlatformEventsService/createBrowserPlatformEventsService.js
var createBrowserPlatformEventsService = (window2) => {
  const emitter = new eventemitter3_default2();
  const mapPlatformEventsToRequestChannel = {
    appFocused: () => {
      window2.addEventListener("focus", () => {
        emitter.emit("appFocused");
      });
    }
  };
  Object.values(mapPlatformEventsToRequestChannel).forEach((handler) => handler());
  return emitter;
};

// node_modules/@dynamic-labs/utils/src/services/PlatformEventsService/PlatformEventsService.js
var _a2;
var _PlatformEventsService_implementation;
var PlatformEventsService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a2, _a2, "f", _PlatformEventsService_implementation)) {
      __classPrivateFieldSet(_a2, _a2, createBrowserPlatformEventsService(window), "f", _PlatformEventsService_implementation);
    }
    return __classPrivateFieldGet(_a2, _a2, "f", _PlatformEventsService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a2, _a2, implementation, "f", _PlatformEventsService_implementation);
  }
  static get on() {
    return _a2.implementation.on.bind(_a2.implementation);
  }
  static get off() {
    return _a2.implementation.off.bind(_a2.implementation);
  }
  static get once() {
    return _a2.implementation.once.bind(_a2.implementation);
  }
};
_a2 = PlatformEventsService;
_PlatformEventsService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/utils/src/services/FetchService/FetchService.js
var _a3;
var _FetchService_implementation;
var FetchService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a3, _a3, "f", _FetchService_implementation)) {
      return { fetch: window.fetch.bind(window) };
    }
    return __classPrivateFieldGet(_a3, _a3, "f", _FetchService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a3, _a3, implementation, "f", _FetchService_implementation);
  }
  static get fetch() {
    return _a3.implementation.fetch;
  }
};
_a3 = FetchService;
_FetchService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/types/package.js
var version2 = "4.57.1";

// node_modules/@dynamic-labs/types/src/oauth/index.js
var SocialOAuthErrorCode;
(function(SocialOAuthErrorCode2) {
  SocialOAuthErrorCode2["ACCOUNT_ALREADY_LINKED"] = "account_already_linked";
  SocialOAuthErrorCode2["ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE"] = "account_already_linked_to_different_profile";
  SocialOAuthErrorCode2["INVALID_PROVIDER"] = "invalid_provider";
  SocialOAuthErrorCode2["NO_ACCOUNT_LINKED"] = "no_account_linked";
  SocialOAuthErrorCode2["NO_AUTH_CODE"] = "no_auth_code";
  SocialOAuthErrorCode2["NO_OAUTH_URL"] = "no_oauth_url";
  SocialOAuthErrorCode2["NO_PROVIDER"] = "no_provider";
  SocialOAuthErrorCode2["OAUTH_ERROR"] = "oauth_error";
  SocialOAuthErrorCode2["OAUTH_WINDOW_BLOCKED"] = "oauth_window_blocked";
  SocialOAuthErrorCode2["OAUTH_WINDOW_CLOSED"] = "oauth_window_closed";
  SocialOAuthErrorCode2["OAUTH_WINDOW_TIMEOUT"] = "oauth_window_timeout";
  SocialOAuthErrorCode2["PROVIDER_NOT_ENABLED"] = "provider_not_enabled";
  SocialOAuthErrorCode2["SESSION_TIMEOUT"] = "session_timeout";
  SocialOAuthErrorCode2["SIGNIN_ERROR"] = "signin_error";
  SocialOAuthErrorCode2["SOCIAL_LINKING_NOT_ENABLED"] = "social_linking_not_enabled";
  SocialOAuthErrorCode2["UNLINK_ERROR"] = "unlink_error";
  SocialOAuthErrorCode2["VERIFICATION_ERROR"] = "verification_error";
  SocialOAuthErrorCode2["GENERAL_ERROR"] = "general_error";
  SocialOAuthErrorCode2["USER_CANCELLED"] = "user_cancelled";
})(SocialOAuthErrorCode || (SocialOAuthErrorCode = {}));

// node_modules/@dynamic-labs/types/src/wallets/BaseWallet.js
var BaseWallet = class {
  constructor({ id, key, address, additionalAddresses = [], chain, isAuthenticated }) {
    this.id = id;
    this.key = key;
    this.address = address;
    this.additionalAddresses = additionalAddresses;
    this.chain = chain;
    this.isAuthenticated = isAuthenticated;
  }
};

// node_modules/@dynamic-labs/types/src/index.js
assertPackageVersion("@dynamic-labs/types", version2);

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/utils/loadAppleId/loadAppleId.js
var appleIdScriptSrc = "https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js";
var loadAppleId = () => new Promise((resolve, reject) => {
  const script = document.querySelector("script[data-apple-sdk]");
  if (script) {
    if (script.hasAttribute("data-loaded")) {
      resolve();
    } else {
      script.addEventListener("load", () => resolve());
      script.addEventListener("error", () => reject(new Error("Failed to load Apple SDK")));
    }
  } else {
    const script2 = document.createElement("script");
    script2.type = "text/javascript";
    script2.src = appleIdScriptSrc;
    script2.setAttribute("data-apple-sdk", "true");
    script2.onload = () => {
      script2 === null || script2 === void 0 ? void 0 : script2.setAttribute("data-loaded", "true");
      resolve();
    };
    script2.onerror = () => reject(new Error("Failed to load Apple SDK"));
    window.document.head.appendChild(script2);
  }
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/utils/connectWithAppleId/connectWithAppleId.js
var connectWithAppleId = (_a5) => __awaiter2(void 0, [_a5], void 0, function* ({ clientId, oauthLoginUrl, state }) {
  yield loadAppleId();
  AppleID.auth.init({
    clientId,
    redirectURI: oauthLoginUrl.searchParams.get("redirect_uri"),
    scope: "name email",
    state,
    usePopup: false
  });
  AppleID.auth.signIn();
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/createWindowOauth2Service/createWindowOauth2Service.js
var authWindowInterval;
var createWindowOauth2Service = () => ({
  getOauthCode: ({ apiProvider, provider, redirectUrl, setIsProcessing, state, oauthLoginUrl, initWebAuth, strategy }) => new Promise((resolve, _reject) => {
    if (provider === ProviderEnum.Apple && (isSafariBrowser() || isIOS() || strategy === "redirect")) {
      initWebAuth({
        redirectUrl: redirectUrl || window.location.href
      }).then(() => connectWithAppleId({
        clientId: apiProvider === null || apiProvider === void 0 ? void 0 : apiProvider.clientId,
        oauthLoginUrl,
        state
      }).catch(_reject));
      return;
    }
    if (strategy === "redirect" && provider !== ProviderEnum.Telegram) {
      initWebAuth({
        redirectUrl: redirectUrl || window.location.href
      }).then(() => {
        PlatformService.openURL(oauthLoginUrl.toString());
      });
      return;
    }
    const typedReject = (params) => _reject(params);
    clearInterval(authWindowInterval);
    const providersWaitingOauthMessage = {};
    const authWindow = window.open("", "_blank", "width=500,height=600");
    if (authWindow === null || typeof authWindow === "undefined") {
      typedReject({
        code: SocialOAuthErrorCode.OAUTH_WINDOW_BLOCKED,
        message: "Please allow popups and try again."
      });
      return;
    }
    const clearListeners = () => {
      window.removeEventListener("message", handleWindowMessage);
      providersWaitingOauthMessage[provider] = false;
    };
    const handleWindowMessage = (event) => __awaiter2(void 0, void 0, void 0, function* () {
      const message = event.data;
      const expectedOrigin = getExpectedOrigin(apiProvider);
      if (!expectedOrigin) {
        return;
      }
      if ((message === null || message === void 0 ? void 0 : message.type) === "origin_check" && authWindow) {
        logger2.debug("Origin check message received. Sending response now.", {
          data: message,
          expectedOrigin
        });
        authWindow.postMessage("origin_check_response", expectedOrigin);
        return;
      }
      const isTelegramCompletedMessage = (message === null || message === void 0 ? void 0 : message.type) === "telegram_completed";
      const isAuthorizationMessage = (message === null || message === void 0 ? void 0 : message.type) === "authorization_response";
      if (isAuthorizationMessage || isTelegramCompletedMessage) {
        logger2.debug("Message received", { data: message });
      }
      const isExpectedOrigin = event.origin === expectedOrigin;
      const isValidMessage = (isAuthorizationMessage && (message === null || message === void 0 ? void 0 : message.provider) === provider || isTelegramCompletedMessage) && isExpectedOrigin;
      if (!isValidMessage) {
        return;
      }
      setIsProcessing(true);
      if (!providersWaitingOauthMessage[provider]) {
        typedReject({
          code: SocialOAuthErrorCode.SESSION_TIMEOUT,
          message: `Connecting ${provider} account session timeout.`
        });
        return;
      }
      clearListeners();
      if (isTelegramCompletedMessage) {
        handleTelegramCompletionMessage(message, state);
        return;
      }
      handleAuthorizationMessage(message, provider, state);
    });
    const getExpectedOrigin = (apiProvider2) => {
      if (!(apiProvider2 === null || apiProvider2 === void 0 ? void 0 : apiProvider2.redirectUrl)) {
        return;
      }
      try {
        const redirectUri = new URL(apiProvider2.redirectUrl);
        return redirectUri.origin;
      } catch (e) {
        logger2.error("Failed to parse social provider redirect url", {
          error: e
        });
        return;
      }
    };
    const handleTelegramCompletionMessage = (message, state2) => {
      logger2.debug("Telegram completion message received", {
        data: message
      });
      const { code, state: authState } = message;
      if (state2 !== authState) {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: "Failed to connect telegram account: Invalid random state"
        });
        return;
      }
      resolve(code);
      setIsProcessing(false);
    };
    const handleAuthorizationMessage = (message, provider2, state2) => {
      const { code, error: error79, state: authState } = message;
      if (error79 && error79 !== "undefined") {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: `Failed to connect ${provider2} social account: ${error79}`
        });
        return;
      }
      if (state2 !== authState) {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: `Failed to connect ${provider2} social account: Invalid random state`
        });
        return;
      }
      if (!code) {
        typedReject({
          code: SocialOAuthErrorCode.NO_AUTH_CODE,
          message: `Failed to connect ${provider2} social account: no authorization code`
        });
        return;
      }
      resolve(code);
      setIsProcessing(false);
    };
    if (!providersWaitingOauthMessage[provider]) {
      window.addEventListener("message", handleWindowMessage);
      providersWaitingOauthMessage[provider] = true;
    }
    initWebAuth().then(() => {
      authWindow === null || authWindow === void 0 ? void 0 : authWindow.location.assign(oauthLoginUrl);
      authWindowInterval = setInterval(() => {
        if (!(authWindow === null || authWindow === void 0 ? void 0 : authWindow.closed))
          return;
        clearInterval(authWindowInterval);
        setIsProcessing(false);
        if (providersWaitingOauthMessage[provider])
          typedReject({
            code: SocialOAuthErrorCode.USER_CANCELLED,
            message: "User cancelled connection"
          });
      }, 2e3);
    });
  })
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/Oauth2Service.js
var _a4;
var _Oauth2Service_implementation;
var Oauth2Service = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a4, _a4, "f", _Oauth2Service_implementation)) {
      return createWindowOauth2Service();
    }
    return __classPrivateFieldGet(_a4, _a4, "f", _Oauth2Service_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a4, _a4, implementation, "f", _Oauth2Service_implementation);
  }
  static get getOauthCode() {
    return _a4.implementation.getOauthCode;
  }
};
_a4 = Oauth2Service;
_Oauth2Service_implementation = { value: void 0 };
Oauth2Service.isGetOauthCodeError = (error79) => typeof error79 === "object" && "code" in error79 && Object.values(SocialOAuthErrorCode).includes(error79.code) && "message" in error79 && typeof error79.message === "string";

// node_modules/@dynamic-labs/utils/src/services/StorageService/createStorageService/createStorageService.js
var createStorageService = ({ storage }) => {
  const packValue = (value) => JSON.stringify(value);
  const unpackValue = (value) => JSON.parse(value);
  const getItem = (key) => {
    const value = storage.getItem(key);
    if (!value || value === "undefined" || value === "null") {
      return void 0;
    }
    try {
      return unpackValue(value);
    } catch (error79) {
      logger2.error(`Error while parsing ${key} from local storage`, {
        value
      });
      removeItem(key);
      StorageService.events.emit("parseFailure", error79, key);
    }
    return void 0;
  };
  const setItem = (key, value) => {
    storage.setItem(key, packValue(value));
  };
  const removeItem = (key) => {
    storage.removeItem(key);
  };
  const getKeys = () => Object.keys(storage);
  return {
    getItem,
    getKeys,
    removeItem,
    setItem
  };
};

// node_modules/@dynamic-labs/utils/src/services/StorageService/StorageService.js
var StorageService = class _StorageService {
  static clearRegistry() {
    _StorageService.registry = {
      localStorage: void 0,
      secureStorage: void 0,
      sessionStorage: void 0
    };
  }
  static registerSourceStorage(source, implementation) {
    logger2.logVerboseTroubleshootingMessage("StorageService.registerSourceStorage", {
      implementation,
      source
    });
    _StorageService.registry[source] = implementation;
  }
  static getSourceStorage(source) {
    return _StorageService.registry[source];
  }
  static resolveStorage(options) {
    const priority = (options === null || options === void 0 ? void 0 : options.priority) || ["localStorage"];
    for (const source of priority) {
      const storage = _StorageService.getSourceStorage(source);
      if (storage) {
        return storage;
      }
    }
    if (priority.includes("localStorage")) {
      logger2.info("No available storage found based on the specified priority, defaulting to localStorage");
      return createStorageService({
        storage: localStorage
      });
    }
    if (priority.includes("sessionStorage")) {
      logger2.info("No available storage found based on the specified priority, defaulting to sessionStorage");
      return createStorageService({
        storage: sessionStorage
      });
    }
    logger2.logVerboseTroubleshootingMessage("No storage found â€” StorageService.registry:", _StorageService.registry);
    throw new Error("No available storage found based on the specified priority");
  }
  static getItem(key, options) {
    const storage = _StorageService.resolveStorage(options);
    return storage.getItem(key);
  }
  static setItem(key, value, options) {
    const storage = _StorageService.resolveStorage(options);
    storage.setItem(key, value);
  }
  static removeItem(key, options) {
    const storage = _StorageService.resolveStorage(options);
    storage.removeItem(key);
  }
  static getKeys(options) {
    return _StorageService.resolveStorage(options).getKeys();
  }
};
StorageService.registry = {
  localStorage: void 0,
  secureStorage: void 0,
  sessionStorage: void 0
};
StorageService.events = new eventemitter3_default2();

// node_modules/@dynamic-labs/utils/src/services/StorageService/applyPostfixToStorageService/applyPostfixToStorageService.js
var applyPostfixToStorageService = ({ storage, postfix }) => {
  const getKeyWithPostfix = (key) => postfix ? `${key}_${postfix}` : key;
  return Object.assign(Object.assign({}, storage), { getItem: (key) => storage.getItem(getKeyWithPostfix(key)), removeItem: (key) => storage.removeItem(getKeyWithPostfix(key)), setItem: (key, data) => storage.setItem(getKeyWithPostfix(key), data) });
};

// node_modules/@dynamic-labs/utils/src/solToLamports/solToLamports.js
var solToLamports = (solAmount) => {
  const lamportsPerSol = 1e9;
  return solAmount * lamportsPerSol;
};

// node_modules/@dynamic-labs/utils/src/env/getEnvVarWithFallback.js
var getEnvVarWithFallback = (keys, defaultValue) => {
  if (typeof process === "undefined" || !process.env) {
    return defaultValue;
  }
  const keysToTry = Array.isArray(keys) ? keys : [keys];
  for (const key of keysToTry) {
    const value = process.env[key];
    if (value !== void 0) {
      return value;
    }
  }
  return defaultValue;
};

// node_modules/@dynamic-labs/utils/src/setupInsideIframe/utils/logger.js
var logger3 = new Logger("@dynamic-labs/iframe-setup");

// node_modules/@dynamic-labs/utils/src/index.js
assertPackageVersion("@dynamic-labs/utils", version);

// node_modules/@dynamic-labs/iconic/package.js
var version3 = "4.57.1";

// node_modules/@dynamic-labs/iconic/src/Iconic.js
var import_react = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/iconic/src/helpers/getIconicSpriteUrl.js
var DEFAULT_ICONIC_SPRITE_URL = "https://iconic.dynamic-static-assets.com/icons/sprite.svg";
var getIconicSpriteUrl = () => {
  var _a5, _b, _c;
  if (typeof process !== "undefined" && process.env) {
    return (_c = (_b = (_a5 = process.env["ICONIC_SPRITE_CDN_URL"]) !== null && _a5 !== void 0 ? _a5 : process.env["NEXT_PUBLIC_ICONIC_SPRITE_CDN_URL"]) !== null && _b !== void 0 ? _b : process.env["REACT_APP_ICONIC_SPRITE_CDN_URL"]) !== null && _c !== void 0 ? _c : DEFAULT_ICONIC_SPRITE_URL;
  }
  return DEFAULT_ICONIC_SPRITE_URL;
};

// node_modules/@dynamic-labs/iconic/src/Iconic.js
var ICONIC_SPRITE_URL = getIconicSpriteUrl();
var createIconic = (props) => {
  const Icon = Object.assign(Object.assign({}, props), { function: (props2) => {
    const url = `${ICONIC_SPRITE_URL}#${Icon.iconName}`;
    return (0, import_react.createElement)("img", Object.assign(Object.assign({ "data-testid": `iconic-${Icon.iconName}` }, props2), { alt: Icon.alt, src: url }));
  } });
  const IconicComponent = Icon.function.bind(Icon);
  Object.assign(IconicComponent, {
    iconName: Icon.iconName,
    sourcePath: Icon.sourcePath
  });
  return IconicComponent;
};

// node_modules/@dynamic-labs/iconic/src/icons/browsers/index.js
var BraveIcon = createIconic({
  alt: "Brave Browser",
  iconName: "brave",
  sourcePath: "icons/browsers/brave.svg"
});
var ChromeIcon = createIconic({
  alt: "Chrome Browser",
  iconName: "chrome",
  sourcePath: "icons/browsers/chrome.svg"
});
var EdgeIcon = createIconic({
  alt: "Edge Browser",
  iconName: "edge",
  sourcePath: "icons/browsers/edge.svg"
});
var FirefoxIcon = createIconic({
  alt: "Firefox Browser",
  iconName: "firefox",
  sourcePath: "icons/browsers/firefox.svg"
});
var OperaIcon = createIconic({
  alt: "Opera Browser",
  iconName: "opera",
  sourcePath: "icons/browsers/opera.svg"
});
var SafariIcon = createIconic({
  alt: "Opera Browser",
  iconName: "safari",
  sourcePath: "icons/browsers/safari.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/chains/index.js
var AleoIcon = createIconic({
  alt: "Aleo Chain",
  iconName: "aleo",
  sourcePath: "icons/chains/aleo.svg"
});
var AlgorandIcon = createIconic({
  alt: "Algorand Chain",
  iconName: "algorand",
  sourcePath: "icons/chains/algorand.svg"
});
var AptosIcon = createIconic({
  alt: "Aptos Chain",
  iconName: "aptos",
  sourcePath: "icons/chains/aptos.svg"
});
var ArbitrumIcon = createIconic({
  alt: "Arbitrum Chain",
  iconName: "arbitrum",
  sourcePath: "icons/chains/arbitrum.svg"
});
var AuroraIcon = createIconic({
  alt: "Aurora Chain",
  iconName: "aurora",
  sourcePath: "icons/chains/aurora.svg"
});
var AxelarIcon = createIconic({
  alt: "Axelar Chain",
  iconName: "axelar",
  sourcePath: "icons/chains/axelar.svg"
});
var BaseChainIcon = createIconic({
  alt: "Base Chain",
  iconName: "base",
  sourcePath: "icons/chains/base.svg"
});
var BerachainIcon = createIconic({
  alt: "Berachain Chain",
  iconName: "berachain",
  sourcePath: "icons/chains/berachain.svg"
});
var BitcoinIcon = createIconic({
  alt: "Bitcoin Chain",
  iconName: "bitcoin",
  sourcePath: "icons/chains/bitcoin.svg"
});
var BnbIcon = createIconic({
  alt: "BNB Chain",
  iconName: "bnb",
  sourcePath: "icons/chains/bnb.svg"
});
var CosmosIcon = createIconic({
  alt: "Cosmos Chain",
  iconName: "cosmos",
  sourcePath: "icons/chains/cosmos.svg"
});
var EclipseIcon = createIconic({
  alt: "Eclipse",
  iconName: "eclipse",
  sourcePath: "icons/chains/eclipse.svg"
});
var EthereumIcon = createIconic({
  alt: "Ethereum Chain",
  iconName: "ethereum",
  sourcePath: "icons/chains/ethereum.svg"
});
var FlowIcon = createIconic({
  alt: "Flow Chain",
  iconName: "flow",
  sourcePath: "icons/chains/flow.svg"
});
var GnosisIcon = createIconic({
  alt: "Gnosis Chain",
  iconName: "gnosis",
  sourcePath: "icons/chains/gnosis.svg"
});
var GoerliIcon = createIconic({
  alt: "Goerli Chain",
  iconName: "goerli",
  sourcePath: "icons/chains/goerli.svg"
});
var OptimismIcon = createIconic({
  alt: "Optimism Chain",
  iconName: "optimism",
  sourcePath: "icons/chains/optimism.svg"
});
var OsmosisIcon = createIconic({
  alt: "Osmosis Chain",
  iconName: "osmosis",
  sourcePath: "icons/chains/osmosis.svg"
});
var PalmIcon = createIconic({
  alt: "Palm Chain",
  iconName: "palm",
  sourcePath: "icons/chains/palm.svg"
});
var PolygonIcon = createIconic({
  alt: "Polygon Chain",
  iconName: "polygon",
  sourcePath: "icons/chains/polygon.svg"
});
var SeiIcon = createIconic({
  alt: "Sei Chain",
  iconName: "sei",
  sourcePath: "icons/chains/sei.svg"
});
var SolanaIcon = createIconic({
  alt: "Solana Chain",
  iconName: "solana",
  sourcePath: "icons/chains/solana.svg"
});
var SparkIcon = createIconic({
  alt: "Spark Chain",
  iconName: "spark",
  sourcePath: "icons/chains/spark.svg"
});
var StarknetIcon = createIconic({
  alt: "Starknet Chain",
  iconName: "starknet",
  sourcePath: "icons/chains/starknet.svg"
});
var StellarIcon = createIconic({
  alt: "Stellar Chain",
  iconName: "stellar",
  sourcePath: "icons/chains/stellar.svg"
});
var SuiIcon = createIconic({
  alt: "Sui Chain",
  iconName: "sui",
  sourcePath: "icons/chains/sui.svg"
});
var TonIcon = createIconic({
  alt: "Ton Chain",
  iconName: "ton",
  sourcePath: "icons/chains/ton.svg"
});
var TronIcon = createIconic({
  alt: "Tron Chain",
  iconName: "tron",
  sourcePath: "icons/chains/tron.svg"
});
var ZkSyncIcon = createIconic({
  alt: "zkSync Era Chain",
  iconName: "zkSync",
  sourcePath: "icons/chains/zkSync.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/onramps/index.js
var BanxaIcon = createIconic({
  alt: "Banxa",
  iconName: "banxa",
  sourcePath: "icons/onramps/banxa.svg"
});
var CoinbasePayIcon = createIconic({
  alt: "Coinbase Pay",
  iconName: "coinbase-pay",
  sourcePath: "icons/onramps/coinbase-pay.svg"
});
var CryptoDotComIcon = createIconic({
  alt: "Crypto.com",
  iconName: "crypto-dot-com",
  sourcePath: "icons/onramps/crypto-dot-com.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/social/index.js
var social_exports = {};
__export(social_exports, {
  AppleDarkSocialIcon: () => AppleDarkSocialIcon,
  AppleSocialIcon: () => AppleSocialIcon,
  BinanceSocialIcon: () => BinanceSocialIcon,
  BitbucketIcon: () => BitbucketIcon,
  CoinbaseSocialDarkIcon: () => CoinbaseSocialDarkIcon,
  CoinbaseSocialIcon: () => CoinbaseSocialIcon,
  DiscordIcon: () => DiscordIcon,
  EpicGamesDarkIcon: () => EpicGamesDarkIcon,
  EpicGamesIcon: () => EpicGamesIcon,
  FacebookIcon: () => FacebookIcon,
  FarcasterIcon: () => FarcasterIcon,
  GithubDarkIcon: () => GithubDarkIcon,
  GithubIcon: () => GithubIcon,
  GitlabIcon: () => GitlabIcon,
  GoogleIcon: () => GoogleIcon,
  HelpdeskIcon: () => HelpdeskIcon,
  InstagramIcon: () => InstagramIcon,
  KrakenDarkIcon: () => KrakenDarkIcon,
  KrakenIcon: () => KrakenIcon,
  LineIcon: () => LineIcon,
  LinkedinIcon: () => LinkedinIcon,
  MicrosoftIcon: () => MicrosoftIcon,
  OktaIcon: () => OktaIcon,
  OnePasswordDarkIcon: () => OnePasswordDarkIcon,
  OnePasswordIcon: () => OnePasswordIcon,
  ShopifyIcon: () => ShopifyIcon,
  SlackIcon: () => SlackIcon,
  SpotifyDarkIcon: () => SpotifyDarkIcon,
  SpotifyIcon: () => SpotifyIcon,
  SteamDarkIcon: () => SteamDarkIcon,
  SteamIcon: () => SteamIcon,
  TelegramIcon: () => TelegramIcon,
  TikTokDarkIcon: () => TikTokDarkIcon,
  TikTokIcon: () => TikTokIcon,
  TwitchDarkIcon: () => TwitchDarkIcon,
  TwitchIcon: () => TwitchIcon,
  TwitterDarkIcon: () => TwitterDarkIcon,
  TwitterIcon: () => TwitterIcon,
  YouTubeIcon: () => YouTubeIcon
});
var BitbucketIcon = createIconic({
  alt: "Bitbucket",
  iconName: "bitbucket",
  sourcePath: "icons/social/bitbucket.svg"
});
var DiscordIcon = createIconic({
  alt: "Discord",
  iconName: "discord",
  sourcePath: "icons/social/discord.svg"
});
var FacebookIcon = createIconic({
  alt: "Facebook",
  iconName: "facebook",
  sourcePath: "icons/social/facebook.svg"
});
var FarcasterIcon = createIconic({
  alt: "Farcaster",
  iconName: "farcaster",
  sourcePath: "icons/social/farcaster.svg"
});
var GithubIcon = createIconic({
  alt: "Github",
  iconName: "github",
  sourcePath: "icons/social/github.svg"
});
var GithubDarkIcon = createIconic({
  alt: "Github",
  iconName: "github-dark",
  sourcePath: "icons/social/github-dark.svg"
});
var GitlabIcon = createIconic({
  alt: "Gitlab",
  iconName: "gitlab",
  sourcePath: "icons/social/gitlab.svg"
});
var GoogleIcon = createIconic({
  alt: "Google",
  iconName: "google",
  sourcePath: "icons/social/google.svg"
});
var HelpdeskIcon = createIconic({
  alt: "Helpdesk",
  iconName: "helpdesk",
  sourcePath: "icons/social/helpdesk.svg"
});
var LinkedinIcon = createIconic({
  alt: "Linkedin",
  iconName: "linkedin",
  sourcePath: "icons/social/linkedin.svg"
});
var MicrosoftIcon = createIconic({
  alt: "Microsoft",
  iconName: "microsoft",
  sourcePath: "icons/social/microsoft.svg"
});
var SlackIcon = createIconic({
  alt: "Slack",
  iconName: "slack",
  sourcePath: "icons/social/slack.svg"
});
var TelegramIcon = createIconic({
  alt: "Telegram",
  iconName: "telegram",
  sourcePath: "icons/social/telegram.svg"
});
var TwitchIcon = createIconic({
  alt: "Twitch",
  iconName: "twitch",
  sourcePath: "icons/social/twitch.svg"
});
var TwitchDarkIcon = createIconic({
  alt: "Twitch",
  iconName: "twitch-dark",
  sourcePath: "icons/social/twitch-dark.svg"
});
var TwitterIcon = createIconic({
  alt: "Twitter",
  iconName: "twitter",
  sourcePath: "icons/social/twitter.svg"
});
var TwitterDarkIcon = createIconic({
  alt: "Twitter",
  iconName: "twitter-dark",
  sourcePath: "icons/social/twitter-dark.svg"
});
var AppleSocialIcon = createIconic({
  alt: "Apple",
  iconName: "apple",
  sourcePath: "icons/social/apple.svg"
});
var AppleDarkSocialIcon = createIconic({
  alt: "Apple",
  iconName: "apple-dark",
  sourcePath: "icons/social/apple-dark.svg"
});
var CoinbaseSocialIcon = createIconic({
  alt: "Coinbase",
  iconName: "coinbasesocial",
  sourcePath: "icons/social/coinbasesocial.svg"
});
var CoinbaseSocialDarkIcon = createIconic({
  alt: "Coinbase",
  iconName: "coinbasesocial-dark",
  sourcePath: "icons/social/coinbasesocial-dark.svg"
});
var InstagramIcon = createIconic({
  alt: "Instagram",
  iconName: "instagram",
  sourcePath: "icons/social/instagram.svg"
});
var YouTubeIcon = createIconic({
  alt: "YouTube",
  iconName: "youtube",
  sourcePath: "icons/social/youtube.svg"
});
var OnePasswordIcon = createIconic({
  alt: "onePassword",
  iconName: "one-password",
  sourcePath: "icons/social/onePassword.svg"
});
var OnePasswordDarkIcon = createIconic({
  alt: "onePassword-dark",
  iconName: "one-password-dark",
  sourcePath: "icons/social/onePassword-dark.svg"
});
var EpicGamesIcon = createIconic({
  alt: "epicGames",
  iconName: "epicgames",
  sourcePath: "icons/social/epicgames.svg"
});
var EpicGamesDarkIcon = createIconic({
  alt: "epicGames-dark",
  iconName: "epicgames-dark",
  sourcePath: "icons/social/epicgames-dark.svg"
});
var SpotifyIcon = createIconic({
  alt: "spotify",
  iconName: "spotify",
  sourcePath: "icons/social/spotify.svg"
});
var SpotifyDarkIcon = createIconic({
  alt: "spotify-dark",
  iconName: "spotify-dark",
  sourcePath: "icons/social/spotify-dark.svg"
});
var SteamIcon = createIconic({
  alt: "steam",
  iconName: "steam",
  sourcePath: "icons/social/steam.svg"
});
var SteamDarkIcon = createIconic({
  alt: "steam-dark",
  iconName: "steam-dark",
  sourcePath: "icons/social/steam-dark.svg"
});
var TikTokIcon = createIconic({
  alt: "tiktok",
  iconName: "tiktok",
  sourcePath: "icons/social/tiktok.svg"
});
var TikTokDarkIcon = createIconic({
  alt: "tiktok-dark",
  iconName: "tiktok-dark",
  sourcePath: "icons/social/tiktok-dark.svg"
});
var LineIcon = createIconic({
  alt: "line",
  iconName: "line",
  sourcePath: "icons/social/line.svg"
});
var ShopifyIcon = createIconic({
  alt: "shopify",
  iconName: "shopify",
  sourcePath: "icons/social/shopify.svg"
});
var KrakenIcon = createIconic({
  alt: "kraken",
  iconName: "kraken",
  sourcePath: "icons/social/kraken.svg"
});
var KrakenDarkIcon = createIconic({
  alt: "kraken-dark",
  iconName: "kraken-dark",
  sourcePath: "icons/social/kraken-dark.svg"
});
var BinanceSocialIcon = createIconic({
  alt: "binance",
  iconName: "binancesocial",
  sourcePath: "icons/social/binancesocial.svg"
});
var OktaIcon = createIconic({
  alt: "okta",
  iconName: "okta",
  sourcePath: "icons/social/okta.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/wallets/index.js
var OneInchIcon = createIconic({
  alt: "1inch Wallet",
  iconName: "1inch.svg",
  sourcePath: "icons/wallets/1inch.svg"
});
var ArgentXIcon = createIconic({
  alt: "Argent X Wallet",
  iconName: "argentx",
  sourcePath: "icons/wallets/argentx.svg"
});
var ArgentMobile = createIconic({
  alt: "Argent Mobile",
  iconName: "argentmobile",
  sourcePath: "icons/wallets/argent-mobile.svg"
});
var ArgentWebWallet = createIconic({
  alt: "Argent Web Wallet",
  iconName: "argentwebwallet",
  sourcePath: "icons/wallets/argent-web-wallet.svg"
});
var BackpackIcon = createIconic({
  alt: "Backpack Wallet",
  iconName: "backpack",
  sourcePath: "icons/wallets/backpack.svg"
});
var BinanceIcon = createIconic({
  alt: "Binance Wallet",
  iconName: "binance.svg",
  sourcePath: "icons/wallets/binance.svg"
});
var BitPayIcon = createIconic({
  alt: "BitPay Wallet",
  iconName: "bitpay.svg",
  sourcePath: "icons/wallets/bitpay.svg"
});
var BloctoIcon = createIconic({
  alt: "Blocto Wallet",
  iconName: "blocto",
  sourcePath: "icons/wallets/blocto.svg"
});
var BraavosIcon = createIconic({
  alt: "Braavos Wallet",
  iconName: "braavos",
  sourcePath: "icons/wallets/braavos.svg"
});
var ByBitIcon = createIconic({
  alt: "ByBit Wallet",
  iconName: "bybit",
  sourcePath: "icons/wallets/bybit.svg"
});
var Coin98Icon = createIconic({
  alt: "Coin98 Wallet",
  iconName: "coin98",
  sourcePath: "icons/wallets/coin98.svg"
});
var CoinbaseIcon = createIconic({
  alt: "Coinbase Wallet",
  iconName: "coinbase",
  sourcePath: "icons/wallets/coinbase.svg"
});
var CryptoIcon = createIconic({
  alt: "Crypto Wallet",
  iconName: "crypto.svg",
  sourcePath: "icons/wallets/crypto.svg"
});
var DapperIcon = createIconic({
  alt: "Dapper Wallet",
  iconName: "dapper",
  sourcePath: "icons/wallets/dapper.svg"
});
var DawnIcon = createIconic({
  alt: "Dawn Wallet",
  iconName: "dawn",
  sourcePath: "icons/wallets/dawn.svg"
});
var DefaultIcon = createIconic({
  alt: "Default Wallet",
  iconName: "defaultwallet",
  sourcePath: "icons/wallets/default.svg"
});
var EmailSignIcon = createIconic({
  alt: "Dapper Wallet",
  iconName: "emailsign.svg",
  sourcePath: "icons/wallets/emailsign.svg"
});
var SignInWithEmailIcon = createIconic({
  alt: "Sign in with Email",
  iconName: "signinwithemail",
  sourcePath: "icons/wallets/signinwithemail.svg"
});
var ExodusIcon = createIconic({
  alt: "Exodus Wallet",
  iconName: "exodus",
  sourcePath: "icons/wallets/exodus.svg"
});
var FireblocksIcon = createIconic({
  alt: "Fireblocks Wallet",
  iconName: "fireblocks",
  sourcePath: "icons/wallets/fireblocks.svg"
});
var FlowWalletIcon = createIconic({
  alt: "Flow Wallet",
  iconName: "flowwallet",
  sourcePath: "icons/wallets/flowwallet.svg"
});
var FordefiIcon = createIconic({
  alt: "Fordefi Wallet",
  iconName: "fordefi",
  sourcePath: "icons/wallets/fordefi.svg"
});
var FortmaticIcon = createIconic({
  alt: "Fortmatic Wallet",
  iconName: "fortmatic",
  sourcePath: "icons/wallets/fortmatic.svg"
});
var FrameIcon = createIconic({
  alt: "Frame Wallet",
  iconName: "frame",
  sourcePath: "icons/wallets/frame.svg"
});
var GamestopIcon = createIconic({
  alt: "Gamestop Wallet",
  iconName: "gamestop",
  sourcePath: "icons/wallets/gamestop.svg"
});
var GlowIcon = createIconic({
  alt: "Glow Wallet",
  iconName: "glow",
  sourcePath: "icons/wallets/glow.svg"
});
var ImTokenWallet = createIconic({
  alt: "ImToken Wallet",
  iconName: "imtoken.svg",
  sourcePath: "icons/wallets/imtoken.svg"
});
var InjectedWalletIcon = createIconic({
  alt: "Injected Wallet",
  iconName: "injectedwallet",
  sourcePath: "icons/wallets/injectedwallet.svg"
});
var InfinexIcon = createIconic({
  alt: "Infinex Wallet",
  iconName: "infinex",
  sourcePath: "icons/wallets/infinex.svg"
});
var KeplrIcon = createIconic({
  alt: "Keplr Wallet",
  iconName: "keplr",
  sourcePath: "icons/wallets/keplr.svg"
});
var LedgerIcon = createIconic({
  alt: "Ledger Wallet",
  iconName: "ledger",
  sourcePath: "icons/wallets/ledger.svg"
});
var LilicoIcon = createIconic({
  alt: "Lilico Wallet",
  iconName: "lilico",
  sourcePath: "icons/wallets/lilico.svg"
});
var LinenIcon = createIconic({
  alt: "Linen Wallet",
  iconName: "linen.svg",
  sourcePath: "icons/wallets/linen.svg"
});
var MaticIcon = createIconic({
  alt: "Matic Wallet",
  iconName: "matic",
  sourcePath: "icons/wallets/matic.svg"
});
var MetaMaskIcon = createIconic({
  alt: "MetaMask Wallet",
  iconName: "metamask",
  sourcePath: "icons/wallets/metamask.svg"
});
var MissingIcon = createIconic({
  alt: "Missing Wallet",
  iconName: "missing",
  sourcePath: "icons/wallets/missing.svg"
});
var MyalgoIcon = createIconic({
  alt: "MyAlgo Wallet",
  iconName: "myalgo",
  sourcePath: "icons/wallets/myalgo.svg"
});
var OmniIcon = createIconic({
  alt: "Omni Wallet",
  iconName: "omni",
  sourcePath: "icons/wallets/omni.svg"
});
var OpeanSeaIcon = createIconic({
  alt: "OpeanSea Wallet",
  iconName: "opeansea",
  sourcePath: "icons/wallets/opensea.svg"
});
var OylIcon = createIconic({
  alt: "Oyl Wallet",
  iconName: "oyl",
  sourcePath: "icons/wallets/oyl.svg"
});
var PasskeysWalletIcon = createIconic({
  alt: "Passkeys Wallet",
  iconName: "passkeys",
  sourcePath: "icons/wallets/passkeys.svg"
});
var PeraIcon = createIconic({
  alt: "Pera Wallet",
  iconName: "pera",
  sourcePath: "icons/wallets/pera.svg"
});
var PhantomIcon = createIconic({
  alt: "Phantom Wallet",
  iconName: "phantom",
  sourcePath: "icons/wallets/phantom.svg"
});
var RabbyIcon = createIconic({
  alt: "Rabby Wallet",
  iconName: "rabby",
  sourcePath: "icons/wallets/rabby.svg"
});
var RainbowIcon = createIconic({
  alt: "Rainbow Wallet",
  iconName: "rainbow",
  sourcePath: "icons/wallets/rainbow.svg"
});
var SafeIcon = createIconic({
  alt: "Safe Wallet",
  iconName: "safe",
  sourcePath: "icons/wallets/safe.svg"
});
var SequenceIcon = createIconic({
  alt: "Sequence Wallet",
  iconName: "sequence",
  sourcePath: "icons/wallets/sequence.svg"
});
var SlushIcon = createIconic({
  alt: "Slush â€” A Sui wallet",
  iconName: "slush",
  sourcePath: "icons/wallets/slush.svg"
});
var SolflareIcon = createIconic({
  alt: "Solflare Wallet",
  iconName: "solflare",
  sourcePath: "icons/wallets/solflare.svg"
});
var SpotIcon = createIconic({
  alt: "Spot Wallet",
  iconName: "spot",
  sourcePath: "icons/wallets/spot.svg"
});
var StrokeIcon = createIconic({
  alt: "Stroke Wallet",
  iconName: "stroke",
  sourcePath: "icons/wallets/stroke.svg"
});
var SuietIcon = createIconic({
  alt: "Suiet Wallet",
  iconName: "suiet",
  sourcePath: "icons/wallets/suiet.svg"
});
var TallyCashIcon = createIconic({
  alt: "Taho Wallet",
  iconName: "tallycash",
  sourcePath: "icons/wallets/tallycash.svg"
});
var TerraIcon = createIconic({
  alt: "Terra Wallet",
  iconName: "terra",
  sourcePath: "icons/wallets/terra.svg"
});
var TorusIcon = createIconic({
  alt: "Torus Wallet",
  iconName: "torus",
  sourcePath: "icons/wallets/torus.svg"
});
var TronLinkIcon = createIconic({
  alt: "TronLink Wallet",
  iconName: "tronlink",
  sourcePath: "icons/wallets/tronlink.svg"
});
var TrustIcon = createIconic({
  alt: "Trust Wallet",
  iconName: "trust",
  sourcePath: "icons/wallets/trust.svg"
});
var UnstoppableIcon = createIconic({
  alt: "Unstoppable Wallet",
  iconName: "unstoppable",
  sourcePath: "icons/wallets/unstoppable.svg"
});
var VenlyIcon = createIconic({
  alt: "Venly Wallet",
  iconName: "venly",
  sourcePath: "icons/wallets/venly.svg"
});
var WalletConnectIcon = createIconic({
  alt: "Wallet Connect Wallet",
  iconName: "walletconnect",
  sourcePath: "icons/wallets/walletconnect.svg"
});
var MagicLinkIcon = createIconic({
  alt: "Magic Link Wallet",
  iconName: "magiclink",
  sourcePath: "icons/wallets/magic-link.svg"
});
var TurnkeyIcon = createIconic({
  alt: "Turnkey",
  iconName: "turnkey",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var DynamicWaasIcon = createIconic({
  alt: "Dynamic Waas",
  iconName: "dynamicwaas",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var ZengoIcon = createIconic({
  alt: "Zengo Wallet",
  iconName: "zengo",
  sourcePath: "icons/wallets/zengo.svg"
});
var SuperbIcon = createIconic({
  alt: "Superb Wallet",
  iconName: "superb",
  sourcePath: "icons/wallets/superb.svg"
});
var ZeroDevIcon = createIconic({
  alt: "ZeroDev",
  iconName: "zerodev",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var SmartWalletIcon = createIconic({
  alt: "Smart Wallet",
  iconName: "smartwallet",
  sourcePath: "icons/wallets/smart-wallet.svg"
});
var MagicEdenIcon = createIconic({
  alt: "Magic Eden",
  iconName: "magiceden",
  sourcePath: "icons/wallets/magiceden.svg"
});
var XverseEdenIcon = createIconic({
  alt: "Xverse",
  iconName: "xverse",
  sourcePath: "icons/wallets/xverse.svg"
});
var UnisatIcon = createIconic({
  alt: "Unisat",
  iconName: "unisat",
  sourcePath: "icons/wallets/unisat.svg"
});
var LeatherIcon = createIconic({
  alt: "Leather",
  iconName: "leather",
  sourcePath: "icons/wallets/leather.svg"
});
var OkxIcon = createIconic({
  alt: "OKX",
  iconName: "okx",
  sourcePath: "icons/wallets/okx.svg"
});
var CoinbaseWaaSIcon = createIconic({
  alt: "Coinbase WaaS",
  iconName: "coinbasewaas",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var MetaMaskStarknetIcon = createIconic({
  alt: "MetaMask Starknet Snap",
  iconName: "metamaskstarknetsnap",
  sourcePath: "icons/wallets/metamask-starknet.svg"
});
var NightlyIcon = createIconic({
  alt: "Nightly",
  iconName: "nightly",
  sourcePath: "icons/wallets/nightly.svg"
});
var OneKeyIcon = createIconic({
  alt: "OneKey",
  iconName: "onekey",
  sourcePath: "icons/wallets/onekey.svg"
});
var AmbireIcon = createIconic({
  alt: "Ambire",
  iconName: "ambire",
  sourcePath: "icons/wallets/ambire.svg"
});
var BitGetWalletIcon = createIconic({
  alt: "Bitget Wallet",
  iconName: "bitgetwallet",
  sourcePath: "icons/wallets/bitgetwallet.svg"
});
var MathWalletIcon = createIconic({
  alt: "Math Wallet",
  iconName: "coin98",
  sourcePath: "icons/wallets/coin98.svg"
});
var CloverWalletIcon = createIconic({
  alt: "Clover Wallet",
  iconName: "clover",
  sourcePath: "icons/wallets/clover.svg"
});
var UnknownWalletIcon = createIconic({
  alt: "Unknown Wallet",
  iconName: "unknown-wallet",
  sourcePath: "icons/wallets/unknown.svg"
});
var AbstractIcon = createIconic({
  alt: "Abstract",
  iconName: "abstract",
  sourcePath: "icons/wallets/abstract.svg"
});
var EdenOnlineIcon = createIconic({
  alt: "Eden Online",
  iconName: "edenonline",
  sourcePath: "icons/wallets/edenonline.svg"
});
var IntersendIcon = createIconic({
  alt: "Intersend",
  iconName: "intersend",
  sourcePath: "icons/wallets/intersend.svg"
});
var PontemIcon = createIconic({
  alt: "Pontem",
  iconName: "pontem",
  sourcePath: "icons/wallets/pontem.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/mobile/index.js
var AppleIcon = createIconic({
  alt: "Apple",
  iconName: "apple",
  sourcePath: "icons/mobile/apple.svg"
});
var AndroidIcon = createIconic({
  alt: "Android",
  iconName: "android",
  sourcePath: "icons/mobile/android.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/misc/index.js
var CaptchaWaveIcon = createIconic({
  alt: "Captcha Wave",
  iconName: "captcha-wave",
  sourcePath: "icons/misc/captcha-wave.svg"
});
var UserProfileIcon = createIconic({
  alt: "User Profile",
  iconName: "user-profile",
  sourcePath: "icons/misc/user-profile.svg"
});
var ArrowSendIcon = createIconic({
  alt: "Arrow Send",
  iconName: "arrow-send",
  sourcePath: "icons/misc/arrow-send.svg"
});

// node_modules/@dynamic-labs/iconic/_virtual/_tslib.js
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/@dynamic-labs/iconic/src/components/SocialIcon.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/iconic/src/logger.js
var logger4 = new Logger("iconic");

// node_modules/@dynamic-labs/iconic/src/components/getSocialIcon.js
var getSocialIcon = (name2, variant = "light") => {
  const map = Object.fromEntries(Object.values(social_exports).map((icon2) => [icon2.iconName, icon2]));
  if (variant === "dark") {
    const darkIcon = map[`${name2.toLowerCase()}-dark`];
    if (darkIcon)
      return darkIcon;
  }
  const icon = map[name2.toLowerCase()];
  if (icon)
    return icon;
  throw new Error(`Icon ${name2}, not found`);
};

// node_modules/@dynamic-labs/iconic/src/components/findSocialIcon.js
var findSocialIcon = (name2, variant = "light") => {
  try {
    return getSocialIcon(name2, variant);
  } catch (e) {
    logger4.error(e);
    return null;
  }
};

// node_modules/@dynamic-labs/iconic/src/components/SocialIcon.js
var SocialIcon = (_a5) => {
  var { name: name2, variant } = _a5, props = __rest(_a5, ["name", "variant"]);
  const Icon = findSocialIcon(name2, variant);
  if (!Icon)
    return null;
  return (0, import_react2.createElement)(Icon, props, null);
};

// node_modules/@dynamic-labs/iconic/src/index.js
assertPackageVersion("@dynamic-labs/iconic", version3);

// node_modules/@dynamic-labs/wallet-book/package.js
var version4 = "4.57.1";

// node_modules/@dynamic-labs/wallet-book/src/context/WalletBookContext.js
var import_react3 = __toESM(require_react(), 1);
var WalletBookContext = (0, import_react3.createContext)(void 0);
var useWalletBookContext = () => {
  const context = (0, import_react3.useContext)(WalletBookContext);
  if (context === void 0) {
    throw new Error("useWalletBookContext must be used within a WalletBookContextProvider");
  }
  return context;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletBookWallet.js
var getWalletBookWallet = (walletBook, walletKey, walletFallback) => {
  var _a5, _b, _c;
  if (!walletKey)
    throw new Error("Wallet key is required. Please pass in a wallet key to getWalletBookWallet");
  const walletData = (_b = (_a5 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) === null || _a5 === void 0 ? void 0 : _a5[walletKey]) !== null && _b !== void 0 ? _b : walletFallback;
  if (!walletData) {
    throw new Error(`Wallet ${walletKey} not found in wallet book (${Object.keys((_c = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _c !== void 0 ? _c : {}).length} wallets found)`);
  }
  return walletData;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/renderTemplate.js
var TEMPLATES = {
  androidUrl: "https://play.google.com/store/apps/details?id={{id}}",
  chromeUrl: "https://chrome.google.com/webstore/detail/{{id}}",
  edgeUrl: "https://microsoftedge.microsoft.com/addons/detail/{{id}}",
  firefoxUrl: "https://addons.mozilla.org/en-US/firefox/addon/{{id}}",
  iconicUrl: `${getIconicSpriteUrl()}#{{id}}`,
  iosUrl: "https://apps.apple.com/app/apple-store/{{id}}",
  walletConnectUrl: "https://registry.walletconnect.org/v2/logo/sm/{{id}}"
};
var renderTemplate = (templateName, data) => {
  if (!data)
    return void 0;
  return TEMPLATES[templateName].replace("{{id}}", data);
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getBrandIconUrl.js
var getBrandIconUrl = (brand) => {
  if (brand.spriteId) {
    return renderTemplate("iconicUrl", brand.spriteId);
  }
  return "";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/logger.js
var logger5 = new Logger("WalletBook");

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletIconUrl.js
var getDefaultWalletIconUrl = () => {
  try {
    return renderTemplate("iconicUrl", "defaultwallet");
  } catch (err) {
    logger5.error(err);
  }
  return "";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletBookWallet.js
var findWalletBookWallet = (walletBook, walletKey) => {
  try {
    const walletData = getWalletBookWallet(walletBook, walletKey);
    return walletData;
  } catch (err) {
    return void 0;
  }
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletGroup.js
var getWalletGroup = (walletBook, key) => {
  const group = walletBook.groups[key];
  if (!group)
    throw new Error(`Group ${key} not found in wallet book`);
  return group;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletGroup.js
var findWalletGroup = (walletBook, walletGroup) => {
  try {
    return getWalletGroup(walletBook, walletGroup);
  } catch (err) {
    logger5.error(err);
    return void 0;
  }
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletBookCdnUrl.js
var DEFAULT_WALLET_BOOK_CDN_URL = "https://dynamic-static-assets.com/wallet-book/v1/stable/wallet-book.json";
var getWalletBookCdnUrl = () => getEnvVarWithFallback([
  "WALLET_BOOK_CDN_URL",
  "NEXT_PUBLIC_WALLET_BOOK_CDN_URL",
  "REACT_APP_WALLET_BOOK_CDN_URL"
], DEFAULT_WALLET_BOOK_CDN_URL);

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletGroupOverride.js
var findWalletGroupOverride = (walletBook, groupKey, walletKey) => {
  var _a5;
  const group = findWalletGroup(walletBook, groupKey);
  return (_a5 = group === null || group === void 0 ? void 0 : group.walletOverrides) === null || _a5 === void 0 ? void 0 : _a5[walletKey];
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/isWalletBookPopulated.js
var isWalletBookPopulated = (walletBook) => {
  var _a5;
  return Object.keys((_a5 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a5 !== void 0 ? _a5 : {}).length > 0;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletBookWalletByNameAndChain.js
var findWalletBookWalletByNameAndChain = (walletBook, walletName, chain) => {
  var _a5;
  return Object.values((_a5 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a5 !== void 0 ? _a5 : {}).find((wallet) => {
    var _a6, _b;
    return wallet.name === walletName && ((_b = (_a6 = wallet.injectedConfig) === null || _a6 === void 0 ? void 0 : _a6[0]) === null || _b === void 0 ? void 0 : _b.chain) === chain;
  });
};

// node_modules/@dynamic-labs/wallet-book/src/hooks/useWalletBookCdn.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/wallet-book/_virtual/_tslib.js
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter3(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/wallet-book/node_modules/eventemitter3/index.mjs
var import_index3 = __toESM(require_eventemitter33(), 1);
var eventemitter3_default3 = import_index3.default;

// node_modules/@dynamic-labs/wallet-book/wallet-book-fallbacks.js
var groups = {
  argentx: {
    brand: {
      alt: "ArgentX",
      primaryColor: "#FF875B",
      spriteId: "argentx"
    },
    key: "argentx",
    name: "ArgentX"
  },
  backpack: {
    brand: {
      alt: "Backpack",
      spriteId: "backpack"
    },
    key: "backpack",
    name: "Backpack"
  },
  bitgetwallet: {
    brand: {
      alt: "Bitget Wallet",
      spriteId: "bitget"
    },
    key: "bitgetwallet",
    name: "Bitget"
  },
  blocto: {
    brand: {
      alt: "Blocto",
      primaryColor: "#5E678A",
      spriteId: "blocto"
    },
    key: "blocto",
    name: "Blocto"
  },
  brave: {
    brand: {
      alt: "Brave Browser",
      primaryColor: "#4B49C6",
      spriteId: "brave"
    },
    key: "brave",
    name: "Brave"
  },
  coin98: {
    brand: {
      alt: "Coin98 Wallet",
      primaryColor: "#CDA349",
      spriteId: "fc460647-ea95-447a-99f0-1bff8fa4be00"
    },
    key: "coin98",
    name: "Coin98"
  },
  coinbase: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    key: "coinbase",
    name: "Coinbase"
  },
  compasswallet: {
    brand: {
      alt: "Compass",
      primaryColor: "#4B49C6",
      spriteId: "1d7dea00-96be-4ce8-ca15-d14bddbb5000"
    },
    key: "compasswallet",
    name: "Compass"
  },
  exodus: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    key: "exodus",
    name: "Exodus"
  },
  fireblocks: {
    brand: {
      alt: "Fireblocks",
      spriteId: "fireblocks"
    },
    key: "fireblocks",
    name: "Fireblocks"
  },
  flowwallet: {
    brand: {
      alt: "Flow Wallet",
      primaryColor: "#2BE829",
      spriteId: "flowwallet"
    },
    key: "flowwallet",
    name: "Flow Wallet"
  },
  keplr: {
    brand: {
      alt: "Keplr",
      spriteId: "keplr"
    },
    key: "keplr",
    name: "Keplr"
  },
  magiceden: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    key: "magiceden",
    name: "Magic Eden"
  },
  mathwallet: {
    brand: {
      alt: "MathWallet Wallet",
      spriteId: "26a8f588-3231-4411-60ce-5bb6b805a700"
    },
    key: "mathwallet",
    name: "Math Wallet"
  },
  metamask: {
    brand: {
      alt: "MetaMask",
      primaryColor: "#E2761B",
      spriteId: "metamask"
    },
    key: "metamask",
    name: "MetaMask"
  },
  nightly: {
    brand: {
      alt: "Nightly Wallet",
      spriteId: "nightly"
    },
    key: "nightly",
    name: "Nightly"
  },
  okxwallet: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    key: "okxwallet",
    name: "OKX Wallet"
  },
  onekey: {
    brand: {
      alt: "OneKey Wallet",
      spriteId: "onekey"
    },
    key: "onekey",
    name: "OneKey"
  },
  phantom: {
    brand: {
      alt: "Phantom",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    key: "phantom",
    name: "Phantom"
  },
  tronlinkwallet: {
    brand: {
      alt: "TronLink Wallet",
      primaryColor: "#1677FF",
      spriteId: "tronlink"
    },
    key: "tronlink",
    name: "TronLink"
  },
  trust: {
    brand: {
      alt: "Trust Wallet",
      spriteId: "trust"
    },
    key: "trust",
    name: "Trust"
  },
  walletconnect: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    key: "walletconnect",
    name: "WalletConnect"
  },
  xverse: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    key: "xverse",
    name: "Xverse"
  }
};
var wallets = {
  metamask: {
    brand: {
      alt: "MetaMask Wallet",
      primaryColor: "#E8831D",
      spriteId: "metamask"
    },
    chainGroup: "metamask",
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:42161",
      "eip155:42170",
      "eip155:7777777",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453"
    ],
    desktop: {
      chromeId: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edgeId: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefoxId: "ether-metamask"
    },
    eip6963Config: {
      rdns: "io.metamask"
    },
    filterFromWalletConnect: true,
    group: "metamask",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isMetaMask",
            value: true
          },
          {
            flag: "isDawn",
            value: false
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isTrustWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isZerion",
            value: false
          },
          {
            flag: "isSuperb",
            value: false
          },
          {
            flag: "isRabby",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          },
          {
            flag: "isRainbow",
            value: false
          },
          {
            flag: "isAvalanche",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isZerion",
            value: false
          },
          {
            flag: "isOneKey",
            value: false
          },
          {
            flag: "isPhantom",
            value: false
          },
          {
            flag: "isCoin98",
            value: false
          },
          {
            flag: "isBinance",
            value: false
          }
        ]
      }
    ],
    mobile: {
      androidId: "io.metamask",
      inAppBrowser: "https://metamask.app.link/dapp",
      inAppBrowserV2: "https://metamask.app.link/dapp/{{dappURI}}",
      iosId: "id1438144202",
      native: "metamask://wc",
      universal: "https://metamask.app.link/wc"
    },
    name: "MetaMask",
    shortName: "MetaMask",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  coinbase: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    chainGroup: "coinbase",
    desktop: {
      chromeId: "hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    eip6963Config: {
      rdns: "com.coinbase.wallet"
    },
    group: "coinbase",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isCoinbaseWallet",
            value: true
          }
        ],
        windowLocations: [
          "coinbaseWalletExtension"
        ]
      }
    ],
    mobile: {
      androidId: "org.toshi",
      inAppBrowserV2: "https://go.cb-w.com/dapp?cb_url={{encodedDappURI}}",
      iosId: "id1278383455"
    },
    name: "Coinbase",
    shortName: "Coinbase Wallet"
  },
  coinbasesolana: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    chainGroup: "coinbase",
    desktop: {
      chromeId: "hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    group: "coinbase",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [],
        windowLocations: [
          "coinbaseSolana"
        ]
      }
    ],
    mobile: {
      androidId: "org.toshi",
      inAppBrowser: "https://go.cb-w.com/dapp?cb_url={{encodedDappURI}}",
      inAppBrowserV2: "https://go.cb-w.com/dapp?cb_url={{encodedDappURI}}",
      iosId: "id1278383455"
    },
    mobileExperience: "in-app-browser",
    name: "Coinbase",
    shortName: "Coinbase Wallet (Solana)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  phantom: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isGlow",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          }
        ],
        walletStandardLocators: [
          {
            locator: "features.phantom:.phantom",
            name: "Phantom"
          }
        ],
        windowLocations: [
          "phantom.solana"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    mobileExperience: "redirect",
    name: "Phantom"
  },
  phantombtc: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          }
        ],
        walletStandard: {
          features: [
            "bitcoin:connect"
          ],
          name: "Phantom"
        },
        windowLocations: [
          "phantom.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (Bitcoin)"
  },
  phantomevm: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          }
        ],
        windowLocations: [
          "phantom.ethereum"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    mobileExperience: "in-app-browser",
    name: "Phantom",
    shortName: "Phantom (EVM)"
  },
  phantomledger: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isGlow",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          }
        ],
        walletStandardLocators: [
          {
            locator: "features.phantom:.phantom",
            name: "Phantom"
          }
        ],
        windowLocations: [
          "phantom.solana"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (Ledger)"
  },
  walletconnect: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    chainGroup: "walletconnect",
    group: "walletconnect",
    mobile: {
      androidId: "enable-android",
      iosId: "id1438144202"
    },
    name: "WalletConnect",
    shortName: "WalletConnect"
  },
  walletconnectsol: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    chainGroup: "walletconnect",
    group: "walletconnect",
    mobile: {
      androidId: "enable-android",
      iosId: "id1438144202"
    },
    name: "WalletConnect"
  },
  argentx: {
    brand: {
      alt: "Argent X Wallet",
      primaryColor: "#FF875B",
      spriteId: "argentx"
    },
    desktop: {
      chromeId: "dlcobpjiigpikoobohmabehhmhfoodbb",
      edgeId: "ajcicjlkibolbeaaagejfhnofogocgcj",
      firefoxId: "argent-x"
    },
    name: "Ready Wallet (formerly Argent)",
    shortName: "Ready Wallet (formerly Argent)"
  },
  perawallet: {
    brand: {
      alt: "Pera Wallet",
      spriteId: "pera"
    },
    mobile: {
      androidId: "com.algorand.android",
      iosId: "id1459898525"
    },
    name: "Pera Wallet"
  },
  blocto: {
    brand: {
      alt: "Blocto Wallet",
      primaryColor: "#5E678A",
      spriteId: "blocto"
    },
    chainGroup: "blocto",
    group: "blocto",
    mobile: {
      androidId: "com.portto.blocto",
      iosId: "id1481181682"
    },
    name: "Blocto",
    shortName: "Blocto (Flow)"
  },
  solflare: {
    brand: {
      alt: "Solflare Wallet",
      primaryColor: "#FC7227",
      spriteId: "solflare"
    },
    chains: [
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "bhhhlbepdkbapadjdnnojkbgioiodbic"
    },
    filterFromWalletConnect: true,
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isSolflare",
            value: true
          }
        ],
        windowLocations: [
          "solflare"
        ]
      }
    ],
    mobile: {
      androidId: "com.solflare.mobile",
      inAppBrowser: "https://solflare.com/ul/v1/browse/{{encodedDappURI}}?ref={{encodedDappURI}}",
      inAppBrowserV2: "https://solflare.com/ul/v1/browse/{{encodedDappURI}}?ref={{encodedDappURI}}",
      iosId: "id1580902717"
    },
    name: "Solflare",
    walletConnect: {
      sdks: [
        "sign_v1"
      ]
    },
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  braavos: {
    brand: {
      alt: "Braavos Wallet",
      primaryColor: "#FABB38",
      spriteId: "braavos"
    },
    desktop: {
      chromeId: "jnlgamecbpmbajjfhmmmlhejkemejdma",
      edgeId: "hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      firefoxId: "braavos-wallet"
    },
    injectedConfig: [
      {
        chain: "starknet",
        extensionLocators: [],
        windowLocations: [
          "braavos"
        ]
      }
    ],
    mobile: {
      androidId: "app.braavos.wallet",
      inAppBrowser: "https://link.braavos.app/dapp/{{encodedDappURI}}",
      inAppBrowserV2: "https://link.braavos.app/dapp/{{encodedDappURI}}",
      iosId: "id1636013523"
    },
    name: "Braavos"
  },
  trust: {
    brand: {
      alt: "Trust Wallet",
      primaryColor: "#0500FF",
      spriteId: "7677b54f-3486-46e2-4e37-bf8747814f00"
    },
    chainGroup: "trust",
    chains: [
      "cosmos:cosmoshub-4",
      "cosmos:kava-4",
      "cosmos:thorchain-mainnet-v1",
      "eip155:1",
      "eip155:10",
      "eip155:100",
      "eip155:108",
      "eip155:1101",
      "eip155:128",
      "eip155:137",
      "eip155:2020",
      "eip155:288",
      "eip155:321",
      "eip155:324",
      "eip155:361",
      "eip155:42161",
      "eip155:42220",
      "eip155:43114",
      "eip155:4689",
      "eip155:56",
      "eip155:56288",
      "eip155:59144",
      "eip155:60",
      "eip155:80084",
      "eip155:80085",
      "eip155:820",
      "eip155:88",
      "eip155:9001",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "egjidjbpglichdcondbcbdnbeeppgdph"
    },
    eip6963Config: {
      rdns: "com.trustwallet.app"
    },
    filterFromWalletConnect: true,
    group: "trust",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isTrustWallet",
            value: true
          }
        ],
        windowLocations: [
          "trustWallet"
        ]
      }
    ],
    mobile: {
      androidId: "com.wallet.crypto.trustapp",
      inAppBrowserV2: "https://link.trustwallet.com/open_url?url={{encodedDappURI}}",
      iosId: "id1288339409",
      native: "trust://wc",
      universal: "https://link.trustwallet.com/wc"
    },
    name: "Trust",
    shortName: "Trust",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  rainbow: {
    brand: {
      alt: "Rainbow Wallet",
      primaryColor: "#001e59",
      spriteId: "rainbow"
    },
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:137",
      "eip155:42161",
      "eip155:56",
      "eip155:7777777",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453"
    ],
    desktop: {
      chromeId: "opfgelmcmbiajamepnmloijbpoleiama",
      edgeId: "cpojfbodiccabbabgimdeohkkpjfpbnf",
      firefoxId: "rainbow-extension"
    },
    eip6963Config: {
      rdns: "me.rainbow"
    },
    filterFromWalletConnect: true,
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isRainbow",
            value: true
          }
        ],
        windowLocations: [
          "rainbow"
        ]
      }
    ],
    mobile: {
      androidId: "me.rainbow",
      inAppBrowserV2: "rainbow://dapp?url={{encodedDappURI}}",
      iosId: "id1457119021",
      native: "rainbow://wc",
      universal: "https://rnbwapp.com/wc"
    },
    name: "Rainbow",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  dapper: {
    brand: {
      alt: "Dapper Wallet",
      primaryColor: "#762FBE",
      spriteId: "dapper"
    },
    mobile: {
      android: "fake-to-get-dapper-to-appear",
      ios: "fake-to-get-dapper-to-appear"
    },
    name: "Dapper"
  },
  glow: {
    brand: {
      alt: "Glow Wallet",
      spriteId: "glow"
    },
    desktop: {
      chromeId: "ojbcfhjmpigfobfclfflafhblgemeidi",
      edgeId: "niihfokdlimbddhfmngnplgfcgpmlido",
      firefoxId: "glow-solana-wallet"
    },
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isGlow",
            value: true
          }
        ],
        windowLocations: [
          "glowSolana"
        ]
      }
    ],
    name: "Glow"
  },
  lilico: {
    brand: {
      alt: "Lilico Wallet",
      spriteId: "lilico"
    },
    desktop: {
      chromeId: "hpclkefagolihohboafpheddmmgdffjm"
    },
    filterFromWalletConnect: true,
    name: "Lilico"
  },
  flowwalletflow: {
    brand: {
      alt: "Flow Wallet",
      spriteId: "flowwallet"
    },
    chainGroup: "flowwallet",
    desktop: {
      chromeId: "hpclkefagolihohboafpheddmmgdffjm"
    },
    filterFromWalletConnect: true,
    group: "flowwallet",
    name: "Flow Wallet"
  },
  magicemailotp: {
    brand: {
      alt: "Magic Email OTP",
      spriteId: "magiclink"
    },
    name: "Magic Email OTP"
  },
  magiclink: {
    brand: {
      alt: "Magic Link",
      spriteId: "magiclink"
    },
    name: "Magic Link"
  },
  magicsocial: {
    brand: {
      alt: "Magic Social",
      spriteId: "magiclink"
    },
    name: "Magic Social"
  },
  magiceden: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    eip6963Config: {
      rdns: "io.magiceden.wallet"
    },
    filterFromWalletConnect: true,
    group: "magiceden",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isMagicEden",
            value: true
          }
        ],
        windowLocations: [
          "magicEden.ethereum"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      inAppBrowser: "magiceden://browser",
      inAppBrowserV2: "magiceden://browser/{{encodedDappURI}}",
      iosId: "id6478631482",
      native: "magiceden://wc",
      universal: "https://magiceden.io/browser"
    },
    name: "Magic Eden"
  },
  magicedenbtc: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    group: "magiceden",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Magic Eden"
        },
        windowLocations: [
          "magicEden.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      inAppBrowser: "magiceden://browser/{{encodedDappURI}}",
      inAppBrowserV2: "magiceden://browser/{{encodedDappURI}}",
      iosId: "id6478631482",
      universal: "https://magiceden.io/browser/{{encodedDappURI}}"
    },
    mobileExperience: "in-app-browser",
    name: "Magic Eden",
    shortName: "Magic Eden (Bitcoin)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  magicedensol: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    group: "magiceden",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isMagicEden",
            value: true
          }
        ],
        windowLocations: [
          "magicEden.solana"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      inAppBrowser: "magiceden://browser/{{encodedDappURI}}",
      inAppBrowserV2: "magiceden://browser/{{encodedDappURI}}",
      iosId: "id6478631482",
      universal: "https://magiceden.io/browser/{{encodedDappURI}}"
    },
    name: "Magic Eden",
    shortName: "Magic Eden (Solana)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  exodus: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "4c16cad4-cac9-4643-6726-c696efaf5200"
    },
    chainGroup: "exodus",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56",
      "eip155:80084",
      "eip155:80085",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    filterFromWalletConnect: true,
    group: "exodus",
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc",
      universal: "https://exodus.com/m/wc"
    },
    name: "Exodus",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  exodusevm: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    chainGroup: "exodus",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    eip6963Config: {
      rdns: "com.exodus.web3-wallet"
    },
    filterFromWalletConnect: true,
    group: "exodus",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isExodus",
            value: true
          }
        ]
      }
    ],
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc"
    },
    name: "Exodus",
    shortName: "Exodus Wallet (EVM)",
    walletConnect: {
      sdks: [
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  exodussol: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    chainGroup: "exodus",
    chains: [
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    group: "exodus",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isExodus",
            value: true
          }
        ],
        windowLocations: [
          "exodus.solana"
        ]
      }
    ],
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc"
    },
    name: "Exodus",
    shortName: "Exodus Wallet (Solana)",
    walletConnect: {
      sdks: [
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  okxwallet: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    chains: [
      "bip122:000000000019d6689c085ae165831e93",
      "bip122:000000000933ea01ad0ee984209779ba",
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56",
      "eip155:66",
      "eip155:80084",
      "eip155:80085",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    eip6963Config: {
      rdns: "com.okex.wallet"
    },
    filterFromWalletConnect: true,
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isOKExWallet",
            value: true
          },
          {
            flag: "isOkxWallet",
            value: true
          }
        ],
        windowLocations: [
          "okxwallet"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      inAppBrowserV2: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470",
      native: "okex://main/wc"
    },
    name: "OKX Wallet",
    shortName: "OKX Wallet",
    walletConnect: {
      sdks: [
        "sign_v2"
      ]
    }
  },
  backpack: {
    brand: {
      alt: "Backpack",
      primaryColor: "#e43c3c",
      spriteId: "backpack"
    },
    chainGroup: "backpack",
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:10143",
      "eip155:137",
      "eip155:42161",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "aflkmfhebedbjioipglgcbcmnbpgliof"
    },
    eip6963Config: {
      rdns: "app.backpack"
    },
    filterFromWalletConnect: true,
    group: "backpack",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isBackpack",
            value: true
          }
        ],
        windowLocations: []
      }
    ],
    mobile: {
      androidId: "app.backpack.mobile",
      iosId: "id6445964121",
      native: "backpack://wc"
    },
    name: "Backpack",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  okxwalletbtc: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "okxwallet.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      inAppBrowserV2: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470"
    },
    mobileExperience: "in-app-browser",
    name: "OKX Wallet",
    shortName: "OKX Wallet (Bitcoin)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  unisat: {
    brand: {
      alt: "UniSat",
      spriteId: "unisat"
    },
    desktop: {
      chromeId: "ppbibelpcjmhbdihakflkdcoccbgbkpo"
    },
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "unisat"
        ]
      }
    ],
    name: "UniSat"
  },
  unknown: {
    brand: {
      spriteId: "unknown-wallet"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1234567890"
    },
    name: "Unknown Wallet",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  xverse: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    chainGroup: "xverse",
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    group: "xverse",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Xverse",
          providerId: "XverseProviders.BitcoinProvider"
        },
        windowLocations: [
          "XverseProviders.BitcoinProvider"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      inAppBrowserV2: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    name: "Xverse",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  fallbackconnector: {
    brand: {
      spriteId: "unknown-wallet"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1234567890"
    },
    name: "Fallback Connector",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  oylwallet: {
    brand: {
      alt: "Oyl Wallet",
      spriteId: "oyl"
    },
    desktop: {
      chromeId: "ilolmnhjbbggkmopnemiphomhaojndmb"
    },
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "oyl"
        ]
      }
    ],
    name: "Oyl Wallet"
  },
  abstract: {
    brand: {
      alt: "Abstract",
      spriteId: "abstract"
    },
    chains: [
      "eip155:11124",
      "eip155:2741"
    ],
    desktop: {
      universal: "https://portal.abs.xyz/profile"
    },
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: []
      }
    ],
    name: "Abstract",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  edenonline: {
    brand: {
      alt: "Eden Online",
      spriteId: "edenonline"
    },
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: []
      }
    ],
    name: "Eden Online"
  },
  onekeybtc: {
    brand: {
      alt: "OneKey Wallet",
      spriteId: "onekey"
    },
    chainGroup: "onekey",
    desktop: {
      chromeId: "jnmbobjmhlngoefaiojfljckilhhlhcj"
    },
    group: "onekey",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "$onekey.btc"
        ]
      }
    ],
    mobile: {
      androidId: "so.onekey.app.wallet",
      iosId: "id1609559473"
    },
    mobileExperience: "in-app-browser",
    name: "OneKey"
  },
  intersend: {
    brand: {
      alt: "Intersend",
      spriteId: "intersend"
    },
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: []
      }
    ],
    name: "Intersend"
  },
  okxeclipse: {
    brand: {
      alt: "OKX Wallet",
      primaryColor: "#FABB38",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "eclipse",
        extensionLocators: [
          {
            flag: "isOKExWallet",
            value: true
          },
          {
            flag: "isOkxWallet",
            value: true
          }
        ],
        windowLocations: [
          "okxwallet.solana"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      inAppBrowserV2: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470"
    },
    name: "OKX Wallet"
  },
  dynamicwaas: {
    brand: {
      alt: "Dynamic Waas",
      primaryColor: "#4779ff",
      spriteId: "dynamicwaas"
    },
    name: "Dynamic Waas"
  },
  nightlyeclipse: {
    brand: {
      alt: "Nightly Wallet",
      spriteId: "nightly"
    },
    chainGroup: "nightly",
    desktop: {
      chromeId: "fiikommddbeccaoicoejoniammnalkfa",
      edgeId: "fiikommddbeccaoicoejoniammnalkfa",
      operaId: "fiikommddbeccaoicoejoniammnalkfa"
    },
    group: "nightly",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "eclipse",
        extensionLocators: [],
        walletStandard: {
          features: [
            "standard:connect",
            "standard:disconnect",
            "solana:signMessage",
            "solana:signTransaction",
            "solana:signAndSendTransaction"
          ],
          name: "Nightly"
        }
      }
    ],
    name: "Nightly"
  },
  bitgetwalletbtc: {
    brand: {
      alt: "Bitget Wallet",
      spriteId: "bitgetwallet"
    },
    chainGroup: "bitgetwallet",
    group: "bitgetwallet",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "bitkeep.unisat"
        ]
      }
    ],
    mobile: {
      androidId: "com.bitkeep.wallet",
      inAppBrowser: "https://bkcode.vip?action=dapp&url={{encodedDappURI}}",
      inAppBrowserV2: "https://bkcode.vip?action=dapp&url={{encodedDappURI}}",
      iosId: "id1395301115"
    },
    name: "Bitget Wallet"
  },
  backpackeclipse: {
    brand: {
      alt: "Backpack",
      primaryColor: "#e43c3c",
      spriteId: "backpack"
    },
    chainGroup: "backpack",
    desktop: {
      chromeId: "aflkmfhebedbjioipglgcbcmnbpgliof"
    },
    group: "backpack",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "eclipse",
        extensionLocators: [
          {
            flag: "isBackpack",
            value: true
          }
        ],
        windowLocations: [
          "backpack"
        ]
      }
    ],
    mobile: {
      androidId: "app.backpack.mobile",
      inAppBrowser: "backpack://ul/v1/browse/{{encodedDappURI}}",
      inAppBrowserV2: "backpack://ul/v1/browse/{{encodedDappURI}}",
      iosId: "id6445964121"
    },
    mobileExperience: "in-app-browser",
    name: "Backpack"
  },
  binancewalletbtc: {
    brand: {
      alt: "Binance Wallet",
      spriteId: "binance"
    },
    chainGroup: "binance",
    group: "binance",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "binancew3w.bitcoin"
        ]
      }
    ],
    name: "Binance Wallet",
    shortName: "Binance"
  },
  xversestarknet: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    chainGroup: "xverse",
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    group: "xverse",
    injectedConfig: [
      {
        chain: "starknet",
        extensionLocators: [],
        windowLocations: [
          "xverse"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      inAppBrowserV2: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    name: "Xverse"
  },
  xversespark: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    chainGroup: "xverse",
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    group: "xverse",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "spark",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Xverse",
          providerId: "XverseProviders.SparkProvider"
        },
        windowLocations: [
          "XverseProviders.SparkProvider"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      inAppBrowserV2: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    mobileExperience: "in-app-browser",
    name: "Xverse",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  turnkey: {
    brand: {
      alt: "Turnkey Wallet",
      spriteId: "turnkey"
    },
    name: "Turnkey"
  },
  turnkeyhd: {
    brand: {
      alt: "Turnkey Wallet",
      spriteId: "turnkey"
    },
    name: "Turnkey HD"
  }
};
var walletBookFallbacks = {
  groups,
  wallets
};

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse2,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version5
});

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name2, initializer3, params) {
  function init(inst, def) {
    var _a5;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a5 = inst._zod).traits ?? (_a5.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name2);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name2 });
  function _(def) {
    var _a5;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a5 = inst._zod).deferred ?? (_a5.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a5, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a5 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a5.traits) == null ? void 0 : _b.has(name2);
    }
  });
  Object.defineProperty(_, "name", { value: name2 });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object3, key, getter) {
  const set = false;
  Object.defineProperty(object3, key, {
    get() {
      if (!set) {
        const value = getter();
        object3[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  var _a5;
  if (typeof navigator !== "undefined" && ((_a5 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a5.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class3, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class3 ? new Class3({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class3 ? new Class3({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class3, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class3({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class3({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  var _a5;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a5 = x.issues[i]) == null ? void 0 : _a5.continue) !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a5;
    (_a5 = iss).path ?? (_a5.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config3) {
  var _a5, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a5 = iss.inst) == null ? void 0 : _a5._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config3.customError) == null ? void 0 : _e.call(config3, iss)) ?? unwrapMessage((_f = config3.localeError) == null ? void 0 : _f.call(config3, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error79, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error79.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error79, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error80) => {
    for (const issue3 of error80.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error79);
  return fieldErrors;
}
function treeifyError(error79, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error80, path = []) => {
    var _a5, _b;
    for (const issue3 of error80.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a5 = curr.properties)[el] ?? (_a5[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error79);
  return result;
}
function toDotPath(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error79) {
  var _a5;
  const lines = [];
  const issues = [...error79.issues].sort((a, b) => a.path.length - b.path.length);
  for (const issue3 of issues) {
    lines.push(`âœ– ${issue3.message}`);
    if ((_a5 = issue3.path) == null ? void 0 : _a5.length)
      lines.push(`  â†’ at ${toDotPath(issue3.path)}`);
  }
  return lines.join("\n");
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
var parse2 = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version10) => {
  if (!version10)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version10}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a5;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a5 = inst._zod).onattach ?? (_a5.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a5;
    (_a5 = inst2._zod.bag).multipleOf ?? (_a5.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a5 = def.format) == null ? void 0 : _a5.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a5, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a5 = inst._zod).check ?? (_a5.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/versions.js
var version5 = {
  major: 4,
  minor: 0,
  patch: 5
};

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a6;
  var _a5;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version5;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a5 = inst._zod).deferred ?? (_a5.deferred = []);
    (_a6 = inst._zod.deferred) == null ? void 0 : _a6.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a7;
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: (_a7 = r.error) == null ? void 0 : _a7.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => {
          var _a8;
          return r.success ? { value: r.data } : { issues: (_a8 = r.error) == null ? void 0 : _a8.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  var _a5;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a5 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a5.patterns) ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval3 = allowsEval;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    var _a5;
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = (_a5 = o._zod.propValues) == null ? void 0 : _a5[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "Ø­Ø±Ù", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
    file: { unit: "Ø¨Ø§ÙŠØª", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
    array: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
    set: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ù…Ø¯Ø®Ù„",
    email: "Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
    url: "Ø±Ø§Ø¨Ø·",
    emoji: "Ø¥ÙŠÙ…ÙˆØ¬ÙŠ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ØªØ§Ø±ÙŠØ® ÙˆÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    date: "ØªØ§Ø±ÙŠØ® Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    time: "ÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    duration: "Ù…Ø¯Ø© Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    ipv4: "Ø¹Ù†ÙˆØ§Ù† IPv4",
    ipv6: "Ø¹Ù†ÙˆØ§Ù† IPv6",
    cidrv4: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv4",
    cidrv6: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv6",
    base64: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64-encoded",
    base64url: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64url-encoded",
    json_string: "Ù†ÙŽØµ Ø¹Ù„Ù‰ Ù‡ÙŠØ¦Ø© JSON",
    e164: "Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¨Ù…Ø¹ÙŠØ§Ø± E.164",
    jwt: "JWT",
    template_literal: "Ù…Ø¯Ø®Ù„"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${issue3.expected}ØŒ ÙˆÙ„ÙƒÙ† ØªÙ… Ø¥Ø¯Ø®Ø§Ù„ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${stringifyPrimitive(issue3.values[0])}`;
        return `Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØªÙˆÙ‚Ø¹ Ø§Ù†ØªÙ‚Ø§Ø¡ Ø£Ø­Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${issue3.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±"}`;
        return `Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${issue3.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${issue3.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${issue3.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù‘ÙŽÙ† "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ù†Ù…Ø· ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„`;
      }
      case "not_multiple_of":
        return `Ø±Ù‚Ù… ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Ù…Ø¹Ø±Ù${issue3.keys.length > 1 ? "Ø§Øª" : ""} ØºØ±ÙŠØ¨${issue3.keys.length > 1 ? "Ø©" : ""}: ${joinValues(issue3.keys, "ØŒ ")}`;
      case "invalid_key":
        return `Ù…Ø¹Ø±Ù ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${issue3.origin}`;
      case "invalid_union":
        return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„";
      case "invalid_element":
        return `Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${issue3.origin}`;
      default:
        return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalÄ±dÄ±r" },
    file: { unit: "bayt", verb: "olmalÄ±dÄ±r" },
    array: { unit: "element", verb: "olmalÄ±dÄ±r" },
    set: { unit: "element", verb: "olmalÄ±dÄ±r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${issue3.expected}, daxil olan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${stringifyPrimitive(issue3.values[0])}`;
        return `YanlÄ±ÅŸ seÃ§im: aÅŸaÄŸÄ±dakÄ±lardan biri olmalÄ±dÄ±r: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${issue3.origin ?? "dÉ™yÉ™r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${issue3.origin ?? "dÉ™yÉ™r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `YanlÄ±ÅŸ mÉ™tn: "${_issue.prefix}" ilÉ™ baÅŸlamalÄ±dÄ±r`;
        if (_issue.format === "ends_with")
          return `YanlÄ±ÅŸ mÉ™tn: "${_issue.suffix}" ilÉ™ bitmÉ™lidir`;
        if (_issue.format === "includes")
          return `YanlÄ±ÅŸ mÉ™tn: "${_issue.includes}" daxil olmalÄ±dÄ±r`;
        if (_issue.format === "regex")
          return `YanlÄ±ÅŸ mÉ™tn: ${_issue.pattern} ÅŸablonuna uyÄŸun olmalÄ±dÄ±r`;
        return `YanlÄ±ÅŸ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `YanlÄ±ÅŸ É™dÉ™d: ${issue3.divisor} ilÉ™ bÃ¶lÃ¼nÉ™ bilÉ™n olmalÄ±dÄ±r`;
      case "unrecognized_keys":
        return `TanÄ±nmayan aÃ§ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilindÉ™ yanlÄ±ÅŸ aÃ§ar`;
      case "invalid_union":
        return "YanlÄ±ÅŸ dÉ™yÉ™r";
      case "invalid_element":
        return `${issue3.origin} daxilindÉ™ yanlÄ±ÅŸ dÉ™yÉ™r`;
      default:
        return `YanlÄ±ÅŸ dÉ™yÉ™r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "ÑÑ–Ð¼Ð²Ð°Ð»",
        few: "ÑÑ–Ð¼Ð²Ð°Ð»Ñ‹",
        many: "ÑÑ–Ð¼Ð²Ð°Ð»Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    },
    array: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    },
    set: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    },
    file: {
      unit: {
        one: "Ð±Ð°Ð¹Ñ‚",
        few: "Ð±Ð°Ð¹Ñ‚Ñ‹",
        many: "Ð±Ð°Ð¹Ñ‚Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ð»Ñ–Ðº";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÑ–Ñž";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ÑƒÐ²Ð¾Ð´",
    email: "email Ð°Ð´Ñ€Ð°Ñ",
    url: "URL",
    emoji: "ÑÐ¼Ð¾Ð´Ð·Ñ–",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚Ð° Ñ– Ñ‡Ð°Ñ",
    date: "ISO Ð´Ð°Ñ‚Ð°",
    time: "ISO Ñ‡Ð°Ñ",
    duration: "ISO Ð¿Ñ€Ð°Ñ†ÑÐ³Ð»Ð°ÑÑ†ÑŒ",
    ipv4: "IPv4 Ð°Ð´Ñ€Ð°Ñ",
    ipv6: "IPv6 Ð°Ð´Ñ€Ð°Ñ",
    cidrv4: "IPv4 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
    cidrv6: "IPv6 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
    base64: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64",
    base64url: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64url",
    json_string: "JSON Ñ€Ð°Ð´Ð¾Ðº",
    e164: "Ð½ÑƒÐ¼Ð°Ñ€ E.164",
    jwt: "JWT",
    template_literal: "ÑƒÐ²Ð¾Ð´"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°ÑžÑÑ ${issue3.expected}, Ð°Ñ‚Ñ€Ñ‹Ð¼Ð°Ð½Ð° ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ ${stringifyPrimitive(issue3.values[0])}`;
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð²Ð°Ñ€Ñ‹ÑÐ½Ñ‚: Ñ‡Ð°ÐºÐ°ÑžÑÑ Ð°Ð´Ð·Ñ–Ð½ Ð· ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð¿Ð°Ñ‡Ñ‹Ð½Ð°Ñ†Ñ†Ð° Ð· "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð°ÐºÐ°Ð½Ñ‡Ð²Ð°Ñ†Ñ†Ð° Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð¼ÑÑˆÑ‡Ð°Ñ†ÑŒ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð°Ð´Ð¿Ð°Ð²ÑÐ´Ð°Ñ†ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð»Ñ–Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð±Ñ‹Ñ†ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð°ÑÐ¿Ð°Ð·Ð½Ð°Ð½Ñ‹ ${issue3.keys.length > 1 ? "ÐºÐ»ÑŽÑ‡Ñ‹" : "ÐºÐ»ÑŽÑ‡"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue3.origin}`;
      case "invalid_union":
        return "ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´";
      case "invalid_element":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ð°Ðµ Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ Ñž ${issue3.origin}`;
      default:
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "carÃ cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreÃ§a electrÃ²nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreÃ§a IPv4",
    ipv6: "adreÃ§a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nÃºmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus invÃ lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType7(issue3.input)}`;
      // return `Tipus invÃ lid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor invÃ lid: s'esperava ${stringifyPrimitive(issue3.values[0])}`;
        return `OpciÃ³ invÃ lida: s'esperava una de ${joinValues(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a mÃ xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} continguÃ©s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a mÃ­nim" : "mÃ©s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} continguÃ©s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format invÃ lid: ha de comenÃ§ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invÃ lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invÃ lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invÃ lid: ha de coincidir amb el patrÃ³ ${_issue.pattern}`;
        return `Format invÃ lid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NÃºmero invÃ lid: ha de ser mÃºltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau invÃ lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invÃ lida";
      // Could also be "Tipus d'uniÃ³ invÃ lid" but "Entrada invÃ lida" is more general
      case "invalid_element":
        return `Element invÃ lid a ${issue3.origin}`;
      default:
        return `Entrada invÃ lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znakÅ¯", verb: "mÃ­t" },
    file: { unit: "bajtÅ¯", verb: "mÃ­t" },
    array: { unit: "prvkÅ¯", verb: "mÃ­t" },
    set: { unit: "prvkÅ¯", verb: "mÃ­t" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "ÄÃ­slo";
      }
      case "string": {
        return "Å™etÄ›zec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulÃ¡rnÃ­ vÃ½raz",
    email: "e-mailovÃ¡ adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a Äas ve formÃ¡tu ISO",
    date: "datum ve formÃ¡tu ISO",
    time: "Äas ve formÃ¡tu ISO",
    duration: "doba trvÃ¡nÃ­ ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64",
    base64url: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64url",
    json_string: "Å™etÄ›zec ve formÃ¡tu JSON",
    e164: "ÄÃ­slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${issue3.expected}, obdrÅ¾eno ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${stringifyPrimitive(issue3.values[0])}`;
        return `NeplatnÃ¡ moÅ¾nost: oÄekÃ¡vÃ¡na jedna z hodnot ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ mÃ­t ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvkÅ¯"}`;
        }
        return `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ bÃ½t ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ mÃ­t ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvkÅ¯"}`;
        }
        return `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ bÃ½t ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ zaÄÃ­nat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ konÄit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ odpovÃ­dat vzoru ${_issue.pattern}`;
        return `NeplatnÃ½ formÃ¡t ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NeplatnÃ© ÄÃ­slo: musÃ­ bÃ½t nÃ¡sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `NeznÃ¡mÃ© klÃ­Äe: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `NeplatnÃ½ klÃ­Ä v ${issue3.origin}`;
      case "invalid_union":
        return "NeplatnÃ½ vstup";
      case "invalid_element":
        return `NeplatnÃ¡ hodnota v ${issue3.origin}`;
      default:
        return `NeplatnÃ½ vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/de.js
var error6 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `UngÃ¼ltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `UngÃ¼ltige Eingabe: erwartet ${stringifyPrimitive(issue3.values[0])}`;
        return `UngÃ¼ltige Option: erwartet eine von ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu groÃŸ: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groÃŸ: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `UngÃ¼ltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `UngÃ¼ltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `UngÃ¼ltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `UngÃ¼ltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `UngÃ¼ltig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `UngÃ¼ltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte SchlÃ¼ssel" : "Unbekannter SchlÃ¼ssel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `UngÃ¼ltiger SchlÃ¼ssel in ${issue3.origin}`;
      case "invalid_union":
        return "UngÃ¼ltige Eingabe";
      case "invalid_element":
        return `UngÃ¼ltiger Wert in ${issue3.origin}`;
      default:
        return `UngÃ¼ltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error6()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error7 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error7()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoÄio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daÅ­ro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiÄis ${issue3.expected}, riceviÄis ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendiÄis ${stringifyPrimitive(issue3.values[0])}`;
        return `Nevalida opcio: atendiÄis unu el ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendiÄis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiÄis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendiÄis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiÄis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciÄi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiÄi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} Ålosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida Ålosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error8()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/es.js
var error9 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nÃºmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcciÃ³n de correo electrÃ³nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraciÃ³n ISO",
    ipv4: "direcciÃ³n IPv4",
    ipv6: "direcciÃ³n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nÃºmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada invÃ¡lida: se esperaba ${issue3.expected}, recibido ${parsedType7(issue3.input)}`;
      // return `Entrada invÃ¡lida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada invÃ¡lida: se esperaba ${stringifyPrimitive(issue3.values[0])}`;
        return `OpciÃ³n invÃ¡lida: se esperaba una de ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue3.origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue3.origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Demasiado pequeÃ±o: se esperaba que ${issue3.origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeÃ±o: se esperaba que ${issue3.origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena invÃ¡lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invÃ¡lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invÃ¡lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invÃ¡lida: debe coincidir con el patrÃ³n ${_issue.pattern}`;
        return `InvÃ¡lido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NÃºmero invÃ¡lido: debe ser mÃºltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave invÃ¡lida en ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invÃ¡lida";
      case "invalid_element":
        return `Valor invÃ¡lido en ${issue3.origin}`;
      default:
        return `Entrada invÃ¡lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error9()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/fa.js
var error10 = () => {
  const Sizable = {
    string: { unit: "Ú©Ø§Ø±Ø§Ú©ØªØ±", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
    file: { unit: "Ø¨Ø§ÛŒØª", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
    array: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
    set: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ø¹Ø¯Ø¯";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ø¢Ø±Ø§ÛŒÙ‡";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ÙˆØ±ÙˆØ¯ÛŒ",
    email: "Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„",
    url: "URL",
    emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ØªØ§Ø±ÛŒØ® Ùˆ Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
    date: "ØªØ§Ø±ÛŒØ® Ø§ÛŒØ²Ùˆ",
    time: "Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
    duration: "Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
    ipv4: "IPv4 Ø¢Ø¯Ø±Ø³",
    ipv6: "IPv6 Ø¢Ø¯Ø±Ø³",
    cidrv4: "IPv4 Ø¯Ø§Ù…Ù†Ù‡",
    cidrv6: "IPv6 Ø¯Ø§Ù…Ù†Ù‡",
    base64: "base64-encoded Ø±Ø´ØªÙ‡",
    base64url: "base64url-encoded Ø±Ø´ØªÙ‡",
    json_string: "JSON Ø±Ø´ØªÙ‡",
    e164: "E.164 Ø¹Ø¯Ø¯",
    jwt: "JWT",
    template_literal: "ÙˆØ±ÙˆØ¯ÛŒ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${issue3.expected} Ù…ÛŒâ€ŒØ¨ÙˆØ¯ØŒ ${parsedType7(issue3.input)} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${stringifyPrimitive(issue3.values[0])} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`;
        }
        return `Ú¯Ø²ÛŒÙ†Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ÛŒÚ©ÛŒ Ø§Ø² ${joinValues(issue3.values, "|")} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${issue3.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±"} Ø¨Ø§Ø´Ø¯`;
        }
        return `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${issue3.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} Ø¨Ø§Ø´Ø¯`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} ${sizing.unit} Ø¨Ø§Ø´Ø¯`;
        }
        return `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} Ø¨Ø§Ø´Ø¯`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${_issue.prefix}" Ø´Ø±ÙˆØ¹ Ø´ÙˆØ¯`;
        }
        if (_issue.format === "ends_with") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${_issue.suffix}" ØªÙ…Ø§Ù… Ø´ÙˆØ¯`;
        }
        if (_issue.format === "includes") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ "${_issue.includes}" Ø¨Ø§Ø´Ø¯`;
        }
        if (_issue.format === "regex") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ø§Ù„Ú¯ÙˆÛŒ ${_issue.pattern} Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
      }
      case "not_multiple_of":
        return `Ø¹Ø¯Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ù…Ø¶Ø±Ø¨ ${issue3.divisor} Ø¨Ø§Ø´Ø¯`;
      case "unrecognized_keys":
        return `Ú©Ù„ÛŒØ¯${issue3.keys.length > 1 ? "Ù‡Ø§ÛŒ" : ""} Ù†Ø§Ø´Ù†Ø§Ø³: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ú©Ù„ÛŒØ¯ Ù†Ø§Ø´Ù†Ø§Ø³ Ø¯Ø± ${issue3.origin}`;
      case "invalid_union":
        return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
      case "invalid_element":
        return `Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¯Ø± ${issue3.origin}`;
      default:
        return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
    }
  };
};
function fa_default() {
  return {
    localeError: error10()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/fi.js
var error11 = () => {
  const Sizable = {
    string: { unit: "merkkiÃ¤", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "sÃ¤Ã¤nnÃ¶llinen lauseke",
    email: "sÃ¤hkÃ¶postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen syÃ¶te: tÃ¤ytyy olla ${stringifyPrimitive(issue3.values[0])}`;
        return `Virheellinen valinta: tÃ¤ytyy olla yksi seuraavista: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tÃ¤ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tÃ¤ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tÃ¤ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tÃ¤ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen syÃ¶te: tÃ¤ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syÃ¶te: tÃ¤ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syÃ¶te: tÃ¤ytyy sisÃ¤ltÃ¤Ã¤ "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syÃ¶te: tÃ¤ytyy vastata sÃ¤Ã¤nnÃ¶llistÃ¤ lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tÃ¤ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syÃ¶te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error11()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/fr.js
var error12 = () => {
  const Sizable = {
    string: { unit: "caractÃ¨res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "Ã©lÃ©ments", verb: "avoir" },
    set: { unit: "Ã©lÃ©ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrÃ©e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durÃ©e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaÃ®ne encodÃ©e en base64",
    base64url: "chaÃ®ne encodÃ©e en base64url",
    json_string: "chaÃ®ne JSON",
    e164: "numÃ©ro E.164",
    jwt: "JWT",
    template_literal: "entrÃ©e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `EntrÃ©e invalide : ${issue3.expected} attendu, ${parsedType7(issue3.input)} reÃ§u`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `EntrÃ©e invalide : ${stringifyPrimitive(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ã©lÃ©ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit Ãªtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit Ãªtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ChaÃ®ne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ChaÃ®ne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ChaÃ®ne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ChaÃ®ne invalide : doit correspondre au modÃ¨le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit Ãªtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ClÃ©${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ClÃ© invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "EntrÃ©e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `EntrÃ©e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error12()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/fr-CA.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caractÃ¨res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "Ã©lÃ©ments", verb: "avoir" },
    set: { unit: "Ã©lÃ©ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrÃ©e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durÃ©e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaÃ®ne encodÃ©e en base64",
    base64url: "chaÃ®ne encodÃ©e en base64url",
    json_string: "chaÃ®ne JSON",
    e164: "numÃ©ro E.164",
    jwt: "JWT",
    template_literal: "entrÃ©e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `EntrÃ©e invalide : attendu ${issue3.expected}, reÃ§u ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `EntrÃ©e invalide : attendu ${stringifyPrimitive(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "â‰¤" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "â‰¥" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ChaÃ®ne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ChaÃ®ne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ChaÃ®ne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ChaÃ®ne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit Ãªtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ClÃ©${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ClÃ© invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "EntrÃ©e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `EntrÃ©e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error13()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/he.js
var error14 = () => {
  const Sizable = {
    string: { unit: "××•×ª×™×•×ª", verb: "×œ×›×œ×•×œ" },
    file: { unit: "×‘×™×™×˜×™×", verb: "×œ×›×œ×•×œ" },
    array: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" },
    set: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "×§×œ×˜",
    email: "×›×ª×•×‘×ª ××™×ž×™×™×œ",
    url: "×›×ª×•×‘×ª ×¨×©×ª",
    emoji: "××™×ž×•×’'×™",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "×ª××¨×™×š ×•×–×ž×Ÿ ISO",
    date: "×ª××¨×™×š ISO",
    time: "×–×ž×Ÿ ISO",
    duration: "×ž×©×š ×–×ž×Ÿ ISO",
    ipv4: "×›×ª×•×‘×ª IPv4",
    ipv6: "×›×ª×•×‘×ª IPv6",
    cidrv4: "×˜×•×•×— IPv4",
    cidrv6: "×˜×•×•×— IPv6",
    base64: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64",
    base64url: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64 ×œ×›×ª×•×‘×•×ª ×¨×©×ª",
    json_string: "×ž×—×¨×•×–×ª JSON",
    e164: "×ž×¡×¤×¨ E.164",
    jwt: "JWT",
    template_literal: "×§×œ×˜"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${issue3.expected}, ×”×ª×§×‘×œ ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${stringifyPrimitive(issue3.values[0])}`;
        return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ××—×ª ×ž×”××¤×©×¨×•×™×•×ª  ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `×’×“×•×œ ×ž×“×™: ${issue3.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `×’×“×•×œ ×ž×“×™: ${issue3.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `×§×˜×Ÿ ×ž×“×™: ${issue3.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `×§×˜×Ÿ ×ž×“×™: ${issue3.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª×—×™×œ ×‘"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×¡×ª×™×™× ×‘ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×›×œ×•×œ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª××™× ×œ×ª×‘× ×™×ª ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} ×œ× ×ª×§×™×Ÿ`;
      }
      case "not_multiple_of":
        return `×ž×¡×¤×¨ ×œ× ×ª×§×™×Ÿ: ×—×™×™×‘ ×œ×”×™×•×ª ×ž×›×¤×œ×” ×©×œ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `×ž×¤×ª×—${issue3.keys.length > 1 ? "×•×ª" : ""} ×œ× ×ž×–×•×”${issue3.keys.length > 1 ? "×™×" : "×”"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `×ž×¤×ª×— ×œ× ×ª×§×™×Ÿ ×‘${issue3.origin}`;
      case "invalid_union":
        return "×§×œ×˜ ×œ× ×ª×§×™×Ÿ";
      case "invalid_element":
        return `×¢×¨×š ×œ× ×ª×§×™×Ÿ ×‘${issue3.origin}`;
      default:
        return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ`;
    }
  };
};
function he_default() {
  return {
    localeError: error14()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/hu.js
var error15 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szÃ¡m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tÃ¶mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cÃ­m",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idÅ‘bÃ©lyeg",
    date: "ISO dÃ¡tum",
    time: "ISO idÅ‘",
    duration: "ISO idÅ‘intervallum",
    ipv4: "IPv4 cÃ­m",
    ipv6: "IPv6 cÃ­m",
    cidrv4: "IPv4 tartomÃ¡ny",
    cidrv6: "IPv6 tartomÃ¡ny",
    base64: "base64-kÃ³dolt string",
    base64url: "base64url-kÃ³dolt string",
    json_string: "JSON string",
    e164: "E.164 szÃ¡m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${issue3.expected}, a kapott Ã©rtÃ©k ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${stringifyPrimitive(issue3.values[0])}`;
        return `Ã‰rvÃ©nytelen opciÃ³: valamelyik Ã©rtÃ©k vÃ¡rt ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `TÃºl nagy: ${issue3.origin ?? "Ã©rtÃ©k"} mÃ©rete tÃºl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `TÃºl nagy: a bemeneti Ã©rtÃ©k ${issue3.origin ?? "Ã©rtÃ©k"} tÃºl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${issue3.origin} mÃ©rete tÃºl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${issue3.origin} tÃºl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ã‰rvÃ©nytelen string: "${_issue.prefix}" Ã©rtÃ©kkel kell kezdÅ‘dnie`;
        if (_issue.format === "ends_with")
          return `Ã‰rvÃ©nytelen string: "${_issue.suffix}" Ã©rtÃ©kkel kell vÃ©gzÅ‘dnie`;
        if (_issue.format === "includes")
          return `Ã‰rvÃ©nytelen string: "${_issue.includes}" Ã©rtÃ©ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Ã‰rvÃ©nytelen string: ${_issue.pattern} mintÃ¡nak kell megfelelnie`;
        return `Ã‰rvÃ©nytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ã‰rvÃ©nytelen szÃ¡m: ${issue3.divisor} tÃ¶bbszÃ¶rÃ¶sÃ©nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ã‰rvÃ©nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "Ã‰rvÃ©nytelen bemenet";
      case "invalid_element":
        return `Ã‰rvÃ©nytelen Ã©rtÃ©k: ${issue3.origin}`;
      default:
        return `Ã‰rvÃ©nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error15()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/id.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error16()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/it.js
var error17 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType7(issue3.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error17()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ja.js
var error18 = () => {
  const Sizable = {
    string: { unit: "æ–‡å­—", verb: "ã§ã‚ã‚‹" },
    file: { unit: "ãƒã‚¤ãƒˆ", verb: "ã§ã‚ã‚‹" },
    array: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" },
    set: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "æ•°å€¤";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "é…åˆ—";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "å…¥åŠ›å€¤",
    email: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
    url: "URL",
    emoji: "çµµæ–‡å­—",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISOæ—¥æ™‚",
    date: "ISOæ—¥ä»˜",
    time: "ISOæ™‚åˆ»",
    duration: "ISOæœŸé–“",
    ipv4: "IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹",
    ipv6: "IPv6ã‚¢ãƒ‰ãƒ¬ã‚¹",
    cidrv4: "IPv4ç¯„å›²",
    cidrv6: "IPv6ç¯„å›²",
    base64: "base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—",
    base64url: "base64urlã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—",
    json_string: "JSONæ–‡å­—åˆ—",
    e164: "E.164ç•ªå·",
    jwt: "JWT",
    template_literal: "å…¥åŠ›å€¤"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ç„¡åŠ¹ãªå…¥åŠ›: ${issue3.expected}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸãŒã€${parsedType7(issue3.input)}ãŒå…¥åŠ›ã•ã‚Œã¾ã—ãŸ`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ç„¡åŠ¹ãªå…¥åŠ›: ${stringifyPrimitive(issue3.values[0])}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸ`;
        return `ç„¡åŠ¹ãªé¸æŠž: ${joinValues(issue3.values, "ã€")}ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      case "too_big": {
        const adj = issue3.inclusive ? "ä»¥ä¸‹ã§ã‚ã‚‹" : "ã‚ˆã‚Šå°ã•ã„";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `å¤§ãã™ãŽã‚‹å€¤: ${issue3.origin ?? "å€¤"}ã¯${issue3.maximum.toString()}${sizing.unit ?? "è¦ç´ "}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        return `å¤§ãã™ãŽã‚‹å€¤: ${issue3.origin ?? "å€¤"}ã¯${issue3.maximum.toString()}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "ä»¥ä¸Šã§ã‚ã‚‹" : "ã‚ˆã‚Šå¤§ãã„";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `å°ã•ã™ãŽã‚‹å€¤: ${issue3.origin}ã¯${issue3.minimum.toString()}${sizing.unit}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        return `å°ã•ã™ãŽã‚‹å€¤: ${issue3.origin}ã¯${issue3.minimum.toString()}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.prefix}"ã§å§‹ã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        if (_issue.format === "ends_with")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.suffix}"ã§çµ‚ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        if (_issue.format === "includes")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.includes}"ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        if (_issue.format === "regex")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: ãƒ‘ã‚¿ãƒ¼ãƒ³${_issue.pattern}ã«ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        return `ç„¡åŠ¹ãª${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ç„¡åŠ¹ãªæ•°å€¤: ${issue3.divisor}ã®å€æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      case "unrecognized_keys":
        return `èªè­˜ã•ã‚Œã¦ã„ãªã„ã‚­ãƒ¼${issue3.keys.length > 1 ? "ç¾¤" : ""}: ${joinValues(issue3.keys, "ã€")}`;
      case "invalid_key":
        return `${issue3.origin}å†…ã®ç„¡åŠ¹ãªã‚­ãƒ¼`;
      case "invalid_union":
        return "ç„¡åŠ¹ãªå…¥åŠ›";
      case "invalid_element":
        return `${issue3.origin}å†…ã®ç„¡åŠ¹ãªå€¤`;
      default:
        return `ç„¡åŠ¹ãªå…¥åŠ›`;
    }
  };
};
function ja_default() {
  return {
    localeError: error18()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/kh.js
var error19 = () => {
  const Sizable = {
    string: { unit: "ážáž½áž¢áž€áŸ’ážŸážš", verb: "áž‚áž½ážšáž˜áž¶áž“" },
    file: { unit: "áž”áŸƒ", verb: "áž‚áž½ážšáž˜áž¶áž“" },
    array: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" },
    set: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "áž˜áž·áž“áž˜áŸ‚áž“áž‡áž¶áž›áŸáž (NaN)" : "áž›áŸáž";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "áž¢áž¶ážšáŸ (Array)";
        }
        if (data === null) {
          return "áž‚áŸ’áž˜áž¶áž“ážáž˜áŸ’áž›áŸƒ (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›",
    email: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“áž¢áŸŠáž¸áž˜áŸ‚áž›",
    url: "URL",
    emoji: "ážŸáž‰áŸ’áž‰áž¶áž¢áž¶ážšáž˜áŸ’áž˜ážŽáŸ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ áž“áž·áž„áž˜áŸ‰áŸ„áž„ ISO",
    date: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ ISO",
    time: "áž˜áŸ‰áŸ„áž„ ISO",
    duration: "ážšáž™áŸˆáž–áŸáž› ISO",
    ipv4: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4",
    ipv6: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6",
    cidrv4: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4",
    cidrv6: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6",
    base64: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64",
    base64url: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64url",
    json_string: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážš JSON",
    e164: "áž›áŸáž E.164",
    jwt: "JWT",
    template_literal: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.expected} áž”áŸ‰áž»áž“áŸ’ážáŸ‚áž‘áž‘áž½áž›áž”áž¶áž“ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${stringifyPrimitive(issue3.values[0])}`;
        return `áž‡áž˜áŸ’ážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž‡áž¶áž˜áž½áž™áž€áŸ’áž“áž»áž„áž…áŸ†ážŽáŸ„áž˜ ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "áž’áž¶ážáž»"}`;
        return `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážŠáŸ„áž™ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž”áž‰áŸ’áž…áž”áŸ‹ážŠáŸ„áž™ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž˜áž¶áž“ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž•áŸ’áž‚áž¼áž•áŸ’áž‚áž„áž“áž¹áž„áž‘áž˜áŸ’ážšáž„áŸ‹ážŠáŸ‚áž›áž”áž¶áž“áž€áŸ†ážŽážáŸ‹ ${_issue.pattern}`;
        return `áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `áž›áŸážáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž‡áž¶áž–áž áž»áž‚áž»ážŽáž“áŸƒ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ážšáž€ážƒáž¾áž‰ážŸáŸ„áž˜áž·áž“ážŸáŸ’áž‚áž¶áž›áŸ‹áŸ– ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ážŸáŸ„áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${issue3.origin}`;
      case "invalid_union":
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ`;
      case "invalid_element":
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${issue3.origin}`;
      default:
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ`;
    }
  };
};
function kh_default() {
  return {
    localeError: error19()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ko.js
var error20 = () => {
  const Sizable = {
    string: { unit: "ë¬¸ìž", verb: "to have" },
    file: { unit: "ë°”ì´íŠ¸", verb: "to have" },
    array: { unit: "ê°œ", verb: "to have" },
    set: { unit: "ê°œ", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ìž…ë ¥",
    email: "ì´ë©”ì¼ ì£¼ì†Œ",
    url: "URL",
    emoji: "ì´ëª¨ì§€",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ë‚ ì§œì‹œê°„",
    date: "ISO ë‚ ì§œ",
    time: "ISO ì‹œê°„",
    duration: "ISO ê¸°ê°„",
    ipv4: "IPv4 ì£¼ì†Œ",
    ipv6: "IPv6 ì£¼ì†Œ",
    cidrv4: "IPv4 ë²”ìœ„",
    cidrv6: "IPv6 ë²”ìœ„",
    base64: "base64 ì¸ì½”ë”© ë¬¸ìžì—´",
    base64url: "base64url ì¸ì½”ë”© ë¬¸ìžì—´",
    json_string: "JSON ë¬¸ìžì—´",
    e164: "E.164 ë²ˆí˜¸",
    jwt: "JWT",
    template_literal: "ìž…ë ¥"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ìž˜ëª»ëœ ìž…ë ¥: ì˜ˆìƒ íƒ€ìž…ì€ ${issue3.expected}, ë°›ì€ íƒ€ìž…ì€ ${parsedType7(issue3.input)}ìž…ë‹ˆë‹¤`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ìž˜ëª»ëœ ìž…ë ¥: ê°’ì€ ${stringifyPrimitive(issue3.values[0])} ì´ì–´ì•¼ í•©ë‹ˆë‹¤`;
        return `ìž˜ëª»ëœ ì˜µì…˜: ${joinValues(issue3.values, "ë˜ëŠ” ")} ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤`;
      case "too_big": {
        const adj = issue3.inclusive ? "ì´í•˜" : "ë¯¸ë§Œ";
        const suffix = adj === "ë¯¸ë§Œ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤";
        const sizing = getSizing(issue3.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "ìš”ì†Œ";
        if (sizing)
          return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "ì´ìƒ" : "ì´ˆê³¼";
        const suffix = adj === "ì´ìƒ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤";
        const sizing = getSizing(issue3.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "ìš”ì†Œ";
        if (sizing) {
          return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.prefix}"(ìœ¼)ë¡œ ì‹œìž‘í•´ì•¼ í•©ë‹ˆë‹¤`;
        }
        if (_issue.format === "ends_with")
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.suffix}"(ìœ¼)ë¡œ ëë‚˜ì•¼ í•©ë‹ˆë‹¤`;
        if (_issue.format === "includes")
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.includes}"ì„(ë¥¼) í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤`;
        if (_issue.format === "regex")
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: ì •ê·œì‹ ${_issue.pattern} íŒ¨í„´ê³¼ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤`;
        return `ìž˜ëª»ëœ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ìž˜ëª»ëœ ìˆ«ìž: ${issue3.divisor}ì˜ ë°°ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤`;
      case "unrecognized_keys":
        return `ì¸ì‹í•  ìˆ˜ ì—†ëŠ” í‚¤: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ìž˜ëª»ëœ í‚¤: ${issue3.origin}`;
      case "invalid_union":
        return `ìž˜ëª»ëœ ìž…ë ¥`;
      case "invalid_element":
        return `ìž˜ëª»ëœ ê°’: ${issue3.origin}`;
      default:
        return `ìž˜ëª»ëœ ìž…ë ¥`;
    }
  };
};
function ko_default() {
  return {
    localeError: error20()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/mk.js
var error21 = () => {
  const Sizable = {
    string: { unit: "Ð·Ð½Ð°Ñ†Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
    file: { unit: "Ð±Ð°Ñ˜Ñ‚Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
    array: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
    set: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ð±Ñ€Ð¾Ñ˜";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð½Ð¸Ð·Ð°";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ð²Ð½ÐµÑ",
    email: "Ð°Ð´Ñ€ÐµÑÐ° Ð½Ð° Ðµ-Ð¿Ð¾ÑˆÑ‚Ð°",
    url: "URL",
    emoji: "ÐµÐ¼Ð¾ÑŸÐ¸",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚ÑƒÐ¼ Ð¸ Ð²Ñ€ÐµÐ¼Ðµ",
    date: "ISO Ð´Ð°Ñ‚ÑƒÐ¼",
    time: "ISO Ð²Ñ€ÐµÐ¼Ðµ",
    duration: "ISO Ð²Ñ€ÐµÐ¼ÐµÑ‚Ñ€Ð°ÐµÑšÐµ",
    ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑÐ°",
    ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑÐ°",
    cidrv4: "IPv4 Ð¾Ð¿ÑÐµÐ³",
    cidrv6: "IPv6 Ð¾Ð¿ÑÐµÐ³",
    base64: "base64-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°",
    base64url: "base64url-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°",
    json_string: "JSON Ð½Ð¸Ð·Ð°",
    e164: "E.164 Ð±Ñ€Ð¾Ñ˜",
    jwt: "JWT",
    template_literal: "Ð²Ð½ÐµÑ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.expected}, Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¾ ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
        return `Ð“Ñ€ÐµÑˆÐ°Ð½Ð° Ð¾Ð¿Ñ†Ð¸Ñ˜Ð°: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ÐµÐ´Ð½Ð° ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð¸Ð¼Ð° ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¸"}`;
        return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð±Ð¸Ð´Ðµ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin} Ð´Ð° Ð¸Ð¼Ð° ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin} Ð´Ð° Ð±Ð¸Ð´Ðµ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð¿Ð¾Ñ‡Ð½ÑƒÐ²Ð° ÑÐ¾ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð²Ñ€ÑˆÑƒÐ²Ð° ÑÐ¾ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð²ÐºÐ»ÑƒÑ‡ÑƒÐ²Ð° "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð¾Ð´Ð³Ð¾Ð°Ñ€Ð° Ð½Ð° Ð¿Ð°Ñ‚ÐµÑ€Ð½Ð¾Ñ‚ ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð±Ñ€Ð¾Ñ˜: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð±Ð¸Ð´Ðµ Ð´ÐµÐ»Ð¸Ð² ÑÐ¾ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½Ð¸ ÐºÐ»ÑƒÑ‡ÐµÐ²Ð¸" : "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½ ÐºÐ»ÑƒÑ‡"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ð“Ñ€ÐµÑˆÐµÐ½ ÐºÐ»ÑƒÑ‡ Ð²Ð¾ ${issue3.origin}`;
      case "invalid_union":
        return "Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ";
      case "invalid_element":
        return `Ð“Ñ€ÐµÑˆÐ½Ð° Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚ Ð²Ð¾ ${issue3.origin}`;
      default:
        return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ`;
    }
  };
};
function mk_default() {
  return {
    localeError: error21()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ms.js
var error22 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error22()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/nl.js
var error23 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue3.values[0])}`;
        return `Ongeldige optie: verwacht Ã©Ã©n van ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error23()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/no.js
var error24 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "Ã¥ ha" },
    file: { unit: "bytes", verb: "Ã¥ ha" },
    array: { unit: "elementer", verb: "Ã¥ inneholde" },
    set: { unit: "elementer", verb: "Ã¥ inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrÃ¥de",
    ipv6: "IPv6-omrÃ¥de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til Ã¥ ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til Ã¥ ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til Ã¥ ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til Ã¥ ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: mÃ¥ starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: mÃ¥ ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: mÃ¥ inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: mÃ¥ matche mÃ¸nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: mÃ¥ vÃ¦re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente nÃ¸kler" : "Ukjent nÃ¸kkel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nÃ¸kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error24()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ota.js
var error25 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalÄ±dÄ±r" },
    file: { unit: "bayt", verb: "olmalÄ±dÄ±r" },
    array: { unit: "unsur", verb: "olmalÄ±dÄ±r" },
    set: { unit: "unsur", verb: "olmalÄ±dÄ±r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagÃ¢h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengÃ¢mÄ±",
    date: "ISO tarihi",
    time: "ISO zamanÄ±",
    duration: "ISO mÃ¼ddeti",
    ipv4: "IPv4 niÅŸÃ¢nÄ±",
    ipv6: "IPv6 niÅŸÃ¢nÄ±",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ÅŸifreli metin",
    base64url: "base64url-ÅŸifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayÄ±sÄ±",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `FÃ¢sit giren: umulan ${issue3.expected}, alÄ±nan ${parsedType7(issue3.input)}`;
      // return `FÃ¢sit giren: umulan ${issue.expected}, alÄ±nan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `FÃ¢sit giren: umulan ${stringifyPrimitive(issue3.values[0])}`;
        return `FÃ¢sit tercih: mÃ»teberler ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla bÃ¼yÃ¼k: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalÄ±ydÄ±.`;
        return `Fazla bÃ¼yÃ¼k: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmalÄ±ydÄ±.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla kÃ¼Ã§Ã¼k: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmalÄ±ydÄ±.`;
        }
        return `Fazla kÃ¼Ã§Ã¼k: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmalÄ±ydÄ±.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `FÃ¢sit metin: "${_issue.prefix}" ile baÅŸlamalÄ±.`;
        if (_issue.format === "ends_with")
          return `FÃ¢sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `FÃ¢sit metin: "${_issue.includes}" ihtivÃ¢ etmeli.`;
        if (_issue.format === "regex")
          return `FÃ¢sit metin: ${_issue.pattern} nakÅŸÄ±na uymalÄ±.`;
        return `FÃ¢sit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `FÃ¢sit sayÄ±: ${issue3.divisor} katÄ± olmalÄ±ydÄ±.`;
      case "unrecognized_keys":
        return `TanÄ±nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} iÃ§in tanÄ±nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanÄ±namadÄ±.";
      case "invalid_element":
        return `${issue3.origin} iÃ§in tanÄ±nmayan kÄ±ymet var.`;
      default:
        return `KÄ±ymet tanÄ±namadÄ±.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error25()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ps.js
var error26 = () => {
  const Sizable = {
    string: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
    file: { unit: "Ø¨Ø§ÛŒÙ¼Ø³", verb: "ÙˆÙ„Ø±ÙŠ" },
    array: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
    set: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ø¹Ø¯Ø¯";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ø§Ø±Û";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ÙˆØ±ÙˆØ¯ÙŠ",
    email: "Ø¨Ø±ÛŒÚšÙ†Ø§Ù„ÛŒÚ©",
    url: "ÛŒÙˆ Ø¢Ø± Ø§Ù„",
    emoji: "Ø§ÛŒÙ…ÙˆØ¬ÙŠ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "Ù†ÛŒÙ¼Ù‡ Ø§Ùˆ ÙˆØ®Øª",
    date: "Ù†ÛÙ¼Ù‡",
    time: "ÙˆØ®Øª",
    duration: "Ù…ÙˆØ¯Ù‡",
    ipv4: "Ø¯ IPv4 Ù¾ØªÙ‡",
    ipv6: "Ø¯ IPv6 Ù¾ØªÙ‡",
    cidrv4: "Ø¯ IPv4 Ø³Ø§Ø­Ù‡",
    cidrv6: "Ø¯ IPv6 Ø³Ø§Ø­Ù‡",
    base64: "base64-encoded Ù…ØªÙ†",
    base64url: "base64url-encoded Ù…ØªÙ†",
    json_string: "JSON Ù…ØªÙ†",
    e164: "Ø¯ E.164 Ø´Ù…ÛØ±Ù‡",
    jwt: "JWT",
    template_literal: "ÙˆØ±ÙˆØ¯ÙŠ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${issue3.expected} ÙˆØ§ÛŒ, Ù…Ú«Ø± ${parsedType7(issue3.input)} ØªØ±Ù„Ø§Ø³Ù‡ Ø´Ùˆ`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${stringifyPrimitive(issue3.values[0])} ÙˆØ§ÛŒ`;
        }
        return `Ù†Ø§Ø³Ù… Ø§Ù†ØªØ®Ø§Ø¨: Ø¨Ø§ÛŒØ¯ ÛŒÙˆ Ù„Ù‡ ${joinValues(issue3.values, "|")} Ú…Ø®Ù‡ ÙˆØ§ÛŒ`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${issue3.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±ÙˆÙ†Ù‡"} ÙˆÙ„Ø±ÙŠ`;
        }
        return `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${issue3.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} ÙˆÙŠ`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} ${sizing.unit} ÙˆÙ„Ø±ÙŠ`;
        }
        return `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} ÙˆÙŠ`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${_issue.prefix}" Ø³Ø±Ù‡ Ù¾ÛŒÙ„ Ø´ÙŠ`;
        }
        if (_issue.format === "ends_with") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${_issue.suffix}" Ø³Ø±Ù‡ Ù¾Ø§ÛŒ ØªÙ‡ ÙˆØ±Ø³ÙŠÚ–ÙŠ`;
        }
        if (_issue.format === "includes") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ "${_issue.includes}" ÙˆÙ„Ø±ÙŠ`;
        }
        if (_issue.format === "regex") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ ${_issue.pattern} Ø³Ø±Ù‡ Ù…Ø·Ø§Ø¨Ù‚Øª ÙˆÙ„Ø±ÙŠ`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} Ù†Ø§Ø³Ù… Ø¯ÛŒ`;
      }
      case "not_multiple_of":
        return `Ù†Ø§Ø³Ù… Ø¹Ø¯Ø¯: Ø¨Ø§ÛŒØ¯ Ø¯ ${issue3.divisor} Ù…Ø¶Ø±Ø¨ ÙˆÙŠ`;
      case "unrecognized_keys":
        return `Ù†Ø§Ø³Ù… ${issue3.keys.length > 1 ? "Ú©Ù„ÛŒÚ‰ÙˆÙ†Ù‡" : "Ú©Ù„ÛŒÚ‰"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ù†Ø§Ø³Ù… Ú©Ù„ÛŒÚ‰ Ù¾Ù‡ ${issue3.origin} Ú©Û`;
      case "invalid_union":
        return `Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ`;
      case "invalid_element":
        return `Ù†Ø§Ø³Ù… Ø¹Ù†ØµØ± Ù¾Ù‡ ${issue3.origin} Ú©Û`;
      default:
        return `Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ`;
    }
  };
};
function ps_default() {
  return {
    localeError: error26()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/pl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "znakÃ³w", verb: "mieÄ‡" },
    file: { unit: "bajtÃ³w", verb: "mieÄ‡" },
    array: { unit: "elementÃ³w", verb: "mieÄ‡" },
    set: { unit: "elementÃ³w", verb: "mieÄ‡" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyraÅ¼enie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciÄ…g znakÃ³w zakodowany w formacie base64",
    base64url: "ciÄ…g znakÃ³w zakodowany w formacie base64url",
    json_string: "ciÄ…g znakÃ³w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejÅ›cie"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${stringifyPrimitive(issue3.values[0])}`;
        return `NieprawidÅ‚owa opcja: oczekiwano jednej z wartoÅ›ci ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za duÅ¼a wartoÅ›Ä‡: oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementÃ³w"}`;
        }
        return `Zbyt duÅ¼(y/a/e): oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za maÅ‚a wartoÅ›Ä‡: oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "elementÃ³w"}`;
        }
        return `Zbyt maÅ‚(y/a/e): oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zaczynaÄ‡ siÄ™ od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi koÅ„czyÄ‡ siÄ™ na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zawieraÄ‡ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi odpowiadaÄ‡ wzorcowi ${_issue.pattern}`;
        return `NieprawidÅ‚ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NieprawidÅ‚owa liczba: musi byÄ‡ wielokrotnoÅ›ciÄ… ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `NieprawidÅ‚owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "NieprawidÅ‚owe dane wejÅ›ciowe";
      case "invalid_element":
        return `NieprawidÅ‚owa wartoÅ›Ä‡ w ${issue3.origin}`;
      default:
        return `NieprawidÅ‚owe dane wejÅ›ciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error27()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/pt.js
var error28 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nÃºmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padrÃ£o",
    email: "endereÃ§o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duraÃ§Ã£o ISO",
    ipv4: "endereÃ§o IPv4",
    ipv6: "endereÃ§o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nÃºmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo invÃ¡lido: esperado ${issue3.expected}, recebido ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada invÃ¡lida: esperado ${stringifyPrimitive(issue3.values[0])}`;
        return `OpÃ§Ã£o invÃ¡lida: esperada uma das ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto invÃ¡lido: deve comeÃ§ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invÃ¡lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invÃ¡lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invÃ¡lido: deve corresponder ao padrÃ£o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invÃ¡lido`;
      }
      case "not_multiple_of":
        return `NÃºmero invÃ¡lido: deve ser mÃºltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave invÃ¡lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invÃ¡lida";
      case "invalid_element":
        return `Valor invÃ¡lido em ${issue3.origin}`;
      default:
        return `Campo invÃ¡lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error28()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error29 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "ÑÐ¸Ð¼Ð²Ð¾Ð»",
        few: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°",
        many: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    },
    file: {
      unit: {
        one: "Ð±Ð°Ð¹Ñ‚",
        few: "Ð±Ð°Ð¹Ñ‚Ð°",
        many: "Ð±Ð°Ð¹Ñ‚"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    },
    array: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    },
    set: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÑÐ¸Ð²";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ð²Ð²Ð¾Ð´",
    email: "email Ð°Ð´Ñ€ÐµÑ",
    url: "URL",
    emoji: "ÑÐ¼Ð¾Ð´Ð·Ð¸",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚Ð° Ð¸ Ð²Ñ€ÐµÐ¼Ñ",
    date: "ISO Ð´Ð°Ñ‚Ð°",
    time: "ISO Ð²Ñ€ÐµÐ¼Ñ",
    duration: "ISO Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ",
    ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑ",
    ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑ",
    cidrv4: "IPv4 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½",
    cidrv6: "IPv6 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½",
    base64: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64",
    base64url: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64url",
    json_string: "JSON ÑÑ‚Ñ€Ð¾ÐºÐ°",
    e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164",
    jwt: "JWT",
    template_literal: "Ð²Ð²Ð¾Ð´"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${issue3.expected}, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${stringifyPrimitive(issue3.values[0])}`;
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin} Ð±ÑƒÐ´ÐµÑ‚ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð½Ð°Ñ‡Ð¸Ð½Ð°Ñ‚ÑŒÑÑ Ñ "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð·Ð°ÐºÐ°Ð½Ñ‡Ð¸Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¾Ð²Ð°Ñ‚ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð½${issue3.keys.length > 1 ? "Ñ‹Ðµ" : "Ñ‹Ð¹"} ÐºÐ»ÑŽÑ‡${issue3.keys.length > 1 ? "Ð¸" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÐºÐ»ÑŽÑ‡ Ð² ${issue3.origin}`;
      case "invalid_union":
        return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ";
      case "invalid_element":
        return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð² ${issue3.origin}`;
      default:
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ`;
    }
  };
};
function ru_default() {
  return {
    localeError: error29()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/sl.js
var error30 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Å¡tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poÅ¡tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in Äas",
    date: "ISO datum",
    time: "ISO Äas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 Å¡tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: priÄakovano ${issue3.expected}, prejeto ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: priÄakovano ${stringifyPrimitive(issue3.values[0])}`;
        return `Neveljavna moÅ¾nost: priÄakovano eno izmed ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: priÄakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priÄakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: priÄakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priÄakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaÄeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konÄati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno Å¡tevilo: mora biti veÄkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i kljuÄi" : " kljuÄ"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven kljuÄ v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error30()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/sv.js
var error31 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehÃ¥lla" },
    set: { unit: "objekt", verb: "att innehÃ¥lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljÃ¤rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strÃ¤ng",
    base64url: "base64url-kodad strÃ¤ng",
    json_string: "JSON-strÃ¤ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${issue3.expected}, fick ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${stringifyPrimitive(issue3.values[0])}`;
        return `Ogiltigt val: fÃ¶rvÃ¤ntade en av ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `FÃ¶r stor(t): fÃ¶rvÃ¤ntade ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `FÃ¶r stor(t): fÃ¶rvÃ¤ntat ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig strÃ¤ng: mÃ¥ste bÃ¶rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strÃ¤ng: mÃ¥ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strÃ¤ng: mÃ¥ste innehÃ¥lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strÃ¤ng: mÃ¥ste matcha mÃ¶nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mÃ¥ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "OkÃ¤nda nycklar" : "OkÃ¤nd nyckel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "vÃ¤rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vÃ¤rde i ${issue3.origin ?? "vÃ¤rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error31()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ta.js
var error32 = () => {
  const Sizable = {
    string: { unit: "à®Žà®´à¯à®¤à¯à®¤à¯à®•à¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
    file: { unit: "à®ªà¯ˆà®Ÿà¯à®Ÿà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
    array: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
    set: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "à®Žà®£à¯ à®…à®²à¯à®²à®¾à®¤à®¤à¯" : "à®Žà®£à¯";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "à®…à®£à®¿";
        }
        if (data === null) {
          return "à®µà¯†à®±à¯à®®à¯ˆ";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "à®‰à®³à¯à®³à¯€à®Ÿà¯",
    email: "à®®à®¿à®©à¯à®©à®žà¯à®šà®²à¯ à®®à¯à®•à®µà®°à®¿",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO à®¤à¯‡à®¤à®¿ à®¨à¯‡à®°à®®à¯",
    date: "ISO à®¤à¯‡à®¤à®¿",
    time: "ISO à®¨à¯‡à®°à®®à¯",
    duration: "ISO à®•à®¾à®² à®…à®³à®µà¯",
    ipv4: "IPv4 à®®à¯à®•à®µà®°à®¿",
    ipv6: "IPv6 à®®à¯à®•à®µà®°à®¿",
    cidrv4: "IPv4 à®µà®°à®®à¯à®ªà¯",
    cidrv6: "IPv6 à®µà®°à®®à¯à®ªà¯",
    base64: "base64-encoded à®šà®°à®®à¯",
    base64url: "base64url-encoded à®šà®°à®®à¯",
    json_string: "JSON à®šà®°à®®à¯",
    e164: "E.164 à®Žà®£à¯",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.expected}, à®ªà¯†à®±à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${stringifyPrimitive(issue3.values[0])}`;
        return `à®¤à®µà®±à®¾à®© à®µà®¿à®°à¯à®ªà¯à®ªà®®à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${joinValues(issue3.values, "|")} à®‡à®²à¯ à®’à®©à¯à®±à¯`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯"} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        }
        return `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${adj}${issue3.maximum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        }
        return `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin} ${adj}${issue3.minimum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.prefix}" à®‡à®²à¯ à®¤à¯Šà®Ÿà®™à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        if (_issue.format === "ends_with")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.suffix}" à®‡à®²à¯ à®®à¯à®Ÿà®¿à®µà®Ÿà¯ˆà®¯ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        if (_issue.format === "includes")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.includes}" à® à®‰à®³à¯à®³à®Ÿà®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        if (_issue.format === "regex")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: ${_issue.pattern} à®®à¯à®±à¯ˆà®ªà®¾à®Ÿà¯à®Ÿà¯à®Ÿà®©à¯ à®ªà¯Šà®°à¯à®¨à¯à®¤ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        return `à®¤à®µà®±à®¾à®© ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `à®¤à®µà®±à®¾à®© à®Žà®£à¯: ${issue3.divisor} à®‡à®©à¯ à®ªà®²à®®à®¾à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
      case "unrecognized_keys":
        return `à®…à®Ÿà¯ˆà®¯à®¾à®³à®®à¯ à®¤à¯†à®°à®¿à®¯à®¾à®¤ à®µà®¿à®šà¯ˆ${issue3.keys.length > 1 ? "à®•à®³à¯" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®µà®¿à®šà¯ˆ`;
      case "invalid_union":
        return "à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯";
      case "invalid_element":
        return `${issue3.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®®à®¤à®¿à®ªà¯à®ªà¯`;
      default:
        return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯`;
    }
  };
};
function ta_default() {
  return {
    localeError: error32()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/th.js
var error33 = () => {
  const Sizable = {
    string: { unit: "à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
    file: { unit: "à¹„à¸šà¸•à¹Œ", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
    array: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
    set: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸•à¸±à¸§à¹€à¸¥à¸‚ (NaN)" : "à¸•à¸±à¸§à¹€à¸¥à¸‚";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "à¸­à¸²à¸£à¹Œà¹€à¸£à¸¢à¹Œ (Array)";
        }
        if (data === null) {
          return "à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¹ˆà¸² (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™",
    email: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆà¸­à¸µà¹€à¸¡à¸¥",
    url: "URL",
    emoji: "à¸­à¸´à¹‚à¸¡à¸ˆà¸´",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
    date: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹à¸šà¸š ISO",
    time: "à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
    duration: "à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
    ipv4: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv4",
    ipv6: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv6",
    cidrv4: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv4",
    cidrv6: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv6",
    base64: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64",
    base64url: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64 à¸ªà¸³à¸«à¸£à¸±à¸š URL",
    json_string: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š JSON",
    e164: "à¹€à¸šà¸­à¸£à¹Œà¹‚à¸—à¸£à¸¨à¸±à¸žà¸—à¹Œà¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸›à¸£à¸°à¹€à¸—à¸¨ (E.164)",
    jwt: "à¹‚à¸—à¹€à¸„à¸™ JWT",
    template_literal: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `à¸›à¸£à¸°à¹€à¸ à¸—à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${issue3.expected} à¹à¸•à¹ˆà¹„à¸”à¹‰à¸£à¸±à¸š ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${stringifyPrimitive(issue3.values[0])}`;
        return `à¸•à¸±à¸§à¹€à¸¥à¸·à¸­à¸à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™à¸«à¸™à¸¶à¹ˆà¸‡à¹ƒà¸™ ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "à¹„à¸¡à¹ˆà¹€à¸à¸´à¸™" : "à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${issue3.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "à¸£à¸²à¸¢à¸à¸²à¸£"}`;
        return `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${issue3.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢" : "à¸¡à¸²à¸à¸à¸§à¹ˆà¸²";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${issue3.origin} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${issue3.origin} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸‚à¸¶à¹‰à¸™à¸•à¹‰à¸™à¸”à¹‰à¸§à¸¢ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¥à¸‡à¸—à¹‰à¸²à¸¢à¸”à¹‰à¸§à¸¢ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¡à¸µ "${_issue.includes}" à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡`;
        if (_issue.format === "regex")
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸” ${_issue.pattern}`;
        return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `à¸•à¸±à¸§à¹€à¸¥à¸‚à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¸ˆà¸³à¸™à¸§à¸™à¸—à¸µà¹ˆà¸«à¸²à¸£à¸”à¹‰à¸§à¸¢ ${issue3.divisor} à¹„à¸”à¹‰à¸¥à¸‡à¸•à¸±à¸§`;
      case "unrecognized_keys":
        return `à¸žà¸šà¸„à¸µà¸¢à¹Œà¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸£à¸¹à¹‰à¸ˆà¸±à¸: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `à¸„à¸µà¸¢à¹Œà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${issue3.origin}`;
      case "invalid_union":
        return "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¹„à¸¡à¹ˆà¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸¢à¸¹à¹€à¸™à¸µà¸¢à¸™à¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸”à¹„à¸§à¹‰";
      case "invalid_element":
        return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${issue3.origin}`;
      default:
        return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡`;
    }
  };
};
function th_default() {
  return {
    localeError: error33()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error34 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalÄ±" },
    file: { unit: "bayt", verb: "olmalÄ±" },
    array: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" },
    set: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sÃ¼re",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralÄ±ÄŸÄ±",
    cidrv6: "IPv6 aralÄ±ÄŸÄ±",
    base64: "base64 ile ÅŸifrelenmiÅŸ metin",
    base64url: "base64url ile ÅŸifrelenmiÅŸ metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayÄ±sÄ±",
    jwt: "JWT",
    template_literal: "Åžablon dizesi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `GeÃ§ersiz deÄŸer: beklenen ${issue3.expected}, alÄ±nan ${parsedType3(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `GeÃ§ersiz deÄŸer: beklenen ${stringifyPrimitive(issue3.values[0])}`;
        return `GeÃ§ersiz seÃ§enek: aÅŸaÄŸÄ±dakilerden biri olmalÄ±: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ok bÃ¼yÃ¼k: beklenen ${issue3.origin ?? "deÄŸer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ã¶ÄŸe"}`;
        return `Ã‡ok bÃ¼yÃ¼k: beklenen ${issue3.origin ?? "deÄŸer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `GeÃ§ersiz metin: "${_issue.prefix}" ile baÅŸlamalÄ±`;
        if (_issue.format === "ends_with")
          return `GeÃ§ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `GeÃ§ersiz metin: "${_issue.includes}" iÃ§ermeli`;
        if (_issue.format === "regex")
          return `GeÃ§ersiz metin: ${_issue.pattern} desenine uymalÄ±`;
        return `GeÃ§ersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `GeÃ§ersiz sayÄ±: ${issue3.divisor} ile tam bÃ¶lÃ¼nebilmeli`;
      case "unrecognized_keys":
        return `TanÄ±nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} iÃ§inde geÃ§ersiz anahtar`;
      case "invalid_union":
        return "GeÃ§ersiz deÄŸer";
      case "invalid_element":
        return `${issue3.origin} iÃ§inde geÃ§ersiz deÄŸer`;
      default:
        return `GeÃ§ersiz deÄŸer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error34()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ua.js
var error35 = () => {
  const Sizable = {
    string: { unit: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
    file: { unit: "Ð±Ð°Ð¹Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
    array: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
    set: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÐ¸Ð²";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–",
    email: "Ð°Ð´Ñ€ÐµÑÐ° ÐµÐ»ÐµÐºÑ‚Ñ€Ð¾Ð½Ð½Ð¾Ñ— Ð¿Ð¾ÑˆÑ‚Ð¸",
    url: "URL",
    emoji: "ÐµÐ¼Ð¾Ð´Ð·Ñ–",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "Ð´Ð°Ñ‚Ð° Ñ‚Ð° Ñ‡Ð°Ñ ISO",
    date: "Ð´Ð°Ñ‚Ð° ISO",
    time: "Ñ‡Ð°Ñ ISO",
    duration: "Ñ‚Ñ€Ð¸Ð²Ð°Ð»Ñ–ÑÑ‚ÑŒ ISO",
    ipv4: "Ð°Ð´Ñ€ÐµÑÐ° IPv4",
    ipv6: "Ð°Ð´Ñ€ÐµÑÐ° IPv6",
    cidrv4: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv4",
    cidrv6: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv6",
    base64: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64",
    base64url: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64url",
    json_string: "Ñ€ÑÐ´Ð¾Ðº JSON",
    e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164",
    jwt: "JWT",
    template_literal: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${issue3.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${parsedType7(issue3.input)}`;
      // return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${issue.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${stringifyPrimitive(issue3.values[0])}`;
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð° Ð¾Ð¿Ñ†Ñ–Ñ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ Ð¾Ð´Ð½Ðµ Ð· ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²"}`;
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} Ð±ÑƒÐ´Ðµ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin} Ð±ÑƒÐ´Ðµ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¿Ð¾Ñ‡Ð¸Ð½Ð°Ñ‚Ð¸ÑÑ Ð· "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð·Ð°ÐºÑ–Ð½Ñ‡ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¼Ñ–ÑÑ‚Ð¸Ñ‚Ð¸ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð°Ñ‚Ð¸ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð¿Ð¾Ð²Ð¸Ð½Ð½Ð¾ Ð±ÑƒÑ‚Ð¸ ÐºÑ€Ð°Ñ‚Ð½Ð¸Ð¼ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð¾Ð·Ð¿Ñ–Ð·Ð½Ð°Ð½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡${issue3.keys.length > 1 ? "Ñ–" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue3.origin}`;
      case "invalid_union":
        return "ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–";
      case "invalid_element":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ñƒ ${issue3.origin}`;
      default:
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–`;
    }
  };
};
function ua_default() {
  return {
    localeError: error35()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/ur.js
var error36 = () => {
  const Sizable = {
    string: { unit: "Ø­Ø±ÙˆÙ", verb: "ÛÙˆÙ†Ø§" },
    file: { unit: "Ø¨Ø§Ø¦Ù¹Ø³", verb: "ÛÙˆÙ†Ø§" },
    array: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" },
    set: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ù†Ù…Ø¨Ø±";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ø¢Ø±Û’";
        }
        if (data === null) {
          return "Ù†Ù„";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ø§Ù† Ù¾Ù¹",
    email: "Ø§ÛŒ Ù…ÛŒÙ„ Ø§ÛŒÚˆØ±ÛŒØ³",
    url: "ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„",
    emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
    uuid: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    uuidv4: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 4",
    uuidv6: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 6",
    nanoid: "Ù†ÛŒÙ†Ùˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    guid: "Ø¬ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    cuid: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    cuid2: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ 2",
    ulid: "ÛŒÙˆ Ø§ÛŒÙ„ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    xid: "Ø§ÛŒÚ©Ø³ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    ksuid: "Ú©Û’ Ø§ÛŒØ³ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    datetime: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÚˆÛŒÙ¹ Ù¹Ø§Ø¦Ù…",
    date: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ØªØ§Ø±ÛŒØ®",
    time: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÙˆÙ‚Øª",
    duration: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ Ù…Ø¯Øª",
    ipv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø§ÛŒÚˆØ±ÛŒØ³",
    ipv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø§ÛŒÚˆØ±ÛŒØ³",
    cidrv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø±ÛŒÙ†Ø¬",
    cidrv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø±ÛŒÙ†Ø¬",
    base64: "Ø¨ÛŒØ³ 64 Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯",
    base64url: "Ø¨ÛŒØ³ 64 ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„ Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯",
    json_string: "Ø¬Û’ Ø§ÛŒØ³ Ø§Ùˆ Ø§ÛŒÙ† Ø³Ù¹Ø±Ù†Ú¯",
    e164: "Ø§ÛŒ 164 Ù†Ù…Ø¨Ø±",
    jwt: "Ø¬Û’ ÚˆØ¨Ù„ÛŒÙˆ Ù¹ÛŒ",
    template_literal: "Ø§Ù† Ù¾Ù¹"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${issue3.expected} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§ØŒ ${parsedType7(issue3.input)} Ù…ÙˆØµÙˆÙ„ ÛÙˆØ§`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${stringifyPrimitive(issue3.values[0])} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
        return `ØºÙ„Ø· Ø¢Ù¾Ø´Ù†: ${joinValues(issue3.values, "|")} Ù…ÛŒÚº Ø³Û’ Ø§ÛŒÚ© Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ø¨ÛØª Ø¨Ú‘Ø§: ${issue3.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Û’ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†Ø§ØµØ±"} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’`;
        return `Ø¨ÛØª Ø¨Ú‘Ø§: ${issue3.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Ø§ ${adj}${issue3.maximum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${issue3.origin} Ú©Û’ ${adj}${issue3.minimum.toString()} ${sizing.unit} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’`;
        }
        return `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${issue3.origin} Ú©Ø§ ${adj}${issue3.minimum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.prefix}" Ø³Û’ Ø´Ø±ÙˆØ¹ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        }
        if (_issue.format === "ends_with")
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.suffix}" Ù¾Ø± Ø®ØªÙ… ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        if (_issue.format === "includes")
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.includes}" Ø´Ø§Ù…Ù„ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        if (_issue.format === "regex")
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: Ù¾ÛŒÙ¹Ø±Ù† ${_issue.pattern} Ø³Û’ Ù…ÛŒÚ† ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        return `ØºÙ„Ø· ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ØºÙ„Ø· Ù†Ù…Ø¨Ø±: ${issue3.divisor} Ú©Ø§ Ù…Ø¶Ø§Ø¹Ù ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
      case "unrecognized_keys":
        return `ØºÛŒØ± ØªØ³Ù„ÛŒÙ… Ø´Ø¯Û Ú©ÛŒ${issue3.keys.length > 1 ? "Ø²" : ""}: ${joinValues(issue3.keys, "ØŒ ")}`;
      case "invalid_key":
        return `${issue3.origin} Ù…ÛŒÚº ØºÙ„Ø· Ú©ÛŒ`;
      case "invalid_union":
        return "ØºÙ„Ø· Ø§Ù† Ù¾Ù¹";
      case "invalid_element":
        return `${issue3.origin} Ù…ÛŒÚº ØºÙ„Ø· ÙˆÛŒÙ„ÛŒÙˆ`;
      default:
        return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹`;
    }
  };
};
function ur_default() {
  return {
    localeError: error36()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/vi.js
var error37 = () => {
  const Sizable = {
    string: { unit: "kÃ½ tá»±", verb: "cÃ³" },
    file: { unit: "byte", verb: "cÃ³" },
    array: { unit: "pháº§n tá»­", verb: "cÃ³" },
    set: { unit: "pháº§n tá»­", verb: "cÃ³" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sá»‘";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "máº£ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ä‘áº§u vÃ o",
    email: "Ä‘á»‹a chá»‰ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngÃ y giá» ISO",
    date: "ngÃ y ISO",
    time: "giá» ISO",
    duration: "khoáº£ng thá»i gian ISO",
    ipv4: "Ä‘á»‹a chá»‰ IPv4",
    ipv6: "Ä‘á»‹a chá»‰ IPv6",
    cidrv4: "dáº£i IPv4",
    cidrv6: "dáº£i IPv6",
    base64: "chuá»—i mÃ£ hÃ³a base64",
    base64url: "chuá»—i mÃ£ hÃ³a base64url",
    json_string: "chuá»—i JSON",
    e164: "sá»‘ E.164",
    jwt: "JWT",
    template_literal: "Ä‘áº§u vÃ o"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${issue3.expected}, nháº­n Ä‘Æ°á»£c ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${stringifyPrimitive(issue3.values[0])}`;
        return `TÃ¹y chá»n khÃ´ng há»£p lá»‡: mong Ä‘á»£i má»™t trong cÃ¡c giÃ¡ trá»‹ ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `QuÃ¡ lá»›n: mong Ä‘á»£i ${issue3.origin ?? "giÃ¡ trá»‹"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "pháº§n tá»­"}`;
        return `QuÃ¡ lá»›n: mong Ä‘á»£i ${issue3.origin ?? "giÃ¡ trá»‹"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `QuÃ¡ nhá»: mong Ä‘á»£i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `QuÃ¡ nhá»: mong Ä‘á»£i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i báº¯t Ä‘áº§u báº±ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i káº¿t thÃºc báº±ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i bao gá»“m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i khá»›p vá»›i máº«u ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} khÃ´ng há»£p lá»‡`;
      }
      case "not_multiple_of":
        return `Sá»‘ khÃ´ng há»£p lá»‡: pháº£i lÃ  bá»™i sá»‘ cá»§a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `KhÃ³a khÃ´ng Ä‘Æ°á»£c nháº­n dáº¡ng: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `KhÃ³a khÃ´ng há»£p lá»‡ trong ${issue3.origin}`;
      case "invalid_union":
        return "Äáº§u vÃ o khÃ´ng há»£p lá»‡";
      case "invalid_element":
        return `GiÃ¡ trá»‹ khÃ´ng há»£p lá»‡ trong ${issue3.origin}`;
      default:
        return `Äáº§u vÃ o khÃ´ng há»£p lá»‡`;
    }
  };
};
function vi_default() {
  return {
    localeError: error37()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/zh-CN.js
var error38 = () => {
  const Sizable = {
    string: { unit: "å­—ç¬¦", verb: "åŒ…å«" },
    file: { unit: "å­—èŠ‚", verb: "åŒ…å«" },
    array: { unit: "é¡¹", verb: "åŒ…å«" },
    set: { unit: "é¡¹", verb: "åŒ…å«" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "éžæ•°å­—(NaN)" : "æ•°å­—";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "æ•°ç»„";
        }
        if (data === null) {
          return "ç©ºå€¼(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "è¾“å…¥",
    email: "ç”µå­é‚®ä»¶",
    url: "URL",
    emoji: "è¡¨æƒ…ç¬¦å·",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISOæ—¥æœŸæ—¶é—´",
    date: "ISOæ—¥æœŸ",
    time: "ISOæ—¶é—´",
    duration: "ISOæ—¶é•¿",
    ipv4: "IPv4åœ°å€",
    ipv6: "IPv6åœ°å€",
    cidrv4: "IPv4ç½‘æ®µ",
    cidrv6: "IPv6ç½‘æ®µ",
    base64: "base64ç¼–ç å­—ç¬¦ä¸²",
    base64url: "base64urlç¼–ç å­—ç¬¦ä¸²",
    json_string: "JSONå­—ç¬¦ä¸²",
    e164: "E.164å·ç ",
    jwt: "JWT",
    template_literal: "è¾“å…¥"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${issue3.expected}ï¼Œå®žé™…æŽ¥æ”¶ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${stringifyPrimitive(issue3.values[0])}`;
        return `æ— æ•ˆé€‰é¡¹ï¼šæœŸæœ›ä»¥ä¸‹ä¹‹ä¸€ ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${issue3.origin ?? "å€¼"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ä¸ªå…ƒç´ "}`;
        return `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${issue3.origin ?? "å€¼"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${_issue.prefix}" å¼€å¤´`;
        if (_issue.format === "ends_with")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${_issue.suffix}" ç»“å°¾`;
        if (_issue.format === "includes")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»åŒ…å« "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼ ${_issue.pattern}`;
        return `æ— æ•ˆ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `æ— æ•ˆæ•°å­—ï¼šå¿…é¡»æ˜¯ ${issue3.divisor} çš„å€æ•°`;
      case "unrecognized_keys":
        return `å‡ºçŽ°æœªçŸ¥çš„é”®(key): ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} ä¸­çš„é”®(key)æ— æ•ˆ`;
      case "invalid_union":
        return "æ— æ•ˆè¾“å…¥";
      case "invalid_element":
        return `${issue3.origin} ä¸­åŒ…å«æ— æ•ˆå€¼(value)`;
      default:
        return `æ— æ•ˆè¾“å…¥`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error38()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/locales/zh-TW.js
var error39 = () => {
  const Sizable = {
    string: { unit: "å­—å…ƒ", verb: "æ“æœ‰" },
    file: { unit: "ä½å…ƒçµ„", verb: "æ“æœ‰" },
    array: { unit: "é …ç›®", verb: "æ“æœ‰" },
    set: { unit: "é …ç›®", verb: "æ“æœ‰" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "è¼¸å…¥",
    email: "éƒµä»¶åœ°å€",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO æ—¥æœŸæ™‚é–“",
    date: "ISO æ—¥æœŸ",
    time: "ISO æ™‚é–“",
    duration: "ISO æœŸé–“",
    ipv4: "IPv4 ä½å€",
    ipv6: "IPv6 ä½å€",
    cidrv4: "IPv4 ç¯„åœ",
    cidrv6: "IPv6 ç¯„åœ",
    base64: "base64 ç·¨ç¢¼å­—ä¸²",
    base64url: "base64url ç·¨ç¢¼å­—ä¸²",
    json_string: "JSON å­—ä¸²",
    e164: "E.164 æ•¸å€¼",
    jwt: "JWT",
    template_literal: "è¼¸å…¥"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${issue3.expected}ï¼Œä½†æ”¶åˆ° ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${stringifyPrimitive(issue3.values[0])}`;
        return `ç„¡æ•ˆçš„é¸é …ï¼šé æœŸç‚ºä»¥ä¸‹å…¶ä¸­ä¹‹ä¸€ ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${issue3.origin ?? "å€¼"} æ‡‰ç‚º ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "å€‹å…ƒç´ "}`;
        return `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${issue3.origin ?? "å€¼"} æ‡‰ç‚º ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `æ•¸å€¼éŽå°ï¼šé æœŸ ${issue3.origin} æ‡‰ç‚º ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `æ•¸å€¼éŽå°ï¼šé æœŸ ${issue3.origin} æ‡‰ç‚º ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${_issue.prefix}" é–‹é ­`;
        }
        if (_issue.format === "ends_with")
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${_issue.suffix}" çµå°¾`;
        if (_issue.format === "includes")
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆåŒ…å« "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆç¬¦åˆæ ¼å¼ ${_issue.pattern}`;
        return `ç„¡æ•ˆçš„ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ç„¡æ•ˆçš„æ•¸å­—ï¼šå¿…é ˆç‚º ${issue3.divisor} çš„å€æ•¸`;
      case "unrecognized_keys":
        return `ç„¡æ³•è­˜åˆ¥çš„éµå€¼${issue3.keys.length > 1 ? "å€‘" : ""}ï¼š${joinValues(issue3.keys, "ã€")}`;
      case "invalid_key":
        return `${issue3.origin} ä¸­æœ‰ç„¡æ•ˆçš„éµå€¼`;
      case "invalid_union":
        return "ç„¡æ•ˆçš„è¼¸å…¥å€¼";
      case "invalid_element":
        return `${issue3.origin} ä¸­æœ‰ç„¡æ•ˆçš„å€¼`;
      default:
        return `ç„¡æ•ˆçš„è¼¸å…¥å€¼`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error39()
  };
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = registry();

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/api.js
function _string(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom(Class3, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/function.js
var $ZodFunction = class {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = ((...args) => {
      const parsedArgs = this._def.input ? parse2(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse2(this._def.output, output, void 0, { callee: impl }) : output;
    });
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, void 0, { callee: impl }) : output;
    });
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
};
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params == null ? void 0 : params.input) ? _tuple($ZodTuple, params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: (params == null ? void 0 : params.output) ?? _unknown($ZodUnknown)
  });
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry;
    this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
    this.override = (params == null ? void 0 : params.override) ?? (() => {
    });
    this.io = (params == null ? void 0 : params.io) ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a6, _b, _c;
    var _a5;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = (_b = (_a6 = schema._zod).toJSONSchema) == null ? void 0 : _b.call(_a6);
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (((_c = def.catchall) == null ? void 0 : _c._zod.def.type) === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file.minLength = minimum;
            if (maximum !== void 0)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a5 = result.schema).default ?? (_a5.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    var _a5, _b, _c, _d, _e, _f;
    const params = {
      cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
      reused: (_params == null ? void 0 : _params.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (_params == null ? void 0 : _params.external) ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      var _a6;
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = (_a6 = params.external.registry.get(entry[0])) == null ? void 0 : _a6.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${(_a5 = seen.cycle) == null ? void 0 : _a5.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = (_b = params.external.registry.get(entry[0])) == null ? void 0 : _b.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = (_c = this.metadataRegistry.get(entry[0])) == null ? void 0 : _c.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if ((_d = params.external) == null ? void 0 : _d.uri) {
      const id = (_e = params.external.registry.get(schema)) == null ? void 0 : _e.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = ((_f = params.external) == null ? void 0 : _f.defs) ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params == null ? void 0 : _params.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/mini/schemas.js
var ZodMiniType = $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
});
var ZodMiniString = $constructor("ZodMiniString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodMiniType.init(inst, def);
});
function string2(params) {
  return _string(ZodMiniString, params);
}
var ZodMiniStringFormat = $constructor("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  ZodMiniString.init(inst, def);
});
var ZodMiniEmail = $constructor("ZodMiniEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniGUID = $constructor("ZodMiniGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniUUID = $constructor("ZodMiniUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniURL = $constructor("ZodMiniURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniEmoji = $constructor("ZodMiniEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNanoID = $constructor("ZodMiniNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID = $constructor("ZodMiniCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID2 = $constructor("ZodMiniCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniULID = $constructor("ZodMiniULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniXID = $constructor("ZodMiniXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniKSUID = $constructor("ZodMiniKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv4 = $constructor("ZodMiniIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv6 = $constructor("ZodMiniIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv4 = $constructor("ZodMiniCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv6 = $constructor("ZodMiniCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64 = $constructor("ZodMiniBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64URL = $constructor("ZodMiniBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniE164 = $constructor("ZodMiniE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniJWT = $constructor("ZodMiniJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCustomStringFormat = $constructor("ZodMiniCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNumber = $constructor("ZodMiniNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNumberFormat = $constructor("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodMiniNumber.init(inst, def);
});
var ZodMiniBoolean = $constructor("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodMiniType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodMiniBoolean, params);
}
var ZodMiniBigInt = $constructor("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniBigIntFormat = $constructor("ZodMiniBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodMiniBigInt.init(inst, def);
});
var ZodMiniSymbol = $constructor("ZodMiniSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUndefined = $constructor("ZodMiniUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNull = $constructor("ZodMiniNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniAny = $constructor("ZodMiniAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUnknown = $constructor("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNever = $constructor("ZodMiniNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniVoid = $constructor("ZodMiniVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDate = $constructor("ZodMiniDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniArray = $constructor("ZodMiniArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodMiniType.init(inst, def);
});
function array(element, params) {
  return new ZodMiniArray({
    type: "array",
    element,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniObject = $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodMiniObject(def);
}
var ZodMiniUnion = $constructor("ZodMiniUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDiscriminatedUnion = $constructor("ZodMiniDiscriminatedUnion", (inst, def) => {
  $ZodDiscriminatedUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniIntersection = $constructor("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTuple = $constructor("ZodMiniTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniRecord = $constructor("ZodMiniRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodMiniType.init(inst, def);
});
function record(keyType, valueType, params) {
  return new ZodMiniRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniMap = $constructor("ZodMiniMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSet = $constructor("ZodMiniSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniEnum = $constructor("ZodMiniEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodMiniEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniLiteral = $constructor("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniFile = $constructor("ZodMiniFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTransform = $constructor("ZodMiniTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodMiniType.init(inst, def);
});
function transform(fn) {
  return new ZodMiniTransform({
    type: "transform",
    transform: fn
  });
}
var ZodMiniOptional = $constructor("ZodMiniOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
function optional(innerType) {
  return new ZodMiniOptional({
    type: "optional",
    innerType
  });
}
var ZodMiniNullable = $constructor("ZodMiniNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodMiniType.init(inst, def);
});
function nullable(innerType) {
  return new ZodMiniNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodMiniDefault = $constructor("ZodMiniDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _default2(innerType, defaultValue) {
  return new ZodMiniDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodMiniPrefault = $constructor("ZodMiniPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNonOptional = $constructor("ZodMiniNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSuccess = $constructor("ZodMiniSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCatch = $constructor("ZodMiniCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNaN = $constructor("ZodMiniNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPipe = $constructor("ZodMiniPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodMiniType.init(inst, def);
});
function pipe2(in_, out) {
  return new ZodMiniPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodMiniReadonly = $constructor("ZodMiniReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTemplateLiteral = $constructor("ZodMiniTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniLazy = $constructor("ZodMiniLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPromise = $constructor("ZodMiniPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCustom = $constructor("ZodMiniCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodMiniType.init(inst, def);
});
function refine(fn, _params = {}) {
  return _refine(ZodMiniCustom, fn, _params);
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/mini/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodMiniISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodMiniISODateTime, params);
}
var ZodMiniISODate = $constructor("$ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodMiniISODate, params);
}
var ZodMiniISOTime = $constructor("$ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodMiniISOTime, params);
}
var ZodMiniISODuration = $constructor("$ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodMiniISODuration, params);
}

// node_modules/@dynamic-labs/wallet-book/node_modules/zod/v4/mini/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint2,
  boolean: () => boolean3,
  date: () => date3,
  number: () => number2,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodMiniString, params);
}
function number2(params) {
  return _coercedNumber(ZodMiniNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodMiniBoolean, params);
}
function bigint2(params) {
  return _coercedBigint(ZodMiniBigInt, params);
}
function date3(params) {
  return _coercedDate(ZodMiniDate, params);
}

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/nonEmptyString.js
var nonEmptyString = optional(pipe2(transform((val) => val ? val : void 0), optional(string2())));

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/filterEmptyObject.js
var filterEmptyObject = (val) => val && Object.values(val).some((x) => Boolean(x)) ? val : void 0;

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/nonEmptyStringArray.js
var nonEmptyStringArray = optional(pipe2(transform((val) => Array.isArray(val) && val.length > 0 ? val : void 0), optional(array(string2()))));

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformAndroidId.js
var transformAndroidId = (url) => {
  if (!(url === null || url === void 0 ? void 0 : url.match(/^https?:\/\//)))
    return url;
  if (!url)
    return;
  try {
    const urlObject = new URL(url);
    const id = urlObject.searchParams.get("id");
    if (id) {
      return id;
    }
  } catch (_a5) {
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformChromeExtensionId.js
var transformChromeExtensionId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(/^[a-z]{32}$/))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("chrome.google.com/webstore/detail/")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.split("/").at(-1);
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformEdgeExtensionId.js
var transformEdgeExtensionId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(/^[a-z]{32}$/))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("microsoftedge.microsoft.com/addons/detail/")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.split("/").at(-1);
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformFirefoxExtensionId.js
var transformFirefoxExtensionId = (url) => {
  if (!(url === null || url === void 0 ? void 0 : url.match(/^https?:\/\//)))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("addons.mozilla.org")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.replace(/\/$/, "").split("/").at(-1);
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformIosId.js
var idRegex = /^id[0-9]{1,36}$/;
var transformIosId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(idRegex))
    return url;
  if (url === null || url === void 0 ? void 0 : url.match(/^https:\/\/[a-zA-Z0-9-]+\.apple\.com/)) {
    try {
      const urlObject = new URL(url);
      const expectedId = urlObject.pathname.replace(/\/$/, "").split("/").at(-1);
      if (expectedId === null || expectedId === void 0 ? void 0 : expectedId.match(idRegex)) {
        return expectedId;
      }
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletSchema.js
var injectedConfigSchema = object({
  chain: string2(),
  extensionLocators: array(object({
    flag: string2(),
    value: _default2(optional(boolean2()), true)
  })),
  /**
   * Allows declaring which interface, if any, this wallet's implementation follows
   * ex. Leather with https://btckit.org/
   */
  providerInterface: optional(string2()),
  /**
   * Allows declaring that this wallet is discoverable through the the Wallet Standard
   * See https://github.com/wallet-standard/wallet-standard
   * Also allows ignoring wallets that don't support the provided features
   */
  walletStandard: optional(object({
    features: array(string2()),
    name: string2(),
    providerId: optional(string2())
  })),
  walletStandardLocators: optional(array(object({ locator: string2(), name: string2() }))),
  windowLocations: optional(array(string2())).check(refine((val) => {
    if (!val)
      return true;
    if (!val.some((v) => ["ethereum", "ethereum.providers"].includes(v)))
      return true;
    return false;
  }, {
    message: "windowLocations cannot include ethereum or ethereum.providers as they are included by default",
    path: ["config"]
  }))
});
var brandSchema = object({
  alt: nonEmptyString,
  primaryColor: nonEmptyString,
  spriteId: nonEmptyString
});
var walletSchema = pipe2(pipe2(transform((val) => val), object({
  brand: optional(brandSchema),
  chainGroup: optional(string2()),
  chains: optional(array(string2())),
  desktop: optional(pipe2(object({
    chromeId: optional(pipe2(nonEmptyString, transform(transformChromeExtensionId))),
    edgeId: optional(pipe2(nonEmptyString, transform(transformEdgeExtensionId))),
    firefoxId: optional(pipe2(nonEmptyString, transform(transformFirefoxExtensionId))),
    native: nonEmptyString,
    operaId: nonEmptyString,
    safariId: nonEmptyString,
    universal: nonEmptyString
  }), transform(filterEmptyObject))),
  eip6963Config: optional(object({ rdns: string2() })),
  filterFromWalletConnect: optional(boolean2()),
  group: optional(string2()),
  /**
   * Indicates which hardware wallets are enabled for this wallet
   */
  hardwareWallets: optional(array(string2())),
  injectedConfig: optional(array(injectedConfigSchema)),
  mobile: optional(pipe2(optional(object({
    android: nullish2(string2()),
    androidId: optional(pipe2(nonEmptyString, transform(transformAndroidId))),
    /**
     * @deprecated Use inAppBrowserV2 instead for EVM wallet deep linking
     */
    inAppBrowser: nullish2(string2()),
    inAppBrowserV2: nullish2(string2()),
    ios: nullish2(string2()),
    iosId: optional(pipe2(nonEmptyString, transform(transformIosId))),
    native: nonEmptyString,
    universal: nonEmptyString
  })), transform(filterEmptyObject))),
  mobileExperience: optional(_enum2(["in-app-browser", "redirect"])),
  name: string2(),
  /**
   * Indicates if the wallet requires disconnecting current wallet before connecting a new one.
   * An example is Slush.
   */
  requiresDisconnectBeforeNewConnection: optional(boolean2()),
  shortName: nonEmptyString,
  showOnlyIfInstalled: optional(boolean2()),
  switchNetworkOnlyFromWallet: optional(boolean2()),
  walletConnect: optional(pipe2(optional(object({
    sdks: nonEmptyStringArray
  })), transform(filterEmptyObject))),
  walletGroup: optional(string2()),
  /**
   * Indicates which connector methods/events are not supported, keyed by wallet type
   */
  walletLimitations: optional(object({
    browserExtension: optional(object({
      unsupportedEvents: optional(array(string2())),
      unsupportedMethods: optional(array(string2()))
    })),
    mobile: optional(object({
      unsupportedEvents: optional(array(string2())),
      unsupportedMethods: optional(array(string2()))
    }))
  }))
})), transform((val) => {
  var _a5, _b, _c, _d, _e, _f;
  if (val.group) {
    val.chainGroup = val.group;
  }
  if (((_a5 = val.mobile) === null || _a5 === void 0 ? void 0 : _a5.iosId) || ((_b = val.mobile) === null || _b === void 0 ? void 0 : _b.ios) === null) {
    (_c = val.mobile) === null || _c === void 0 ? true : delete _c.ios;
  }
  if (((_d = val.mobile) === null || _d === void 0 ? void 0 : _d.androidId) || ((_e = val.mobile) === null || _e === void 0 ? void 0 : _e.android) === null) {
    (_f = val.mobile) === null || _f === void 0 ? true : delete _f.android;
  }
  return val;
}));

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletGroup.js
var WalletOverrideEntrySchema = object({
  brand: optional(brandSchema),
  name: nonEmptyString
});
var walletGroupSchema = object({
  brand: optional(object({
    alt: nonEmptyString,
    primaryColor: nonEmptyString,
    spriteId: nonEmptyString
  })),
  key: string2(),
  name: string2(),
  walletOverrides: optional(record(string2(), WalletOverrideEntrySchema))
});

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletBookSchema.js
record(string2(), walletSchema);
var walletBookSchema = pipe2(transform((val) => val), object({
  groups: record(string2(), walletGroupSchema),
  wallets: record(string2(), walletSchema)
}));
record(string2(), walletGroupSchema);

// node_modules/@dynamic-labs/wallet-book/src/hooks/fetchWalletBook/fetchWalletBook.js
var walletBookCache = { current: {} };
var walletBookEmitter = new eventemitter3_default3();
var fetchWalletBook = () => __awaiter3(void 0, void 0, void 0, function* () {
  const url = getWalletBookCdnUrl();
  const fn = () => __awaiter3(void 0, void 0, void 0, function* () {
    const res = yield fetch(url, { mode: "cors" });
    if (!res.ok) {
      throw new Error(`Failed to fetch wallet book data from ${url} with status code ${res.status}`);
    }
    const json = yield res.json();
    try {
      const parsedData = walletBookSchema.parse(json);
      return parsedData;
    } catch (e) {
      logger5.error("Error parsing wallet book data", e, json);
      throw e;
    }
  });
  walletBookCache.current = yield retryableFn(fn, {
    fallbackValue: walletBookSchema.parse(walletBookFallbacks),
    maxRetries: 3,
    retryStrategy: "timeout-and-rejection",
    timeoutMs: 3e4
  });
  walletBookEmitter.emit("walletBookLoaded", walletBookCache.current);
});

// node_modules/@dynamic-labs/wallet-book/src/hooks/useWalletBookCdn.js
fetchWalletBook();
var useWalletBookCdn = () => {
  const [walletBookState, setWalletBookState] = (0, import_react4.useState)(walletBookCache.current);
  (0, import_react4.useEffect)(() => {
    walletBookEmitter.on("walletBookLoaded", setWalletBookState);
    setWalletBookState(walletBookCache.current);
    return () => {
      walletBookEmitter.off("walletBookLoaded", setWalletBookState);
    };
  }, []);
  return walletBookState;
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletIcon.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletIconData.js
var getWalletIconData = (walletBook, walletKey, isGroup) => {
  if (!walletKey) {
    return {
      walletIconAlt: "",
      walletIconUrl: ""
    };
  }
  try {
    const walletData = isGroup ? findWalletGroup(walletBook, walletKey) : getWalletBookWallet(walletBook, walletKey);
    const iconData = walletData === null || walletData === void 0 ? void 0 : walletData.brand;
    if (iconData) {
      return {
        walletIconAlt: iconData.alt,
        walletIconUrl: getBrandIconUrl(iconData)
      };
    }
  } catch (err) {
    logger5.debug(err);
  }
  return {
    walletIconAlt: "",
    walletIconUrl: ""
  };
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletIcon.js
var WalletBookWalletIcon = (_a5) => {
  var { walletKey, isGroup, children } = _a5, props = __rest2(_a5, ["walletKey", "isGroup", "children"]);
  const { walletBook } = useWalletBookContext();
  const [imgError, setImgError] = (0, import_react5.useState)(false);
  const { walletIconUrl, walletIconAlt } = getWalletIconData(walletBook, walletKey, isGroup);
  const defaultWalletIconUrl = getDefaultWalletIconUrl();
  if (!walletIconUrl) {
    return (0, import_react5.createElement)(import_react5.Fragment, {}, children);
  }
  const onError = () => {
    setImgError(true);
  };
  return (0, import_react5.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: walletIconAlt, key: walletKey, onError, src: imgError ? defaultWalletIconUrl : walletIconUrl }), children);
};
var WalletIcon = (_a5) => {
  var { icon, walletKey, isGroup, children } = _a5, props = __rest2(_a5, ["icon", "walletKey", "isGroup", "children"]);
  if (!icon) {
    return (0, import_react5.createElement)(WalletBookWalletIcon, Object.assign({
      children,
      isGroup,
      walletKey
    }, props));
  }
  return (0, import_react5.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: walletKey, key: walletKey, src: icon }), children);
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletBookContextProvider.js
var import_react6 = __toESM(require_react(), 1);
var WalletBookContextProvider = ({ walletBook, children }) => (0, import_react6.createElement)(WalletBookContext.Provider, {
  value: { walletBook }
}, children);

// node_modules/@dynamic-labs/wallet-book/src/components/BrandIcon.js
var import_react7 = __toESM(require_react(), 1);
var BrandIcon = (_a5) => {
  var { brand, walletKey } = _a5, props = __rest2(_a5, ["brand", "walletKey"]);
  const [imgError, setImgError] = (0, import_react7.useState)(false);
  const walletIconUrl = getBrandIconUrl(brand);
  const defaultWalletIconUrl = getDefaultWalletIconUrl();
  if (!walletIconUrl) {
    return (0, import_react7.createElement)(import_react7.Fragment, {});
  }
  const onError = () => {
    setImgError(true);
  };
  return (0, import_react7.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: brand.alt, onError, src: imgError ? defaultWalletIconUrl : walletIconUrl }));
};

// node_modules/@dynamic-labs/wallet-book/src/index.js
assertPackageVersion("@dynamic-labs/wallet-book", version4);

// node_modules/@dynamic-labs/wallet-connector-core/package.js
var version6 = "4.57.1";

// node_modules/@dynamic-labs/wallet-connector-core/node_modules/eventemitter3/index.mjs
var import_index4 = __toESM(require_eventemitter34(), 1);
var eventemitter3_default4 = import_index4.default;

// node_modules/@dynamic-labs/wallet-connector-core/src/events/walletConnectorEvents.js
var walletConnectorEvents = new eventemitter3_default4();

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/logger.js
var logger6 = new Logger("WalletConnector");

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/ProviderLookup/ProviderLookup.js
var ProviderLookup = (installedProviders, extensionLocators) => {
  if (extensionLocators.length === 0) {
    return void 0;
  }
  return installedProviders.find((provider) => {
    const extensionLocatorMatch = extensionLocators.every((condition) => {
      const flagValue = (provider === null || provider === void 0 ? void 0 : provider[condition.flag]) || false;
      return flagValue === condition.value;
    });
    return extensionLocatorMatch === true;
  });
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getChainInfo/getChainInfo.js
var createChainInfo = (blockchainName, name2, symbol, displayName) => ({
  blockchainName,
  displayName: displayName !== null && displayName !== void 0 ? displayName : blockchainName,
  name: name2,
  symbol
});
var chainsInfo = [
  createChainInfo("Algorand", "algorand", "ALGO"),
  createChainInfo("Aptos", "aptos", "APTOS"),
  createChainInfo("Bitcoin", "bitcoin", "BTC"),
  createChainInfo("Cosmos", "cosmos", "COSMOS"),
  createChainInfo("Eclipse", "eclipse", "ECLIPSE"),
  createChainInfo("Ethereum", "evm", "ETH", "EVM"),
  createChainInfo("Flow", "flow", "FLOW"),
  createChainInfo("Solana", "solana", "SOL"),
  createChainInfo("Spark", "spark", "SPARK"),
  createChainInfo("Starknet", "starknet", "ETH"),
  createChainInfo("Sui", "sui", "SUI"),
  createChainInfo("Tron", "tron", "TRON"),
  createChainInfo("TON", "ton", "TON")
];
var chainOverrides = {
  algo: "algorand",
  bip122: "bitcoin",
  btc: "bitcoin",
  eip155: "evm",
  eth: "evm",
  sol: "solana",
  stark: "starknet",
  sui: "sui"
};
var chainInfoOverrides;
var setChainInfoOverrides = (overrides) => {
  chainInfoOverrides = overrides;
};
var getChainInfo = (chain) => {
  var _a5;
  const lowerCasedChain = chain.toLowerCase();
  const normalizedChain = (_a5 = chainOverrides[lowerCasedChain]) !== null && _a5 !== void 0 ? _a5 : lowerCasedChain;
  const chainInfo = chainsInfo.find((info) => info.name === normalizedChain || info.symbol.toLocaleLowerCase() === normalizedChain);
  if (!chainInfo) {
    return;
  }
  return chainInfo;
};
var getChainInfoWithOverrides = (chain) => {
  var _a5, _b;
  const chainInfo = getChainInfo(chain);
  if (!chainInfo) {
    return;
  }
  const overrides = chainInfoOverrides === null || chainInfoOverrides === void 0 ? void 0 : chainInfoOverrides[chainInfo.name];
  const chainInfoClone = Object.assign({}, chainInfo);
  if (overrides) {
    chainInfoClone.blockchainName = (_a5 = overrides.displayName) !== null && _a5 !== void 0 ? _a5 : chainInfo.blockchainName;
    chainInfoClone.displayName = (_b = overrides.displayName) !== null && _b !== void 0 ? _b : chainInfo.displayName;
  }
  return chainInfoClone;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmailOTPWalletConnector/isEmailOTPWalletConnector.js
var isEmailOTPWalletConnector = (walletConnector) => Boolean(walletConnector.verifyOneTimePassword);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmailWalletConnector/isEmailWalletConnector.js
var isEmailWalletConnector = (walletConnector) => Boolean(walletConnector.clearEmail);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isTurnkeyWalletConnector/isTurnkeyWalletConnector.js
var isTurnkeyWalletConnector = (walletConnector) => {
  const turnkeyWalletConnector = walletConnector;
  return Boolean(turnkeyWalletConnector && turnkeyWalletConnector.key === "turnkeyhd" && typeof turnkeyWalletConnector.getWebAuthnAttestation === "function" && typeof turnkeyWalletConnector.getAuthenticatorHandler === "function" && typeof turnkeyWalletConnector.getExportHandler === "function" && typeof turnkeyWalletConnector.isSessionKeyCompatible === "function" && typeof turnkeyWalletConnector.createOrRestoreSession === "function");
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/shouldLowercaseAddress.js
var shouldLowercaseAddress = (chain) => (
  // these are standard from CAIP-2: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md
  // see also: https://github.com/ChainAgnostic/namespaces
  // note: no standard namespace currently exists for flow
  ["eip155", "flow", "evm", "eth", "avax", "matic"].includes(chain.toLowerCase())
);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSameAddress/utils/normalizeAddress/normalizeAddress.js
var normalizeAddress = (rawAddress, chain) => {
  let address = rawAddress;
  if (address === null || address === void 0 ? void 0 : address.startsWith("0x")) {
    address = address.slice(2);
  }
  address = shouldLowercaseAddress(chain) ? address === null || address === void 0 ? void 0 : address.toLowerCase() : address;
  return address;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSameAddress/isSameAddress.js
var isSameAddress = (left, right, chain) => normalizeAddress(left, chain) === normalizeAddress(right, chain);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSocialWalletConnector/isSocialWalletConnector.js
var isSocialWalletConnector = (walletConnector) => Boolean(walletConnector.canConnectViaSocial);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletConnectorByKey.js
var filterWalletsByKey = (wallets2, keys, chain) => keys.flatMap((key) => wallets2.find((w) => walletHasKey(w, key, chain))).filter(isWalletConnector);
var walletHasKey = (wallet, key, chain) => wallet.key === key && (chain ? wallet.connectedChain === chain : true);
var isWalletConnector = (item) => Boolean(item);
var getWalletConnectorByKey = (wallets2, key, chain) => {
  const filteredWallets = filterWalletsByKey(wallets2, [key], chain);
  return filteredWallets.length > 0 ? filteredWallets[0] : null;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/walletConnectDeepLinks/walletConnectDeepLinks.js
var getConnectionDeepLink = (uri, deepLinks, preference) => {
  if (isAndroid()) {
    return uri;
  }
  const deepLink = getRegularDeepLink(uri, deepLinks, preference);
  if (!deepLink) {
    return `${deepLink}?uri=${encodeURIComponent(uri)}`;
  }
  const deepLinkUrl = new URL(deepLink);
  const deepLinkParams = new URLSearchParams(deepLinkUrl.search);
  deepLinkParams.set("uri", uri);
  deepLinkUrl.search = deepLinkParams.toString();
  return deepLinkUrl.toString();
};
var getRegularDeepLink = (uri, deepLinks, preference) => {
  var _a5, _b, _c, _d;
  if (isAndroid()) {
    return uri.split("?")[0];
  }
  const index = isMobile() ? "mobile" : "desktop";
  let origin;
  if (preference === "native") {
    origin = ((_a5 = deepLinks[index]) === null || _a5 === void 0 ? void 0 : _a5.native) || ((_b = deepLinks[index]) === null || _b === void 0 ? void 0 : _b.universal);
  } else {
    origin = ((_c = deepLinks[index]) === null || _c === void 0 ? void 0 : _c.universal) || ((_d = deepLinks[index]) === null || _d === void 0 ? void 0 : _d.native);
  }
  return origin || "";
};
var getDeepLink = ({ mode, uri = "", deepLinks, preference }) => {
  if (!deepLinks) {
    return "";
  }
  switch (mode) {
    case "connection":
      return getConnectionDeepLink(uri, deepLinks, preference);
    case "regular":
      return getRegularDeepLink(uri, deepLinks, preference);
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/_virtual/_tslib.js
function __rest3(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter4(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/walletConnectDeepLinks/performPlatformSpecificConnectionMethod.js
var performPlatformSpecificConnectionMethod = (uri, deepLinks, opts, preference) => __awaiter4(void 0, void 0, void 0, function* () {
  var _a5, _b, _c;
  const deepLink = getDeepLink({
    deepLinks,
    mode: "connection",
    preference,
    uri
  });
  if (isMobile()) {
    yield PlatformService.openURL(deepLink);
  } else {
    if ((_a5 = deepLinks === null || deepLinks === void 0 ? void 0 : deepLinks.desktop) === null || _a5 === void 0 ? void 0 : _a5.native) {
      (_b = opts.onDesktopUri) === null || _b === void 0 ? void 0 : _b.call(opts, deepLink);
    }
    (_c = opts.onDisplayUri) === null || _c === void 0 ? void 0 : _c.call(opts, uri);
  }
});

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmbeddedConnector/isEmbeddedConnector.js
var isEmbeddedConnector = (connector) => Boolean(connector.isEmbeddedWallet);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isMagicConnector/isMagicConnector.js
var isMagicConnector = (connector) => ["magicemailotp", "magicsocial"].includes(connector.key);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isBloctoConnector/isBloctoConnector.js
var isBloctoConnector = (connector) => ["bloctoemail", "bloctoevm", "Blocto"].includes(connector.key);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isPasskeyWalletConnector/isPasskeyWalletConnector.js
var isPasskeyWalletConnector = (walletConnector) => Boolean(walletConnector.getWebAuthnAttestation);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isAccountAbstractionConnector/isAccountAbstractionConnector.js
var isAccountAbstractionConnector = (walletConnector) => walletConnector !== void 0 && walletConnector !== null && typeof walletConnector === "object" && "canSponsorTransactionGas" in walletConnector;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isBitcoinConnector/isBitcoinConnector.js
var isBitcoinConnector = (connector) => Boolean(connector === null || connector === void 0 ? void 0 : connector.sendBitcoin);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isHardwareWalletConnector/isHardwareWalletConnector.js
var isHardwareWalletConnector = (connector) => "canConnectWithHardwareWallet" in connector;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isPhantomRedirectConnector/isPhantomRedirectConnector.js
var isPhantomRedirectConnector = (connector) => connector.key === "phantom" && connector.extractSignature !== void 0;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isWalletConnectConnector/isWalletConnectConnector.js
var isWalletConnectConnector = (connector) => Boolean(connector === null || connector === void 0 ? void 0 : connector.isWalletConnect);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSendBalanceWalletConnector/isSendBalanceWalletConnector.js
var isSendBalanceWalletConnector = (walletConnector) => {
  var _a5;
  return "createUiTransaction" in walletConnector && typeof walletConnector.createUiTransaction === "function" && walletConnector.isAvailable && !((_a5 = walletConnector.isSendBalanceUnsupported) === null || _a5 === void 0 ? void 0 : _a5.call(walletConnector));
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSessionKeyCompatible/isSessionKeyCompatibleWalletConnector/isSessionKeyCompatibleWalletConnector.js
var isSessionKeyCompatibleWalletConnector = (walletConnector) => {
  const connector = walletConnector;
  return Boolean(typeof (connector === null || connector === void 0 ? void 0 : connector.isSessionKeyCompatible) === "function" && connector.isSessionKeyCompatible());
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSessionKeyCompatible/isSessionKeyCompatibleWallet/isSessionKeyCompatibleWallet.js
var isSessionKeyCompatibleWallet = (wallet) => isSessionKeyCompatibleWalletConnector(wallet.connector);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getMobileExperience/getMobileExperience.js
var getMobileExperienceFromProp = ({ mobileExperienceProp, walletKey }) => {
  if (!mobileExperienceProp) {
    return void 0;
  }
  if (typeof mobileExperienceProp === "string") {
    return mobileExperienceProp;
  }
  if (mobileExperienceProp[walletKey]) {
    return mobileExperienceProp[walletKey];
  }
  if (mobileExperienceProp.default) {
    return mobileExperienceProp.default;
  }
  return void 0;
};
var getMobileExperience = ({ mobileExperienceProp, walletBook, walletKey, walletConnector }) => {
  logger6.logVerboseTroubleshootingMessage("[getMobileExperience]", {
    mobileExperienceProp,
    walletKey
  });
  const mobileExperienceFromProp = getMobileExperienceFromProp({
    mobileExperienceProp,
    walletKey
  });
  const supportsRedirect = walletConnector.isWalletConnect || walletConnector.canConnectViaCustodialService;
  if (mobileExperienceFromProp && (supportsRedirect || mobileExperienceFromProp !== "redirect")) {
    return mobileExperienceFromProp;
  }
  const walletBookRecord = findWalletBookWallet(walletBook, walletKey);
  logger6.logVerboseTroubleshootingMessage("[getMobileExperience]", {
    isWalletConnect: walletConnector.isWalletConnect,
    walletBookRecord
  });
  if (walletBookRecord === null || walletBookRecord === void 0 ? void 0 : walletBookRecord.mobileExperience) {
    return walletBookRecord.mobileExperience;
  }
  if (walletKey === "metamask") {
    return "redirect";
  }
  if (walletConnector.isWalletConnect) {
    return "redirect";
  }
  return "in-app-browser";
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getDeepLinks/getDeepLinks.js
var getMobileDeepLinks = (mobile) => {
  if (!mobile) {
    return;
  }
  return {
    native: mobile.native,
    universal: mobile.universal
  };
};
var getDesktopDeepLinks = (desktop) => {
  if (!desktop) {
    return;
  }
  return {
    native: desktop.native,
    universal: desktop.universal
  };
};
var getDeepLinks = ({ mobile, desktop }) => {
  const mobileDeepLinks = getMobileDeepLinks(mobile);
  const desktopDeepLinks = getDesktopDeepLinks(desktop);
  if (!mobileDeepLinks && !desktopDeepLinks) {
    return;
  }
  return {
    desktop: desktopDeepLinks,
    mobile: mobileDeepLinks
  };
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getDownloadLinks/getDownloadLinks.js
var getMobileDownloadLinks = (mobile) => {
  if (!mobile) {
    return;
  }
  return {
    androidId: mobile.androidId,
    iosId: mobile.iosId
  };
};
var getDesktopDownloadLinks = (desktop) => {
  if (!desktop) {
    return;
  }
  return {
    chromeId: desktop.chromeId,
    edgeId: desktop.edgeId,
    firefoxId: desktop.firefoxId,
    operaId: desktop.operaId,
    safariId: desktop.safariId
  };
};
var getDownloadLinks = (wallet) => {
  const mobileLinks = getMobileDownloadLinks(wallet.mobile);
  const desktopLinks = getDesktopDownloadLinks(wallet.desktop);
  if (!mobileLinks && !desktopLinks) {
    return;
  }
  return Object.assign(Object.assign({}, mobileLinks), desktopLinks);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getIconUrl/getIconUrl.js
var getIconUrl = (spriteId) => {
  if (!spriteId) {
    return renderTemplate("iconicUrl", "defaultwallet");
  }
  return renderTemplate("iconicUrl", spriteId);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getValidHexColor/getValidHexColor.js
var getValidHexColor = (color) => {
  if (!color) {
    return;
  }
  const hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  return hexColorRegex.test(color) ? color : void 0;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getWalletLimitations/getWalletLimitations.js
var getWalletLimitations = (walletLimitations) => {
  if (!(walletLimitations === null || walletLimitations === void 0 ? void 0 : walletLimitations.browserExtension)) {
    return;
  }
  const { unsupportedEvents, unsupportedMethods } = walletLimitations.browserExtension;
  return {
    desktop: {
      unsupportedEvents,
      unsupportedMethods
    }
  };
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getWalletMetadataFromWalletBook.js
var getWalletMetadataFromWalletBook = ({ walletKey, walletBookWallet, walletBook, walletFallback }) => {
  var _a5, _b, _c, _d, _e, _f, _g, _h, _j;
  if (!isWalletBookPopulated(walletBook) && !walletFallback) {
    logger6.warn("Wallet book is required");
    return;
  }
  try {
    const wallet = walletBookWallet !== null && walletBookWallet !== void 0 ? walletBookWallet : getWalletBookWallet(walletBook, walletKey, walletFallback);
    if (!wallet) {
      logger6.warn("Wallet not found in wallet book");
      return;
    }
    return {
      brandColor: getValidHexColor((_a5 = wallet === null || wallet === void 0 ? void 0 : wallet.brand) === null || _a5 === void 0 ? void 0 : _a5.primaryColor),
      deepLinks: getDeepLinks({
        desktop: wallet === null || wallet === void 0 ? void 0 : wallet.desktop,
        mobile: wallet === null || wallet === void 0 ? void 0 : wallet.mobile
      }),
      downloadLinks: getDownloadLinks(wallet),
      groupKey: (_b = wallet === null || wallet === void 0 ? void 0 : wallet.chainGroup) !== null && _b !== void 0 ? _b : wallet === null || wallet === void 0 ? void 0 : wallet.walletGroup,
      icon: (_d = getIconUrl((_c = wallet === null || wallet === void 0 ? void 0 : wallet.brand) === null || _c === void 0 ? void 0 : _c.spriteId)) !== null && _d !== void 0 ? _d : "",
      id: walletKey,
      inAppBrowserUrl: (_h = (_f = (_e = wallet.mobile) === null || _e === void 0 ? void 0 : _e.inAppBrowserV2) !== null && _f !== void 0 ? _f : (_g = wallet.mobile) === null || _g === void 0 ? void 0 : _g.inAppBrowser) !== null && _h !== void 0 ? _h : void 0,
      name: wallet.name,
      rdns: (_j = wallet.eip6963Config) === null || _j === void 0 ? void 0 : _j.rdns,
      supportedHardwareWallets: wallet.hardwareWallets,
      walletLimitations: getWalletLimitations(wallet.walletLimitations)
    };
  } catch (e) {
    logger6.warn("Error getting wallet metadata from wallet book", {
      error: e
    });
    return;
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isConnectorMethodSupported/isConnectorMethodSupported.js
var isConnectorMethodSupported = (connector, method, platform) => {
  var _a5, _b, _c;
  return !((_c = (_b = (_a5 = connector.metadata.walletLimitations) === null || _a5 === void 0 ? void 0 : _a5[platform]) === null || _b === void 0 ? void 0 : _b.unsupportedMethods) === null || _c === void 0 ? void 0 : _c.includes(method));
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isConnectorEventSupported/isConnectorEventSupported.js
var isConnectorEventSupported = (connector, event, platform) => {
  var _a5, _b, _c;
  return !((_c = (_b = (_a5 = connector.metadata.walletLimitations) === null || _a5 === void 0 ? void 0 : _a5[platform]) === null || _b === void 0 ? void 0 : _b.unsupportedEvents) === null || _c === void 0 ? void 0 : _c.includes(event));
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletLinks/getWalletLinks.js
var getWalletLinks = (downloadLinks) => {
  var _a5, _b, _c, _d, _e, _f, _g, _h;
  const links = {
    android: "",
    brave: "",
    chrome: "",
    edge: "",
    firefox: "",
    ios: ""
  };
  if (!downloadLinks) {
    return links;
  }
  links.brave = (_a5 = renderTemplate("chromeUrl", downloadLinks.chromeId)) !== null && _a5 !== void 0 ? _a5 : "";
  links.chrome = (_b = renderTemplate("chromeUrl", downloadLinks.chromeId)) !== null && _b !== void 0 ? _b : "";
  links.edge = (_c = renderTemplate("edgeUrl", downloadLinks.edgeId)) !== null && _c !== void 0 ? _c : "";
  links.firefox = (_d = renderTemplate("firefoxUrl", downloadLinks.firefoxId)) !== null && _d !== void 0 ? _d : "";
  links.ios = (_f = (_e = renderTemplate("iosUrl", downloadLinks.iosId)) !== null && _e !== void 0 ? _e : downloadLinks.iosUrl) !== null && _f !== void 0 ? _f : "";
  links.android = (_h = (_g = renderTemplate("androidUrl", downloadLinks.androidId)) !== null && _g !== void 0 ? _g : downloadLinks.androidUrl) !== null && _h !== void 0 ? _h : "";
  return links;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isDynamicWaasConnector/isDynamicWaasConnector.js
var isDynamicWaasConnector = (walletConnector) => {
  const dynamicWaasConnector = walletConnector;
  return Boolean(dynamicWaasConnector && dynamicWaasConnector.key === "dynamicwaas");
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletProvider/getWalletProvider.js
var getWalletProvider = (connector) => {
  if (connector.isEmbeddedWallet) {
    return WalletProviderEnum.EmbeddedWallet;
  }
  if (connector.canConnectViaCustodialService) {
    return WalletProviderEnum.CustodialService;
  }
  if (connector.isInstalledOnBrowser()) {
    return WalletProviderEnum.BrowserExtension;
  }
  return isMobile() ? WalletProviderEnum.DeepLink : WalletProviderEnum.QrCode;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/connectorRequiresDisconnectionForNewConnection/connectorRequiresDisconnectionForNewConnection.js
var connectorRequiresDisconnectionForNewConnection = (connector) => {
  if (!connector || !connector.key) {
    return false;
  }
  try {
    const { walletBook } = connector;
    if (!walletBook || !walletBook.wallets) {
      return false;
    }
    const walletBookRecord = findWalletBookWallet(walletBook, connector.key);
    if (!walletBookRecord) {
      return false;
    }
    return Boolean("requiresDisconnectBeforeNewConnection" in walletBookRecord && walletBookRecord.requiresDisconnectBeforeNewConnection);
  } catch (error79) {
    return false;
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/Wallet/Wallet.js
var Wallet = class extends BaseWallet {
  constructor(_a5) {
    var { connector } = _a5, props = __rest3(_a5, ["connector"]);
    super(props);
    this._connector = connector;
  }
  /**
   * Gets the wallet connector.
   */
  get connector() {
    return this._connector;
  }
  /**
   * Retrieves the balance of the wallet.
   * @returns A promise that resolves to the balance of the wallet as a string,
   * or undefined if the balance cannot be retrieved.
   */
  getBalance() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._connector.getBalance(this.address);
    });
  }
  /**
   * Retrieves the name service data associated with the wallet.
   * @returns A promise that resolves to the name service data of the wallet,
   * or undefined if the data cannot be retrieved.
   */
  getNameService() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._connector.getNameService(this.address);
    });
  }
  /**
   * Retrieves the network that the wallet is connected to.
   * @returns A promise that resolves to the network value as a string or number,
   * or undefined if the network cannot be retrieved.
   */
  getNetwork() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._connector.getNetwork(true);
    });
  }
  /**
   * If the wallet is connected.
   * @returns A promise that resolves to true the wallet is connected or false if it's not connected.
   */
  isConnected() {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const connectedAccounts = yield this._connector.getConnectedAccounts();
        return connectedAccounts.map((address) => normalizeAddress(address, this.chain)).includes(normalizeAddress(this.address, this.chain));
      } catch (error79) {
        logger6.error("[Wallet] isConnected - Error detecting if wallet is connected", error79);
        return false;
      }
    });
  }
  /**
   * Proves ownership of the wallet by signing a message.
   * @param messageToSign - The message to sign.
   * @returns A promise that resolves to the signature of the message as a string,
   *  or undefined if the message cannot be signed.
   */
  proveOwnership(messageToSign) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._connector.proveOwnership(this.address, messageToSign);
    });
  }
  /**
   * Signs a message using the wallet.
   * @param messageToSign - The message to sign.
   * @returns A promise that resolves to the signature of the message as a string,
   * or undefined if the message cannot be signed.
   */
  signMessage(messageToSign) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.signMessage(messageToSign, {
        address: this.address
      });
    });
  }
  /**
   * Switches the network that the wallet is connected to.
   * @param networkChainId - The chain id of the network to switch to.
   * @returns A promise that resolves when the network is switched.
   */
  switchNetwork(networkChainId) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._connector.switchNetwork({
        networkChainId
      });
    });
  }
  /**
   * Synchronizes the wallet with the connector.
   * @returns A promise that resolves when the wallet is connected and active.
   */
  sync() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._connector.validateActiveWallet(this.address);
    });
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/WalletBookSingleton/WalletBookSingleton.js
var WalletBookSingleton = class _WalletBookSingleton {
  constructor(walletBook) {
    this.walletBook = walletBook;
  }
  static getOrCreate(walletBook) {
    var _a5;
    if (!((_a5 = _WalletBookSingleton.instance) === null || _a5 === void 0 ? void 0 : _a5.walletBook)) {
      _WalletBookSingleton.instance = new _WalletBookSingleton(walletBook);
    }
    return _WalletBookSingleton.instance;
  }
  static reset() {
    _WalletBookSingleton.instance = void 0;
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/WalletConnectorBase/WalletConnectorBase.js
var _WalletConnectorBase_registeredExtensions;
var WalletConnectorBase = class _WalletConnectorBase extends eventemitter3_default4 {
  createWallet(props) {
    const wallet = new this.ChainWallet(props);
    return wallet;
  }
  /**
   * We store the constructor props so that we can use them later on
   * in getMobileOrInstalledWallet which may fall back to a different class
   * but will need the original constructor props.
   * @param props - constructor props
   */
  constructor(props) {
    super();
    this.chainRpcProviders = void 0;
    this.isGlobalTransaction = false;
    _WalletConnectorBase_registeredExtensions.set(this, []);
    this.didSetup = false;
    this.requiresNonDynamicEmailOtp = false;
    this.canConnectViaCustodialService = false;
    this.canConnectViaQrCode = false;
    this.canConnectViaSocial = false;
    this.canHandleMultipleConnections = true;
    this.mergeWalletBookChains = true;
    this.isAvailable = true;
    this.isEmbeddedWallet = false;
    this.isWalletConnect = false;
    this.overrideKey = void 0;
    this.providerResources = void 0;
    this.switchNetworkOnlyFromWallet = void 0;
    this.isInitialized = true;
    this.constructorProps = props;
    this._walletBookInstance = WalletBookSingleton.getOrCreate(props.walletBook);
    this._metadata = props.metadata;
    this.walletConnectorEventsEmitter = this.constructorProps.walletConnectorEventsEmitter || walletConnectorEvents;
    if (this.walletBook === void 0) {
      throw new Error("WalletConnectorBase was not called with super(props) and is missing wallet-book");
    }
  }
  extend(extension, settings) {
    if (__classPrivateFieldGet2(this, _WalletConnectorBase_registeredExtensions, "f").includes(extension.name)) {
      throw new Error(`You can only register a single extension of: ${extension.name}`);
    }
    if (extension.name === "global-wallet-extension") {
      if (!this.isEmbeddedWallet || !this.supportedChains.includes("EVM"))
        return;
    }
    __classPrivateFieldGet2(this, _WalletConnectorBase_registeredExtensions, "f").push(extension.name);
    extension.extend(this, settings !== null && settings !== void 0 ? settings : {});
  }
  /**
   * Add the event listeners for the wallet and connect
   * with event emitter.
   */
  initEventListener() {
    if (this.didSetup)
      return;
    this.didSetup = true;
    this.setupEventListeners();
  }
  get walletBook() {
    return this._walletBookInstance.walletBook;
  }
  filter() {
    return true;
  }
  get mobileExperience() {
    return getMobileExperience({
      mobileExperienceProp: this.constructorProps.mobileExperience,
      walletBook: this.walletBook,
      walletConnector: this,
      walletKey: this.key
    });
  }
  /**
   * Prompt the user to choose accounts to connect (see behavior in MM)
   * @default Promise<[]>
   */
  chooseAccountsToConnect() {
    return Promise.resolve([]);
  }
  connect() {
    return __awaiter4(this, void 0, void 0, function* () {
      yield this.getAddress();
    });
  }
  /**
   * Generic function to close the wallet connection
   *
   * Originally implemented for WalletConnect, but it is used
   * for anything that needs to be "logged out" or cleaned up.
   *
   * Remember to call teardownEventListeners() in the implementation.
   *
   * @default Promise<undefined>
   */
  endSession() {
    return Promise.resolve();
  }
  /**
   * Gets the public address of the wallet
   *
   * @default Promise<undefined>
   */
  getAddress(opts) {
    return Promise.resolve(void 0);
  }
  /**
   * Parses a public address to ensure it follows a correct format.
   *
   * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
   *
   * @default string
   */
  parseAddress(address) {
    return address;
  }
  /**
   * Whether this wallet connector is targeting a testnet.
   * So far only supported for EVM connectors.
   *
   * @default Promise<false>
   */
  isTestnet() {
    return Promise.resolve(false);
  }
  /**
   * Gets the additional addresses of the wallet, given the main address
   *
   * @default Promise<[]>
   */
  getAdditionalAddresses(mainAddress) {
    return Promise.resolve([]);
  }
  /**
   * Sets the additional addresses of the wallet, given the main address
   *
   * @default Promise<void>
   */
  setAdditionalAddresses(mainAddress, additionalAddresses) {
    return Promise.resolve();
  }
  /**
   * Gets the balance of the wallet
   *
   * @default Promise<undefined>
   */
  getBalance(address) {
    return Promise.resolve(void 0);
  }
  /**
   * Get the address silently
   *
   * This is used to check which accounts are already connected and
   * should silently attempt to reconnect. If the user refreshes their
   * page and gets disconnected, there's likely an issue with the
   * implementation of this method.
   *
   * @default Promise<[]>
   */
  getConnectedAccounts() {
    return Promise.resolve([]);
  }
  /**
   * Gets the deep link of the wallet
   *
   * @default undefined
   */
  getDeepLink() {
    return void 0;
  }
  getNetwork() {
    return Promise.resolve(void 0);
  }
  /**
   * Gets current network of connected wallet
   *
   * @default Promise<undefined>
   */
  getNameService(address) {
    return Promise.resolve(void 0);
  }
  getPublicClient() {
    return Promise.resolve(void 0);
  }
  getSession() {
    return __awaiter4(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  getSigner() {
    return Promise.resolve(void 0);
  }
  getWalletClient(chainId) {
    return void 0;
  }
  /**
   * Initialize the wallet connector with any async operations
   *
   * @default Promise<void>
   */
  init() {
    return Promise.resolve();
  }
  /**
   * Check if the wallet is installed on the browser
   *
   * @default false
   */
  isInstalledOnBrowser() {
    return false;
  }
  /**
   * Override key or the normalized wallet name if needed
   */
  get key() {
    return this.overrideKey || this.name.replace(/\W/g, "").toLowerCase();
  }
  get metadata() {
    var _a5;
    if (!this._metadata) {
      this._metadata = getWalletMetadataFromWalletBook({
        walletBook: this.walletBook,
        walletKey: this.key
      });
    }
    return (_a5 = this._metadata) !== null && _a5 !== void 0 ? _a5 : { icon: "", id: this.key, name: this.name };
  }
  /**
   * Whether the wallet connector should fall back to a different wallet connector
   * This is called after the object is instantiated, so it can't be a static property
   * and will return the appropriate instance of the wallet connector
   * @returns WalletConnector
   * @default this
   */
  getMobileOrInstalledWallet() {
    return this;
  }
  /**
   * In most cases this is an alias for `signMessage`
   *
   * @default Promise<undefined>
   */
  proveOwnership(address, messageToSign) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      return this.signMessage(messageToSign);
    });
  }
  /**
   * Set up event listeners for the wallet
   *
   * @default void
   */
  setupEventListeners() {
    return;
  }
  /**
   * Sign a message
   *
   * @default Promise<undefined>
   */
  signMessage(messageToSign, options) {
    return Promise.resolve(void 0);
  }
  /**
   * Returns the array of block explorer URLs available for the current network
   */
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter4(this, void 0, void 0, function* () {
      return [];
    });
  }
  /**
   * Whether the wallet supports network switching
   *
   * @default false
   */
  supportsNetworkSwitching() {
    return false;
  }
  switchNetwork({ networkName, networkChainId }) {
    return Promise.resolve(void 0);
  }
  /**
   * Tear down event listeners for the wallet
   * @default void
   */
  teardownEventListeners() {
    return;
  }
  /**
   * Receive the user verified credentials
   */
  setVerifiedCredentials(verifiedCredentials) {
    return;
  }
  /**
   * Whether the wallet allow for getting the address in the
   * current chain.
   * This is used for multi chain wallets.
   * @default true
   */
  canGetChainAddress() {
    return true;
  }
  /**
   * Prompts the user to make expected wallet active
   *
   * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
   * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
   * otherwise rejects with an error.
   */
  handleWalletNotActive(_a5) {
    return __awaiter4(this, arguments, void 0, function* ({ activeAddress, expectedAddress, reconnectedAddress }) {
      logger6.debug("validateActiveWallet - wallet is not active", {
        activeAddress,
        expectedAddress,
        reconnectedAddress
      });
      const currentActiveAddress = activeAddress || reconnectedAddress || "";
      const walletUiUtils = this.constructorProps.walletUiUtils;
      if (!walletUiUtils) {
        throw new WalletAddressMismatchError(`Wallet ${expectedAddress !== null && expectedAddress !== void 0 ? expectedAddress : ""} is not currently active in ${this.name || this.key}.`, {
          activeAddress: currentActiveAddress,
          expectedAddress,
          walletName: this.name || this.key
        });
      }
      return walletUiUtils.syncWallet({
        activeAddress: currentActiveAddress,
        expectedAddress,
        walletConnector: this
      });
    });
  }
  /**
   * Validates if the address is connected and active in the wallet app
   *
   * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
   * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
   * otherwise rejects with an error.
   */
  validateActiveWallet(expectedAddress) {
    return __awaiter4(this, void 0, void 0, function* () {
      logger6.debug("validateActiveWallet - validating wallet", expectedAddress);
      const canFetchConnectedAccounts = isConnectorMethodSupported(this, "getConnectedAccounts", "desktop");
      logger6.debug("validateActiveWallet - getting connected accounts", {
        canFetchConnectedAccounts
      });
      const [activeAddress] = canFetchConnectedAccounts ? yield this.getConnectedAccounts() : [];
      const isWalletActive = activeAddress && isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (isWalletActive) {
        logger6.debug("validateActiveWallet - wallet is active");
        return;
      }
      logger6.debug("validateActiveWallet - trying to reconnect wallet...");
      const getReconnectedAddress = () => __awaiter4(this, void 0, void 0, function* () {
        if (!this.canHandleMultipleConnections || !this.canGetChainAddress()) {
          return void 0;
        }
        return this.getAddress().catch((err) => {
          logger6.debug("validateActiveWallet - error getting address", err);
          return void 0;
        });
      });
      const reconnectedAddress = yield getReconnectedAddress();
      if (reconnectedAddress && isSameAddress(reconnectedAddress, expectedAddress, this.connectedChain)) {
        logger6.debug("validateActiveWallet - wallet reconnected successfuly");
        return;
      }
      return this.handleWalletNotActive({
        activeAddress,
        expectedAddress,
        reconnectedAddress
      });
    });
  }
  /**
   * Get the enabled networks for the wallet.
   *
   * These are normally set in the opts prop of the wallet connector constructor. The
   * network values are passed from project settings and can require an update to
   * [getWalletConnectorConstructorOptions] for new chains.
   *
   * @returns {GenericNetwork[]} The enabled networks
   */
  getEnabledNetworks() {
    return [];
  }
  /**
   * Retry the deeplink connection for mobile wallets
   * @default Promise<void>
   */
  retryDeeplinkConnection() {
    return;
  }
  /**
   * Check if retryDeeplinkConnection has been implemented by a subclass
   */
  hasRetryDeeplinkConnection() {
    return this.retryDeeplinkConnection !== _WalletConnectorBase.prototype.retryDeeplinkConnection;
  }
  /**
   * Open the inAppBrowser if required
   * @returns True if the inAppBrowser was opened, false otherwise.
   */
  openInAppBrowserIfRequired() {
    var _a5;
    if (this.isInstalledOnBrowser() || !isMobile() || !((_a5 = this.metadata) === null || _a5 === void 0 ? void 0 : _a5.inAppBrowserUrl) || this.mobileExperience === "redirect") {
      return false;
    }
    const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
    const { href } = PlatformService.getUrl();
    const deepLink = inAppBrowserCompiledTemplate({
      encodedDappURI: encodeURIComponent(href)
    });
    PlatformService.openURL(deepLink);
    return true;
  }
};
_WalletConnectorBase_registeredExtensions = /* @__PURE__ */ new WeakMap();

// node_modules/@dynamic-labs/wallet-connector-core/src/index.js
assertPackageVersion("@dynamic-labs/wallet-connector-core", version6);

// node_modules/@dynamic-labs/rpc-providers/package.js
var version7 = "4.57.1";

// node_modules/@dynamic-labs/rpc-providers/src/RpcProviders.js
var ProviderChain;
(function(ProviderChain2) {
  ProviderChain2["ECLIPSE"] = "eclipse";
  ProviderChain2["EVM"] = "evm";
  ProviderChain2["SOLANA"] = "solana";
  ProviderChain2["STARKNET"] = "starknet";
  ProviderChain2["SUI"] = "sui";
})(ProviderChain || (ProviderChain = {}));

// node_modules/@dynamic-labs/rpc-providers/_virtual/_tslib.js
function __awaiter5(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/rpc-providers/src/ChainRpcProviders.js
var ChainRpcProvidersClass = class _ChainRpcProvidersClass {
  static get client() {
    if (!_ChainRpcProvidersClass.instance) {
      _ChainRpcProvidersClass.instance = new _ChainRpcProvidersClass();
    }
    return _ChainRpcProvidersClass.instance;
  }
  constructor() {
    this.getProvidersMethods = {};
  }
  static getProviders(configurations) {
    Object.values(ProviderChain).forEach((chain) => {
      var _a5, _b;
      if (!_ChainRpcProvidersClass.providers[chain]) {
        const providers = (_b = (_a5 = _ChainRpcProvidersClass.client.getProvidersMethods)[chain]) === null || _b === void 0 ? void 0 : _b.call(_a5, configurations);
        if (providers) {
          Object.assign(_ChainRpcProvidersClass.providers, {
            [chain]: providers
          });
        }
      }
    });
    return _ChainRpcProvidersClass.providers;
  }
  static registerChainProviders(providerChain, fn) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!_ChainRpcProvidersClass.client.getProvidersMethods[providerChain]) {
        Object.assign(_ChainRpcProvidersClass.client.getProvidersMethods, {
          [providerChain]: fn
        });
      }
    });
  }
};
ChainRpcProvidersClass.providers = {};
ChainRpcProvidersClass.wipeInstance = () => {
  ChainRpcProvidersClass.instance = void 0;
  ChainRpcProvidersClass.providers = {};
};
var ChainRpcProviders = ChainRpcProvidersClass;

// node_modules/@dynamic-labs/rpc-providers/src/index.js
assertPackageVersion("@dynamic-labs/rpc-providers", version7);

// node_modules/@dynamic-labs-sdk/client/dist/constants-hy8OYHwt.esm.js
var import_buffer2 = __toESM(require_buffer(), 1);
var name = "@dynamic-labs-sdk/client";
var version8 = "0.4.0";
var dependencies = {
  "@dynamic-labs-sdk/assert-package-version": "workspace:*",
  "@dynamic-labs-wallet/browser-wallet-client": "0.0.250",
  "@dynamic-labs/sdk-api-core": "0.0.860",
  "@simplewebauthn/browser": "13.1.0",
  "buffer": "6.0.3",
  "eventemitter3": "5.0.1",
  "zod": "4.0.5"
};
var getCore = (client) => {
  return client.__core;
};
var getDetails = ({ details, cause }) => {
  if (cause instanceof BaseError) return cause.details;
  if (cause == null ? void 0 : cause.message) return cause.message;
  return details;
};
var formatMessage = ({ shortMessage, details, docsUrl, metaMessages }) => {
  return [
    shortMessage,
    "",
    ...metaMessages ? [...metaMessages, ""] : [],
    ...docsUrl ? [`Docs: ${docsUrl}`] : [],
    ...details ? [`Details: ${details}`] : [],
    `Version: ${version8}`,
    `Timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}`
  ].join("\n");
};
var BaseError = class BaseError2 extends Error {
  constructor(args) {
    const details = getDetails(args);
    const formattedMessage = formatMessage({
      ...args,
      details
    });
    super(args.shortMessage ?? formattedMessage, args.cause ? { cause: args.cause } : void 0);
    /** The error unique code */
    __publicField(this, "code");
    __publicField(this, "details");
    __publicField(this, "formattedMessage");
    __publicField(this, "name", "BaseError");
    __publicField(this, "cause");
    this.formattedMessage = formattedMessage;
    this.details = details;
    this.name = args.name ?? this.name;
    this.cause = args.cause ?? this.cause;
    this.code = args.code;
  }
  /**
  * Walks the cause chain of the error and returns the root error
  */
  walk() {
    const cause = this.cause;
    if (cause instanceof BaseError2) return cause.walk();
    return cause;
  }
  toString() {
    return this.formattedMessage;
  }
};
var ClientNotFoundError = class extends BaseError {
  constructor() {
    super({
      cause: null,
      code: "client_not_found_error",
      docsUrl: null,
      name: "ClientNotFoundError",
      shortMessage: "No Dynamic client has been created yet. Make sure you have called createDynamicClient() first."
    });
  }
};
var defaultClient = null;
var numOfInitializedClients = 0;
var getDefaultClient = () => {
  if (!defaultClient) throw new ClientNotFoundError();
  if (numOfInitializedClients > 1) getCore(defaultClient).logger.debug('Multiple instances of DynamicClient found. If you are only using one client (recommended), make sure you are not calling "createDynamicClient" multiple times. If you are using multiple clients, make sure you are passing which client to use as the last param of all Dynamic functions.');
  return defaultClient;
};
var setDefaultClient = (client) => {
  defaultClient = client;
  numOfInitializedClients++;
};
var DYNAMIC_API_VERSION_HEADER = "x-dyn-api-version";
var DYNAMIC_REQUEST_ID_HEADER = "x-dyn-request-id";
var DYNAMIC_SDK_VERSION_HEADER = "x-dyn-version";
var MFA_TOKEN_HEADER = "x-mfa-auth-token";
var SESSION_PUBLIC_KEY_HEADER = "x-dyn-session-public-key";
var DYNAMIC_SDK_API_VERSION = dependencies["@dynamic-labs/sdk-api-core"];
var CLIENT_SDK_NAME = "ClientSDK";
var randomString2 = (length) => {
  const CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  let result = "";
  for (let i = length; i > 0; --i) result += CHARS[Math.floor(Math.random() * 64)];
  return result;
};
var ValueMustBeDefinedError = class extends BaseError {
  constructor(message) {
    super({
      cause: null,
      code: "value_must_be_defined_error",
      docsUrl: null,
      name: "ValueMustBeDefined",
      shortMessage: message
    });
  }
};
function assertDefined2(value, message) {
  if (value === null || value === void 0) throw new ValueMustBeDefinedError(message);
}
var isCookieEnabled = (client) => {
  var _a5, _b;
  assertDefined2(client.projectSettings, "Project settings are not defined");
  const securitySettings = client.projectSettings.security;
  if (!securitySettings) return false;
  const dynamicCookiesEnabled = (((_a5 = securitySettings.auth) == null ? void 0 : _a5.storage) || []).includes(AuthStorageEnum.Cookie);
  const byoJwtCookieEnabled = Boolean((_b = securitySettings.externalAuth) == null ? void 0 : _b.cookieName);
  return dynamicCookiesEnabled || byoJwtCookieEnabled;
};
var getBuffer = () => typeof Buffer !== "undefined" ? Buffer : import_buffer2.Buffer;
var getSessionKeys = (client) => {
  const core = getCore(client);
  const encodedKeys = core.state.get().sessionKeys;
  if (!encodedKeys) return;
  try {
    return JSON.parse(getBuffer().from(encodedKeys, "base64").toString());
  } catch (error79) {
    core.logger.error("Error decoding session keys", error79);
    return;
  }
};
var APIError = class APIError2 extends BaseError {
  constructor(message, code, status) {
    super({
      cause: null,
      code,
      docsUrl: null,
      name: "APIError",
      shortMessage: message
    });
    __publicField(this, "status");
    this.status = status;
  }
  static async fromResponse(response) {
    try {
      const errorBody = await response.clone().json();
      if (errorBody && "error" in errorBody && typeof errorBody.error === "string") {
        const errorCode = "code" in errorBody && typeof errorBody.code === "string" ? errorBody.code : "unknown_error";
        return new APIError2(errorBody.error, errorCode, response.status);
      }
      return null;
    } catch {
      return null;
    }
  }
};
var InvalidExternalAuthError = class extends BaseError {
  constructor({ cause }) {
    super({
      cause,
      code: "invalid_external_auth_error",
      docsUrl: "https://www.dynamic.xyz/docs/external-auth/third-party-auth-overview",
      name: "InvalidExternalAuthError",
      shortMessage: "Error authenticating with external JWT"
    });
  }
};
var LinkCredentialError = class extends BaseError {
  constructor({ cause }) {
    super({
      cause,
      code: "link_credential_error",
      docsUrl: null,
      name: "LinkCredentialError",
      shortMessage: "The credential you are trying to link is associated with another account and cannot be reassigned."
    });
  }
};
var MfaInvalidOtpError = class extends BaseError {
  constructor({ cause }) {
    super({
      cause,
      code: "mfa_invalid_otp_error",
      docsUrl: null,
      name: "MfaInvalidOtpError",
      shortMessage: "Invalid OTP"
    });
  }
};
var MfaRateLimitedError = class extends BaseError {
  constructor({ cause }) {
    super({
      cause,
      code: "mfa_rate_limited_error",
      docsUrl: null,
      name: "MfaRateLimitedError",
      shortMessage: "Rate limited"
    });
  }
};
var SandboxMaximumThresholdReachedError2 = class extends BaseError {
  constructor({ cause }) {
    super({
      cause,
      code: "sandbox_maximum_threshold_reached_error",
      docsUrl: "https://www.dynamic.xyz/docs/developer-dashboard/sandbox-vs-live#sandbox-vs-live",
      name: "SandboxMaximumThresholdReachedError",
      shortMessage: "Your sandbox environment has reached the maximum MAU. Please use a live environment for production traffic."
    });
  }
};
var clientErrorMapper = (error79) => {
  if (error79 instanceof APIError) {
    if (error79.code === "mfa_invalid_code") return new MfaInvalidOtpError({ cause: error79 });
    if (error79.code === "mfa_rate_limited") return new MfaRateLimitedError({ cause: error79 });
    if (error79.code === "invalid_external_auth") return new InvalidExternalAuthError({ cause: error79 });
    if (error79.code === "sandbox_maximum_threshold_reached") return new SandboxMaximumThresholdReachedError2({ cause: error79 });
    if (error79.code === "merge_accounts_invalid" || error79.code === "reassign_wallet_error") return new LinkCredentialError({ cause: error79 });
  }
  return null;
};
var createConvertToApiErrorMiddleware = ({ errorMappers = [] }) => ({ post: async (context) => {
  if (context.response.status >= 400) {
    const apiError = await APIError.fromResponse(context.response);
    if (apiError) {
      let errorToThrow = apiError;
      for (const mapper of errorMappers) {
        const newError = mapper(apiError);
        if (newError) {
          errorToThrow = newError;
          break;
        }
      }
      throw errorToThrow;
    }
  }
  return context.response;
} });
var createApiClient = (options = {}, client) => {
  var _a5;
  const core = getCore(client);
  const coreState = core.state.get();
  const settings = {
    basePath: core.apiBaseUrl,
    headers: {
      "Content-Type": "application/json",
      [DYNAMIC_API_VERSION_HEADER]: `API/${DYNAMIC_SDK_API_VERSION}`,
      [DYNAMIC_REQUEST_ID_HEADER]: randomString2(50),
      [DYNAMIC_SDK_VERSION_HEADER]: `${CLIENT_SDK_NAME}/${version8}`,
      ...core.getApiHeaders(),
      ...options.headers
    }
  };
  if (client.token) settings.headers.Authorization = `Bearer ${client.token}`;
  if (client.projectSettings && isCookieEnabled(client)) settings.credentials = "include";
  if (options.includeMfaToken && coreState.mfaToken) settings.headers[MFA_TOKEN_HEADER] = coreState.mfaToken;
  const sessionPublicKey = (_a5 = getSessionKeys(client)) == null ? void 0 : _a5.publicKey;
  const isSessionPublicKeyHeaderPresent = settings.headers[SESSION_PUBLIC_KEY_HEADER] !== void 0;
  if (sessionPublicKey && !isSessionPublicKeyHeaderPresent) settings.headers[SESSION_PUBLIC_KEY_HEADER] = sessionPublicKey;
  return new SDKApi(new Configuration({
    ...settings,
    fetchApi: core.fetch,
    middleware: [createConvertToApiErrorMiddleware({ errorMappers: [...options.errorMappers || [], clientErrorMapper] })]
  }));
};
var CHAINS_INFO_MAP = {
  ALGO: {
    apiChainName: "algo",
    blockchainName: "Algorand",
    verifiedCredentialChainName: "algorand"
  },
  APTOS: {
    apiChainName: "aptos",
    blockchainName: "Aptos",
    verifiedCredentialChainName: "aptos"
  },
  BTC: {
    apiChainName: "bitcoin",
    blockchainName: "Bitcoin",
    verifiedCredentialChainName: "bip122"
  },
  COSMOS: {
    apiChainName: "cosmos",
    blockchainName: "Cosmos",
    verifiedCredentialChainName: "cosmos"
  },
  ECLIPSE: {
    apiChainName: "eclipse",
    blockchainName: "Eclipse",
    verifiedCredentialChainName: "eclipse"
  },
  EVM: {
    apiChainName: "evm",
    blockchainName: "Ethereum",
    verifiedCredentialChainName: "eip155"
  },
  FLOW: {
    apiChainName: "flow",
    blockchainName: "Flow",
    verifiedCredentialChainName: "flow"
  },
  SOL: {
    apiChainName: "solana",
    blockchainName: "Solana",
    verifiedCredentialChainName: "solana",
    waasChainNameOverride: "SVM"
  },
  SPARK: {
    apiChainName: "spark",
    blockchainName: "Spark",
    verifiedCredentialChainName: "spark"
  },
  STARK: {
    apiChainName: "starknet",
    blockchainName: "Starknet",
    verifiedCredentialChainName: "starknet"
  },
  STELLAR: {
    apiChainName: "stellar",
    blockchainName: "Stellar",
    verifiedCredentialChainName: "stellar"
  },
  SUI: {
    apiChainName: "sui",
    blockchainName: "Sui",
    verifiedCredentialChainName: "sui"
  },
  TON: {
    apiChainName: "ton",
    blockchainName: "TON",
    verifiedCredentialChainName: "ton"
  },
  TRON: {
    apiChainName: "tron",
    blockchainName: "Tron",
    verifiedCredentialChainName: "tron"
  }
};
var getChainFromVerifiedCredentialChain = (verifiedCredentialChain) => {
  const chain = Object.keys(CHAINS_INFO_MAP).find((chain$1) => CHAINS_INFO_MAP[chain$1].verifiedCredentialChainName === verifiedCredentialChain);
  assertDefined2(chain, `Unknown chain: ${verifiedCredentialChain}`);
  return chain;
};
var SDK_API_CORE_VERSION = dependencies["@dynamic-labs/sdk-api-core"];
var DYNAMIC_ICONIC_SPRITE_URL = "https://iconic.dynamic-static-assets.com/icons/sprite.svg";
var DYNAMIC_WAAS_METADATA = {
  displayName: "Dynamic WaaS",
  icon: `${DYNAMIC_ICONIC_SPRITE_URL}#dynamicwaas`,
  normalizedWalletName: "dynamicwaas"
};

// node_modules/@dynamic-labs-sdk/client/dist/getVerifiedCredentialForWalletAccount-c_lbXWMG.esm.js
var setCookie = (cookie) => {
  document.cookie = cookie;
};
var onEvent = ({ event, listener }, client = getDefaultClient()) => {
  const { eventEmitter } = getCore(client);
  eventEmitter.on(event, listener);
  return () => {
    eventEmitter.off(event, listener);
  };
};
var emitEvent = ({ event, args }, client) => {
  const { eventEmitter } = getCore(client);
  eventEmitter.emit(event, args);
};
var InvalidWalletProviderKeyError = class extends BaseError {
  constructor(value) {
    super({
      cause: null,
      code: "invalid_wallet_provider_key",
      docsUrl: null,
      name: "InvalidWalletProviderKeyError",
      shortMessage: `Invalid wallet provider key: ${value}. Key must be in the format of <normalizedWalletNameWithChain>:<walletProviderType>[:<suffix>]`
    });
  }
};
var splitWalletProviderKey = (walletProviderKey) => {
  const [normalizedWalletNameWithChain, walletProviderType, suffix, ...rest] = walletProviderKey.split(":");
  if (!normalizedWalletNameWithChain || !Object.values(WalletProviderEnum).includes(walletProviderType) || rest.length > 0) throw new InvalidWalletProviderKeyError(walletProviderKey);
  return {
    normalizedWalletNameWithChain,
    suffix,
    walletProviderType
  };
};
var normalizeAddress2 = (address, chain) => {
  let normalizedAddress = address;
  if (normalizedAddress == null ? void 0 : normalizedAddress.startsWith("0x")) normalizedAddress = normalizedAddress.slice(2);
  normalizedAddress = ["EVM", "FLOW"].includes(chain) ? normalizedAddress == null ? void 0 : normalizedAddress.toLowerCase() : normalizedAddress;
  return normalizedAddress;
};
var formatWalletAccountId = ({ address, chain, walletProviderKey }) => {
  const { normalizedWalletNameWithChain } = splitWalletProviderKey(walletProviderKey);
  return `${normalizedWalletNameWithChain}:${normalizeAddress2(address, chain)}`;
};
var convertUnverifiedWalletAccountToWalletAccount = ({ unverifiedWalletAccount }) => ({
  address: unverifiedWalletAccount.address,
  addressesWithTypes: unverifiedWalletAccount.addressesWithTypes,
  chain: unverifiedWalletAccount.chain,
  id: formatWalletAccountId({
    address: unverifiedWalletAccount.address,
    chain: unverifiedWalletAccount.chain,
    walletProviderKey: unverifiedWalletAccount.walletProviderKey
  }),
  lastSelectedAt: unverifiedWalletAccount.lastSelectedAt,
  verifiedCredentialId: null,
  walletProviderKey: unverifiedWalletAccount.walletProviderKey
});
var normalizeWalletNameWithChain = ({ displayName, chain }) => {
  const sanitizedWalletName = displayName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
  const chainLowered = chain.toLocaleLowerCase();
  if (sanitizedWalletName.endsWith(chainLowered)) return sanitizedWalletName;
  return `${sanitizedWalletName}${chainLowered}`;
};
var formatWalletProviderKey = ({ suffix, chain, displayName, walletProviderType }) => {
  return `${normalizeWalletNameWithChain({
    chain,
    displayName
  })}:${walletProviderType}${suffix ? `:${suffix}` : ""}`;
};
var getWalletProviderKeyFromVerifiedCredential = ({ verifiedCredential }, client) => {
  const { walletProviderKeyMap } = getCore(client).state.get();
  const storedWalletProviderKey = walletProviderKeyMap[verifiedCredential.id];
  if (storedWalletProviderKey) return { walletProviderKey: storedWalletProviderKey };
  assertDefined2(verifiedCredential.walletName, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletName`);
  assertDefined2(verifiedCredential.walletProvider, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletProvider`);
  assertDefined2(verifiedCredential.chain, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing chain`);
  return { walletProviderKey: formatWalletProviderKey({
    chain: getChainFromVerifiedCredentialChain(verifiedCredential.chain),
    displayName: verifiedCredential.walletName,
    walletProviderType: verifiedCredential.walletProvider
  }) };
};
var convertVerifiedCredentialToWalletAccount = ({ verifiedCredential }, client) => {
  assertDefined2(verifiedCredential.address, "Missing address in verified credential");
  assertDefined2(verifiedCredential.chain, "Missing chain in verified credential");
  const chain = getChainFromVerifiedCredentialChain(verifiedCredential.chain);
  const { walletProviderKey } = getWalletProviderKeyFromVerifiedCredential({ verifiedCredential }, client);
  const walletAccountId = formatWalletAccountId({
    address: verifiedCredential.address,
    chain,
    walletProviderKey
  });
  return {
    address: verifiedCredential.address,
    addressesWithTypes: verifiedCredential.walletAdditionalAddresses,
    chain,
    id: walletAccountId,
    lastSelectedAt: verifiedCredential.lastSelectedAt ?? null,
    verifiedCredentialId: verifiedCredential.id,
    walletProviderKey
  };
};
var getWalletAccountsFromState = ({ unverifiedWalletAccounts, user }, client) => {
  const walletAccountsMap = /* @__PURE__ */ new Map();
  unverifiedWalletAccounts.forEach((unverifiedWalletAccount) => {
    const walletAccount = convertUnverifiedWalletAccountToWalletAccount({ unverifiedWalletAccount });
    walletAccountsMap.set(walletAccount.id, walletAccount);
  });
  ((user == null ? void 0 : user.verifiedCredentials) ?? []).filter((verified) => verified.format === JwtVerifiedCredentialFormatEnum.Blockchain).forEach((verifiedWalletAccount) => {
    const walletAccount = convertVerifiedCredentialToWalletAccount({ verifiedCredential: verifiedWalletAccount }, client);
    walletAccountsMap.set(walletAccount.id, walletAccount);
  });
  return Array.from(walletAccountsMap.values());
};
var getWalletAccounts = (client = getDefaultClient()) => {
  const { unverifiedWalletAccounts, user } = getCore(client).state.get();
  return getWalletAccountsFromState({
    unverifiedWalletAccounts,
    user
  }, client);
};
var NoWalletProviderFoundError = class extends BaseError {
  constructor({ walletProviderKey }) {
    super({
      cause: null,
      code: "no_wallet_provider_found_error",
      docsUrl: null,
      name: "NoWalletProviderFoundError",
      shortMessage: `No wallet provider found with key: ${walletProviderKey}`
    });
  }
};
var createRuntimeServiceAccessKey = (key, builder) => (client) => {
  const { runtimeServices } = getCore(client);
  const currentService = runtimeServices.getByKey(key);
  if (currentService) return currentService;
  const service = builder(client);
  runtimeServices.register(key, service);
  return service;
};
var createWalletProviderRegistry = (client) => {
  const registry3 = /* @__PURE__ */ new Map();
  return {
    getByKey: (key) => {
      var _a5;
      return (_a5 = registry3.get(key)) == null ? void 0 : _a5.walletProvider;
    },
    listProviders: () => Array.from(registry3.values()).map((v) => v.walletProvider),
    register: (args) => {
      const existingEntry = registry3.get(args.walletProvider.key);
      if (existingEntry) {
        if (existingEntry.priority < args.priority) {
          registry3.set(args.walletProvider.key, args);
          emitEvent({
            args: { walletProviderKey: args.walletProvider.key },
            event: "walletProviderChanged"
          }, client);
        }
      } else {
        registry3.set(args.walletProvider.key, args);
        emitEvent({
          args: { walletProvider: args.walletProvider },
          event: "walletProviderRegistered"
        }, client);
        emitEvent({
          args: { walletProviderKey: args.walletProvider.key },
          event: "walletProviderChanged"
        }, client);
      }
    },
    unregister: (key) => {
      registry3.delete(key);
      emitEvent({
        args: { walletProviderKey: key },
        event: "walletProviderUnregistered"
      }, client);
    }
  };
};
var getWalletProviderRegistry = createRuntimeServiceAccessKey("walletProviderRegistry", (client) => createWalletProviderRegistry(client));
var WalletProviderPriority = (function(WalletProviderPriority$1) {
  WalletProviderPriority$1[WalletProviderPriority$1["WALLET_SDK"] = 100] = "WALLET_SDK";
  WalletProviderPriority$1[WalletProviderPriority$1["WALLET_SELF_ANNOUNCEMENT_STANDARD"] = 50] = "WALLET_SELF_ANNOUNCEMENT_STANDARD";
  WalletProviderPriority$1[WalletProviderPriority$1["WINDOW_INJECT"] = 20] = "WINDOW_INJECT";
  return WalletProviderPriority$1;
})({});
var getWalletProviderFromWalletAccount = ({ walletAccount }, client) => {
  const walletProvider = getWalletProviderRegistry(client).getByKey(walletAccount.walletProviderKey);
  if (!walletProvider) throw new NoWalletProviderFoundError({ walletProviderKey: walletAccount.walletProviderKey });
  return walletProvider;
};
var DYNAMIC_AUTH_COOKIE_NAME = "DYNAMIC_JWT_TOKEN";
var emitWalletAccountsChangedEvent = (client) => {
  emitEvent({
    args: { walletAccounts: getWalletAccounts(client) },
    event: "walletAccountsChanged"
  }, client);
};
var checkAndRaiseWalletAccountsChangedEvent = ({ previousState }, client) => {
  const core = getCore(client);
  if (getWalletAccountsHash(previousState, client) !== getWalletAccountsHash(core.state.get(), client)) emitWalletAccountsChangedEvent(client);
};
var getWalletAccountsHash = (state, client) => getWalletAccountsFromState(state, client).map((walletAccount) => JSON.stringify(walletAccount)).sort().join("-");
var getWalletProviders = (client) => {
  return getWalletProviderRegistry(client).listProviders();
};
var isWaasWalletProvider = (walletProvider) => {
  return walletProvider.key.includes(DYNAMIC_WAAS_METADATA.normalizedWalletName);
};
var findWaasWalletProviderByChain = ({ chain }, client) => {
  const providers = getWalletProviders(client);
  const waasProviderKey = formatWalletProviderKey({
    chain,
    displayName: DYNAMIC_WAAS_METADATA.displayName,
    walletProviderType: WalletProviderEnum.EmbeddedWallet
  });
  const waasProvider = providers.find((provider) => provider.key === waasProviderKey && provider.chain === chain);
  if (!waasProvider || !isWaasWalletProvider(waasProvider)) return null;
  return waasProvider;
};
var isWaasWalletAccount = ({ walletAccount }) => {
  return walletAccount.walletProviderKey.includes(DYNAMIC_WAAS_METADATA.normalizedWalletName);
};
var restoreUserSharesForAllWalletAccounts = async (client) => {
  const waasWalletAccounts = getWalletAccounts(client).filter((walletAccount) => isWaasWalletAccount({ walletAccount }));
  await Promise.all(waasWalletAccounts.map(async (walletAccount) => {
    const provider = findWaasWalletProviderByChain({ chain: walletAccount.chain }, client);
    if (!provider) return;
    return provider.restoreUserShareForWalletAccount({ walletAccount });
  }));
};
var updateAuthFromVerifyResponse = ({ response }, client) => {
  const core = getCore(client);
  const previousState = { ...core.state.get() };
  const { user, minifiedJwt, jwt, expiresAt, mfaToken } = response;
  const sessionExpiresAt = new Date(expiresAt * 1e3);
  const newState = {
    legacyToken: jwt ?? null,
    sessionExpiresAt,
    token: minifiedJwt ?? null,
    user
  };
  if (mfaToken) newState.mfaToken = mfaToken;
  core.state.set(newState);
  if (minifiedJwt && isCookieEnabled(client)) setCookie(`${DYNAMIC_AUTH_COOKIE_NAME}=${minifiedJwt}; expires=${sessionExpiresAt.toUTCString()}; path=/; SameSite=Lax`);
  checkAndRaiseWalletAccountsChangedEvent({ previousState }, client);
  if (!previousState.user && Boolean(newState.user)) restoreUserSharesForAllWalletAccounts(client);
};
var getWalletProviderByKey = ({ walletProviderKey }, client) => {
  const walletProvider = getWalletProviders(client).find((walletProvider$1) => walletProvider$1.key === walletProviderKey);
  if (!walletProvider) throw new NoWalletProviderFoundError({ walletProviderKey });
  return walletProvider;
};

// node_modules/@dynamic-labs-sdk/client/node_modules/eventemitter3/index.mjs
var import_index5 = __toESM(require_eventemitter35(), 1);
var eventemitter3_default5 = import_index5.default;

// node_modules/@dynamic-labs-sdk/client/dist/getNetworkProviderFromNetworkId-vL_E8aHC.esm.js
var isEqualShallow = (objA, objB) => {
  if (Object.is(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return objA === objB;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return false;
    for (const [key, value] of objA) if (!Object.is(value, objB.get(key))) return false;
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return false;
    for (const value of objA) if (!objB.has(value)) return false;
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) return false;
  for (const keyA of keysA) if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) return false;
  if (objA.constructor !== objB.constructor) return false;
  return true;
};
var subscribeWithSelector = (observable, selector) => (callback) => {
  let lastSlice = selector(observable.get());
  return observable.subscribe((value) => {
    const nextSlice = selector(value);
    if (isEqualShallow(nextSlice, lastSlice)) return;
    lastSlice = nextSlice;
    callback(nextSlice);
  });
};
var createLocalStorageAdapter = () => ({
  getItem: async (key) => localStorage.getItem(key),
  removeItem: async (key) => localStorage.removeItem(key),
  setItem: async (key, value) => localStorage.setItem(key, value)
});
var InvalidStorageSet = class extends BaseError {
  constructor({ key, value }) {
    super({
      cause: null,
      code: "invalid_storage_set",
      docsUrl: null,
      metaMessages: [`key: ${key}`, value],
      name: "InvalidStorageSet",
      shortMessage: "Tried to store a value that does not match the schema"
    });
  }
};
var isValidDateISOString = (value) => {
  const date8 = new Date(value);
  return !isNaN(date8.getTime()) && date8.toISOString() === value;
};
var DATE_PREFIX = "__DATE__";
var formatForStorage = (value) => {
  const item = { value };
  return JSON.stringify(item, (_, entry) => {
    if (isValidDateISOString(entry)) return `${DATE_PREFIX}${entry}`;
    return entry;
  });
};
var parseFromStorage = (value) => {
  try {
    return JSON.parse(value, (_, entry) => {
      if (typeof entry === "string" && entry.startsWith(DATE_PREFIX)) return new Date(entry.slice(8));
      return entry;
    });
  } catch (error79) {
    return null;
  }
};
var createStorage = ({ prefix = "", storageAdapter }) => {
  const getPrefixedKey = (key) => prefix ? `${prefix}_${key}` : key;
  return {
    getItem: async (storageKeySchema) => {
      const rawItem = await storageAdapter.getItem(getPrefixedKey(storageKeySchema.key));
      const parsedItem = rawItem ? parseFromStorage(rawItem) : null;
      if (parsedItem !== null) {
        const parsed = storageKeySchema.schema.safeParse(parsedItem.value);
        if (parsed.success) return parsed.data;
      }
      await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));
      return null;
    },
    removeItem: async (storageKeySchema) => {
      await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));
    },
    setItem: async (storageKeySchema, value) => {
      const parsed = storageKeySchema.schema.safeParse(value);
      if (!parsed.success) throw new InvalidStorageSet({
        key: storageKeySchema.key,
        value: JSON.stringify(value)
      });
      const item = formatForStorage(parsed.data);
      await storageAdapter.setItem(getPrefixedKey(storageKeySchema.key), item);
    }
  };
};
var createStorageKeySchema = (params) => {
  return params;
};
var REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY = "refresh-user-state-from-cookie";
var INITIALIZE_STORAGE_SYNC_TRACKER_KEY = "initialize-storage-sync";
var FETCH_PROJECT_SETTINGS_TRACKER_KEY = "fetch-project-settings";
var GENERATE_SESSION_KEYS_TRACKER_KEY = "generate-session-keys";
var createDeferredPromise = () => {
  let resolve;
  let reject;
  return {
    promise: new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    }),
    reject: (reason) => reject == null ? void 0 : reject(reason),
    resolve: (value) => resolve == null ? void 0 : resolve(value)
  };
};
var CannotTrackError = class extends BaseError {
  constructor() {
    super({
      cause: null,
      code: "cannot_track_error",
      docsUrl: null,
      name: "CannotTrackError",
      shortMessage: "All track calls must be performed in the same node tick"
    });
  }
};
var LOG_LEVELS = {
  debug: 0,
  error: 3,
  info: 1,
  warn: 2
};
var defaultConsole = console;
var createLogger = (options = {}) => {
  const eventEmitter = new import_index5.default();
  const minLevel = options.level ?? "warn";
  const shouldLog = (level) => {
    return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];
  };
  const formatMessage2 = (level, message) => {
    return `[${(/* @__PURE__ */ new Date()).toISOString()}] ${level.toUpperCase()}: ${message}`;
  };
  const log = (level, consoleMethod, message, ...args) => {
    eventEmitter.emit("log", level, message, ...args);
    if (!shouldLog(level)) return;
    consoleMethod(formatMessage2(level, message), ...args);
  };
  return {
    debug: (message, ...args) => log("debug", defaultConsole.debug, message, ...args),
    error: (message, ...args) => log("error", defaultConsole.error, message, ...args),
    info: (message, ...args) => log("info", defaultConsole.info, message, ...args),
    off: eventEmitter.off.bind(eventEmitter),
    on: eventEmitter.on.bind(eventEmitter),
    warn: (message, ...args) => log("warn", defaultConsole.warn, message, ...args)
  };
};
var NoNetworkProvidersError = class extends BaseError {
  constructor() {
    super({
      cause: null,
      code: "no_network_providers",
      docsUrl: null,
      name: "NoNetworkProvidersError",
      shortMessage: "No networks were registered in the client"
    });
  }
};
var hasExtension = ({ extensionKey }, client = getDefaultClient()) => {
  return getCore(client).extensions.has(extensionKey);
};
var getSdkChainFromApiChainName = (chainName) => {
  return Object.keys(CHAINS_INFO_MAP).find((chain) => CHAINS_INFO_MAP[chain].apiChainName === chainName) || null;
};
var getNetworksData = (client = getDefaultClient()) => {
  const { state } = getCore(client);
  const { projectSettings } = state.get();
  assertDefined2(projectSettings, "projectSettings not found");
  const networks = projectSettings.networks;
  if (!networks) return [];
  return networks.map((network) => {
    var _a5;
    if (!network.chainName) return [];
    const chain = getSdkChainFromApiChainName(network.chainName);
    if (!((_a5 = network == null ? void 0 : network.networks) == null ? void 0 : _a5.length) || !chain) return [];
    return network.networks.map((networkConfiguration) => ({
      blockExplorerUrls: networkConfiguration.blockExplorerUrls,
      chain,
      cluster: networkConfiguration.cluster,
      displayName: networkConfiguration.vanityName || networkConfiguration.name,
      genesisHash: networkConfiguration.genesisHash,
      iconUrl: networkConfiguration.iconUrls[0],
      nativeCurrency: {
        decimals: networkConfiguration.nativeCurrency.decimals,
        iconUrl: networkConfiguration.nativeCurrency.iconUrl,
        name: networkConfiguration.nativeCurrency.name,
        symbol: networkConfiguration.nativeCurrency.symbol
      },
      networkId: networkConfiguration.networkId,
      rpcUrls: { http: [...networkConfiguration.privateCustomerRpcUrls ?? [], ...networkConfiguration.rpcUrls ?? []] },
      testnet: networkConfiguration.isTestnet ?? false
    }));
  }).flat();
};
var createNetworkProviderBuilderRegistry = () => {
  const registry3 = /* @__PURE__ */ new Map();
  return {
    get: () => registry3,
    register: (networkProviderBuilder) => {
      registry3.set(networkProviderBuilder.chain, networkProviderBuilder);
    }
  };
};
var getNetworkProviderBuilderRegistry = createRuntimeServiceAccessKey("networkProviderBuilderRegistry", createNetworkProviderBuilderRegistry);
var getNetworkProviders = (client) => {
  const networkProviderBuilderRegistry = getNetworkProviderBuilderRegistry(client);
  const registeredNetworkProviderBuilders = Array.from(networkProviderBuilderRegistry.get().values());
  const networksData = getNetworksData(client);
  return registeredNetworkProviderBuilders.map(({ builder, chain }) => {
    return networksData.filter((networkData) => networkData.chain === chain).map(builder);
  }).flat();
};

// node_modules/@dynamic-labs-sdk/client/dist/isMfaRequiredForAction-BgevGq0s.esm.js
var bufferToHex2 = (buffer) => [...new Uint8Array(buffer)].map((x) => x.toString(16).padStart(2, "0")).join("");
var consumeMfaToken = (client = getDefaultClient()) => {
  const core = getCore(client);
  const mfaToken = core.state.get().mfaToken;
  assertDefined2(mfaToken, "No MFA token found");
  core.state.set({ mfaToken: null });
  return mfaToken;
};
var getMfaMethods = async (client = getDefaultClient()) => {
  const core = getCore(client);
  return await createApiClient({}, client).getUserMfaMethods({
    environmentId: core.environmentId,
    verifiedOnly: true
  });
};
var isMfaRequiredForAction = async ({ mfaAction }, client = getDefaultClient()) => {
  var _a5, _b, _c, _d, _e;
  const projectSettings = client.projectSettings;
  if (!((_c = (_b = (_a5 = projectSettings == null ? void 0 : projectSettings.security) == null ? void 0 : _a5.mfa) == null ? void 0 : _b.actions) == null ? void 0 : _c.some((action) => action.action === mfaAction && action.required))) return false;
  if ((_e = (_d = projectSettings == null ? void 0 : projectSettings.security) == null ? void 0 : _d.mfa) == null ? void 0 : _e.required) return true;
  return (await getMfaMethods(client)).userHasVerifiedMfaMethods;
};

// node_modules/@dynamic-labs-sdk/assert-package-version/dist/index.esm.js
var VersionMismatchError = class extends Error {
  constructor(targetVersion, packageVersions$1) {
    const errorMessage = `
ðŸš¨ Version Mismatch Error

One or more \`@dynamic-labs-sdk\` packages are installed with mismatched versions. All \`@dynamic-labs-sdk\` packages must be on the same version to work correctly.

Affected Packages:
${Object.entries(packageVersions$1).filter(([, v]) => v !== targetVersion).map(([pkgName, installedVersion]) => `- \`${pkgName}\` (installed: **${installedVersion}**, required: **${targetVersion}**)`).join("\n")}

ðŸ’¡ To fix this issue, update all @dynamic-labs-sdk/* packages to version \`${targetVersion}\` in your package.json
`;
    super(errorMessage.trim());
    this.name = "VersionMismatchError";
  }
};
var packageVersions2 = {};
var versionCheckTimeout2 = null;
var assertPackageVersion2 = (packageName, version10) => {
  packageVersions2[packageName] = version10;
  if (versionCheckTimeout2) {
    clearTimeout(versionCheckTimeout2);
    versionCheckTimeout2 = null;
  }
  versionCheckTimeout2 = setTimeout(() => {
    const versions = Object.values(packageVersions2);
    const [firstVersion] = versions;
    if (!versions.every((v) => v === firstVersion)) {
      const error79 = new VersionMismatchError(packageVersions2["@dynamic-labs-sdk/client"] || firstVersion, packageVersions2);
      console.error(error79);
    }
    versionCheckTimeout2 = null;
  }, 100);
};

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/index.js
var core_exports4 = {};
__export(core_exports4, {
  $ZodAny: () => $ZodAny2,
  $ZodArray: () => $ZodArray2,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodBase64: () => $ZodBase642,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCUID: () => $ZodCUID3,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCatch: () => $ZodCatch2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodDate: () => $ZodDate2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodE164: () => $ZodE1642,
  $ZodEmail: () => $ZodEmail2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEnum: () => $ZodEnum2,
  $ZodError: () => $ZodError2,
  $ZodFile: () => $ZodFile2,
  $ZodFunction: () => $ZodFunction2,
  $ZodGUID: () => $ZodGUID2,
  $ZodIPv4: () => $ZodIPv42,
  $ZodIPv6: () => $ZodIPv62,
  $ZodISODate: () => $ZodISODate2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodJWT: () => $ZodJWT2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodLazy: () => $ZodLazy2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodMap: () => $ZodMap2,
  $ZodNaN: () => $ZodNaN2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNever: () => $ZodNever2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNull: () => $ZodNull2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodObject: () => $ZodObject2,
  $ZodOptional: () => $ZodOptional2,
  $ZodPipe: () => $ZodPipe2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPromise: () => $ZodPromise2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodRealError: () => $ZodRealError2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodSet: () => $ZodSet2,
  $ZodString: () => $ZodString2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTuple: () => $ZodTuple2,
  $ZodType: () => $ZodType2,
  $ZodULID: () => $ZodULID2,
  $ZodURL: () => $ZodURL2,
  $ZodUUID: () => $ZodUUID2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodVoid: () => $ZodVoid2,
  $ZodXID: () => $ZodXID2,
  $brand: () => $brand2,
  $constructor: () => $constructor2,
  $input: () => $input2,
  $output: () => $output2,
  Doc: () => Doc2,
  JSONSchema: () => json_schema_exports2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision2,
  _any: () => _any2,
  _array: () => _array2,
  _base64: () => _base642,
  _base64url: () => _base64url2,
  _bigint: () => _bigint2,
  _boolean: () => _boolean2,
  _catch: () => _catch2,
  _cidrv4: () => _cidrv42,
  _cidrv6: () => _cidrv62,
  _coercedBigint: () => _coercedBigint2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedDate: () => _coercedDate2,
  _coercedNumber: () => _coercedNumber2,
  _coercedString: () => _coercedString2,
  _cuid: () => _cuid3,
  _cuid2: () => _cuid22,
  _custom: () => _custom2,
  _date: () => _date2,
  _default: () => _default3,
  _discriminatedUnion: () => _discriminatedUnion2,
  _e164: () => _e1642,
  _email: () => _email2,
  _emoji: () => _emoji4,
  _endsWith: () => _endsWith2,
  _enum: () => _enum3,
  _file: () => _file2,
  _float32: () => _float322,
  _float64: () => _float642,
  _gt: () => _gt2,
  _gte: () => _gte2,
  _guid: () => _guid2,
  _includes: () => _includes2,
  _int: () => _int2,
  _int32: () => _int322,
  _int64: () => _int642,
  _intersection: () => _intersection2,
  _ipv4: () => _ipv42,
  _ipv6: () => _ipv62,
  _isoDate: () => _isoDate2,
  _isoDateTime: () => _isoDateTime2,
  _isoDuration: () => _isoDuration2,
  _isoTime: () => _isoTime2,
  _jwt: () => _jwt2,
  _ksuid: () => _ksuid2,
  _lazy: () => _lazy2,
  _length: () => _length2,
  _literal: () => _literal2,
  _lowercase: () => _lowercase2,
  _lt: () => _lt2,
  _lte: () => _lte2,
  _map: () => _map2,
  _max: () => _lte2,
  _maxLength: () => _maxLength2,
  _maxSize: () => _maxSize2,
  _mime: () => _mime2,
  _min: () => _gte2,
  _minLength: () => _minLength2,
  _minSize: () => _minSize2,
  _multipleOf: () => _multipleOf2,
  _nan: () => _nan2,
  _nanoid: () => _nanoid2,
  _nativeEnum: () => _nativeEnum2,
  _negative: () => _negative2,
  _never: () => _never2,
  _nonnegative: () => _nonnegative2,
  _nonoptional: () => _nonoptional2,
  _nonpositive: () => _nonpositive2,
  _normalize: () => _normalize2,
  _null: () => _null4,
  _nullable: () => _nullable2,
  _number: () => _number2,
  _optional: () => _optional2,
  _overwrite: () => _overwrite2,
  _parse: () => _parse2,
  _parseAsync: () => _parseAsync2,
  _pipe: () => _pipe2,
  _positive: () => _positive2,
  _promise: () => _promise2,
  _property: () => _property2,
  _readonly: () => _readonly2,
  _record: () => _record2,
  _refine: () => _refine2,
  _regex: () => _regex2,
  _safeParse: () => _safeParse2,
  _safeParseAsync: () => _safeParseAsync2,
  _set: () => _set2,
  _size: () => _size2,
  _startsWith: () => _startsWith2,
  _string: () => _string2,
  _stringFormat: () => _stringFormat2,
  _stringbool: () => _stringbool2,
  _success: () => _success2,
  _symbol: () => _symbol2,
  _templateLiteral: () => _templateLiteral2,
  _toLowerCase: () => _toLowerCase2,
  _toUpperCase: () => _toUpperCase2,
  _transform: () => _transform2,
  _trim: () => _trim2,
  _tuple: () => _tuple2,
  _uint32: () => _uint322,
  _uint64: () => _uint642,
  _ulid: () => _ulid2,
  _undefined: () => _undefined4,
  _union: () => _union2,
  _unknown: () => _unknown2,
  _uppercase: () => _uppercase2,
  _url: () => _url2,
  _uuid: () => _uuid2,
  _uuidv4: () => _uuidv42,
  _uuidv6: () => _uuidv62,
  _uuidv7: () => _uuidv72,
  _void: () => _void2,
  _xid: () => _xid2,
  clone: () => clone2,
  config: () => config2,
  flattenError: () => flattenError2,
  formatError: () => formatError2,
  function: () => _function2,
  globalConfig: () => globalConfig2,
  globalRegistry: () => globalRegistry2,
  isValidBase64: () => isValidBase642,
  isValidBase64URL: () => isValidBase64URL2,
  isValidJWT: () => isValidJWT2,
  locales: () => locales_exports2,
  parse: () => parse3,
  parseAsync: () => parseAsync2,
  prettifyError: () => prettifyError2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  toDotPath: () => toDotPath2,
  toJSONSchema: () => toJSONSchema2,
  treeifyError: () => treeifyError2,
  util: () => util_exports2,
  version: () => version9
});

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/core.js
var NEVER2 = Object.freeze({
  status: "aborted"
});
function $constructor2(name2, initializer3, params) {
  function init(inst, def) {
    var _a5;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a5 = inst._zod).traits ?? (_a5.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name2);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name2 });
  function _(def) {
    var _a5;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a5 = inst._zod).deferred ?? (_a5.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a5, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a5 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a5.traits) == null ? void 0 : _b.has(name2);
    }
  });
  Object.defineProperty(_, "name", { value: name2 });
  return _;
}
var $brand2 = Symbol("zod_brand");
var $ZodAsyncError2 = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig2 = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/util.js
var util_exports2 = {};
__export(util_exports2, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2,
  Class: () => Class2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  aborted: () => aborted2,
  allowsEval: () => allowsEval2,
  assert: () => assert2,
  assertEqual: () => assertEqual2,
  assertIs: () => assertIs2,
  assertNever: () => assertNever2,
  assertNotEqual: () => assertNotEqual2,
  assignProp: () => assignProp2,
  cached: () => cached2,
  captureStackTrace: () => captureStackTrace2,
  cleanEnum: () => cleanEnum2,
  cleanRegex: () => cleanRegex2,
  clone: () => clone2,
  createTransparentProxy: () => createTransparentProxy2,
  defineLazy: () => defineLazy2,
  esc: () => esc2,
  escapeRegex: () => escapeRegex2,
  extend: () => extend2,
  finalizeIssue: () => finalizeIssue2,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath2,
  getEnumValues: () => getEnumValues2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin2,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject2,
  issue: () => issue2,
  joinValues: () => joinValues2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  merge: () => merge2,
  normalizeParams: () => normalizeParams2,
  nullish: () => nullish3,
  numKeys: () => numKeys2,
  omit: () => omit2,
  optionalKeys: () => optionalKeys2,
  partial: () => partial2,
  pick: () => pick2,
  prefixIssues: () => prefixIssues2,
  primitiveTypes: () => primitiveTypes2,
  promiseAllObject: () => promiseAllObject2,
  propertyKeyTypes: () => propertyKeyTypes2,
  randomString: () => randomString3,
  required: () => required2,
  stringifyPrimitive: () => stringifyPrimitive2,
  unwrapMessage: () => unwrapMessage2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {
}
function assertNever2(_x) {
  throw new Error();
}
function assert2(_) {
}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === void 0;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy2(object3, key, getter) {
  const set = false;
  Object.defineProperty(object3, key, {
    get() {
      if (!set) {
        const value = getter();
        object3[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath2(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString3(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
var captureStackTrace2 = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval2 = cached2(() => {
  var _a5;
  if (typeof navigator !== "undefined" && ((_a5 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a5.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes2 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES2 = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick2(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit2(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone2(schema, def);
}
function merge2(a, b) {
  return clone2(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial2(Class3, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class3 ? new Class3({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class3 ? new Class3({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required2(Class3, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class3({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class3({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted2(x, startIndex = 0) {
  var _a5;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a5 = x.issues[i]) == null ? void 0 : _a5.continue) !== true)
      return true;
  }
  return false;
}
function prefixIssues2(path, issues) {
  return issues.map((iss) => {
    var _a5;
    (_a5 = iss).path ?? (_a5.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue2(iss, ctx, config3) {
  var _a5, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2((_c = (_b = (_a5 = iss.inst) == null ? void 0 : _a5._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage2((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage2((_e = config3.customError) == null ? void 0 : _e.call(config3, iss)) ?? unwrapMessage2((_f = config3.localeError) == null ? void 0 : _f.call(config3, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class2 = class {
  constructor(..._args) {
  }
};

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/errors.js
var initializer2 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer2, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError2 = $constructor2("$ZodError", initializer2);
var $ZodRealError2 = $constructor2("$ZodError", initializer2, { Parent: Error });
function flattenError2(error79, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error79.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error79, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error80) => {
    for (const issue3 of error80.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error79);
  return fieldErrors;
}
function treeifyError2(error79, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error80, path = []) => {
    var _a5, _b;
    for (const issue3 of error80.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a5 = curr.properties)[el] ?? (_a5[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error79);
  return result;
}
function toDotPath2(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error79) {
  var _a5;
  const lines = [];
  const issues = [...error79.issues].sort((a, b) => a.path.length - b.path.length);
  for (const issue3 of issues) {
    lines.push(`âœ– ${issue3.message}`);
    if ((_a5 = issue3.path) == null ? void 0 : _a5.length)
      lines.push(`  â†’ at ${toDotPath2(issue3.path)}`);
  }
  return lines.join("\n");
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
var parse3 = _parse2($ZodRealError2);
var _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
var parseAsync2 = _parseAsync2($ZodRealError2);
var _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParse2 = _safeParse2($ZodRealError2);
var _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParseAsync2 = _safeParseAsync2($ZodRealError2);

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/regexes.js
var regexes_exports2 = {};
__export(regexes_exports2, {
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint3,
  boolean: () => boolean4,
  browserEmail: () => browserEmail2,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  date: () => date4,
  datetime: () => datetime3,
  domain: () => domain2,
  duration: () => duration3,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  extendedDuration: () => extendedDuration2,
  guid: () => guid2,
  hostname: () => hostname2,
  html5Email: () => html5Email2,
  integer: () => integer2,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  ksuid: () => ksuid2,
  lowercase: () => lowercase2,
  nanoid: () => nanoid2,
  null: () => _null3,
  number: () => number3,
  rfc5322Email: () => rfc5322Email2,
  string: () => string4,
  time: () => time3,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  unicodeEmail: () => unicodeEmail2,
  uppercase: () => uppercase2,
  uuid: () => uuid2,
  uuid4: () => uuid42,
  uuid6: () => uuid62,
  uuid7: () => uuid72,
  xid: () => xid2
});
var cuid3 = /^[cC][^\s-]{8,}$/;
var cuid22 = /^[0-9a-z]+$/;
var ulid2 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid2 = /^[0-9a-vA-V]{20}$/;
var ksuid2 = /^[A-Za-z0-9]{27}$/;
var nanoid2 = /^[a-zA-Z0-9_-]{21}$/;
var duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid2 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid2 = (version10) => {
  if (!version10)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version10}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid42 = uuid2(4);
var uuid62 = uuid2(6);
var uuid72 = uuid2(7);
var email2 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji2() {
  return new RegExp(_emoji3, "u");
}
var ipv42 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv62 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv42 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv62 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base642 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url2 = /^[A-Za-z0-9_-]*$/;
var hostname2 = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e1642 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date4 = new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time5 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
var string4 = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint3 = /^\d+n?$/;
var integer2 = /^\d+$/;
var number3 = /^-?\d+(?:\.\d+)?/i;
var boolean4 = /true|false/i;
var _null3 = /null/i;
var _undefined3 = /undefined/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/checks.js
var $ZodCheck2 = $constructor2("$ZodCheck", (inst, def) => {
  var _a5;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a5 = inst._zod).onattach ?? (_a5.onattach = []);
});
var numericOriginMap2 = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan2 = $constructor2("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan2 = $constructor2("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf2 = $constructor2("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a5;
    (_a5 = inst2._zod.bag).multipleOf ?? (_a5.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat2 = $constructor2("$ZodCheckNumberFormat", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a5 = def.format) == null ? void 0 : _a5.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat2 = $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize2 = $constructor2("$ZodCheckMaxSize", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize2 = $constructor2("$ZodCheckMinSize", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals2 = $constructor2("$ZodCheckSizeEquals", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength2 = $constructor2("$ZodCheckMaxLength", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength2 = $constructor2("$ZodCheckMinLength", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals2 = $constructor2("$ZodCheckLengthEquals", (inst, def) => {
  var _a5;
  $ZodCheck2.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin2(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat2 = $constructor2("$ZodCheckStringFormat", (inst, def) => {
  var _a5, _b;
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a5 = inst._zod).check ?? (_a5.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex2 = $constructor2("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase2 = $constructor2("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckUpperCase2 = $constructor2("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckIncludes2 = $constructor2("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const escapedRegex = escapeRegex2(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith2 = $constructor2("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith2 = $constructor2("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheckProperty2 = $constructor2("$ZodCheckProperty", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
    }
    handleCheckPropertyResult2(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType2 = $constructor2("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite2 = $constructor2("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/doc.js
var Doc2 = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/versions.js
var version9 = {
  major: 4,
  minor: 0,
  patch: 5
};

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/schemas.js
var $ZodType2 = $constructor2("$ZodType", (inst, def) => {
  var _a6;
  var _a5;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version9;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a5 = inst._zod).deferred ?? (_a5.deferred = []);
    (_a6 = inst._zod.deferred) == null ? void 0 : _a6.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted2(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError2();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted2(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a7;
      try {
        const r = safeParse2(inst, value);
        return r.success ? { value: r.data } : { issues: (_a7 = r.error) == null ? void 0 : _a7.issues };
      } catch (_) {
        return safeParseAsync2(inst, value).then((r) => {
          var _a8;
          return r.success ? { value: r.data } : { issues: (_a8 = r.error) == null ? void 0 : _a8.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString2 = $constructor2("$ZodString", (inst, def) => {
  var _a5;
  $ZodType2.init(inst, def);
  inst._zod.pattern = [...((_a5 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a5.patterns) ?? []].pop() ?? string4(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat2 = $constructor2("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  $ZodString2.init(inst, def);
});
var $ZodGUID2 = $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid2);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid2(v));
  } else
    def.pattern ?? (def.pattern = uuid2());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email2);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname2.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji2 = $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji2());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid2);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid22);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid2);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid2);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid2);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = $constructor2("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODate2 = $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date4);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = $constructor2("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodIPv42 = $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv42);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv62 = $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv62);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv42 = $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv42);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv62);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase642 = $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base642);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url2.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase642(padded);
}
var $ZodBase64URL2 = $constructor2("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url2);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL2(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE1642 = $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1642);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT2 = $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat2 = $constructor2("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber2 = $constructor2("$ZodNumber", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number3;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat2 = $constructor2("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat2.init(inst, def);
  $ZodNumber2.init(inst, def);
});
var $ZodBoolean2 = $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt2 = $constructor2("$ZodBigInt", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = bigint3;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat2 = $constructor2("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat2.init(inst, def);
  $ZodBigInt2.init(inst, def);
});
var $ZodSymbol2 = $constructor2("$ZodSymbol", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined2 = $constructor2("$ZodUndefined", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _undefined3;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull2 = $constructor2("$ZodNull", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _null3;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny2 = $constructor2("$ZodAny", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown2 = $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid2 = $constructor2("$ZodVoid", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate2 = $constructor2("$ZodDate", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray2 = $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
      } else {
        handleArrayResult2(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult2(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult2(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues2(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject2 = $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const _normalized = cached2(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType2)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys2(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc2(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc2(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc2(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc2(key)}, ...iss.path] : [${esc2(key)}]
          })));`);
        doc.write(`newResult[${esc2(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig2.jitless;
  const allowsEval3 = allowsEval2;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult2(r2, payload, key, input) : handleObjectResult2(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult2(r, payload, key, input);
        } else {
          handleObjectResult2(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult2(r2, payload, key)));
      } else {
        handleObjectResult2(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
var $ZodUnion2 = $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults2(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion2 = $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy2(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached2(() => {
    var _a5;
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = (_a5 = o._zod.propValues) == null ? void 0 : _a5[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection2 = $constructor2("$ZodIntersection", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults2(payload, left2, right2);
      });
    }
    return handleIntersectionResults2(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple2 = $constructor2("$ZodTuple", (inst, def) => {
  $ZodType2.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
      } else {
        handleTupleResult2(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord2 = $constructor2("$ZodRecord", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues2(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues2(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap2 = $constructor2("$ZodMap", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet2 = $constructor2("$ZodSet", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult2(result2, payload)));
      } else
        handleSetResult2(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum2 = $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral2 = $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile2 = $constructor2("$ZodFile", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform2 = $constructor2("$ZodTransform", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError2();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional2 = $constructor2("$ZodOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable2 = $constructor2("$ZodNullable", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : void 0;
  });
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault2 = $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult2(result2, def));
    }
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault2 = $constructor2("$ZodPrefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional2 = $constructor2("$ZodNonOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult2(result2, inst));
    }
    return handleNonOptionalResult2(result, inst);
  };
});
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess2 = $constructor2("$ZodSuccess", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch2 = $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN2 = $constructor2("$ZodNaN", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe2 = $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult2(left2, def, ctx));
    }
    return handlePipeResult2(left, def, ctx);
  };
});
function handlePipeResult2(left, def, ctx) {
  if (aborted2(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly2 = $constructor2("$ZodReadonly", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult2);
    }
    return handleReadonlyResult2(result);
  };
});
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral2 = $constructor2("$ZodTemplateLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType2) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes2.has(typeof part)) {
      regexParts.push(escapeRegex2(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise2 = $constructor2("$ZodPromise", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy2 = $constructor2("$ZodLazy", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "innerType", () => def.getter());
  defineLazy2(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy2(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy2(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom2 = $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
    }
    handleRefineResult2(r, payload, input, inst);
    return;
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/index.js
var locales_exports2 = {};
__export(locales_exports2, {
  ar: () => ar_default2,
  az: () => az_default2,
  be: () => be_default2,
  ca: () => ca_default2,
  cs: () => cs_default2,
  de: () => de_default2,
  en: () => en_default2,
  eo: () => eo_default2,
  es: () => es_default2,
  fa: () => fa_default2,
  fi: () => fi_default2,
  fr: () => fr_default2,
  frCA: () => fr_CA_default2,
  he: () => he_default2,
  hu: () => hu_default2,
  id: () => id_default2,
  it: () => it_default2,
  ja: () => ja_default2,
  kh: () => kh_default2,
  ko: () => ko_default2,
  mk: () => mk_default2,
  ms: () => ms_default2,
  nl: () => nl_default2,
  no: () => no_default2,
  ota: () => ota_default2,
  pl: () => pl_default2,
  ps: () => ps_default2,
  pt: () => pt_default2,
  ru: () => ru_default2,
  sl: () => sl_default2,
  sv: () => sv_default2,
  ta: () => ta_default2,
  th: () => th_default2,
  tr: () => tr_default2,
  ua: () => ua_default2,
  ur: () => ur_default2,
  vi: () => vi_default2,
  zhCN: () => zh_CN_default2,
  zhTW: () => zh_TW_default2
});

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ar.js
var error40 = () => {
  const Sizable = {
    string: { unit: "Ø­Ø±Ù", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
    file: { unit: "Ø¨Ø§ÙŠØª", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
    array: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
    set: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ù…Ø¯Ø®Ù„",
    email: "Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
    url: "Ø±Ø§Ø¨Ø·",
    emoji: "Ø¥ÙŠÙ…ÙˆØ¬ÙŠ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ØªØ§Ø±ÙŠØ® ÙˆÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    date: "ØªØ§Ø±ÙŠØ® Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    time: "ÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    duration: "Ù…Ø¯Ø© Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
    ipv4: "Ø¹Ù†ÙˆØ§Ù† IPv4",
    ipv6: "Ø¹Ù†ÙˆØ§Ù† IPv6",
    cidrv4: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv4",
    cidrv6: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv6",
    base64: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64-encoded",
    base64url: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64url-encoded",
    json_string: "Ù†ÙŽØµ Ø¹Ù„Ù‰ Ù‡ÙŠØ¦Ø© JSON",
    e164: "Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¨Ù…Ø¹ÙŠØ§Ø± E.164",
    jwt: "JWT",
    template_literal: "Ù…Ø¯Ø®Ù„"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${issue3.expected}ØŒ ÙˆÙ„ÙƒÙ† ØªÙ… Ø¥Ø¯Ø®Ø§Ù„ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØªÙˆÙ‚Ø¹ Ø§Ù†ØªÙ‚Ø§Ø¡ Ø£Ø­Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${issue3.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±"}`;
        return `Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${issue3.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${issue3.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${issue3.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù‘ÙŽÙ† "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ù†Ù…Ø· ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„`;
      }
      case "not_multiple_of":
        return `Ø±Ù‚Ù… ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Ù…Ø¹Ø±Ù${issue3.keys.length > 1 ? "Ø§Øª" : ""} ØºØ±ÙŠØ¨${issue3.keys.length > 1 ? "Ø©" : ""}: ${joinValues2(issue3.keys, "ØŒ ")}`;
      case "invalid_key":
        return `Ù…Ø¹Ø±Ù ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${issue3.origin}`;
      case "invalid_union":
        return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„";
      case "invalid_element":
        return `Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${issue3.origin}`;
      default:
        return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„";
    }
  };
};
function ar_default2() {
  return {
    localeError: error40()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/az.js
var error41 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalÄ±dÄ±r" },
    file: { unit: "bayt", verb: "olmalÄ±dÄ±r" },
    array: { unit: "element", verb: "olmalÄ±dÄ±r" },
    set: { unit: "element", verb: "olmalÄ±dÄ±r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${issue3.expected}, daxil olan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${stringifyPrimitive2(issue3.values[0])}`;
        return `YanlÄ±ÅŸ seÃ§im: aÅŸaÄŸÄ±dakÄ±lardan biri olmalÄ±dÄ±r: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${issue3.origin ?? "dÉ™yÉ™r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${issue3.origin ?? "dÉ™yÉ™r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `YanlÄ±ÅŸ mÉ™tn: "${_issue.prefix}" ilÉ™ baÅŸlamalÄ±dÄ±r`;
        if (_issue.format === "ends_with")
          return `YanlÄ±ÅŸ mÉ™tn: "${_issue.suffix}" ilÉ™ bitmÉ™lidir`;
        if (_issue.format === "includes")
          return `YanlÄ±ÅŸ mÉ™tn: "${_issue.includes}" daxil olmalÄ±dÄ±r`;
        if (_issue.format === "regex")
          return `YanlÄ±ÅŸ mÉ™tn: ${_issue.pattern} ÅŸablonuna uyÄŸun olmalÄ±dÄ±r`;
        return `YanlÄ±ÅŸ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `YanlÄ±ÅŸ É™dÉ™d: ${issue3.divisor} ilÉ™ bÃ¶lÃ¼nÉ™ bilÉ™n olmalÄ±dÄ±r`;
      case "unrecognized_keys":
        return `TanÄ±nmayan aÃ§ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilindÉ™ yanlÄ±ÅŸ aÃ§ar`;
      case "invalid_union":
        return "YanlÄ±ÅŸ dÉ™yÉ™r";
      case "invalid_element":
        return `${issue3.origin} daxilindÉ™ yanlÄ±ÅŸ dÉ™yÉ™r`;
      default:
        return `YanlÄ±ÅŸ dÉ™yÉ™r`;
    }
  };
};
function az_default2() {
  return {
    localeError: error41()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error42 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "ÑÑ–Ð¼Ð²Ð°Ð»",
        few: "ÑÑ–Ð¼Ð²Ð°Ð»Ñ‹",
        many: "ÑÑ–Ð¼Ð²Ð°Ð»Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    },
    array: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    },
    set: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    },
    file: {
      unit: {
        one: "Ð±Ð°Ð¹Ñ‚",
        few: "Ð±Ð°Ð¹Ñ‚Ñ‹",
        many: "Ð±Ð°Ð¹Ñ‚Ð°Ñž"
      },
      verb: "Ð¼ÐµÑ†ÑŒ"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ð»Ñ–Ðº";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÑ–Ñž";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ÑƒÐ²Ð¾Ð´",
    email: "email Ð°Ð´Ñ€Ð°Ñ",
    url: "URL",
    emoji: "ÑÐ¼Ð¾Ð´Ð·Ñ–",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚Ð° Ñ– Ñ‡Ð°Ñ",
    date: "ISO Ð´Ð°Ñ‚Ð°",
    time: "ISO Ñ‡Ð°Ñ",
    duration: "ISO Ð¿Ñ€Ð°Ñ†ÑÐ³Ð»Ð°ÑÑ†ÑŒ",
    ipv4: "IPv4 Ð°Ð´Ñ€Ð°Ñ",
    ipv6: "IPv6 Ð°Ð´Ñ€Ð°Ñ",
    cidrv4: "IPv4 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
    cidrv6: "IPv6 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
    base64: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64",
    base64url: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64url",
    json_string: "JSON Ñ€Ð°Ð´Ð¾Ðº",
    e164: "Ð½ÑƒÐ¼Ð°Ñ€ E.164",
    jwt: "JWT",
    template_literal: "ÑƒÐ²Ð¾Ð´"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°ÑžÑÑ ${issue3.expected}, Ð°Ñ‚Ñ€Ñ‹Ð¼Ð°Ð½Ð° ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ ${stringifyPrimitive2(issue3.values[0])}`;
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð²Ð°Ñ€Ñ‹ÑÐ½Ñ‚: Ñ‡Ð°ÐºÐ°ÑžÑÑ Ð°Ð´Ð·Ñ–Ð½ Ð· ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue3.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð¿Ð°Ñ‡Ñ‹Ð½Ð°Ñ†Ñ†Ð° Ð· "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð°ÐºÐ°Ð½Ñ‡Ð²Ð°Ñ†Ñ†Ð° Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð¼ÑÑˆÑ‡Ð°Ñ†ÑŒ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð°Ð´Ð¿Ð°Ð²ÑÐ´Ð°Ñ†ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð»Ñ–Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð±Ñ‹Ñ†ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð°ÑÐ¿Ð°Ð·Ð½Ð°Ð½Ñ‹ ${issue3.keys.length > 1 ? "ÐºÐ»ÑŽÑ‡Ñ‹" : "ÐºÐ»ÑŽÑ‡"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue3.origin}`;
      case "invalid_union":
        return "ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´";
      case "invalid_element":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ð°Ðµ Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ Ñž ${issue3.origin}`;
      default:
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´`;
    }
  };
};
function be_default2() {
  return {
    localeError: error42()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ca.js
var error43 = () => {
  const Sizable = {
    string: { unit: "carÃ cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreÃ§a electrÃ²nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreÃ§a IPv4",
    ipv6: "adreÃ§a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nÃºmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus invÃ lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType7(issue3.input)}`;
      // return `Tipus invÃ lid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor invÃ lid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `OpciÃ³ invÃ lida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a mÃ xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} continguÃ©s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a mÃ­nim" : "mÃ©s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} continguÃ©s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format invÃ lid: ha de comenÃ§ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invÃ lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invÃ lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invÃ lid: ha de coincidir amb el patrÃ³ ${_issue.pattern}`;
        return `Format invÃ lid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NÃºmero invÃ lid: ha de ser mÃºltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau invÃ lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invÃ lida";
      // Could also be "Tipus d'uniÃ³ invÃ lid" but "Entrada invÃ lida" is more general
      case "invalid_element":
        return `Element invÃ lid a ${issue3.origin}`;
      default:
        return `Entrada invÃ lida`;
    }
  };
};
function ca_default2() {
  return {
    localeError: error43()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/cs.js
var error44 = () => {
  const Sizable = {
    string: { unit: "znakÅ¯", verb: "mÃ­t" },
    file: { unit: "bajtÅ¯", verb: "mÃ­t" },
    array: { unit: "prvkÅ¯", verb: "mÃ­t" },
    set: { unit: "prvkÅ¯", verb: "mÃ­t" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "ÄÃ­slo";
      }
      case "string": {
        return "Å™etÄ›zec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulÃ¡rnÃ­ vÃ½raz",
    email: "e-mailovÃ¡ adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a Äas ve formÃ¡tu ISO",
    date: "datum ve formÃ¡tu ISO",
    time: "Äas ve formÃ¡tu ISO",
    duration: "doba trvÃ¡nÃ­ ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64",
    base64url: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64url",
    json_string: "Å™etÄ›zec ve formÃ¡tu JSON",
    e164: "ÄÃ­slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${issue3.expected}, obdrÅ¾eno ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${stringifyPrimitive2(issue3.values[0])}`;
        return `NeplatnÃ¡ moÅ¾nost: oÄekÃ¡vÃ¡na jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ mÃ­t ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvkÅ¯"}`;
        }
        return `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ bÃ½t ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ mÃ­t ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvkÅ¯"}`;
        }
        return `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${issue3.origin ?? "hodnota"} musÃ­ bÃ½t ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ zaÄÃ­nat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ konÄit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `NeplatnÃ½ Å™etÄ›zec: musÃ­ odpovÃ­dat vzoru ${_issue.pattern}`;
        return `NeplatnÃ½ formÃ¡t ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NeplatnÃ© ÄÃ­slo: musÃ­ bÃ½t nÃ¡sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `NeznÃ¡mÃ© klÃ­Äe: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `NeplatnÃ½ klÃ­Ä v ${issue3.origin}`;
      case "invalid_union":
        return "NeplatnÃ½ vstup";
      case "invalid_element":
        return `NeplatnÃ¡ hodnota v ${issue3.origin}`;
      default:
        return `NeplatnÃ½ vstup`;
    }
  };
};
function cs_default2() {
  return {
    localeError: error44()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/de.js
var error45 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `UngÃ¼ltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `UngÃ¼ltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `UngÃ¼ltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu groÃŸ: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groÃŸ: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `UngÃ¼ltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `UngÃ¼ltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `UngÃ¼ltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `UngÃ¼ltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `UngÃ¼ltig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `UngÃ¼ltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte SchlÃ¼ssel" : "Unbekannter SchlÃ¼ssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `UngÃ¼ltiger SchlÃ¼ssel in ${issue3.origin}`;
      case "invalid_union":
        return "UngÃ¼ltige Eingabe";
      case "invalid_element":
        return `UngÃ¼ltiger Wert in ${issue3.origin}`;
      default:
        return `UngÃ¼ltige Eingabe`;
    }
  };
};
function de_default2() {
  return {
    localeError: error45()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/en.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error46 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default2() {
  return {
    localeError: error46()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/eo.js
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error47 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoÄio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daÅ­ro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiÄis ${issue3.expected}, riceviÄis ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendiÄis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendiÄis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendiÄis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiÄis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendiÄis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiÄis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciÄi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiÄi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} Ålosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida Ålosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default2() {
  return {
    localeError: error47()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/es.js
var error48 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nÃºmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcciÃ³n de correo electrÃ³nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraciÃ³n ISO",
    ipv4: "direcciÃ³n IPv4",
    ipv6: "direcciÃ³n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nÃºmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada invÃ¡lida: se esperaba ${issue3.expected}, recibido ${parsedType7(issue3.input)}`;
      // return `Entrada invÃ¡lida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada invÃ¡lida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `OpciÃ³n invÃ¡lida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue3.origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue3.origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Demasiado pequeÃ±o: se esperaba que ${issue3.origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeÃ±o: se esperaba que ${issue3.origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena invÃ¡lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invÃ¡lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invÃ¡lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invÃ¡lida: debe coincidir con el patrÃ³n ${_issue.pattern}`;
        return `InvÃ¡lido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NÃºmero invÃ¡lido: debe ser mÃºltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave invÃ¡lida en ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invÃ¡lida";
      case "invalid_element":
        return `Valor invÃ¡lido en ${issue3.origin}`;
      default:
        return `Entrada invÃ¡lida`;
    }
  };
};
function es_default2() {
  return {
    localeError: error48()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/fa.js
var error49 = () => {
  const Sizable = {
    string: { unit: "Ú©Ø§Ø±Ø§Ú©ØªØ±", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
    file: { unit: "Ø¨Ø§ÛŒØª", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
    array: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
    set: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ø¹Ø¯Ø¯";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ø¢Ø±Ø§ÛŒÙ‡";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ÙˆØ±ÙˆØ¯ÛŒ",
    email: "Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„",
    url: "URL",
    emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ØªØ§Ø±ÛŒØ® Ùˆ Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
    date: "ØªØ§Ø±ÛŒØ® Ø§ÛŒØ²Ùˆ",
    time: "Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
    duration: "Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
    ipv4: "IPv4 Ø¢Ø¯Ø±Ø³",
    ipv6: "IPv6 Ø¢Ø¯Ø±Ø³",
    cidrv4: "IPv4 Ø¯Ø§Ù…Ù†Ù‡",
    cidrv6: "IPv6 Ø¯Ø§Ù…Ù†Ù‡",
    base64: "base64-encoded Ø±Ø´ØªÙ‡",
    base64url: "base64url-encoded Ø±Ø´ØªÙ‡",
    json_string: "JSON Ø±Ø´ØªÙ‡",
    e164: "E.164 Ø¹Ø¯Ø¯",
    jwt: "JWT",
    template_literal: "ÙˆØ±ÙˆØ¯ÛŒ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${issue3.expected} Ù…ÛŒâ€ŒØ¨ÙˆØ¯ØŒ ${parsedType7(issue3.input)} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${stringifyPrimitive2(issue3.values[0])} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`;
        }
        return `Ú¯Ø²ÛŒÙ†Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ÛŒÚ©ÛŒ Ø§Ø² ${joinValues2(issue3.values, "|")} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${issue3.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±"} Ø¨Ø§Ø´Ø¯`;
        }
        return `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${issue3.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} Ø¨Ø§Ø´Ø¯`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} ${sizing.unit} Ø¨Ø§Ø´Ø¯`;
        }
        return `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} Ø¨Ø§Ø´Ø¯`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${_issue.prefix}" Ø´Ø±ÙˆØ¹ Ø´ÙˆØ¯`;
        }
        if (_issue.format === "ends_with") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${_issue.suffix}" ØªÙ…Ø§Ù… Ø´ÙˆØ¯`;
        }
        if (_issue.format === "includes") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ "${_issue.includes}" Ø¨Ø§Ø´Ø¯`;
        }
        if (_issue.format === "regex") {
          return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ø§Ù„Ú¯ÙˆÛŒ ${_issue.pattern} Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
      }
      case "not_multiple_of":
        return `Ø¹Ø¯Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ù…Ø¶Ø±Ø¨ ${issue3.divisor} Ø¨Ø§Ø´Ø¯`;
      case "unrecognized_keys":
        return `Ú©Ù„ÛŒØ¯${issue3.keys.length > 1 ? "Ù‡Ø§ÛŒ" : ""} Ù†Ø§Ø´Ù†Ø§Ø³: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ú©Ù„ÛŒØ¯ Ù†Ø§Ø´Ù†Ø§Ø³ Ø¯Ø± ${issue3.origin}`;
      case "invalid_union":
        return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
      case "invalid_element":
        return `Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¯Ø± ${issue3.origin}`;
      default:
        return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
    }
  };
};
function fa_default2() {
  return {
    localeError: error49()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/fi.js
var error50 = () => {
  const Sizable = {
    string: { unit: "merkkiÃ¤", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "sÃ¤Ã¤nnÃ¶llinen lauseke",
    email: "sÃ¤hkÃ¶postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen syÃ¶te: tÃ¤ytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: tÃ¤ytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tÃ¤ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tÃ¤ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tÃ¤ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tÃ¤ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen syÃ¶te: tÃ¤ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syÃ¶te: tÃ¤ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syÃ¶te: tÃ¤ytyy sisÃ¤ltÃ¤Ã¤ "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syÃ¶te: tÃ¤ytyy vastata sÃ¤Ã¤nnÃ¶llistÃ¤ lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tÃ¤ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syÃ¶te`;
    }
  };
};
function fi_default2() {
  return {
    localeError: error50()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/fr.js
var error51 = () => {
  const Sizable = {
    string: { unit: "caractÃ¨res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "Ã©lÃ©ments", verb: "avoir" },
    set: { unit: "Ã©lÃ©ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrÃ©e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durÃ©e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaÃ®ne encodÃ©e en base64",
    base64url: "chaÃ®ne encodÃ©e en base64url",
    json_string: "chaÃ®ne JSON",
    e164: "numÃ©ro E.164",
    jwt: "JWT",
    template_literal: "entrÃ©e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `EntrÃ©e invalide : ${issue3.expected} attendu, ${parsedType7(issue3.input)} reÃ§u`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `EntrÃ©e invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ã©lÃ©ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit Ãªtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit Ãªtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ChaÃ®ne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ChaÃ®ne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ChaÃ®ne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ChaÃ®ne invalide : doit correspondre au modÃ¨le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit Ãªtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ClÃ©${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ClÃ© invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "EntrÃ©e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `EntrÃ©e invalide`;
    }
  };
};
function fr_default2() {
  return {
    localeError: error51()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/fr-CA.js
var error52 = () => {
  const Sizable = {
    string: { unit: "caractÃ¨res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "Ã©lÃ©ments", verb: "avoir" },
    set: { unit: "Ã©lÃ©ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrÃ©e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durÃ©e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaÃ®ne encodÃ©e en base64",
    base64url: "chaÃ®ne encodÃ©e en base64url",
    json_string: "chaÃ®ne JSON",
    e164: "numÃ©ro E.164",
    jwt: "JWT",
    template_literal: "entrÃ©e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `EntrÃ©e invalide : attendu ${issue3.expected}, reÃ§u ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `EntrÃ©e invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "â‰¤" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "â‰¥" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ChaÃ®ne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ChaÃ®ne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ChaÃ®ne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ChaÃ®ne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit Ãªtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ClÃ©${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ClÃ© invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "EntrÃ©e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `EntrÃ©e invalide`;
    }
  };
};
function fr_CA_default2() {
  return {
    localeError: error52()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/he.js
var error53 = () => {
  const Sizable = {
    string: { unit: "××•×ª×™×•×ª", verb: "×œ×›×œ×•×œ" },
    file: { unit: "×‘×™×™×˜×™×", verb: "×œ×›×œ×•×œ" },
    array: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" },
    set: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "×§×œ×˜",
    email: "×›×ª×•×‘×ª ××™×ž×™×™×œ",
    url: "×›×ª×•×‘×ª ×¨×©×ª",
    emoji: "××™×ž×•×’'×™",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "×ª××¨×™×š ×•×–×ž×Ÿ ISO",
    date: "×ª××¨×™×š ISO",
    time: "×–×ž×Ÿ ISO",
    duration: "×ž×©×š ×–×ž×Ÿ ISO",
    ipv4: "×›×ª×•×‘×ª IPv4",
    ipv6: "×›×ª×•×‘×ª IPv6",
    cidrv4: "×˜×•×•×— IPv4",
    cidrv6: "×˜×•×•×— IPv6",
    base64: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64",
    base64url: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64 ×œ×›×ª×•×‘×•×ª ×¨×©×ª",
    json_string: "×ž×—×¨×•×–×ª JSON",
    e164: "×ž×¡×¤×¨ E.164",
    jwt: "JWT",
    template_literal: "×§×œ×˜"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${issue3.expected}, ×”×ª×§×‘×œ ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${stringifyPrimitive2(issue3.values[0])}`;
        return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ××—×ª ×ž×”××¤×©×¨×•×™×•×ª  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `×’×“×•×œ ×ž×“×™: ${issue3.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `×’×“×•×œ ×ž×“×™: ${issue3.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `×§×˜×Ÿ ×ž×“×™: ${issue3.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `×§×˜×Ÿ ×ž×“×™: ${issue3.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª×—×™×œ ×‘"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×¡×ª×™×™× ×‘ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×›×œ×•×œ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª××™× ×œ×ª×‘× ×™×ª ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} ×œ× ×ª×§×™×Ÿ`;
      }
      case "not_multiple_of":
        return `×ž×¡×¤×¨ ×œ× ×ª×§×™×Ÿ: ×—×™×™×‘ ×œ×”×™×•×ª ×ž×›×¤×œ×” ×©×œ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `×ž×¤×ª×—${issue3.keys.length > 1 ? "×•×ª" : ""} ×œ× ×ž×–×•×”${issue3.keys.length > 1 ? "×™×" : "×”"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `×ž×¤×ª×— ×œ× ×ª×§×™×Ÿ ×‘${issue3.origin}`;
      case "invalid_union":
        return "×§×œ×˜ ×œ× ×ª×§×™×Ÿ";
      case "invalid_element":
        return `×¢×¨×š ×œ× ×ª×§×™×Ÿ ×‘${issue3.origin}`;
      default:
        return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ`;
    }
  };
};
function he_default2() {
  return {
    localeError: error53()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/hu.js
var error54 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szÃ¡m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tÃ¶mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cÃ­m",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idÅ‘bÃ©lyeg",
    date: "ISO dÃ¡tum",
    time: "ISO idÅ‘",
    duration: "ISO idÅ‘intervallum",
    ipv4: "IPv4 cÃ­m",
    ipv6: "IPv6 cÃ­m",
    cidrv4: "IPv4 tartomÃ¡ny",
    cidrv6: "IPv6 tartomÃ¡ny",
    base64: "base64-kÃ³dolt string",
    base64url: "base64url-kÃ³dolt string",
    json_string: "JSON string",
    e164: "E.164 szÃ¡m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${issue3.expected}, a kapott Ã©rtÃ©k ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ã‰rvÃ©nytelen opciÃ³: valamelyik Ã©rtÃ©k vÃ¡rt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `TÃºl nagy: ${issue3.origin ?? "Ã©rtÃ©k"} mÃ©rete tÃºl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `TÃºl nagy: a bemeneti Ã©rtÃ©k ${issue3.origin ?? "Ã©rtÃ©k"} tÃºl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${issue3.origin} mÃ©rete tÃºl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${issue3.origin} tÃºl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ã‰rvÃ©nytelen string: "${_issue.prefix}" Ã©rtÃ©kkel kell kezdÅ‘dnie`;
        if (_issue.format === "ends_with")
          return `Ã‰rvÃ©nytelen string: "${_issue.suffix}" Ã©rtÃ©kkel kell vÃ©gzÅ‘dnie`;
        if (_issue.format === "includes")
          return `Ã‰rvÃ©nytelen string: "${_issue.includes}" Ã©rtÃ©ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Ã‰rvÃ©nytelen string: ${_issue.pattern} mintÃ¡nak kell megfelelnie`;
        return `Ã‰rvÃ©nytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ã‰rvÃ©nytelen szÃ¡m: ${issue3.divisor} tÃ¶bbszÃ¶rÃ¶sÃ©nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ã‰rvÃ©nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "Ã‰rvÃ©nytelen bemenet";
      case "invalid_element":
        return `Ã‰rvÃ©nytelen Ã©rtÃ©k: ${issue3.origin}`;
      default:
        return `Ã‰rvÃ©nytelen bemenet`;
    }
  };
};
function hu_default2() {
  return {
    localeError: error54()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/id.js
var error55 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default2() {
  return {
    localeError: error55()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/it.js
var error56 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType7(issue3.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default2() {
  return {
    localeError: error56()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ja.js
var error57 = () => {
  const Sizable = {
    string: { unit: "æ–‡å­—", verb: "ã§ã‚ã‚‹" },
    file: { unit: "ãƒã‚¤ãƒˆ", verb: "ã§ã‚ã‚‹" },
    array: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" },
    set: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "æ•°å€¤";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "é…åˆ—";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "å…¥åŠ›å€¤",
    email: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
    url: "URL",
    emoji: "çµµæ–‡å­—",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISOæ—¥æ™‚",
    date: "ISOæ—¥ä»˜",
    time: "ISOæ™‚åˆ»",
    duration: "ISOæœŸé–“",
    ipv4: "IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹",
    ipv6: "IPv6ã‚¢ãƒ‰ãƒ¬ã‚¹",
    cidrv4: "IPv4ç¯„å›²",
    cidrv6: "IPv6ç¯„å›²",
    base64: "base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—",
    base64url: "base64urlã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—",
    json_string: "JSONæ–‡å­—åˆ—",
    e164: "E.164ç•ªå·",
    jwt: "JWT",
    template_literal: "å…¥åŠ›å€¤"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ç„¡åŠ¹ãªå…¥åŠ›: ${issue3.expected}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸãŒã€${parsedType7(issue3.input)}ãŒå…¥åŠ›ã•ã‚Œã¾ã—ãŸ`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ç„¡åŠ¹ãªå…¥åŠ›: ${stringifyPrimitive2(issue3.values[0])}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸ`;
        return `ç„¡åŠ¹ãªé¸æŠž: ${joinValues2(issue3.values, "ã€")}ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      case "too_big": {
        const adj = issue3.inclusive ? "ä»¥ä¸‹ã§ã‚ã‚‹" : "ã‚ˆã‚Šå°ã•ã„";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `å¤§ãã™ãŽã‚‹å€¤: ${issue3.origin ?? "å€¤"}ã¯${issue3.maximum.toString()}${sizing.unit ?? "è¦ç´ "}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        return `å¤§ãã™ãŽã‚‹å€¤: ${issue3.origin ?? "å€¤"}ã¯${issue3.maximum.toString()}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "ä»¥ä¸Šã§ã‚ã‚‹" : "ã‚ˆã‚Šå¤§ãã„";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `å°ã•ã™ãŽã‚‹å€¤: ${issue3.origin}ã¯${issue3.minimum.toString()}${sizing.unit}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        return `å°ã•ã™ãŽã‚‹å€¤: ${issue3.origin}ã¯${issue3.minimum.toString()}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.prefix}"ã§å§‹ã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        if (_issue.format === "ends_with")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.suffix}"ã§çµ‚ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        if (_issue.format === "includes")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.includes}"ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        if (_issue.format === "regex")
          return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: ãƒ‘ã‚¿ãƒ¼ãƒ³${_issue.pattern}ã«ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
        return `ç„¡åŠ¹ãª${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ç„¡åŠ¹ãªæ•°å€¤: ${issue3.divisor}ã®å€æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
      case "unrecognized_keys":
        return `èªè­˜ã•ã‚Œã¦ã„ãªã„ã‚­ãƒ¼${issue3.keys.length > 1 ? "ç¾¤" : ""}: ${joinValues2(issue3.keys, "ã€")}`;
      case "invalid_key":
        return `${issue3.origin}å†…ã®ç„¡åŠ¹ãªã‚­ãƒ¼`;
      case "invalid_union":
        return "ç„¡åŠ¹ãªå…¥åŠ›";
      case "invalid_element":
        return `${issue3.origin}å†…ã®ç„¡åŠ¹ãªå€¤`;
      default:
        return `ç„¡åŠ¹ãªå…¥åŠ›`;
    }
  };
};
function ja_default2() {
  return {
    localeError: error57()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/kh.js
var error58 = () => {
  const Sizable = {
    string: { unit: "ážáž½áž¢áž€áŸ’ážŸážš", verb: "áž‚áž½ážšáž˜áž¶áž“" },
    file: { unit: "áž”áŸƒ", verb: "áž‚áž½ážšáž˜áž¶áž“" },
    array: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" },
    set: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "áž˜áž·áž“áž˜áŸ‚áž“áž‡áž¶áž›áŸáž (NaN)" : "áž›áŸáž";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "áž¢áž¶ážšáŸ (Array)";
        }
        if (data === null) {
          return "áž‚áŸ’áž˜áž¶áž“ážáž˜áŸ’áž›áŸƒ (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›",
    email: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“áž¢áŸŠáž¸áž˜áŸ‚áž›",
    url: "URL",
    emoji: "ážŸáž‰áŸ’áž‰áž¶áž¢áž¶ážšáž˜áŸ’áž˜ážŽáŸ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ áž“áž·áž„áž˜áŸ‰áŸ„áž„ ISO",
    date: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ ISO",
    time: "áž˜áŸ‰áŸ„áž„ ISO",
    duration: "ážšáž™áŸˆáž–áŸáž› ISO",
    ipv4: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4",
    ipv6: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6",
    cidrv4: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4",
    cidrv6: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6",
    base64: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64",
    base64url: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64url",
    json_string: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážš JSON",
    e164: "áž›áŸáž E.164",
    jwt: "JWT",
    template_literal: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.expected} áž”áŸ‰áž»áž“áŸ’ážáŸ‚áž‘áž‘áž½áž›áž”áž¶áž“ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${stringifyPrimitive2(issue3.values[0])}`;
        return `áž‡áž˜áŸ’ážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž‡áž¶áž˜áž½áž™áž€áŸ’áž“áž»áž„áž…áŸ†ážŽáŸ„áž˜ ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "áž’áž¶ážáž»"}`;
        return `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážŠáŸ„áž™ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž”áž‰áŸ’áž…áž”áŸ‹ážŠáŸ„áž™ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž˜áž¶áž“ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž•áŸ’áž‚áž¼áž•áŸ’áž‚áž„áž“áž¹áž„áž‘áž˜áŸ’ážšáž„áŸ‹ážŠáŸ‚áž›áž”áž¶áž“áž€áŸ†ážŽážáŸ‹ ${_issue.pattern}`;
        return `áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `áž›áŸážáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž‡áž¶áž–áž áž»áž‚áž»ážŽáž“áŸƒ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ážšáž€ážƒáž¾áž‰ážŸáŸ„áž˜áž·áž“ážŸáŸ’áž‚áž¶áž›áŸ‹áŸ– ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ážŸáŸ„áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${issue3.origin}`;
      case "invalid_union":
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ`;
      case "invalid_element":
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${issue3.origin}`;
      default:
        return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ`;
    }
  };
};
function kh_default2() {
  return {
    localeError: error58()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ko.js
var error59 = () => {
  const Sizable = {
    string: { unit: "ë¬¸ìž", verb: "to have" },
    file: { unit: "ë°”ì´íŠ¸", verb: "to have" },
    array: { unit: "ê°œ", verb: "to have" },
    set: { unit: "ê°œ", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ìž…ë ¥",
    email: "ì´ë©”ì¼ ì£¼ì†Œ",
    url: "URL",
    emoji: "ì´ëª¨ì§€",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ë‚ ì§œì‹œê°„",
    date: "ISO ë‚ ì§œ",
    time: "ISO ì‹œê°„",
    duration: "ISO ê¸°ê°„",
    ipv4: "IPv4 ì£¼ì†Œ",
    ipv6: "IPv6 ì£¼ì†Œ",
    cidrv4: "IPv4 ë²”ìœ„",
    cidrv6: "IPv6 ë²”ìœ„",
    base64: "base64 ì¸ì½”ë”© ë¬¸ìžì—´",
    base64url: "base64url ì¸ì½”ë”© ë¬¸ìžì—´",
    json_string: "JSON ë¬¸ìžì—´",
    e164: "E.164 ë²ˆí˜¸",
    jwt: "JWT",
    template_literal: "ìž…ë ¥"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ìž˜ëª»ëœ ìž…ë ¥: ì˜ˆìƒ íƒ€ìž…ì€ ${issue3.expected}, ë°›ì€ íƒ€ìž…ì€ ${parsedType7(issue3.input)}ìž…ë‹ˆë‹¤`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ìž˜ëª»ëœ ìž…ë ¥: ê°’ì€ ${stringifyPrimitive2(issue3.values[0])} ì´ì–´ì•¼ í•©ë‹ˆë‹¤`;
        return `ìž˜ëª»ëœ ì˜µì…˜: ${joinValues2(issue3.values, "ë˜ëŠ” ")} ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤`;
      case "too_big": {
        const adj = issue3.inclusive ? "ì´í•˜" : "ë¯¸ë§Œ";
        const suffix = adj === "ë¯¸ë§Œ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤";
        const sizing = getSizing(issue3.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "ìš”ì†Œ";
        if (sizing)
          return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "ì´ìƒ" : "ì´ˆê³¼";
        const suffix = adj === "ì´ìƒ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤";
        const sizing = getSizing(issue3.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "ìš”ì†Œ";
        if (sizing) {
          return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.prefix}"(ìœ¼)ë¡œ ì‹œìž‘í•´ì•¼ í•©ë‹ˆë‹¤`;
        }
        if (_issue.format === "ends_with")
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.suffix}"(ìœ¼)ë¡œ ëë‚˜ì•¼ í•©ë‹ˆë‹¤`;
        if (_issue.format === "includes")
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.includes}"ì„(ë¥¼) í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤`;
        if (_issue.format === "regex")
          return `ìž˜ëª»ëœ ë¬¸ìžì—´: ì •ê·œì‹ ${_issue.pattern} íŒ¨í„´ê³¼ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤`;
        return `ìž˜ëª»ëœ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ìž˜ëª»ëœ ìˆ«ìž: ${issue3.divisor}ì˜ ë°°ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤`;
      case "unrecognized_keys":
        return `ì¸ì‹í•  ìˆ˜ ì—†ëŠ” í‚¤: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ìž˜ëª»ëœ í‚¤: ${issue3.origin}`;
      case "invalid_union":
        return `ìž˜ëª»ëœ ìž…ë ¥`;
      case "invalid_element":
        return `ìž˜ëª»ëœ ê°’: ${issue3.origin}`;
      default:
        return `ìž˜ëª»ëœ ìž…ë ¥`;
    }
  };
};
function ko_default2() {
  return {
    localeError: error59()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/mk.js
var error60 = () => {
  const Sizable = {
    string: { unit: "Ð·Ð½Ð°Ñ†Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
    file: { unit: "Ð±Ð°Ñ˜Ñ‚Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
    array: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
    set: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ð±Ñ€Ð¾Ñ˜";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð½Ð¸Ð·Ð°";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ð²Ð½ÐµÑ",
    email: "Ð°Ð´Ñ€ÐµÑÐ° Ð½Ð° Ðµ-Ð¿Ð¾ÑˆÑ‚Ð°",
    url: "URL",
    emoji: "ÐµÐ¼Ð¾ÑŸÐ¸",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚ÑƒÐ¼ Ð¸ Ð²Ñ€ÐµÐ¼Ðµ",
    date: "ISO Ð´Ð°Ñ‚ÑƒÐ¼",
    time: "ISO Ð²Ñ€ÐµÐ¼Ðµ",
    duration: "ISO Ð²Ñ€ÐµÐ¼ÐµÑ‚Ñ€Ð°ÐµÑšÐµ",
    ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑÐ°",
    ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑÐ°",
    cidrv4: "IPv4 Ð¾Ð¿ÑÐµÐ³",
    cidrv6: "IPv6 Ð¾Ð¿ÑÐµÐ³",
    base64: "base64-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°",
    base64url: "base64url-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°",
    json_string: "JSON Ð½Ð¸Ð·Ð°",
    e164: "E.164 Ð±Ñ€Ð¾Ñ˜",
    jwt: "JWT",
    template_literal: "Ð²Ð½ÐµÑ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.expected}, Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¾ ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ð“Ñ€ÐµÑˆÐ°Ð½Ð° Ð¾Ð¿Ñ†Ð¸Ñ˜Ð°: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ÐµÐ´Ð½Ð° ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð¸Ð¼Ð° ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¸"}`;
        return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð±Ð¸Ð´Ðµ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin} Ð´Ð° Ð¸Ð¼Ð° ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue3.origin} Ð´Ð° Ð±Ð¸Ð´Ðµ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð¿Ð¾Ñ‡Ð½ÑƒÐ²Ð° ÑÐ¾ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð²Ñ€ÑˆÑƒÐ²Ð° ÑÐ¾ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð²ÐºÐ»ÑƒÑ‡ÑƒÐ²Ð° "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð¾Ð´Ð³Ð¾Ð°Ñ€Ð° Ð½Ð° Ð¿Ð°Ñ‚ÐµÑ€Ð½Ð¾Ñ‚ ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð±Ñ€Ð¾Ñ˜: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð±Ð¸Ð´Ðµ Ð´ÐµÐ»Ð¸Ð² ÑÐ¾ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½Ð¸ ÐºÐ»ÑƒÑ‡ÐµÐ²Ð¸" : "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½ ÐºÐ»ÑƒÑ‡"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ð“Ñ€ÐµÑˆÐµÐ½ ÐºÐ»ÑƒÑ‡ Ð²Ð¾ ${issue3.origin}`;
      case "invalid_union":
        return "Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ";
      case "invalid_element":
        return `Ð“Ñ€ÐµÑˆÐ½Ð° Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚ Ð²Ð¾ ${issue3.origin}`;
      default:
        return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ`;
    }
  };
};
function mk_default2() {
  return {
    localeError: error60()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ms.js
var error61 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default2() {
  return {
    localeError: error61()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/nl.js
var error62 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht Ã©Ã©n van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default2() {
  return {
    localeError: error62()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/no.js
var error63 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "Ã¥ ha" },
    file: { unit: "bytes", verb: "Ã¥ ha" },
    array: { unit: "elementer", verb: "Ã¥ inneholde" },
    set: { unit: "elementer", verb: "Ã¥ inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrÃ¥de",
    ipv6: "IPv6-omrÃ¥de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til Ã¥ ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til Ã¥ ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til Ã¥ ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til Ã¥ ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: mÃ¥ starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: mÃ¥ ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: mÃ¥ inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: mÃ¥ matche mÃ¸nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: mÃ¥ vÃ¦re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente nÃ¸kler" : "Ukjent nÃ¸kkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nÃ¸kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default2() {
  return {
    localeError: error63()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ota.js
var error64 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalÄ±dÄ±r" },
    file: { unit: "bayt", verb: "olmalÄ±dÄ±r" },
    array: { unit: "unsur", verb: "olmalÄ±dÄ±r" },
    set: { unit: "unsur", verb: "olmalÄ±dÄ±r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagÃ¢h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengÃ¢mÄ±",
    date: "ISO tarihi",
    time: "ISO zamanÄ±",
    duration: "ISO mÃ¼ddeti",
    ipv4: "IPv4 niÅŸÃ¢nÄ±",
    ipv6: "IPv6 niÅŸÃ¢nÄ±",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ÅŸifreli metin",
    base64url: "base64url-ÅŸifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayÄ±sÄ±",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `FÃ¢sit giren: umulan ${issue3.expected}, alÄ±nan ${parsedType7(issue3.input)}`;
      // return `FÃ¢sit giren: umulan ${issue.expected}, alÄ±nan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `FÃ¢sit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `FÃ¢sit tercih: mÃ»teberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla bÃ¼yÃ¼k: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalÄ±ydÄ±.`;
        return `Fazla bÃ¼yÃ¼k: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmalÄ±ydÄ±.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla kÃ¼Ã§Ã¼k: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmalÄ±ydÄ±.`;
        }
        return `Fazla kÃ¼Ã§Ã¼k: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmalÄ±ydÄ±.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `FÃ¢sit metin: "${_issue.prefix}" ile baÅŸlamalÄ±.`;
        if (_issue.format === "ends_with")
          return `FÃ¢sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `FÃ¢sit metin: "${_issue.includes}" ihtivÃ¢ etmeli.`;
        if (_issue.format === "regex")
          return `FÃ¢sit metin: ${_issue.pattern} nakÅŸÄ±na uymalÄ±.`;
        return `FÃ¢sit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `FÃ¢sit sayÄ±: ${issue3.divisor} katÄ± olmalÄ±ydÄ±.`;
      case "unrecognized_keys":
        return `TanÄ±nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} iÃ§in tanÄ±nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanÄ±namadÄ±.";
      case "invalid_element":
        return `${issue3.origin} iÃ§in tanÄ±nmayan kÄ±ymet var.`;
      default:
        return `KÄ±ymet tanÄ±namadÄ±.`;
    }
  };
};
function ota_default2() {
  return {
    localeError: error64()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ps.js
var error65 = () => {
  const Sizable = {
    string: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
    file: { unit: "Ø¨Ø§ÛŒÙ¼Ø³", verb: "ÙˆÙ„Ø±ÙŠ" },
    array: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
    set: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ø¹Ø¯Ø¯";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ø§Ø±Û";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ÙˆØ±ÙˆØ¯ÙŠ",
    email: "Ø¨Ø±ÛŒÚšÙ†Ø§Ù„ÛŒÚ©",
    url: "ÛŒÙˆ Ø¢Ø± Ø§Ù„",
    emoji: "Ø§ÛŒÙ…ÙˆØ¬ÙŠ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "Ù†ÛŒÙ¼Ù‡ Ø§Ùˆ ÙˆØ®Øª",
    date: "Ù†ÛÙ¼Ù‡",
    time: "ÙˆØ®Øª",
    duration: "Ù…ÙˆØ¯Ù‡",
    ipv4: "Ø¯ IPv4 Ù¾ØªÙ‡",
    ipv6: "Ø¯ IPv6 Ù¾ØªÙ‡",
    cidrv4: "Ø¯ IPv4 Ø³Ø§Ø­Ù‡",
    cidrv6: "Ø¯ IPv6 Ø³Ø§Ø­Ù‡",
    base64: "base64-encoded Ù…ØªÙ†",
    base64url: "base64url-encoded Ù…ØªÙ†",
    json_string: "JSON Ù…ØªÙ†",
    e164: "Ø¯ E.164 Ø´Ù…ÛØ±Ù‡",
    jwt: "JWT",
    template_literal: "ÙˆØ±ÙˆØ¯ÙŠ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${issue3.expected} ÙˆØ§ÛŒ, Ù…Ú«Ø± ${parsedType7(issue3.input)} ØªØ±Ù„Ø§Ø³Ù‡ Ø´Ùˆ`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${stringifyPrimitive2(issue3.values[0])} ÙˆØ§ÛŒ`;
        }
        return `Ù†Ø§Ø³Ù… Ø§Ù†ØªØ®Ø§Ø¨: Ø¨Ø§ÛŒØ¯ ÛŒÙˆ Ù„Ù‡ ${joinValues2(issue3.values, "|")} Ú…Ø®Ù‡ ÙˆØ§ÛŒ`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${issue3.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±ÙˆÙ†Ù‡"} ÙˆÙ„Ø±ÙŠ`;
        }
        return `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${issue3.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.maximum.toString()} ÙˆÙŠ`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} ${sizing.unit} ÙˆÙ„Ø±ÙŠ`;
        }
        return `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${issue3.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue3.minimum.toString()} ÙˆÙŠ`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${_issue.prefix}" Ø³Ø±Ù‡ Ù¾ÛŒÙ„ Ø´ÙŠ`;
        }
        if (_issue.format === "ends_with") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${_issue.suffix}" Ø³Ø±Ù‡ Ù¾Ø§ÛŒ ØªÙ‡ ÙˆØ±Ø³ÙŠÚ–ÙŠ`;
        }
        if (_issue.format === "includes") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ "${_issue.includes}" ÙˆÙ„Ø±ÙŠ`;
        }
        if (_issue.format === "regex") {
          return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ ${_issue.pattern} Ø³Ø±Ù‡ Ù…Ø·Ø§Ø¨Ù‚Øª ÙˆÙ„Ø±ÙŠ`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} Ù†Ø§Ø³Ù… Ø¯ÛŒ`;
      }
      case "not_multiple_of":
        return `Ù†Ø§Ø³Ù… Ø¹Ø¯Ø¯: Ø¨Ø§ÛŒØ¯ Ø¯ ${issue3.divisor} Ù…Ø¶Ø±Ø¨ ÙˆÙŠ`;
      case "unrecognized_keys":
        return `Ù†Ø§Ø³Ù… ${issue3.keys.length > 1 ? "Ú©Ù„ÛŒÚ‰ÙˆÙ†Ù‡" : "Ú©Ù„ÛŒÚ‰"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ù†Ø§Ø³Ù… Ú©Ù„ÛŒÚ‰ Ù¾Ù‡ ${issue3.origin} Ú©Û`;
      case "invalid_union":
        return `Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ`;
      case "invalid_element":
        return `Ù†Ø§Ø³Ù… Ø¹Ù†ØµØ± Ù¾Ù‡ ${issue3.origin} Ú©Û`;
      default:
        return `Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ`;
    }
  };
};
function ps_default2() {
  return {
    localeError: error65()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/pl.js
var error66 = () => {
  const Sizable = {
    string: { unit: "znakÃ³w", verb: "mieÄ‡" },
    file: { unit: "bajtÃ³w", verb: "mieÄ‡" },
    array: { unit: "elementÃ³w", verb: "mieÄ‡" },
    set: { unit: "elementÃ³w", verb: "mieÄ‡" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyraÅ¼enie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciÄ…g znakÃ³w zakodowany w formacie base64",
    base64url: "ciÄ…g znakÃ³w zakodowany w formacie base64url",
    json_string: "ciÄ…g znakÃ³w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejÅ›cie"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `NieprawidÅ‚owa opcja: oczekiwano jednej z wartoÅ›ci ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za duÅ¼a wartoÅ›Ä‡: oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementÃ³w"}`;
        }
        return `Zbyt duÅ¼(y/a/e): oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za maÅ‚a wartoÅ›Ä‡: oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "elementÃ³w"}`;
        }
        return `Zbyt maÅ‚(y/a/e): oczekiwano, Å¼e ${issue3.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zaczynaÄ‡ siÄ™ od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi koÅ„czyÄ‡ siÄ™ na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zawieraÄ‡ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi odpowiadaÄ‡ wzorcowi ${_issue.pattern}`;
        return `NieprawidÅ‚ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `NieprawidÅ‚owa liczba: musi byÄ‡ wielokrotnoÅ›ciÄ… ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `NieprawidÅ‚owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "NieprawidÅ‚owe dane wejÅ›ciowe";
      case "invalid_element":
        return `NieprawidÅ‚owa wartoÅ›Ä‡ w ${issue3.origin}`;
      default:
        return `NieprawidÅ‚owe dane wejÅ›ciowe`;
    }
  };
};
function pl_default2() {
  return {
    localeError: error66()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/pt.js
var error67 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nÃºmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padrÃ£o",
    email: "endereÃ§o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duraÃ§Ã£o ISO",
    ipv4: "endereÃ§o IPv4",
    ipv6: "endereÃ§o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nÃºmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo invÃ¡lido: esperado ${issue3.expected}, recebido ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada invÃ¡lida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `OpÃ§Ã£o invÃ¡lida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto invÃ¡lido: deve comeÃ§ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invÃ¡lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invÃ¡lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invÃ¡lido: deve corresponder ao padrÃ£o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invÃ¡lido`;
      }
      case "not_multiple_of":
        return `NÃºmero invÃ¡lido: deve ser mÃºltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave invÃ¡lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invÃ¡lida";
      case "invalid_element":
        return `Valor invÃ¡lido em ${issue3.origin}`;
      default:
        return `Campo invÃ¡lido`;
    }
  };
};
function pt_default2() {
  return {
    localeError: error67()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error68 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "ÑÐ¸Ð¼Ð²Ð¾Ð»",
        few: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°",
        many: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    },
    file: {
      unit: {
        one: "Ð±Ð°Ð¹Ñ‚",
        few: "Ð±Ð°Ð¹Ñ‚Ð°",
        many: "Ð±Ð°Ð¹Ñ‚"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    },
    array: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    },
    set: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²"
      },
      verb: "Ð¸Ð¼ÐµÑ‚ÑŒ"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÑÐ¸Ð²";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ð²Ð²Ð¾Ð´",
    email: "email Ð°Ð´Ñ€ÐµÑ",
    url: "URL",
    emoji: "ÑÐ¼Ð¾Ð´Ð·Ð¸",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚Ð° Ð¸ Ð²Ñ€ÐµÐ¼Ñ",
    date: "ISO Ð´Ð°Ñ‚Ð°",
    time: "ISO Ð²Ñ€ÐµÐ¼Ñ",
    duration: "ISO Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ",
    ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑ",
    ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑ",
    cidrv4: "IPv4 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½",
    cidrv6: "IPv6 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½",
    base64: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64",
    base64url: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64url",
    json_string: "JSON ÑÑ‚Ñ€Ð¾ÐºÐ°",
    e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164",
    jwt: "JWT",
    template_literal: "Ð²Ð²Ð¾Ð´"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${issue3.expected}, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${stringifyPrimitive2(issue3.values[0])}`;
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue3.origin} Ð±ÑƒÐ´ÐµÑ‚ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð½Ð°Ñ‡Ð¸Ð½Ð°Ñ‚ÑŒÑÑ Ñ "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð·Ð°ÐºÐ°Ð½Ñ‡Ð¸Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¾Ð²Ð°Ñ‚ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð½${issue3.keys.length > 1 ? "Ñ‹Ðµ" : "Ñ‹Ð¹"} ÐºÐ»ÑŽÑ‡${issue3.keys.length > 1 ? "Ð¸" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÐºÐ»ÑŽÑ‡ Ð² ${issue3.origin}`;
      case "invalid_union":
        return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ";
      case "invalid_element":
        return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð² ${issue3.origin}`;
      default:
        return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ`;
    }
  };
};
function ru_default2() {
  return {
    localeError: error68()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/sl.js
var error69 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Å¡tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poÅ¡tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in Äas",
    date: "ISO datum",
    time: "ISO Äas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 Å¡tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: priÄakovano ${issue3.expected}, prejeto ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: priÄakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna moÅ¾nost: priÄakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: priÄakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priÄakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: priÄakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priÄakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaÄeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konÄati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno Å¡tevilo: mora biti veÄkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i kljuÄi" : " kljuÄ"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven kljuÄ v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default2() {
  return {
    localeError: error69()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/sv.js
var error70 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehÃ¥lla" },
    set: { unit: "objekt", verb: "att innehÃ¥lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljÃ¤rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strÃ¤ng",
    base64url: "base64url-kodad strÃ¤ng",
    json_string: "JSON-strÃ¤ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${issue3.expected}, fick ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: fÃ¶rvÃ¤ntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `FÃ¶r stor(t): fÃ¶rvÃ¤ntade ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `FÃ¶r stor(t): fÃ¶rvÃ¤ntat ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${issue3.origin ?? "vÃ¤rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig strÃ¤ng: mÃ¥ste bÃ¶rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strÃ¤ng: mÃ¥ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strÃ¤ng: mÃ¥ste innehÃ¥lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strÃ¤ng: mÃ¥ste matcha mÃ¶nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mÃ¥ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "OkÃ¤nda nycklar" : "OkÃ¤nd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "vÃ¤rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vÃ¤rde i ${issue3.origin ?? "vÃ¤rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default2() {
  return {
    localeError: error70()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ta.js
var error71 = () => {
  const Sizable = {
    string: { unit: "à®Žà®´à¯à®¤à¯à®¤à¯à®•à¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
    file: { unit: "à®ªà¯ˆà®Ÿà¯à®Ÿà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
    array: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
    set: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "à®Žà®£à¯ à®…à®²à¯à®²à®¾à®¤à®¤à¯" : "à®Žà®£à¯";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "à®…à®£à®¿";
        }
        if (data === null) {
          return "à®µà¯†à®±à¯à®®à¯ˆ";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "à®‰à®³à¯à®³à¯€à®Ÿà¯",
    email: "à®®à®¿à®©à¯à®©à®žà¯à®šà®²à¯ à®®à¯à®•à®µà®°à®¿",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO à®¤à¯‡à®¤à®¿ à®¨à¯‡à®°à®®à¯",
    date: "ISO à®¤à¯‡à®¤à®¿",
    time: "ISO à®¨à¯‡à®°à®®à¯",
    duration: "ISO à®•à®¾à®² à®…à®³à®µà¯",
    ipv4: "IPv4 à®®à¯à®•à®µà®°à®¿",
    ipv6: "IPv6 à®®à¯à®•à®µà®°à®¿",
    cidrv4: "IPv4 à®µà®°à®®à¯à®ªà¯",
    cidrv6: "IPv6 à®µà®°à®®à¯à®ªà¯",
    base64: "base64-encoded à®šà®°à®®à¯",
    base64url: "base64url-encoded à®šà®°à®®à¯",
    json_string: "JSON à®šà®°à®®à¯",
    e164: "E.164 à®Žà®£à¯",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.expected}, à®ªà¯†à®±à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${stringifyPrimitive2(issue3.values[0])}`;
        return `à®¤à®µà®±à®¾à®© à®µà®¿à®°à¯à®ªà¯à®ªà®®à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${joinValues2(issue3.values, "|")} à®‡à®²à¯ à®’à®©à¯à®±à¯`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯"} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        }
        return `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${adj}${issue3.maximum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        }
        return `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue3.origin} ${adj}${issue3.minimum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.prefix}" à®‡à®²à¯ à®¤à¯Šà®Ÿà®™à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        if (_issue.format === "ends_with")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.suffix}" à®‡à®²à¯ à®®à¯à®Ÿà®¿à®µà®Ÿà¯ˆà®¯ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        if (_issue.format === "includes")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.includes}" à® à®‰à®³à¯à®³à®Ÿà®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        if (_issue.format === "regex")
          return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: ${_issue.pattern} à®®à¯à®±à¯ˆà®ªà®¾à®Ÿà¯à®Ÿà¯à®Ÿà®©à¯ à®ªà¯Šà®°à¯à®¨à¯à®¤ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
        return `à®¤à®µà®±à®¾à®© ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `à®¤à®µà®±à®¾à®© à®Žà®£à¯: ${issue3.divisor} à®‡à®©à¯ à®ªà®²à®®à®¾à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
      case "unrecognized_keys":
        return `à®…à®Ÿà¯ˆà®¯à®¾à®³à®®à¯ à®¤à¯†à®°à®¿à®¯à®¾à®¤ à®µà®¿à®šà¯ˆ${issue3.keys.length > 1 ? "à®•à®³à¯" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®µà®¿à®šà¯ˆ`;
      case "invalid_union":
        return "à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯";
      case "invalid_element":
        return `${issue3.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®®à®¤à®¿à®ªà¯à®ªà¯`;
      default:
        return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯`;
    }
  };
};
function ta_default2() {
  return {
    localeError: error71()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/th.js
var error72 = () => {
  const Sizable = {
    string: { unit: "à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
    file: { unit: "à¹„à¸šà¸•à¹Œ", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
    array: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
    set: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸•à¸±à¸§à¹€à¸¥à¸‚ (NaN)" : "à¸•à¸±à¸§à¹€à¸¥à¸‚";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "à¸­à¸²à¸£à¹Œà¹€à¸£à¸¢à¹Œ (Array)";
        }
        if (data === null) {
          return "à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¹ˆà¸² (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™",
    email: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆà¸­à¸µà¹€à¸¡à¸¥",
    url: "URL",
    emoji: "à¸­à¸´à¹‚à¸¡à¸ˆà¸´",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
    date: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹à¸šà¸š ISO",
    time: "à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
    duration: "à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
    ipv4: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv4",
    ipv6: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv6",
    cidrv4: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv4",
    cidrv6: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv6",
    base64: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64",
    base64url: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64 à¸ªà¸³à¸«à¸£à¸±à¸š URL",
    json_string: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š JSON",
    e164: "à¹€à¸šà¸­à¸£à¹Œà¹‚à¸—à¸£à¸¨à¸±à¸žà¸—à¹Œà¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸›à¸£à¸°à¹€à¸—à¸¨ (E.164)",
    jwt: "à¹‚à¸—à¹€à¸„à¸™ JWT",
    template_literal: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `à¸›à¸£à¸°à¹€à¸ à¸—à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${issue3.expected} à¹à¸•à¹ˆà¹„à¸”à¹‰à¸£à¸±à¸š ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${stringifyPrimitive2(issue3.values[0])}`;
        return `à¸•à¸±à¸§à¹€à¸¥à¸·à¸­à¸à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™à¸«à¸™à¸¶à¹ˆà¸‡à¹ƒà¸™ ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "à¹„à¸¡à¹ˆà¹€à¸à¸´à¸™" : "à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${issue3.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "à¸£à¸²à¸¢à¸à¸²à¸£"}`;
        return `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${issue3.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢" : "à¸¡à¸²à¸à¸à¸§à¹ˆà¸²";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${issue3.origin} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${issue3.origin} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸‚à¸¶à¹‰à¸™à¸•à¹‰à¸™à¸”à¹‰à¸§à¸¢ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¥à¸‡à¸—à¹‰à¸²à¸¢à¸”à¹‰à¸§à¸¢ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¡à¸µ "${_issue.includes}" à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡`;
        if (_issue.format === "regex")
          return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸” ${_issue.pattern}`;
        return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `à¸•à¸±à¸§à¹€à¸¥à¸‚à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¸ˆà¸³à¸™à¸§à¸™à¸—à¸µà¹ˆà¸«à¸²à¸£à¸”à¹‰à¸§à¸¢ ${issue3.divisor} à¹„à¸”à¹‰à¸¥à¸‡à¸•à¸±à¸§`;
      case "unrecognized_keys":
        return `à¸žà¸šà¸„à¸µà¸¢à¹Œà¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸£à¸¹à¹‰à¸ˆà¸±à¸: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `à¸„à¸µà¸¢à¹Œà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${issue3.origin}`;
      case "invalid_union":
        return "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¹„à¸¡à¹ˆà¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸¢à¸¹à¹€à¸™à¸µà¸¢à¸™à¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸”à¹„à¸§à¹‰";
      case "invalid_element":
        return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${issue3.origin}`;
      default:
        return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡`;
    }
  };
};
function th_default2() {
  return {
    localeError: error72()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/tr.js
var parsedType6 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error73 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalÄ±" },
    file: { unit: "bayt", verb: "olmalÄ±" },
    array: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" },
    set: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sÃ¼re",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralÄ±ÄŸÄ±",
    cidrv6: "IPv6 aralÄ±ÄŸÄ±",
    base64: "base64 ile ÅŸifrelenmiÅŸ metin",
    base64url: "base64url ile ÅŸifrelenmiÅŸ metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayÄ±sÄ±",
    jwt: "JWT",
    template_literal: "Åžablon dizesi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `GeÃ§ersiz deÄŸer: beklenen ${issue3.expected}, alÄ±nan ${parsedType6(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `GeÃ§ersiz deÄŸer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `GeÃ§ersiz seÃ§enek: aÅŸaÄŸÄ±dakilerden biri olmalÄ±: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ok bÃ¼yÃ¼k: beklenen ${issue3.origin ?? "deÄŸer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ã¶ÄŸe"}`;
        return `Ã‡ok bÃ¼yÃ¼k: beklenen ${issue3.origin ?? "deÄŸer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `GeÃ§ersiz metin: "${_issue.prefix}" ile baÅŸlamalÄ±`;
        if (_issue.format === "ends_with")
          return `GeÃ§ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `GeÃ§ersiz metin: "${_issue.includes}" iÃ§ermeli`;
        if (_issue.format === "regex")
          return `GeÃ§ersiz metin: ${_issue.pattern} desenine uymalÄ±`;
        return `GeÃ§ersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `GeÃ§ersiz sayÄ±: ${issue3.divisor} ile tam bÃ¶lÃ¼nebilmeli`;
      case "unrecognized_keys":
        return `TanÄ±nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} iÃ§inde geÃ§ersiz anahtar`;
      case "invalid_union":
        return "GeÃ§ersiz deÄŸer";
      case "invalid_element":
        return `${issue3.origin} iÃ§inde geÃ§ersiz deÄŸer`;
      default:
        return `GeÃ§ersiz deÄŸer`;
    }
  };
};
function tr_default2() {
  return {
    localeError: error73()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ua.js
var error74 = () => {
  const Sizable = {
    string: { unit: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
    file: { unit: "Ð±Ð°Ð¹Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
    array: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
    set: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÐ¸Ð²";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–",
    email: "Ð°Ð´Ñ€ÐµÑÐ° ÐµÐ»ÐµÐºÑ‚Ñ€Ð¾Ð½Ð½Ð¾Ñ— Ð¿Ð¾ÑˆÑ‚Ð¸",
    url: "URL",
    emoji: "ÐµÐ¼Ð¾Ð´Ð·Ñ–",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "Ð´Ð°Ñ‚Ð° Ñ‚Ð° Ñ‡Ð°Ñ ISO",
    date: "Ð´Ð°Ñ‚Ð° ISO",
    time: "Ñ‡Ð°Ñ ISO",
    duration: "Ñ‚Ñ€Ð¸Ð²Ð°Ð»Ñ–ÑÑ‚ÑŒ ISO",
    ipv4: "Ð°Ð´Ñ€ÐµÑÐ° IPv4",
    ipv6: "Ð°Ð´Ñ€ÐµÑÐ° IPv6",
    cidrv4: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv4",
    cidrv6: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv6",
    base64: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64",
    base64url: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64url",
    json_string: "Ñ€ÑÐ´Ð¾Ðº JSON",
    e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164",
    jwt: "JWT",
    template_literal: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${issue3.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${parsedType7(issue3.input)}`;
      // return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${issue.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${stringifyPrimitive2(issue3.values[0])}`;
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð° Ð¾Ð¿Ñ†Ñ–Ñ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ Ð¾Ð´Ð½Ðµ Ð· ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²"}`;
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} Ð±ÑƒÐ´Ðµ ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue3.origin} Ð±ÑƒÐ´Ðµ ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¿Ð¾Ñ‡Ð¸Ð½Ð°Ñ‚Ð¸ÑÑ Ð· "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð·Ð°ÐºÑ–Ð½Ñ‡ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¼Ñ–ÑÑ‚Ð¸Ñ‚Ð¸ "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð°Ñ‚Ð¸ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð¿Ð¾Ð²Ð¸Ð½Ð½Ð¾ Ð±ÑƒÑ‚Ð¸ ÐºÑ€Ð°Ñ‚Ð½Ð¸Ð¼ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð¾Ð·Ð¿Ñ–Ð·Ð½Ð°Ð½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡${issue3.keys.length > 1 ? "Ñ–" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue3.origin}`;
      case "invalid_union":
        return "ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–";
      case "invalid_element":
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ñƒ ${issue3.origin}`;
      default:
        return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–`;
    }
  };
};
function ua_default2() {
  return {
    localeError: error74()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/ur.js
var error75 = () => {
  const Sizable = {
    string: { unit: "Ø­Ø±ÙˆÙ", verb: "ÛÙˆÙ†Ø§" },
    file: { unit: "Ø¨Ø§Ø¦Ù¹Ø³", verb: "ÛÙˆÙ†Ø§" },
    array: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" },
    set: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ù†Ù…Ø¨Ø±";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ø¢Ø±Û’";
        }
        if (data === null) {
          return "Ù†Ù„";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ø§Ù† Ù¾Ù¹",
    email: "Ø§ÛŒ Ù…ÛŒÙ„ Ø§ÛŒÚˆØ±ÛŒØ³",
    url: "ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„",
    emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
    uuid: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    uuidv4: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 4",
    uuidv6: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 6",
    nanoid: "Ù†ÛŒÙ†Ùˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    guid: "Ø¬ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    cuid: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    cuid2: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ 2",
    ulid: "ÛŒÙˆ Ø§ÛŒÙ„ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    xid: "Ø§ÛŒÚ©Ø³ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    ksuid: "Ú©Û’ Ø§ÛŒØ³ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
    datetime: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÚˆÛŒÙ¹ Ù¹Ø§Ø¦Ù…",
    date: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ØªØ§Ø±ÛŒØ®",
    time: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÙˆÙ‚Øª",
    duration: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ Ù…Ø¯Øª",
    ipv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø§ÛŒÚˆØ±ÛŒØ³",
    ipv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø§ÛŒÚˆØ±ÛŒØ³",
    cidrv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø±ÛŒÙ†Ø¬",
    cidrv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø±ÛŒÙ†Ø¬",
    base64: "Ø¨ÛŒØ³ 64 Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯",
    base64url: "Ø¨ÛŒØ³ 64 ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„ Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯",
    json_string: "Ø¬Û’ Ø§ÛŒØ³ Ø§Ùˆ Ø§ÛŒÙ† Ø³Ù¹Ø±Ù†Ú¯",
    e164: "Ø§ÛŒ 164 Ù†Ù…Ø¨Ø±",
    jwt: "Ø¬Û’ ÚˆØ¨Ù„ÛŒÙˆ Ù¹ÛŒ",
    template_literal: "Ø§Ù† Ù¾Ù¹"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${issue3.expected} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§ØŒ ${parsedType7(issue3.input)} Ù…ÙˆØµÙˆÙ„ ÛÙˆØ§`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${stringifyPrimitive2(issue3.values[0])} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
        return `ØºÙ„Ø· Ø¢Ù¾Ø´Ù†: ${joinValues2(issue3.values, "|")} Ù…ÛŒÚº Ø³Û’ Ø§ÛŒÚ© Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Ø¨ÛØª Ø¨Ú‘Ø§: ${issue3.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Û’ ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†Ø§ØµØ±"} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’`;
        return `Ø¨ÛØª Ø¨Ú‘Ø§: ${issue3.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Ø§ ${adj}${issue3.maximum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${issue3.origin} Ú©Û’ ${adj}${issue3.minimum.toString()} ${sizing.unit} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’`;
        }
        return `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${issue3.origin} Ú©Ø§ ${adj}${issue3.minimum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.prefix}" Ø³Û’ Ø´Ø±ÙˆØ¹ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        }
        if (_issue.format === "ends_with")
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.suffix}" Ù¾Ø± Ø®ØªÙ… ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        if (_issue.format === "includes")
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.includes}" Ø´Ø§Ù…Ù„ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        if (_issue.format === "regex")
          return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: Ù¾ÛŒÙ¹Ø±Ù† ${_issue.pattern} Ø³Û’ Ù…ÛŒÚ† ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
        return `ØºÙ„Ø· ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ØºÙ„Ø· Ù†Ù…Ø¨Ø±: ${issue3.divisor} Ú©Ø§ Ù…Ø¶Ø§Ø¹Ù ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
      case "unrecognized_keys":
        return `ØºÛŒØ± ØªØ³Ù„ÛŒÙ… Ø´Ø¯Û Ú©ÛŒ${issue3.keys.length > 1 ? "Ø²" : ""}: ${joinValues2(issue3.keys, "ØŒ ")}`;
      case "invalid_key":
        return `${issue3.origin} Ù…ÛŒÚº ØºÙ„Ø· Ú©ÛŒ`;
      case "invalid_union":
        return "ØºÙ„Ø· Ø§Ù† Ù¾Ù¹";
      case "invalid_element":
        return `${issue3.origin} Ù…ÛŒÚº ØºÙ„Ø· ÙˆÛŒÙ„ÛŒÙˆ`;
      default:
        return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹`;
    }
  };
};
function ur_default2() {
  return {
    localeError: error75()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/vi.js
var error76 = () => {
  const Sizable = {
    string: { unit: "kÃ½ tá»±", verb: "cÃ³" },
    file: { unit: "byte", verb: "cÃ³" },
    array: { unit: "pháº§n tá»­", verb: "cÃ³" },
    set: { unit: "pháº§n tá»­", verb: "cÃ³" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sá»‘";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "máº£ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Ä‘áº§u vÃ o",
    email: "Ä‘á»‹a chá»‰ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngÃ y giá» ISO",
    date: "ngÃ y ISO",
    time: "giá» ISO",
    duration: "khoáº£ng thá»i gian ISO",
    ipv4: "Ä‘á»‹a chá»‰ IPv4",
    ipv6: "Ä‘á»‹a chá»‰ IPv6",
    cidrv4: "dáº£i IPv4",
    cidrv6: "dáº£i IPv6",
    base64: "chuá»—i mÃ£ hÃ³a base64",
    base64url: "chuá»—i mÃ£ hÃ³a base64url",
    json_string: "chuá»—i JSON",
    e164: "sá»‘ E.164",
    jwt: "JWT",
    template_literal: "Ä‘áº§u vÃ o"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${issue3.expected}, nháº­n Ä‘Æ°á»£c ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${stringifyPrimitive2(issue3.values[0])}`;
        return `TÃ¹y chá»n khÃ´ng há»£p lá»‡: mong Ä‘á»£i má»™t trong cÃ¡c giÃ¡ trá»‹ ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `QuÃ¡ lá»›n: mong Ä‘á»£i ${issue3.origin ?? "giÃ¡ trá»‹"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "pháº§n tá»­"}`;
        return `QuÃ¡ lá»›n: mong Ä‘á»£i ${issue3.origin ?? "giÃ¡ trá»‹"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `QuÃ¡ nhá»: mong Ä‘á»£i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `QuÃ¡ nhá»: mong Ä‘á»£i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i báº¯t Ä‘áº§u báº±ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i káº¿t thÃºc báº±ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i bao gá»“m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i khá»›p vá»›i máº«u ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} khÃ´ng há»£p lá»‡`;
      }
      case "not_multiple_of":
        return `Sá»‘ khÃ´ng há»£p lá»‡: pháº£i lÃ  bá»™i sá»‘ cá»§a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `KhÃ³a khÃ´ng Ä‘Æ°á»£c nháº­n dáº¡ng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `KhÃ³a khÃ´ng há»£p lá»‡ trong ${issue3.origin}`;
      case "invalid_union":
        return "Äáº§u vÃ o khÃ´ng há»£p lá»‡";
      case "invalid_element":
        return `GiÃ¡ trá»‹ khÃ´ng há»£p lá»‡ trong ${issue3.origin}`;
      default:
        return `Äáº§u vÃ o khÃ´ng há»£p lá»‡`;
    }
  };
};
function vi_default2() {
  return {
    localeError: error76()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/zh-CN.js
var error77 = () => {
  const Sizable = {
    string: { unit: "å­—ç¬¦", verb: "åŒ…å«" },
    file: { unit: "å­—èŠ‚", verb: "åŒ…å«" },
    array: { unit: "é¡¹", verb: "åŒ…å«" },
    set: { unit: "é¡¹", verb: "åŒ…å«" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "éžæ•°å­—(NaN)" : "æ•°å­—";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "æ•°ç»„";
        }
        if (data === null) {
          return "ç©ºå€¼(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "è¾“å…¥",
    email: "ç”µå­é‚®ä»¶",
    url: "URL",
    emoji: "è¡¨æƒ…ç¬¦å·",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISOæ—¥æœŸæ—¶é—´",
    date: "ISOæ—¥æœŸ",
    time: "ISOæ—¶é—´",
    duration: "ISOæ—¶é•¿",
    ipv4: "IPv4åœ°å€",
    ipv6: "IPv6åœ°å€",
    cidrv4: "IPv4ç½‘æ®µ",
    cidrv6: "IPv6ç½‘æ®µ",
    base64: "base64ç¼–ç å­—ç¬¦ä¸²",
    base64url: "base64urlç¼–ç å­—ç¬¦ä¸²",
    json_string: "JSONå­—ç¬¦ä¸²",
    e164: "E.164å·ç ",
    jwt: "JWT",
    template_literal: "è¾“å…¥"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${issue3.expected}ï¼Œå®žé™…æŽ¥æ”¶ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${stringifyPrimitive2(issue3.values[0])}`;
        return `æ— æ•ˆé€‰é¡¹ï¼šæœŸæœ›ä»¥ä¸‹ä¹‹ä¸€ ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${issue3.origin ?? "å€¼"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ä¸ªå…ƒç´ "}`;
        return `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${issue3.origin ?? "å€¼"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${_issue.prefix}" å¼€å¤´`;
        if (_issue.format === "ends_with")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${_issue.suffix}" ç»“å°¾`;
        if (_issue.format === "includes")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»åŒ…å« "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼ ${_issue.pattern}`;
        return `æ— æ•ˆ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `æ— æ•ˆæ•°å­—ï¼šå¿…é¡»æ˜¯ ${issue3.divisor} çš„å€æ•°`;
      case "unrecognized_keys":
        return `å‡ºçŽ°æœªçŸ¥çš„é”®(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} ä¸­çš„é”®(key)æ— æ•ˆ`;
      case "invalid_union":
        return "æ— æ•ˆè¾“å…¥";
      case "invalid_element":
        return `${issue3.origin} ä¸­åŒ…å«æ— æ•ˆå€¼(value)`;
      default:
        return `æ— æ•ˆè¾“å…¥`;
    }
  };
};
function zh_CN_default2() {
  return {
    localeError: error77()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/locales/zh-TW.js
var error78 = () => {
  const Sizable = {
    string: { unit: "å­—å…ƒ", verb: "æ“æœ‰" },
    file: { unit: "ä½å…ƒçµ„", verb: "æ“æœ‰" },
    array: { unit: "é …ç›®", verb: "æ“æœ‰" },
    set: { unit: "é …ç›®", verb: "æ“æœ‰" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "è¼¸å…¥",
    email: "éƒµä»¶åœ°å€",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO æ—¥æœŸæ™‚é–“",
    date: "ISO æ—¥æœŸ",
    time: "ISO æ™‚é–“",
    duration: "ISO æœŸé–“",
    ipv4: "IPv4 ä½å€",
    ipv6: "IPv6 ä½å€",
    cidrv4: "IPv4 ç¯„åœ",
    cidrv6: "IPv6 ç¯„åœ",
    base64: "base64 ç·¨ç¢¼å­—ä¸²",
    base64url: "base64url ç·¨ç¢¼å­—ä¸²",
    json_string: "JSON å­—ä¸²",
    e164: "E.164 æ•¸å€¼",
    jwt: "JWT",
    template_literal: "è¼¸å…¥"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${issue3.expected}ï¼Œä½†æ”¶åˆ° ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${stringifyPrimitive2(issue3.values[0])}`;
        return `ç„¡æ•ˆçš„é¸é …ï¼šé æœŸç‚ºä»¥ä¸‹å…¶ä¸­ä¹‹ä¸€ ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${issue3.origin ?? "å€¼"} æ‡‰ç‚º ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "å€‹å…ƒç´ "}`;
        return `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${issue3.origin ?? "å€¼"} æ‡‰ç‚º ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `æ•¸å€¼éŽå°ï¼šé æœŸ ${issue3.origin} æ‡‰ç‚º ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `æ•¸å€¼éŽå°ï¼šé æœŸ ${issue3.origin} æ‡‰ç‚º ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${_issue.prefix}" é–‹é ­`;
        }
        if (_issue.format === "ends_with")
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${_issue.suffix}" çµå°¾`;
        if (_issue.format === "includes")
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆåŒ…å« "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆç¬¦åˆæ ¼å¼ ${_issue.pattern}`;
        return `ç„¡æ•ˆçš„ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ç„¡æ•ˆçš„æ•¸å­—ï¼šå¿…é ˆç‚º ${issue3.divisor} çš„å€æ•¸`;
      case "unrecognized_keys":
        return `ç„¡æ³•è­˜åˆ¥çš„éµå€¼${issue3.keys.length > 1 ? "å€‘" : ""}ï¼š${joinValues2(issue3.keys, "ã€")}`;
      case "invalid_key":
        return `${issue3.origin} ä¸­æœ‰ç„¡æ•ˆçš„éµå€¼`;
      case "invalid_union":
        return "ç„¡æ•ˆçš„è¼¸å…¥å€¼";
      case "invalid_element":
        return `${issue3.origin} ä¸­æœ‰ç„¡æ•ˆçš„å€¼`;
      default:
        return `ç„¡æ•ˆçš„è¼¸å…¥å€¼`;
    }
  };
};
function zh_TW_default2() {
  return {
    localeError: error78()
  };
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/registries.js
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");
var $ZodRegistry2 = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry2() {
  return new $ZodRegistry2();
}
var globalRegistry2 = registry2();

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
var TimePrecision2 = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined4(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null4(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void2(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch2(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const _Transform = Classes.Transform ?? $ZodTransform2;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/function.js
var $ZodFunction2 = class {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = ((...args) => {
      const parsedArgs = this._def.input ? parse3(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse3(this._def.output, output, void 0, { callee: impl }) : output;
    });
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync2(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync2(this._def.output, output, void 0, { callee: impl }) : output;
    });
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple2({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
};
function _function2(params) {
  return new $ZodFunction2({
    type: "function",
    input: Array.isArray(params == null ? void 0 : params.input) ? _tuple2($ZodTuple2, params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? _array2($ZodArray2, _unknown2($ZodUnknown2)),
    output: (params == null ? void 0 : params.output) ?? _unknown2($ZodUnknown2)
  });
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator2 = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry2;
    this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
    this.override = (params == null ? void 0 : params.override) ?? (() => {
    });
    this.io = (params == null ? void 0 : params.io) ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a6, _b, _c;
    var _a5;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = (_b = (_a6 = schema._zod).toJSONSchema) == null ? void 0 : _b.call(_a6);
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (((_c = def.catchall) == null ? void 0 : _c._zod.def.type) === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues2(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file.minLength = minimum;
            if (maximum !== void 0)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming2(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a5 = result.schema).default ?? (_a5.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    var _a5, _b, _c, _d, _e, _f;
    const params = {
      cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
      reused: (_params == null ? void 0 : _params.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (_params == null ? void 0 : _params.external) ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      var _a6;
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = (_a6 = params.external.registry.get(entry[0])) == null ? void 0 : _a6.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${(_a5 = seen.cycle) == null ? void 0 : _a5.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = (_b = params.external.registry.get(entry[0])) == null ? void 0 : _b.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = (_c = this.metadataRegistry.get(entry[0])) == null ? void 0 : _c.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if ((_d = params.external) == null ? void 0 : _d.uri) {
      const id = (_e = params.external.registry.get(schema)) == null ? void 0 : _e.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = ((_f = params.external) == null ? void 0 : _f.defs) ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema2(input, _params) {
  if (input instanceof $ZodRegistry2) {
    const gen2 = new JSONSchemaGenerator2(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params == null ? void 0 : _params.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator2(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming2(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming2(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming2(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming2(item, ctx))
          return true;
      }
      if (def.rest && isTransforming2(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "map": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "set": {
      return isTransforming2(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming2(def.innerType, ctx);
    case "lazy":
      return isTransforming2(def.getter(), ctx);
    case "default": {
      return isTransforming2(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming2(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/core/json-schema.js
var json_schema_exports2 = {};

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/mini/schemas.js
var ZodMiniType2 = $constructor2("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType2.init(inst, def);
  inst.def = def;
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (_def, params) => clone2(inst, _def, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
});
var ZodMiniString2 = $constructor2("ZodMiniString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function string5(params) {
  return _string2(ZodMiniString2, params);
}
var ZodMiniStringFormat2 = $constructor2("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  ZodMiniString2.init(inst, def);
});
var ZodMiniEmail2 = $constructor2("ZodMiniEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniGUID2 = $constructor2("ZodMiniGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniUUID2 = $constructor2("ZodMiniUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniURL2 = $constructor2("ZodMiniURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniEmoji2 = $constructor2("ZodMiniEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniNanoID2 = $constructor2("ZodMiniNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniCUID3 = $constructor2("ZodMiniCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniCUID22 = $constructor2("ZodMiniCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniULID2 = $constructor2("ZodMiniULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniXID2 = $constructor2("ZodMiniXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniKSUID2 = $constructor2("ZodMiniKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniIPv42 = $constructor2("ZodMiniIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniIPv62 = $constructor2("ZodMiniIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniCIDRv42 = $constructor2("ZodMiniCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniCIDRv62 = $constructor2("ZodMiniCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniBase642 = $constructor2("ZodMiniBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniBase64URL2 = $constructor2("ZodMiniBase64URL", (inst, def) => {
  $ZodBase64URL2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniE1642 = $constructor2("ZodMiniE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniJWT2 = $constructor2("ZodMiniJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniCustomStringFormat2 = $constructor2("ZodMiniCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
var ZodMiniNumber2 = $constructor2("ZodMiniNumber", (inst, def) => {
  $ZodNumber2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function number4(params) {
  return _number2(ZodMiniNumber2, params);
}
var ZodMiniNumberFormat2 = $constructor2("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat2.init(inst, def);
  ZodMiniNumber2.init(inst, def);
});
var ZodMiniBoolean2 = $constructor2("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniBigInt2 = $constructor2("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniBigIntFormat2 = $constructor2("ZodMiniBigIntFormat", (inst, def) => {
  $ZodBigIntFormat2.init(inst, def);
  ZodMiniBigInt2.init(inst, def);
});
var ZodMiniSymbol2 = $constructor2("ZodMiniSymbol", (inst, def) => {
  $ZodSymbol2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniUndefined2 = $constructor2("ZodMiniUndefined", (inst, def) => {
  $ZodUndefined2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniNull2 = $constructor2("ZodMiniNull", (inst, def) => {
  $ZodNull2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniAny2 = $constructor2("ZodMiniAny", (inst, def) => {
  $ZodAny2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function any() {
  return _any2(ZodMiniAny2);
}
var ZodMiniUnknown2 = $constructor2("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniNever2 = $constructor2("ZodMiniNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniVoid2 = $constructor2("ZodMiniVoid", (inst, def) => {
  $ZodVoid2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniDate2 = $constructor2("ZodMiniDate", (inst, def) => {
  $ZodDate2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function date5(params) {
  return _date2(ZodMiniDate2, params);
}
var ZodMiniArray2 = $constructor2("ZodMiniArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function array2(element, params) {
  return new ZodMiniArray2({
    type: "array",
    element,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodMiniObject2 = $constructor2("ZodMiniObject", (inst, def) => {
  $ZodObject2.init(inst, def);
  ZodMiniType2.init(inst, def);
  util_exports2.defineLazy(inst, "shape", () => def.shape);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports2.normalizeParams(params)
  };
  return new ZodMiniObject2(def);
}
var ZodMiniUnion2 = $constructor2("ZodMiniUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniDiscriminatedUnion2 = $constructor2("ZodMiniDiscriminatedUnion", (inst, def) => {
  $ZodDiscriminatedUnion2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniIntersection2 = $constructor2("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniTuple2 = $constructor2("ZodMiniTuple", (inst, def) => {
  $ZodTuple2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniRecord2 = $constructor2("ZodMiniRecord", (inst, def) => {
  $ZodRecord2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function record2(keyType, valueType, params) {
  return new ZodMiniRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodMiniMap2 = $constructor2("ZodMiniMap", (inst, def) => {
  $ZodMap2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniSet2 = $constructor2("ZodMiniSet", (inst, def) => {
  $ZodSet2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniEnum2 = $constructor2("ZodMiniEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodMiniEnum2({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodMiniLiteral2 = $constructor2("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniFile2 = $constructor2("ZodMiniFile", (inst, def) => {
  $ZodFile2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniTransform2 = $constructor2("ZodMiniTransform", (inst, def) => {
  $ZodTransform2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniOptional2 = $constructor2("ZodMiniOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function optional2(innerType) {
  return new ZodMiniOptional2({
    type: "optional",
    innerType
  });
}
var ZodMiniNullable2 = $constructor2("ZodMiniNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function nullable2(innerType) {
  return new ZodMiniNullable2({
    type: "nullable",
    innerType
  });
}
var ZodMiniDefault2 = $constructor2("ZodMiniDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniPrefault2 = $constructor2("ZodMiniPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniNonOptional2 = $constructor2("ZodMiniNonOptional", (inst, def) => {
  $ZodNonOptional2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniSuccess2 = $constructor2("ZodMiniSuccess", (inst, def) => {
  $ZodSuccess2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniCatch2 = $constructor2("ZodMiniCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniNaN2 = $constructor2("ZodMiniNaN", (inst, def) => {
  $ZodNaN2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniPipe2 = $constructor2("ZodMiniPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniReadonly2 = $constructor2("ZodMiniReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniTemplateLiteral2 = $constructor2("ZodMiniTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniLazy2 = $constructor2("ZodMiniLazy", (inst, def) => {
  $ZodLazy2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniPromise2 = $constructor2("ZodMiniPromise", (inst, def) => {
  $ZodPromise2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
var ZodMiniCustom2 = $constructor2("ZodMiniCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodMiniType2.init(inst, def);
});
function custom(fn, _params) {
  return _custom2(ZodMiniCustom2, fn ?? (() => true), _params);
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/mini/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodMiniISODate: () => ZodMiniISODate2,
  ZodMiniISODateTime: () => ZodMiniISODateTime2,
  ZodMiniISODuration: () => ZodMiniISODuration2,
  ZodMiniISOTime: () => ZodMiniISOTime2,
  date: () => date6,
  datetime: () => datetime4,
  duration: () => duration4,
  time: () => time4
});
var ZodMiniISODateTime2 = $constructor2("$ZodISODateTime", (inst, def) => {
  $ZodISODateTime2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
function datetime4(params) {
  return _isoDateTime2(ZodMiniISODateTime2, params);
}
var ZodMiniISODate2 = $constructor2("$ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
function date6(params) {
  return _isoDate2(ZodMiniISODate2, params);
}
var ZodMiniISOTime2 = $constructor2("$ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
function time4(params) {
  return _isoTime2(ZodMiniISOTime2, params);
}
var ZodMiniISODuration2 = $constructor2("$ZodISODuration", (inst, def) => {
  $ZodISODuration2.init(inst, def);
  ZodMiniStringFormat2.init(inst, def);
});
function duration4(params) {
  return _isoDuration2(ZodMiniISODuration2, params);
}

// node_modules/@dynamic-labs-sdk/client/node_modules/zod/v4/mini/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint4,
  boolean: () => boolean5,
  date: () => date7,
  number: () => number5,
  string: () => string6
});
function string6(params) {
  return _coercedString2(ZodMiniString2, params);
}
function number5(params) {
  return _coercedNumber2(ZodMiniNumber2, params);
}
function boolean5(params) {
  return _coercedBoolean2(ZodMiniBoolean2, params);
}
function bigint4(params) {
  return _coercedBigint2(ZodMiniBigInt2, params);
}
function date7(params) {
  return _coercedDate2(ZodMiniDate2, params);
}

// node_modules/@dynamic-labs-sdk/client/dist/core.esm.js
var registerExtension = ({ extensionKey }, client) => {
  getCore(client).extensions.add(extensionKey);
};
var networkRegistryStorageKeySchema = createStorageKeySchema({
  key: "lastKnownNetworkRegistry",
  schema: record2(string5(), string5())
});
var createLastKnownNetworkRegistry = (client) => {
  const core = getCore(client);
  const walletProviderKeyToNetworkId = /* @__PURE__ */ new Map();
  const getNetworkId = async ({ walletProviderKey }) => {
    if (walletProviderKeyToNetworkId.has(walletProviderKey)) return { networkId: walletProviderKeyToNetworkId.get(walletProviderKey) };
    const storageRecords = await core.storage.getItem(networkRegistryStorageKeySchema);
    if (storageRecords && storageRecords[walletProviderKey]) {
      const networkId = storageRecords[walletProviderKey];
      walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
      return { networkId };
    }
    const walletProvider = getWalletProviderByKey({ walletProviderKey }, client);
    const networkProviders = getNetworkProviders(client);
    if (networkProviders.length === 0) throw new NoNetworkProvidersError();
    const defaultNetworkProvider = networkProviders.find((networkProvider) => networkProvider.chain === walletProvider.chain);
    assertDefined2(defaultNetworkProvider, `No networks found for chain ${walletProvider.chain}`);
    walletProviderKeyToNetworkId.set(walletProviderKey, defaultNetworkProvider.networkId);
    return { networkId: defaultNetworkProvider.networkId };
  };
  const setNetworkId = async ({ networkId, walletProviderKey }) => {
    walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
    await core.storage.setItem(networkRegistryStorageKeySchema, Object.fromEntries(walletProviderKeyToNetworkId.entries()));
  };
  return {
    getNetworkId,
    setNetworkId
  };
};
var getLastKnownNetworkRegistry = createRuntimeServiceAccessKey("last-known-network-registry", (client) => createLastKnownNetworkRegistry(client));
assertPackageVersion2(name, version8);

export {
  LogLevel,
  Logger,
  assertPackageVersion,
  walletConnectorEvents,
  logger6 as logger,
  ProviderLookup,
  setChainInfoOverrides,
  getChainInfo,
  getChainInfoWithOverrides,
  isEmailOTPWalletConnector,
  isEmailWalletConnector,
  isTurnkeyWalletConnector,
  isSameAddress,
  isSocialWalletConnector,
  getWalletConnectorByKey,
  bufferToBase64,
  ceil,
  DeferredPromise,
  CustomError,
  DynamicError,
  AccessBlockedError,
  AccountExistsError,
  ChainalysisError,
  CustomFieldNotUniqueError,
  EmailAlreadyExistsError,
  EmailVerificationError,
  EmbeddedWalletException,
  EmbeddedWalletExistsError,
  ErrorCode,
  GateBlockedError,
  GetAddressCancelledError,
  InsufficientFundsError,
  InvalidEmbeddedWalletSessionKeyError,
  InvalidPhoneNumberError,
  InvalidPrimaryWalletOrConnectorError,
  MergeAccountsConfirmationError,
  MissingEnvironmentIdError,
  MissingPublicAddressError,
  NoAccessError,
  NotSupportedError,
  RequestChannelNotHandledError,
  ResponseError,
  SandboxMaximumThresholdReachedError,
  SmsVerificationError,
  SocialAccountAlreadyExistsError,
  TooManyEmailVerificationsError,
  TransactionGasCannotBeSponsoredError,
  UserHasAccountWithEmailError,
  UsernameAlreadyExistsError,
  UserRejectedRequestError,
  UserRejectedTransactionError,
  VerificationDataCollectionError,
  WalletNotDeployedError,
  WalletUsedError,
  formatNumberText,
  getProvidersFromWindow,
  PlatformService,
  getTLD,
  isMobile,
  isIPhone,
  isIPhone8OrEarlier,
  isIPad,
  isIOS,
  isAndroid,
  isLegacySafari,
  isSamsungBrowser,
  getAndroidVersion,
  handleMobileWalletRedirect,
  isLedgerAddressViaVerifiedCredentials,
  isString,
  pipe,
  sleep,
  sanitizeName,
  filterDuplicates,
  cloneObjectWithOverrides,
  get,
  hexToString,
  isHex,
  runSafe,
  tracing,
  PHANTOM_REDIRECT_CONNECTION_TYPE_KEY,
  FetchService,
  SocialOAuthErrorCode,
  Oauth2Service,
  createStorageService,
  StorageService,
  applyPostfixToStorageService,
  solToLamports,
  getEnvVarWithFallback,
  getDeepLink,
  performPlatformSpecificConnectionMethod,
  isEmbeddedConnector,
  isMagicConnector,
  isBloctoConnector,
  isPasskeyWalletConnector,
  isAccountAbstractionConnector,
  isBitcoinConnector,
  isHardwareWalletConnector,
  isPhantomRedirectConnector,
  isWalletConnectConnector,
  isSendBalanceWalletConnector,
  isSessionKeyCompatibleWalletConnector,
  isSessionKeyCompatibleWallet,
  useWalletBookContext,
  getIconicSpriteUrl,
  BraveIcon,
  ChromeIcon,
  EdgeIcon,
  FirefoxIcon,
  OperaIcon,
  SafariIcon,
  AlgorandIcon,
  AptosIcon,
  BitcoinIcon,
  CosmosIcon,
  EclipseIcon,
  EthereumIcon,
  FlowIcon,
  SolanaIcon,
  SparkIcon,
  StarknetIcon,
  SuiIcon,
  TonIcon,
  TronIcon,
  DiscordIcon,
  HelpdeskIcon,
  SlackIcon,
  TwitterIcon,
  SignInWithEmailIcon,
  WalletConnectIcon,
  AppleIcon,
  AndroidIcon,
  CaptchaWaveIcon,
  UserProfileIcon,
  findSocialIcon,
  SocialIcon,
  findWalletBookWallet,
  getWalletBookCdnUrl,
  findWalletGroupOverride,
  isWalletBookPopulated,
  findWalletBookWalletByNameAndChain,
  useWalletBookCdn,
  WalletIcon,
  WalletBookContextProvider,
  BrandIcon,
  getWalletMetadataFromWalletBook,
  isConnectorEventSupported,
  getWalletLinks,
  isDynamicWaasConnector,
  getWalletProvider,
  connectorRequiresDisconnectionForNewConnection,
  Wallet,
  WalletConnectorBase,
  ProviderChain,
  ChainRpcProviders,
  name,
  version8 as version,
  getCore,
  BaseError,
  getDefaultClient,
  setDefaultClient,
  CLIENT_SDK_NAME,
  assertDefined2 as assertDefined,
  isCookieEnabled,
  getBuffer,
  InvalidExternalAuthError,
  MfaInvalidOtpError,
  MfaRateLimitedError,
  SandboxMaximumThresholdReachedError2,
  createApiClient,
  SDK_API_CORE_VERSION,
  setCookie,
  onEvent,
  emitEvent,
  formatWalletProviderKey,
  getWalletAccounts,
  getWalletProviderFromWalletAccount,
  DYNAMIC_AUTH_COOKIE_NAME,
  checkAndRaiseWalletAccountsChangedEvent,
  restoreUserSharesForAllWalletAccounts,
  updateAuthFromVerifyResponse,
  import_index5 as import_index,
  eventemitter3_default5 as eventemitter3_default,
  isEqualShallow,
  subscribeWithSelector,
  createLocalStorageAdapter,
  createStorage,
  createStorageKeySchema,
  REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY,
  INITIALIZE_STORAGE_SYNC_TRACKER_KEY,
  FETCH_PROJECT_SETTINGS_TRACKER_KEY,
  GENERATE_SESSION_KEYS_TRACKER_KEY,
  createDeferredPromise,
  CannotTrackError,
  createLogger,
  hasExtension,
  bufferToHex2 as bufferToHex,
  consumeMfaToken,
  getMfaMethods,
  isMfaRequiredForAction,
  assertPackageVersion2,
  string5 as string,
  number4 as number,
  any,
  date5 as date,
  array2 as array,
  object2 as object,
  record2 as record,
  _enum4 as _enum,
  optional2 as optional,
  nullable2 as nullable,
  custom,
  registerExtension
};
//# sourceMappingURL=chunk-QJ4AXN3D.js.map
