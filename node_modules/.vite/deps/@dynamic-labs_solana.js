"use client";
import "./chunk-C7YSRRCZ.js";
import {
  BaseError as BaseError2,
  LruMap as LruMap2,
  checksumAddress,
  concat as concat2,
  defineFormatter as defineFormatter2,
  from as from2,
  fromBoolean as fromBoolean2,
  fromBytes as fromBytes2,
  fromNumber as fromNumber2,
  fromString as fromString3,
  fromString2 as fromString4,
  hexToBigInt,
  hexToNumber as hexToNumber2,
  isHex,
  keccak256,
  numberToHex as numberToHex2,
  padLeft as padLeft2,
  padRight as padRight2,
  size as size2,
  size2 as size3,
  toHex
} from "./chunk-PNRWCH66.js";
import {
  require_crypto
} from "./chunk-PVOWFSIG.js";
import "./chunk-XWZ3RPJ2.js";
import {
  createHash
} from "./chunk-GX5ZUNPE.js";
import {
  stringToBase64urlString
} from "./chunk-TJGQWPPV.js";
import {
  createAssociatedTokenAccountInstruction,
  createTransferInstruction,
  getAssociatedTokenAddress
} from "./chunk-OX62JOFF.js";
import "./chunk-QBQGTVJM.js";
import {
  hmac
} from "./chunk-GEEVCR2I.js";
import {
  BaseError,
  LruMap,
  _validateObject,
  aInRange,
  abool,
  bitLen,
  bitMask,
  bytesToNumberBE,
  bytesToNumberLE,
  concat,
  createHmacDrbg,
  defineFormatter,
  ensureBytes,
  equalBytes,
  from,
  fromBoolean,
  fromBytes,
  fromNumber,
  fromString,
  fromString2,
  hexToNumber,
  inRange,
  isHash,
  memoized,
  numberToBytesBE,
  numberToBytesLE,
  numberToHex,
  numberToHexUnpadded,
  padLeft,
  padRight,
  size
} from "./chunk-J7WB3EYP.js";
import {
  ChainRpcProviders,
  DeferredPromise,
  DynamicError,
  LogLevel,
  Logger,
  NotSupportedError,
  PHANTOM_REDIRECT_CONNECTION_TYPE_KEY,
  PlatformService,
  ProviderChain,
  ProviderLookup,
  RequestChannelNotHandledError,
  StorageService,
  Wallet,
  WalletConnectorBase,
  assertPackageVersion,
  bufferToBase64,
  cloneObjectWithOverrides,
  createApiClient,
  filterDuplicates,
  findWalletBookWallet,
  findWalletBookWalletByNameAndChain,
  formatNumberText,
  get,
  getDeepLink,
  getDefaultClient,
  getProvidersFromWindow,
  getTLD,
  getWalletMetadataFromWalletBook,
  handleMobileWalletRedirect,
  isLedgerAddressViaVerifiedCredentials,
  isMobile,
  isSameAddress,
  logger,
  performPlatformSpecificConnectionMethod,
  sanitizeName,
  solToLamports,
  walletConnectorEvents
} from "./chunk-QJ4AXN3D.js";
import {
  AuthenticatorTransportProtocol,
  MFAAction
} from "./chunk-VYCGVLXH.js";
import {
  CommonClient,
  PublicKey,
  Transaction,
  VersionedTransaction,
  WebSocket as WebSocket2,
  any,
  array,
  boolean,
  coerce,
  create,
  ed25519,
  import_index,
  instance,
  literal,
  nullable,
  number,
  optional,
  record,
  require_Layout,
  require_bn,
  require_browser,
  require_lib,
  require_safe_buffer,
  secp256k1,
  sha256 as sha2562,
  string,
  tuple,
  type,
  union,
  unknown
} from "./chunk-AUWC7W23.js";
import "./chunk-CYXDKUZK.js";
import {
  Chi,
  HashMD,
  Maj,
  sha256,
  sha512
} from "./chunk-WH7MQHDY.js";
import {
  keccak_256
} from "./chunk-HUHIQS7X.js";
import {
  abytes,
  anumber,
  bytesToHex,
  clean,
  concatBytes,
  createHasher,
  hexToBytes,
  isBytes,
  randomBytes,
  rotl,
  utf8ToBytes
} from "./chunk-OXML7QZZ.js";
import {
  require_buffer
} from "./chunk-E2DP5LJY.js";
import "./chunk-BUSDCBXK.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-MVEJMUOB.js";

// node_modules/@dynamic-labs/solana-core/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@dynamic-labs/solana-core/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base3(ALPHABET3) {
      if (ALPHABET3.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
        BASE_MAP[j3] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
        var x5 = ALPHABET3.charAt(i4);
        var xc3 = x5.charCodeAt(0);
        if (BASE_MAP[xc3] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc3] = i4;
      }
      var BASE = ALPHABET3.length;
      var LEADER = ALPHABET3.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size9);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          pbegin++;
        }
        var it22 = size9 - length2;
        while (it22 !== size9 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size9; ++it22) {
          str += ALPHABET3.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size9);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          psz++;
        }
        var it4 = size9 - length2;
        while (it4 !== size9 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size9 - it4));
        vch.fill(0, 0, zeroes);
        var j4 = zeroes;
        while (it4 !== size9) {
          vch[j4++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string4) {
        var buffer = decodeUnsafe(string4);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode9
      };
    }
    module.exports = base3;
  }
});

// node_modules/@dynamic-labs/solana-core/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/@dynamic-labs/solana-core/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET3);
  }
});

// node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base3(ALPHABET3) {
      if (ALPHABET3.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
        BASE_MAP[j3] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
        var x5 = ALPHABET3.charAt(i4);
        var xc3 = x5.charCodeAt(0);
        if (BASE_MAP[xc3] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc3] = i4;
      }
      var BASE = ALPHABET3.length;
      var LEADER = ALPHABET3.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size9);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          pbegin++;
        }
        var it22 = size9 - length2;
        while (it22 !== size9 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size9; ++it22) {
          str += ALPHABET3.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size9);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          psz++;
        }
        var it4 = size9 - length2;
        while (it4 !== size9 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size9 - it4));
        vch.fill(0, 0, zeroes);
        var j4 = zeroes;
        while (it4 !== size9) {
          vch[j4++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string4) {
        var buffer = decodeUnsafe(string4);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode9
      };
    }
    module.exports = base3;
  }
});

// node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs582 = __commonJS({
  "node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src2();
    var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET3);
  }
});

// node_modules/@walletconnect/time/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter3,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d4, b4) {
  extendStatics(d4, b4);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
function __rest(s3, e2) {
  var t = {};
  for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
    t[p4] = s3[p4];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s3); i4 < p4.length; i4++) {
      if (e2.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i4]))
        t[p4[i4]] = s3[p4[i4]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c6 = arguments.length, r3 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c6 < 3 ? d4(r3) : c6 > 3 ? d4(target, key, r3) : d4(target, key)) || r3;
  return c6 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter3(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _3 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f8, y5, t, g3;
  return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n5) {
    return function(v6) {
      return step([n5, v6]);
    };
  }
  function step(op) {
    if (f8) throw new TypeError("Generator is already executing.");
    while (_3) try {
      if (f8 = 1, y5 && (t = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t = y5["return"]) && t.call(y5), 0) : y5.next) && !(t = t.call(y5, op[1])).done) return t;
      if (y5 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _3.label++;
          return { value: op[1], done: false };
        case 5:
          _3.label++;
          y5 = op[1];
          op = [0];
          continue;
        case 7:
          op = _3.ops.pop();
          _3.trys.pop();
          continue;
        default:
          if (!(t = _3.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _3 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _3.label = op[1];
            break;
          }
          if (op[0] === 6 && _3.label < t[1]) {
            _3.label = t[1];
            t = op;
            break;
          }
          if (t && _3.label < t[2]) {
            _3.label = t[2];
            _3.ops.push(op);
            break;
          }
          if (t[2]) _3.ops.pop();
          _3.trys.pop();
          continue;
      }
      op = body.call(thisArg, _3);
    } catch (e2) {
      op = [6, e2];
      y5 = 0;
    } finally {
      f8 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o4, m3, k6, k22) {
  if (k22 === void 0) k22 = k6;
  o4[k22] = m3[k6];
}
function __exportStar(m3, exports) {
  for (var p4 in m3) if (p4 !== "default" && !exports.hasOwnProperty(p4)) exports[p4] = m3[p4];
}
function __values(o4) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o4[s3], i4 = 0;
  if (m3) return m3.call(o4);
  if (o4 && typeof o4.length === "number") return {
    next: function() {
      if (o4 && i4 >= o4.length) o4 = void 0;
      return { value: o4 && o4[i4++], done: !o4 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o4, n5) {
  var m3 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m3) return o4;
  var i4 = m3.call(o4), r3, ar3 = [], e2;
  try {
    while ((n5 === void 0 || n5-- > 0) && !(r3 = i4.next()).done) ar3.push(r3.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar3;
}
function __spread() {
  for (var ar3 = [], i4 = 0; i4 < arguments.length; i4++)
    ar3 = ar3.concat(__read(arguments[i4]));
  return ar3;
}
function __spreadArrays() {
  for (var s3 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s3 += arguments[i4].length;
  for (var r3 = Array(s3), k6 = 0, i4 = 0; i4 < il; i4++)
    for (var a3 = arguments[i4], j3 = 0, jl = a3.length; j3 < jl; j3++, k6++)
      r3[k6] = a3[j3];
  return r3;
}
function __await(v6) {
  return this instanceof __await ? (this.v = v6, this) : new __await(v6);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g3 = generator.apply(thisArg, _arguments || []), i4, q = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n5) {
    if (g3[n5]) i4[n5] = function(v6) {
      return new Promise(function(a3, b4) {
        q.push([n5, v6, a3, b4]) > 1 || resume(n5, v6);
      });
    };
  }
  function resume(n5, v6) {
    try {
      step(g3[n5](v6));
    } catch (e2) {
      settle3(q[0][3], e2);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle3(q[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle3(f8, v6) {
    if (f8(v6), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o4) {
  var i4, p4;
  return i4 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n5, f8) {
    i4[n5] = o4[n5] ? function(v6) {
      return (p4 = !p4) ? { value: __await(o4[n5](v6)), done: n5 === "return" } : f8 ? f8(v6) : v6;
    } : f8;
  }
}
function __asyncValues(o4) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o4[Symbol.asyncIterator], i4;
  return m3 ? m3.call(o4) : (o4 = typeof __values === "function" ? __values(o4) : o4[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n5) {
    i4[n5] = o4[n5] && function(v6) {
      return new Promise(function(resolve, reject) {
        v6 = o4[n5](v6), settle3(resolve, reject, v6.done, v6.value);
      });
    };
  }
  function settle3(resolve, reject, d4, v6) {
    Promise.resolve(v6).then(function(v7) {
      resolve({ value: v7, done: d4 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod4) {
  if (mod4 && mod4.__esModule) return mod4;
  var result = {};
  if (mod4 != null) {
    for (var k6 in mod4) if (Object.hasOwnProperty.call(mod4, k6)) result[k6] = mod4[k6];
  }
  result.default = mod4;
  return result;
}
function __importDefault(mod4) {
  return mod4 && mod4.__esModule ? mod4 : { default: mod4 };
}
function __classPrivateFieldGet2(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet2(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/@walletconnect/time/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d4, b4) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {
        d5.__proto__ = b5;
      } || function(d5, b5) {
        for (var p4 in b5) if (b5.hasOwnProperty(p4)) d5[p4] = b5[p4];
      };
      return extendStatics(d4, b4);
    };
    __assign = function() {
      __assign = Object.assign || function __assign4(t) {
        for (var s3, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {
          s3 = arguments[i4];
          for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4)) t[p4] = s3[p4];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    function delay(timeout) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    }
    exports.delay = delay;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
    exports.ONE_HUNDRED = 100;
    exports.ONE_THOUSAND = 1e3;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_time(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromMiliseconds = exports.toMiliseconds = void 0;
    var constants_1 = require_constants();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports.toMiliseconds = toMiliseconds;
    function fromMiliseconds(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports.fromMiliseconds = fromMiliseconds;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
      }
      get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
      }
      elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    };
    exports.Watch = Watch;
    exports.default = Watch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWatch = void 0;
    var IWatch = class {
    };
    exports.IWatch = IWatch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils(), exports);
    tslib_1.__exportStar(require_watch(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name2) {
      const res = getFromWindow(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e2) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i4 = 0; i4 < links.length; i4++) {
          const link = links[i4];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i4 = 0; i4 < metaTags.length; i4++) {
          const tag = metaTags[i4];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex5(bytes2) {
      return Array.prototype.map.call(bytes2, function(n5) {
        return (n5 < 16 ? "0" : "") + n5.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size9) {
      let msg = "\n" + label + " = ";
      for (let i4 = 0; i4 < arr.length; i4 += 2) {
        if (size9 === 32) {
          msg += uint32ToHex(arr[i4]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i4 + 1]).toUpperCase();
        } else if (size9 === 64) {
          msg += uint32ToHex(arr[i4 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i4]).toUpperCase();
        } else throw new Error("Invalid size " + size9);
        if (i4 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i4 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N15, M4) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N15);
      for (let i4 = 0; i4 < N15; i4++) {
        input[i4] = i4 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i4 = 0; i4 < M4; i4++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms2 = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms2 + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N15 / (1 << 20) / (ms2 / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex: toHex5,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v7, a3, b4) {
      const o0 = v7[a3] + v7[b4];
      let o1 = v7[a3 + 1] + v7[b4 + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v7[a3] = o0;
      v7[a3 + 1] = o1;
    }
    function ADD64AC(v7, a3, b0, b1) {
      let o0 = v7[a3] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v7[a3 + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v7[a3] = o0;
      v7[a3 + 1] = o1;
    }
    function B2B_GET32(arr, i4) {
      return arr[i4] ^ arr[i4 + 1] << 8 ^ arr[i4 + 2] << 16 ^ arr[i4 + 3] << 24;
    }
    function B2B_G(a3, b4, c6, d4, ix, iy) {
      const x0 = m3[ix];
      const x1 = m3[ix + 1];
      const y0 = m3[iy];
      const y1 = m3[iy + 1];
      ADD64AA(v6, a3, b4);
      ADD64AC(v6, a3, x0, x1);
      let xor0 = v6[d4] ^ v6[a3];
      let xor1 = v6[d4 + 1] ^ v6[a3 + 1];
      v6[d4] = xor1;
      v6[d4 + 1] = xor0;
      ADD64AA(v6, c6, d4);
      xor0 = v6[b4] ^ v6[c6];
      xor1 = v6[b4 + 1] ^ v6[c6 + 1];
      v6[b4] = xor0 >>> 24 ^ xor1 << 8;
      v6[b4 + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v6, a3, b4);
      ADD64AC(v6, a3, y0, y1);
      xor0 = v6[d4] ^ v6[a3];
      xor1 = v6[d4 + 1] ^ v6[a3 + 1];
      v6[d4] = xor0 >>> 16 ^ xor1 << 16;
      v6[d4 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v6, c6, d4);
      xor0 = v6[b4] ^ v6[c6];
      xor1 = v6[b4 + 1] ^ v6[c6 + 1];
      v6[b4] = xor1 >>> 31 ^ xor0 << 1;
      v6[b4 + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x5) {
        return x5 * 2;
      })
    );
    var v6 = new Uint32Array(32);
    var m3 = new Uint32Array(32);
    function blake2bCompress(ctx, last5) {
      let i4 = 0;
      for (i4 = 0; i4 < 16; i4++) {
        v6[i4] = ctx.h[i4];
        v6[i4 + 16] = BLAKE2B_IV32[i4];
      }
      v6[24] = v6[24] ^ ctx.t;
      v6[25] = v6[25] ^ ctx.t / 4294967296;
      if (last5) {
        v6[28] = ~v6[28];
        v6[29] = ~v6[29];
      }
      for (i4 = 0; i4 < 32; i4++) {
        m3[i4] = B2B_GET32(ctx.b, 4 * i4);
      }
      for (i4 = 0; i4 < 12; i4++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i4 * 16 + 0], SIGMA82[i4 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i4 * 16 + 2], SIGMA82[i4 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i4 * 16 + 4], SIGMA82[i4 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i4 * 16 + 6], SIGMA82[i4 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i4 * 16 + 8], SIGMA82[i4 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i4 * 16 + 10], SIGMA82[i4 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i4 * 16 + 12], SIGMA82[i4 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i4 * 16 + 14], SIGMA82[i4 * 16 + 15]);
      }
      for (i4 = 0; i4 < 16; i4++) {
        ctx.h[i4] = ctx.h[i4] ^ v6[i4] ^ v6[i4 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i4 = 0; i4 < 16; i4++) {
        ctx.h[i4] = BLAKE2B_IV32[i4] ^ B2B_GET32(parameterBlock, i4 * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i4 = 0; i4 < input.length; i4++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i4];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i4 = 0; i4 < ctx.outlen; i4++) {
        out[i4] = ctx.h[i4 >> 2] >> 8 * (i4 & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output2 = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output2);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v7, i4) {
      return v7[i4] ^ v7[i4 + 1] << 8 ^ v7[i4 + 2] << 16 ^ v7[i4 + 3] << 24;
    }
    function B2S_G(a3, b4, c6, d4, x5, y5) {
      v6[a3] = v6[a3] + v6[b4] + x5;
      v6[d4] = ROTR32(v6[d4] ^ v6[a3], 16);
      v6[c6] = v6[c6] + v6[d4];
      v6[b4] = ROTR32(v6[b4] ^ v6[c6], 12);
      v6[a3] = v6[a3] + v6[b4] + y5;
      v6[d4] = ROTR32(v6[d4] ^ v6[a3], 8);
      v6[c6] = v6[c6] + v6[d4];
      v6[b4] = ROTR32(v6[b4] ^ v6[c6], 7);
    }
    function ROTR32(x5, y5) {
      return x5 >>> y5 ^ x5 << 32 - y5;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v6 = new Uint32Array(16);
    var m3 = new Uint32Array(16);
    function blake2sCompress(ctx, last5) {
      let i4 = 0;
      for (i4 = 0; i4 < 8; i4++) {
        v6[i4] = ctx.h[i4];
        v6[i4 + 8] = BLAKE2S_IV[i4];
      }
      v6[12] ^= ctx.t;
      v6[13] ^= ctx.t / 4294967296;
      if (last5) {
        v6[14] = ~v6[14];
      }
      for (i4 = 0; i4 < 16; i4++) {
        m3[i4] = B2S_GET32(ctx.b, 4 * i4);
      }
      for (i4 = 0; i4 < 10; i4++) {
        B2S_G(0, 4, 8, 12, m3[SIGMA[i4 * 16 + 0]], m3[SIGMA[i4 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m3[SIGMA[i4 * 16 + 2]], m3[SIGMA[i4 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m3[SIGMA[i4 * 16 + 4]], m3[SIGMA[i4 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m3[SIGMA[i4 * 16 + 6]], m3[SIGMA[i4 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m3[SIGMA[i4 * 16 + 8]], m3[SIGMA[i4 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m3[SIGMA[i4 * 16 + 10]], m3[SIGMA[i4 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m3[SIGMA[i4 * 16 + 12]], m3[SIGMA[i4 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m3[SIGMA[i4 * 16 + 14]], m3[SIGMA[i4 * 16 + 15]]);
      }
      for (i4 = 0; i4 < 8; i4++) {
        ctx.h[i4] ^= v6[i4] ^ v6[i4 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i4 = 0; i4 < input.length; i4++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i4];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i4 = 0; i4 < ctx.outlen; i4++) {
        out[i4] = ctx.h[i4 >> 2] >> 8 * (i4 & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output2 = blake2s(input, key, outlen);
      return util.toHex(output2);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/@dynamic-labs/solana/node_modules/bs58/node_modules/base-x/src/index.js
var require_src3 = __commonJS({
  "node_modules/@dynamic-labs/solana/node_modules/bs58/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base3(ALPHABET3) {
      if (ALPHABET3.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
        BASE_MAP[j3] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
        var x5 = ALPHABET3.charAt(i4);
        var xc3 = x5.charCodeAt(0);
        if (BASE_MAP[xc3] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc3] = i4;
      }
      var BASE = ALPHABET3.length;
      var LEADER = ALPHABET3.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size9);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          pbegin++;
        }
        var it22 = size9 - length2;
        while (it22 !== size9 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size9; ++it22) {
          str += ALPHABET3.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size9);
        while (source[psz]) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          psz++;
        }
        var it4 = size9 - length2;
        while (it4 !== size9 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size9 - it4));
        var j4 = zeroes;
        while (it4 !== size9) {
          vch[j4++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string4) {
        var buffer = decodeUnsafe(string4);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode9
      };
    }
    module.exports = base3;
  }
});

// node_modules/@dynamic-labs/solana/node_modules/bs58/index.js
var require_bs583 = __commonJS({
  "node_modules/@dynamic-labs/solana/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src3();
    var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET3);
  }
});

// node_modules/@dynamic-labs/solana/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@dynamic-labs/solana/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has3 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn4, context, once) {
      this.fn = fn4;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn4, context, once) {
      if (typeof fn4 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn4, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter5() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has3.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter5.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l6 = handlers.length, ee3 = new Array(l6); i4 < l6; i4++) {
        ee3[i4] = handlers[i4].fn;
      }
      return ee3;
    };
    EventEmitter5.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter5.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i4;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length2 = listeners2.length, j3;
        for (i4 = 0; i4 < length2; i4++) {
          if (listeners2[i4].once) this.removeListener(event, listeners2[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i4].fn.call(listeners2[i4].context);
              break;
            case 2:
              listeners2[i4].fn.call(listeners2[i4].context, a1);
              break;
            case 3:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22);
              break;
            case 4:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners2[i4].fn.apply(listeners2[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter5.prototype.on = function on6(event, fn4, context) {
      return addListener(this, event, fn4, context, false);
    };
    EventEmitter5.prototype.once = function once(event, fn4, context) {
      return addListener(this, event, fn4, context, true);
    };
    EventEmitter5.prototype.removeListener = function removeListener(event, fn4, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn4) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn4 && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length2 = listeners2.length; i4 < length2; i4++) {
          if (listeners2[i4].fn !== fn4 || once && !listeners2[i4].once || context && listeners2[i4].context !== context) {
            events.push(listeners2[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.addListener = EventEmitter5.prototype.on;
    EventEmitter5.prefixed = prefix;
    EventEmitter5.EventEmitter = EventEmitter5;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter5;
    }
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R3 && typeof R3.ownKeys === "function") {
      ReflectOwnKeys = R3.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter5() {
      EventEmitter5.init.call(this);
    }
    module.exports = EventEmitter5;
    module.exports.once = once;
    EventEmitter5.EventEmitter = EventEmitter5;
    EventEmitter5.prototype._events = void 0;
    EventEmitter5.prototype._eventsCount = 0;
    EventEmitter5.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter5, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter5.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter5.prototype.setMaxListeners = function setMaxListeners(n5) {
      if (typeof n5 !== "number" || n5 < 0 || NumberIsNaN(n5)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n5 + ".");
      }
      this._maxListeners = n5;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter5.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter5.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter5.prototype.emit = function emit(type3) {
      var args = [];
      for (var i4 = 1; i4 < arguments.length; i4++) args.push(arguments[i4]);
      var doError = type3 === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er3;
        if (args.length > 0)
          er3 = args[0];
        if (er3 instanceof Error) {
          throw er3;
        }
        var err = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
        err.context = er3;
        throw err;
      }
      var handler = events[type3];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone(handler, len);
        for (var i4 = 0; i4 < len; ++i4)
          ReflectApply(listeners2[i4], this, args);
      }
      return true;
    };
    function _addListener(target, type3, listener, prepend3) {
      var m3;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type3,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type3];
      }
      if (existing === void 0) {
        existing = events[type3] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type3] = prepend3 ? [listener, existing] : [existing, listener];
        } else if (prepend3) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m3 = _getMaxListeners(target);
        if (m3 > 0 && existing.length > m3 && !existing.warned) {
          existing.warned = true;
          var w4 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w4.name = "MaxListenersExceededWarning";
          w4.emitter = target;
          w4.type = type3;
          w4.count = existing.length;
          ProcessEmitWarning(w4);
        }
      }
      return target;
    }
    EventEmitter5.prototype.addListener = function addListener(type3, listener) {
      return _addListener(this, type3, listener, false);
    };
    EventEmitter5.prototype.on = EventEmitter5.prototype.addListener;
    EventEmitter5.prototype.prependListener = function prependListener(type3, listener) {
      return _addListener(this, type3, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type3, listener) {
      var state = { fired: false, wrapFn: void 0, target, type: type3, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter5.prototype.once = function once2(type3, listener) {
      checkListener(listener);
      this.on(type3, _onceWrap(this, type3, listener));
      return this;
    };
    EventEmitter5.prototype.prependOnceListener = function prependOnceListener(type3, listener) {
      checkListener(listener);
      this.prependListener(type3, _onceWrap(this, type3, listener));
      return this;
    };
    EventEmitter5.prototype.removeListener = function removeListener(type3, listener) {
      var list, events, position, i4, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type3];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type3];
          if (events.removeListener)
            this.emit("removeListener", type3, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i4 = list.length - 1; i4 >= 0; i4--) {
          if (list[i4] === listener || list[i4].listener === listener) {
            originalListener = list[i4].listener;
            position = i4;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type3] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type3, originalListener || listener);
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(type3) {
      var listeners2, events, i4;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type3] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type3];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys4 = Object.keys(events);
        var key;
        for (i4 = 0; i4 < keys4.length; ++i4) {
          key = keys4[i4];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type3];
      if (typeof listeners2 === "function") {
        this.removeListener(type3, listeners2);
      } else if (listeners2 !== void 0) {
        for (i4 = listeners2.length - 1; i4 >= 0; i4--) {
          this.removeListener(type3, listeners2[i4]);
        }
      }
      return this;
    };
    function _listeners(target, type3, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type3];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter5.prototype.listeners = function listeners2(type3) {
      return _listeners(this, type3, true);
    };
    EventEmitter5.prototype.rawListeners = function rawListeners(type3) {
      return _listeners(this, type3, false);
    };
    EventEmitter5.listenerCount = function(emitter, type3) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type3);
      } else {
        return listenerCount.call(emitter, type3);
      }
    };
    EventEmitter5.prototype.listenerCount = listenerCount;
    function listenerCount(type3) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type3];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n5) {
      var copy = new Array(n5);
      for (var i4 = 0; i4 < n5; ++i4)
        copy[i4] = arr[i4];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i4 = 0; i4 < ret.length; ++i4) {
        ret[i4] = arr[i4].listener || arr[i4];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o4) {
      try {
        return JSON.stringify(o4);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f8, args, opts2) {
      var ss2 = opts2 && opts2.stringify || tryStringify;
      var offset5 = 1;
      if (typeof f8 === "object" && f8 !== null) {
        var len = args.length + offset5;
        if (len === 1) return f8;
        var objects = new Array(len);
        objects[0] = ss2(f8);
        for (var index = 1; index < len; index++) {
          objects[index] = ss2(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f8 !== "string") {
        return f8;
      }
      var argLen = args.length;
      if (argLen === 0) return f8;
      var str = "";
      var a3 = 1 - offset5;
      var lastPos = -1;
      var flen = f8 && f8.length || 0;
      for (var i4 = 0; i4 < flen; ) {
        if (f8.charCodeAt(i4) === 37 && i4 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f8.charCodeAt(i4 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a3 >= argLen)
                break;
              if (args[a3] == null) break;
              if (lastPos < i4)
                str += f8.slice(lastPos, i4);
              str += Number(args[a3]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 105:
              if (a3 >= argLen)
                break;
              if (args[a3] == null) break;
              if (lastPos < i4)
                str += f8.slice(lastPos, i4);
              str += Math.floor(Number(args[a3]));
              lastPos = i4 + 2;
              i4++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a3 >= argLen)
                break;
              if (args[a3] === void 0) break;
              if (lastPos < i4)
                str += f8.slice(lastPos, i4);
              var type3 = typeof args[a3];
              if (type3 === "string") {
                str += "'" + args[a3] + "'";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              if (type3 === "function") {
                str += args[a3].name || "<anonymous>";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              str += ss2(args[a3]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 115:
              if (a3 >= argLen)
                break;
              if (lastPos < i4)
                str += f8.slice(lastPos, i4);
              str += String(args[a3]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 37:
              if (lastPos < i4)
                str += f8.slice(lastPos, i4);
              str += "%";
              lastPos = i4 + 2;
              i4++;
              a3--;
              break;
          }
          ++a3;
        }
        ++i4;
      }
      if (lastPos === -1)
        return f8;
      else if (lastPos < flen) {
        str += f8.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/@dynamic-labs/wallet-connect/node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/@dynamic-labs/wallet-connect/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize5, serializers) {
      if (Array.isArray(serialize5)) {
        const hasToFilter = serialize5.filter(function(k6) {
          return k6 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize5 === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts2) {
      opts2 = opts2 || {};
      opts2.browser = opts2.browser || {};
      const transmit2 = opts2.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts2.browser.write || _console;
      if (opts2.browser.write) opts2.browser.asObject = true;
      const serializers = opts2.serializers || {};
      const serialize5 = shouldSerialize(opts2.browser.serialize, serializers);
      let stdErrSerialize = opts2.browser.serialize;
      if (Array.isArray(opts2.browser.serialize) && opts2.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts2.enabled === false) opts2.level = "silent";
      const level = opts2.level || "info";
      const logger8 = Object.create(proto);
      if (!logger8.log) logger8.log = noop3;
      Object.defineProperty(logger8, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger8, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize: serialize5,
        asObject: opts2.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts2)
      };
      logger8.levels = pino.levels;
      logger8.level = level;
      logger8.setMaxListeners = logger8.getMaxListeners = logger8.emit = logger8.addListener = logger8.on = logger8.prependListener = logger8.once = logger8.prependOnceListener = logger8.removeListener = logger8.removeAllListeners = logger8.listeners = logger8.listenerCount = logger8.eventNames = logger8.write = logger8.flush = noop3;
      logger8.serializers = serializers;
      logger8._serialize = serialize5;
      logger8._stdErrSerialize = stdErrSerialize;
      logger8.child = child;
      if (transmit2) logger8._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger8, "error", "log");
        set2(setOpts, logger8, "fatal", "error");
        set2(setOpts, logger8, "warn", "error");
        set2(setOpts, logger8, "info", "log");
        set2(setOpts, logger8, "debug", "log");
        set2(setOpts, logger8, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize5 && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize5 && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts2.browser.serialize === true ? Object.keys(childSerializers) : serialize5;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind25(parent, bindings, "error");
          this.fatal = bind25(parent, bindings, "fatal");
          this.warn = bind25(parent, bindings, "warn");
          this.info = bind25(parent, bindings, "info");
          this.debug = bind25(parent, bindings, "debug");
          this.trace = bind25(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger8;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts2, logger8, level, fallback3) {
      const proto = Object.getPrototypeOf(logger8);
      logger8[level] = logger8.levelVal > logger8.levels.values[level] ? noop3 : proto[level] ? proto[level] : _console[level] || _console[fallback3] || noop3;
      wrap(opts2, logger8, level);
    }
    function wrap(opts2, logger8, level) {
      if (!opts2.transmit && logger8[level] === noop3) return;
      logger8[level] = /* @__PURE__ */ (function(write) {
        return function LOG() {
          const ts2 = opts2.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i4 = 0; i4 < args.length; i4++) args[i4] = arguments[i4];
          if (opts2.serialize && !opts2.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts2.asObject) write.call(proto, asObject(this, level, args, ts2));
          else write.apply(proto, args);
          if (opts2.transmit) {
            const transmitLevel = opts2.transmit.level || logger8.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts2.transmit.level || logger8.level],
              send: opts2.transmit.send,
              val: logger8.levelVal
            }, args);
          }
        };
      })(logger8[level]);
    }
    function asObject(logger8, level, args, ts2) {
      if (logger8._serialize) applySerializers(args, logger8._serialize, logger8.serializers, logger8._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o4 = {};
      if (ts2) {
        o4.time = ts2;
      }
      o4.level = pino.levels.values[level];
      let lvl = (logger8._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o4, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o4.msg = msg;
      return o4;
    }
    function applySerializers(args, serialize5, serializers, stdErrSerialize) {
      for (const i4 in args) {
        if (stdErrSerialize && args[i4] instanceof Error) {
          args[i4] = pino.stdSerializers.err(args[i4]);
        } else if (typeof args[i4] === "object" && !Array.isArray(args[i4])) {
          for (const k6 in args[i4]) {
            if (serialize5 && serialize5.indexOf(k6) > -1 && k6 in serializers) {
              args[i4][k6] = serializers[k6](args[i4][k6]);
            }
          }
        }
      }
    }
    function bind25(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i4 = 1; i4 < args.length; i4++) {
          args[i4] = arguments[i4 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger8, opts2, args) {
      const send = opts2.send;
      const ts2 = opts2.ts;
      const methodLevel = opts2.methodLevel;
      const methodValue = opts2.methodValue;
      const val = opts2.val;
      const bindings = logger8._logEvent.bindings;
      applySerializers(
        args,
        logger8._serialize || Object.keys(logger8.serializers),
        logger8.serializers,
        logger8._stdErrSerialize === void 0 ? true : logger8._stdErrSerialize
      );
      logger8._logEvent.ts = ts2;
      logger8._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger8._logEvent.level.label = methodLevel;
      logger8._logEvent.level.value = methodValue;
      send(methodLevel, logger8._logEvent, val);
      logger8._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts2) {
      if (typeof opts2.timestamp === "function") {
        return opts2.timestamp;
      }
      if (opts2.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a3) {
      return a3;
    }
    function noop3() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o4) {
        return typeof o4 !== "undefined" && o4;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e2) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/environment/node_modules/tslib/tslib.es6.js
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter5,
  __classPrivateFieldGet: () => __classPrivateFieldGet3,
  __classPrivateFieldSet: () => __classPrivateFieldSet3,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate2,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __read: () => __read2,
  __rest: () => __rest2,
  __spread: () => __spread2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends2(d4, b4) {
  extendStatics2(d4, b4);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
function __rest2(s3, e2) {
  var t = {};
  for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
    t[p4] = s3[p4];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s3); i4 < p4.length; i4++) {
      if (e2.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i4]))
        t[p4[i4]] = s3[p4[i4]];
    }
  return t;
}
function __decorate2(decorators, target, key, desc) {
  var c6 = arguments.length, r3 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c6 < 3 ? d4(r3) : c6 > 3 ? d4(target, key, r3) : d4(target, key)) || r3;
  return c6 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}
function __param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter5(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _3 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f8, y5, t, g3;
  return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n5) {
    return function(v6) {
      return step([n5, v6]);
    };
  }
  function step(op) {
    if (f8) throw new TypeError("Generator is already executing.");
    while (_3) try {
      if (f8 = 1, y5 && (t = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t = y5["return"]) && t.call(y5), 0) : y5.next) && !(t = t.call(y5, op[1])).done) return t;
      if (y5 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _3.label++;
          return { value: op[1], done: false };
        case 5:
          _3.label++;
          y5 = op[1];
          op = [0];
          continue;
        case 7:
          op = _3.ops.pop();
          _3.trys.pop();
          continue;
        default:
          if (!(t = _3.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _3 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _3.label = op[1];
            break;
          }
          if (op[0] === 6 && _3.label < t[1]) {
            _3.label = t[1];
            t = op;
            break;
          }
          if (t && _3.label < t[2]) {
            _3.label = t[2];
            _3.ops.push(op);
            break;
          }
          if (t[2]) _3.ops.pop();
          _3.trys.pop();
          continue;
      }
      op = body.call(thisArg, _3);
    } catch (e2) {
      op = [6, e2];
      y5 = 0;
    } finally {
      f8 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding2(o4, m3, k6, k22) {
  if (k22 === void 0) k22 = k6;
  o4[k22] = m3[k6];
}
function __exportStar2(m3, exports) {
  for (var p4 in m3) if (p4 !== "default" && !exports.hasOwnProperty(p4)) exports[p4] = m3[p4];
}
function __values2(o4) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o4[s3], i4 = 0;
  if (m3) return m3.call(o4);
  if (o4 && typeof o4.length === "number") return {
    next: function() {
      if (o4 && i4 >= o4.length) o4 = void 0;
      return { value: o4 && o4[i4++], done: !o4 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o4, n5) {
  var m3 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m3) return o4;
  var i4 = m3.call(o4), r3, ar3 = [], e2;
  try {
    while ((n5 === void 0 || n5-- > 0) && !(r3 = i4.next()).done) ar3.push(r3.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar3;
}
function __spread2() {
  for (var ar3 = [], i4 = 0; i4 < arguments.length; i4++)
    ar3 = ar3.concat(__read2(arguments[i4]));
  return ar3;
}
function __spreadArrays2() {
  for (var s3 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s3 += arguments[i4].length;
  for (var r3 = Array(s3), k6 = 0, i4 = 0; i4 < il; i4++)
    for (var a3 = arguments[i4], j3 = 0, jl = a3.length; j3 < jl; j3++, k6++)
      r3[k6] = a3[j3];
  return r3;
}
function __await2(v6) {
  return this instanceof __await2 ? (this.v = v6, this) : new __await2(v6);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g3 = generator.apply(thisArg, _arguments || []), i4, q = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n5) {
    if (g3[n5]) i4[n5] = function(v6) {
      return new Promise(function(a3, b4) {
        q.push([n5, v6, a3, b4]) > 1 || resume(n5, v6);
      });
    };
  }
  function resume(n5, v6) {
    try {
      step(g3[n5](v6));
    } catch (e2) {
      settle3(q[0][3], e2);
    }
  }
  function step(r3) {
    r3.value instanceof __await2 ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle3(q[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle3(f8, v6) {
    if (f8(v6), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator2(o4) {
  var i4, p4;
  return i4 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n5, f8) {
    i4[n5] = o4[n5] ? function(v6) {
      return (p4 = !p4) ? { value: __await2(o4[n5](v6)), done: n5 === "return" } : f8 ? f8(v6) : v6;
    } : f8;
  }
}
function __asyncValues2(o4) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o4[Symbol.asyncIterator], i4;
  return m3 ? m3.call(o4) : (o4 = typeof __values2 === "function" ? __values2(o4) : o4[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n5) {
    i4[n5] = o4[n5] && function(v6) {
      return new Promise(function(resolve, reject) {
        v6 = o4[n5](v6), settle3(resolve, reject, v6.done, v6.value);
      });
    };
  }
  function settle3(resolve, reject, d4, v6) {
    Promise.resolve(v6).then(function(v7) {
      resolve({ value: v7, done: d4 });
    }, reject);
  }
}
function __makeTemplateObject2(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar2(mod4) {
  if (mod4 && mod4.__esModule) return mod4;
  var result = {};
  if (mod4 != null) {
    for (var k6 in mod4) if (Object.hasOwnProperty.call(mod4, k6)) result[k6] = mod4[k6];
  }
  result.default = mod4;
  return result;
}
function __importDefault2(mod4) {
  return mod4 && mod4.__esModule ? mod4 : { default: mod4 };
}
function __classPrivateFieldGet3(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet3(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics2, __assign2;
var init_tslib_es62 = __esm({
  "node_modules/@walletconnect/environment/node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = function(d4, b4) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {
        d5.__proto__ = b5;
      } || function(d5, b5) {
        for (var p4 in b5) if (b5.hasOwnProperty(p4)) d5[p4] = b5[p4];
      };
      return extendStatics2(d4, b4);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign4(t) {
        for (var s3, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {
          s3 = arguments[i4];
          for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4)) t[p4] = s3[p4];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    tslib_1.__exportStar(require_crypto2(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = (function() {
      function F5() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F5.prototype = __global__;
      return new F5();
    })();
    (function(globalThis2) {
      var irrelevant = (function(exports2) {
        var g3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g3,
          iterable: "Symbol" in g3 && "iterator" in Symbol,
          blob: "FileReader" in g3 && "Blob" in g3 && (function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          })(),
          formData: "FormData" in g3,
          arrayBuffer: "ArrayBuffer" in g3
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView3 = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue3(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator4 = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator4[Symbol.iterator] = function() {
              return iterator4;
            };
          }
          return iterator4;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue3(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue3(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob9) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob9);
          return promise;
        }
        function readBlobAsText(blob9) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match14 = /charset=([A-Za-z0-9_-]+)/.exec(blob9.type);
          var encoding = match14 ? match14[1] : "utf-8";
          reader.readAsText(blob9, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i4 = 0; i4 < view.length; i4++) {
            chars[i4] = String.fromCharCode(view[i4]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView3(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode9);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g3) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode9(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes2) {
            if (bytes2) {
              var split5 = bytes2.split("=");
              var name2 = split5.shift().replace(/\+/g, " ");
              var value = split5.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g3.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init4) {
          return new Promise(function(resolve, reject) {
            var request2 = new Request2(input, init4);
            if (request2.signal && request2.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g3.location.href ? g3.location.href : url;
              } catch (e2) {
                return url;
              }
            }
            xhr.open(request2.method, fixUrl(request2.url), true);
            if (request2.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request2.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init4 && typeof init4.headers === "object" && !(init4.headers instanceof Headers || g3.Headers && init4.headers instanceof g3.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init4.headers).forEach(function(name2) {
                names.push(normalizeName(name2));
                xhr.setRequestHeader(name2, normalizeValue3(init4.headers[name2]));
              });
              request2.headers.forEach(function(value, name2) {
                if (names.indexOf(name2) === -1) {
                  xhr.setRequestHeader(name2, value);
                }
              });
            } else {
              request2.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request2.signal) {
              request2.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request2.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!g3.fetch) {
          g3.fetch = fetch3;
          g3.Headers = Headers;
          g3.Request = Request2;
          g3.Response = Response2;
        }
        exports2.Headers = Headers;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/base-x/src/index.js
var require_src4 = __commonJS({
  "node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base3(ALPHABET3) {
      if (ALPHABET3.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
        BASE_MAP[j3] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
        var x5 = ALPHABET3.charAt(i4);
        var xc3 = x5.charCodeAt(0);
        if (BASE_MAP[xc3] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc3] = i4;
      }
      var BASE = ALPHABET3.length;
      var LEADER = ALPHABET3.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size9);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          pbegin++;
        }
        var it22 = size9 - length2;
        while (it22 !== size9 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size9; ++it22) {
          str += ALPHABET3.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size9);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          psz++;
        }
        var it4 = size9 - length2;
        while (it4 !== size9 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size9 - it4));
        vch.fill(0, 0, zeroes);
        var j4 = zeroes;
        while (it4 !== size9) {
          vch[j4++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string4) {
        var buffer = decodeUnsafe(string4);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode9
      };
    }
    module.exports = base3;
  }
});

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/bs58/index.js
var require_bs584 = __commonJS({
  "node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src4();
    var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET3);
  }
});

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/web3.js/node_modules/base-x/src/index.js
var require_src5 = __commonJS({
  "node_modules/@dynamic-labs/waas-svm/node_modules/@solana/web3.js/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base3(ALPHABET3) {
      if (ALPHABET3.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
        BASE_MAP[j3] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
        var x5 = ALPHABET3.charAt(i4);
        var xc3 = x5.charCodeAt(0);
        if (BASE_MAP[xc3] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc3] = i4;
      }
      var BASE = ALPHABET3.length;
      var LEADER = ALPHABET3.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size9);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          pbegin++;
        }
        var it22 = size9 - length2;
        while (it22 !== size9 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size9; ++it22) {
          str += ALPHABET3.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size9);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          psz++;
        }
        var it4 = size9 - length2;
        while (it4 !== size9 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size9 - it4));
        vch.fill(0, 0, zeroes);
        var j4 = zeroes;
        while (it4 !== size9) {
          vch[j4++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string4) {
        var buffer = decodeUnsafe(string4);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode9
      };
    }
    module.exports = base3;
  }
});

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs585 = __commonJS({
  "node_modules/@dynamic-labs/waas-svm/node_modules/@solana/web3.js/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src5();
    var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET3);
  }
});

// node_modules/@dynamic-labs-wallet/forward-mpc-client/node_modules/ws/browser.js
var require_browser4 = __commonJS({
  "node_modules/@dynamic-labs-wallet/forward-mpc-client/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/ws/browser.js
var require_browser5 = __commonJS({
  "node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/depd/lib/browser/index.js
var require_browser6 = __commonJS({
  "node_modules/depd/lib/browser/index.js"(exports, module) {
    "use strict";
    module.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate2(message) {
      }
      deprecate2._file = void 0;
      deprecate2._ignored = true;
      deprecate2._namespace = namespace;
      deprecate2._traced = false;
      deprecate2._warned = /* @__PURE__ */ Object.create(null);
      deprecate2.function = wrapfunction;
      deprecate2.property = wrapproperty;
      return deprecate2;
    }
    function wrapfunction(fn4, message) {
      if (typeof fn4 !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn4;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports, module) {
    "use strict";
    module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/statuses/index.js"(exports, module) {
    "use strict";
    var codes = require_codes();
    module.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map36 = {};
      Object.keys(codes2).forEach(function forEachCode(code2) {
        var message = codes2[code2];
        var status2 = Number(code2);
        map36[message.toLowerCase()] = status2;
      });
      return map36;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code2) {
        return Number(code2);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code2) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code2)) {
        throw new Error("invalid status code: " + code2);
      }
      return status.message[code2];
    }
    function status(code2) {
      if (typeof code2 === "number") {
        return getStatusMessage(code2);
      }
      if (typeof code2 !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n5 = parseInt(code2, 10);
      if (!isNaN(n5)) {
        return getStatusMessage(n5);
      }
      return getStatusCode(code2);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports, module) {
    "use strict";
    module.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/http-errors/index.js"(exports, module) {
    "use strict";
    var deprecate2 = require_browser6()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits3 = require_inherits_browser();
    var toIdentifier = require_toidentifier();
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var arg = arguments[i4];
        var type3 = typeof arg;
        if (type3 === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type3 === "number" && i4 === 0) {
          status = arg;
        } else if (type3 === "string") {
          msg = arg;
        } else if (type3 === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i4 + 1) + " unsupported type " + type3);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate2("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits3(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name2, code2) {
      var className = toClassName(name2);
      function ClientError(message) {
        var msg = message != null ? message : statuses.message[code2];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits3(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code2;
      ClientError.prototype.statusCode = code2;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name2, code2) {
      var className = toClassName(name2);
      function ServerError(message) {
        var msg = message != null ? message : statuses.message[code2];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits3(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code2;
      ServerError.prototype.statusCode = code2;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name2) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name2;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports2, codes, HttpError) {
      codes.forEach(function forEachCode(code2) {
        var CodeError;
        var name2 = toIdentifier(statuses.message[code2]);
        switch (codeClass(code2)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name2, code2);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name2, code2);
            break;
        }
        if (CodeError) {
          exports2[code2] = CodeError;
          exports2[name2] = CodeError;
        }
      });
    }
    function toClassName(name2) {
      return name2.substr(-5) !== "Error" ? name2 + "Error" : name2;
    }
  }
});

// node_modules/@dynamic-labs/waas/node_modules/statuses/codes.json
var require_codes2 = __commonJS({
  "node_modules/@dynamic-labs/waas/node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/@dynamic-labs/waas/node_modules/statuses/index.js
var require_statuses2 = __commonJS({
  "node_modules/@dynamic-labs/waas/node_modules/statuses/index.js"(exports, module) {
    "use strict";
    var codes = require_codes2();
    module.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map36 = {};
      Object.keys(codes2).forEach(function forEachCode(code2) {
        var message = codes2[code2];
        var status2 = Number(code2);
        map36[message.toLowerCase()] = status2;
      });
      return map36;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code2) {
        return Number(code2);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code2) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code2)) {
        throw new Error("invalid status code: " + code2);
      }
      return status.message[code2];
    }
    function status(code2) {
      if (typeof code2 === "number") {
        return getStatusMessage(code2);
      }
      if (typeof code2 !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n5 = parseInt(code2, 10);
      if (!isNaN(n5)) {
        return getStatusMessage(n5);
      }
      return getStatusCode(code2);
    }
  }
});

// node_modules/@dynamic-labs/waas/node_modules/http-errors/index.js
var require_http_errors2 = __commonJS({
  "node_modules/@dynamic-labs/waas/node_modules/http-errors/index.js"(exports, module) {
    "use strict";
    var deprecate2 = require_browser6()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses2();
    var inherits3 = require_inherits_browser();
    var toIdentifier = require_toidentifier();
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var arg = arguments[i4];
        var type3 = typeof arg;
        if (type3 === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type3 === "number" && i4 === 0) {
          status = arg;
        } else if (type3 === "string") {
          msg = arg;
        } else if (type3 === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i4 + 1) + " unsupported type " + type3);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate2("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits3(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name2, code2) {
      var className = toClassName(name2);
      function ClientError(message) {
        var msg = message != null ? message : statuses.message[code2];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits3(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code2;
      ClientError.prototype.statusCode = code2;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name2, code2) {
      var className = toClassName(name2);
      function ServerError(message) {
        var msg = message != null ? message : statuses.message[code2];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits3(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code2;
      ServerError.prototype.statusCode = code2;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name2) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name2;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports2, codes, HttpError) {
      codes.forEach(function forEachCode(code2) {
        var CodeError;
        var name2 = toIdentifier(statuses.message[code2]);
        switch (codeClass(code2)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name2, code2);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name2, code2);
            break;
        }
        if (CodeError) {
          exports2[code2] = CodeError;
          exports2[name2] = CodeError;
        }
      });
    }
    function toClassName(name2) {
      return name2.substr(-5) !== "Error" ? name2 + "Error" : name2;
    }
  }
});

// node_modules/@dynamic-labs/message-transport/node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "node_modules/@dynamic-labs/message-transport/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has3 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn4, context, once) {
      this.fn = fn4;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn4, context, once) {
      if (typeof fn4 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn4, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter5() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has3.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter5.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l6 = handlers.length, ee3 = new Array(l6); i4 < l6; i4++) {
        ee3[i4] = handlers[i4].fn;
      }
      return ee3;
    };
    EventEmitter5.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter5.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i4;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length2 = listeners2.length, j3;
        for (i4 = 0; i4 < length2; i4++) {
          if (listeners2[i4].once) this.removeListener(event, listeners2[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i4].fn.call(listeners2[i4].context);
              break;
            case 2:
              listeners2[i4].fn.call(listeners2[i4].context, a1);
              break;
            case 3:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22);
              break;
            case 4:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners2[i4].fn.apply(listeners2[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter5.prototype.on = function on6(event, fn4, context) {
      return addListener(this, event, fn4, context, false);
    };
    EventEmitter5.prototype.once = function once(event, fn4, context) {
      return addListener(this, event, fn4, context, true);
    };
    EventEmitter5.prototype.removeListener = function removeListener(event, fn4, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn4) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn4 && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length2 = listeners2.length; i4 < length2; i4++) {
          if (listeners2[i4].fn !== fn4 || once && !listeners2[i4].once || context && listeners2[i4].context !== context) {
            events.push(listeners2[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.addListener = EventEmitter5.prototype.on;
    EventEmitter5.prefixed = prefix;
    EventEmitter5.EventEmitter = EventEmitter5;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter5;
    }
  }
});

// node_modules/@dynamic-labs/waas-svm/node_modules/base-x/src/index.js
var require_src6 = __commonJS({
  "node_modules/@dynamic-labs/waas-svm/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base3(ALPHABET3) {
      if (ALPHABET3.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
        BASE_MAP[j3] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
        var x5 = ALPHABET3.charAt(i4);
        var xc3 = x5.charCodeAt(0);
        if (BASE_MAP[xc3] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc3] = i4;
      }
      var BASE = ALPHABET3.length;
      var LEADER = ALPHABET3.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size9);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          pbegin++;
        }
        var it22 = size9 - length2;
        while (it22 !== size9 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size9; ++it22) {
          str += ALPHABET3.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size9);
        while (source[psz]) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i5;
          psz++;
        }
        var it4 = size9 - length2;
        while (it4 !== size9 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size9 - it4));
        var j4 = zeroes;
        while (it4 !== size9) {
          vch[j4++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string4) {
        var buffer = decodeUnsafe(string4);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode9
      };
    }
    module.exports = base3;
  }
});

// node_modules/@dynamic-labs/waas-svm/node_modules/bs58/index.js
var require_bs586 = __commonJS({
  "node_modules/@dynamic-labs/waas-svm/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src6();
    var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET3);
  }
});

// node_modules/@dynamic-labs/waas-svm/node_modules/eventemitter3/index.js
var require_eventemitter33 = __commonJS({
  "node_modules/@dynamic-labs/waas-svm/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has3 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn4, context, once) {
      this.fn = fn4;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn4, context, once) {
      if (typeof fn4 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn4, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter5() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has3.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter5.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l6 = handlers.length, ee3 = new Array(l6); i4 < l6; i4++) {
        ee3[i4] = handlers[i4].fn;
      }
      return ee3;
    };
    EventEmitter5.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter5.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i4;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length2 = listeners2.length, j3;
        for (i4 = 0; i4 < length2; i4++) {
          if (listeners2[i4].once) this.removeListener(event, listeners2[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i4].fn.call(listeners2[i4].context);
              break;
            case 2:
              listeners2[i4].fn.call(listeners2[i4].context, a1);
              break;
            case 3:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22);
              break;
            case 4:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners2[i4].fn.apply(listeners2[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter5.prototype.on = function on6(event, fn4, context) {
      return addListener(this, event, fn4, context, false);
    };
    EventEmitter5.prototype.once = function once(event, fn4, context) {
      return addListener(this, event, fn4, context, true);
    };
    EventEmitter5.prototype.removeListener = function removeListener(event, fn4, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn4) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn4 && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length2 = listeners2.length; i4 < length2; i4++) {
          if (listeners2[i4].fn !== fn4 || once && !listeners2[i4].once || context && listeners2[i4].context !== context) {
            events.push(listeners2[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.addListener = EventEmitter5.prototype.on;
    EventEmitter5.prefixed = prefix;
    EventEmitter5.EventEmitter = EventEmitter5;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter5;
    }
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl4) {
      "use strict";
      var gf2 = function(init4) {
        var i4, r3 = new Float64Array(16);
        if (init4) for (i4 = 0; i4 < init4.length; i4++) r3[i4] = init4[i4];
        return r3;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D4 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X4 = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y4 = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I4 = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x5, i4, h5, l6) {
        x5[i4] = h5 >> 24 & 255;
        x5[i4 + 1] = h5 >> 16 & 255;
        x5[i4 + 2] = h5 >> 8 & 255;
        x5[i4 + 3] = h5 & 255;
        x5[i4 + 4] = l6 >> 24 & 255;
        x5[i4 + 5] = l6 >> 16 & 255;
        x5[i4 + 6] = l6 >> 8 & 255;
        x5[i4 + 7] = l6 & 255;
      }
      function vn5(x5, xi4, y5, yi4, n5) {
        var i4, d4 = 0;
        for (i4 = 0; i4 < n5; i4++) d4 |= x5[xi4 + i4] ^ y5[yi4 + i4];
        return (1 & d4 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x5, xi4, y5, yi4) {
        return vn5(x5, xi4, y5, yi4, 16);
      }
      function crypto_verify_32(x5, xi4, y5, yi4) {
        return vn5(x5, xi4, y5, yi4, 32);
      }
      function core_salsa20(o4, p4, k6, c6) {
        var j0 = c6[0] & 255 | (c6[1] & 255) << 8 | (c6[2] & 255) << 16 | (c6[3] & 255) << 24, j1 = k6[0] & 255 | (k6[1] & 255) << 8 | (k6[2] & 255) << 16 | (k6[3] & 255) << 24, j22 = k6[4] & 255 | (k6[5] & 255) << 8 | (k6[6] & 255) << 16 | (k6[7] & 255) << 24, j3 = k6[8] & 255 | (k6[9] & 255) << 8 | (k6[10] & 255) << 16 | (k6[11] & 255) << 24, j4 = k6[12] & 255 | (k6[13] & 255) << 8 | (k6[14] & 255) << 16 | (k6[15] & 255) << 24, j5 = c6[4] & 255 | (c6[5] & 255) << 8 | (c6[6] & 255) << 16 | (c6[7] & 255) << 24, j6 = p4[0] & 255 | (p4[1] & 255) << 8 | (p4[2] & 255) << 16 | (p4[3] & 255) << 24, j7 = p4[4] & 255 | (p4[5] & 255) << 8 | (p4[6] & 255) << 16 | (p4[7] & 255) << 24, j8 = p4[8] & 255 | (p4[9] & 255) << 8 | (p4[10] & 255) << 16 | (p4[11] & 255) << 24, j9 = p4[12] & 255 | (p4[13] & 255) << 8 | (p4[14] & 255) << 16 | (p4[15] & 255) << 24, j10 = c6[8] & 255 | (c6[9] & 255) << 8 | (c6[10] & 255) << 16 | (c6[11] & 255) << 24, j11 = k6[16] & 255 | (k6[17] & 255) << 8 | (k6[18] & 255) << 16 | (k6[19] & 255) << 24, j12 = k6[20] & 255 | (k6[21] & 255) << 8 | (k6[22] & 255) << 16 | (k6[23] & 255) << 24, j13 = k6[24] & 255 | (k6[25] & 255) << 8 | (k6[26] & 255) << 16 | (k6[27] & 255) << 24, j14 = k6[28] & 255 | (k6[29] & 255) << 8 | (k6[30] & 255) << 16 | (k6[31] & 255) << 24, j15 = c6[12] & 255 | (c6[13] & 255) << 8 | (c6[14] & 255) << 16 | (c6[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j3, x42 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i4 = 0; i4 < 20; i4 += 2) {
          u2 = x0 + x12 | 0;
          x42 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x42 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x42 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x32 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x32 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x32 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x32 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x32 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x32 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x42 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x42 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x42 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j22 | 0;
        x32 = x32 + j3 | 0;
        x42 = x42 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x1 >>> 0 & 255;
        o4[5] = x1 >>> 8 & 255;
        o4[6] = x1 >>> 16 & 255;
        o4[7] = x1 >>> 24 & 255;
        o4[8] = x22 >>> 0 & 255;
        o4[9] = x22 >>> 8 & 255;
        o4[10] = x22 >>> 16 & 255;
        o4[11] = x22 >>> 24 & 255;
        o4[12] = x32 >>> 0 & 255;
        o4[13] = x32 >>> 8 & 255;
        o4[14] = x32 >>> 16 & 255;
        o4[15] = x32 >>> 24 & 255;
        o4[16] = x42 >>> 0 & 255;
        o4[17] = x42 >>> 8 & 255;
        o4[18] = x42 >>> 16 & 255;
        o4[19] = x42 >>> 24 & 255;
        o4[20] = x5 >>> 0 & 255;
        o4[21] = x5 >>> 8 & 255;
        o4[22] = x5 >>> 16 & 255;
        o4[23] = x5 >>> 24 & 255;
        o4[24] = x6 >>> 0 & 255;
        o4[25] = x6 >>> 8 & 255;
        o4[26] = x6 >>> 16 & 255;
        o4[27] = x6 >>> 24 & 255;
        o4[28] = x7 >>> 0 & 255;
        o4[29] = x7 >>> 8 & 255;
        o4[30] = x7 >>> 16 & 255;
        o4[31] = x7 >>> 24 & 255;
        o4[32] = x8 >>> 0 & 255;
        o4[33] = x8 >>> 8 & 255;
        o4[34] = x8 >>> 16 & 255;
        o4[35] = x8 >>> 24 & 255;
        o4[36] = x9 >>> 0 & 255;
        o4[37] = x9 >>> 8 & 255;
        o4[38] = x9 >>> 16 & 255;
        o4[39] = x9 >>> 24 & 255;
        o4[40] = x10 >>> 0 & 255;
        o4[41] = x10 >>> 8 & 255;
        o4[42] = x10 >>> 16 & 255;
        o4[43] = x10 >>> 24 & 255;
        o4[44] = x11 >>> 0 & 255;
        o4[45] = x11 >>> 8 & 255;
        o4[46] = x11 >>> 16 & 255;
        o4[47] = x11 >>> 24 & 255;
        o4[48] = x12 >>> 0 & 255;
        o4[49] = x12 >>> 8 & 255;
        o4[50] = x12 >>> 16 & 255;
        o4[51] = x12 >>> 24 & 255;
        o4[52] = x13 >>> 0 & 255;
        o4[53] = x13 >>> 8 & 255;
        o4[54] = x13 >>> 16 & 255;
        o4[55] = x13 >>> 24 & 255;
        o4[56] = x14 >>> 0 & 255;
        o4[57] = x14 >>> 8 & 255;
        o4[58] = x14 >>> 16 & 255;
        o4[59] = x14 >>> 24 & 255;
        o4[60] = x15 >>> 0 & 255;
        o4[61] = x15 >>> 8 & 255;
        o4[62] = x15 >>> 16 & 255;
        o4[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o4, p4, k6, c6) {
        var j0 = c6[0] & 255 | (c6[1] & 255) << 8 | (c6[2] & 255) << 16 | (c6[3] & 255) << 24, j1 = k6[0] & 255 | (k6[1] & 255) << 8 | (k6[2] & 255) << 16 | (k6[3] & 255) << 24, j22 = k6[4] & 255 | (k6[5] & 255) << 8 | (k6[6] & 255) << 16 | (k6[7] & 255) << 24, j3 = k6[8] & 255 | (k6[9] & 255) << 8 | (k6[10] & 255) << 16 | (k6[11] & 255) << 24, j4 = k6[12] & 255 | (k6[13] & 255) << 8 | (k6[14] & 255) << 16 | (k6[15] & 255) << 24, j5 = c6[4] & 255 | (c6[5] & 255) << 8 | (c6[6] & 255) << 16 | (c6[7] & 255) << 24, j6 = p4[0] & 255 | (p4[1] & 255) << 8 | (p4[2] & 255) << 16 | (p4[3] & 255) << 24, j7 = p4[4] & 255 | (p4[5] & 255) << 8 | (p4[6] & 255) << 16 | (p4[7] & 255) << 24, j8 = p4[8] & 255 | (p4[9] & 255) << 8 | (p4[10] & 255) << 16 | (p4[11] & 255) << 24, j9 = p4[12] & 255 | (p4[13] & 255) << 8 | (p4[14] & 255) << 16 | (p4[15] & 255) << 24, j10 = c6[8] & 255 | (c6[9] & 255) << 8 | (c6[10] & 255) << 16 | (c6[11] & 255) << 24, j11 = k6[16] & 255 | (k6[17] & 255) << 8 | (k6[18] & 255) << 16 | (k6[19] & 255) << 24, j12 = k6[20] & 255 | (k6[21] & 255) << 8 | (k6[22] & 255) << 16 | (k6[23] & 255) << 24, j13 = k6[24] & 255 | (k6[25] & 255) << 8 | (k6[26] & 255) << 16 | (k6[27] & 255) << 24, j14 = k6[28] & 255 | (k6[29] & 255) << 8 | (k6[30] & 255) << 16 | (k6[31] & 255) << 24, j15 = c6[12] & 255 | (c6[13] & 255) << 8 | (c6[14] & 255) << 16 | (c6[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j3, x42 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i4 = 0; i4 < 20; i4 += 2) {
          u2 = x0 + x12 | 0;
          x42 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x42 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x42 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x32 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x32 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x32 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x32 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x32 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x32 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x42 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x42 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x42 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x5 >>> 0 & 255;
        o4[5] = x5 >>> 8 & 255;
        o4[6] = x5 >>> 16 & 255;
        o4[7] = x5 >>> 24 & 255;
        o4[8] = x10 >>> 0 & 255;
        o4[9] = x10 >>> 8 & 255;
        o4[10] = x10 >>> 16 & 255;
        o4[11] = x10 >>> 24 & 255;
        o4[12] = x15 >>> 0 & 255;
        o4[13] = x15 >>> 8 & 255;
        o4[14] = x15 >>> 16 & 255;
        o4[15] = x15 >>> 24 & 255;
        o4[16] = x6 >>> 0 & 255;
        o4[17] = x6 >>> 8 & 255;
        o4[18] = x6 >>> 16 & 255;
        o4[19] = x6 >>> 24 & 255;
        o4[20] = x7 >>> 0 & 255;
        o4[21] = x7 >>> 8 & 255;
        o4[22] = x7 >>> 16 & 255;
        o4[23] = x7 >>> 24 & 255;
        o4[24] = x8 >>> 0 & 255;
        o4[25] = x8 >>> 8 & 255;
        o4[26] = x8 >>> 16 & 255;
        o4[27] = x8 >>> 24 & 255;
        o4[28] = x9 >>> 0 & 255;
        o4[29] = x9 >>> 8 & 255;
        o4[30] = x9 >>> 16 & 255;
        o4[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k6, c6) {
        core_salsa20(out, inp, k6, c6);
      }
      function crypto_core_hsalsa20(out, inp, k6, c6) {
        core_hsalsa20(out, inp, k6, c6);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c6, cpos, m3, mpos, b4, n5, k6) {
        var z4 = new Uint8Array(16), x5 = new Uint8Array(64);
        var u2, i4;
        for (i4 = 0; i4 < 16; i4++) z4[i4] = 0;
        for (i4 = 0; i4 < 8; i4++) z4[i4] = n5[i4];
        while (b4 >= 64) {
          crypto_core_salsa20(x5, z4, k6, sigma);
          for (i4 = 0; i4 < 64; i4++) c6[cpos + i4] = m3[mpos + i4] ^ x5[i4];
          u2 = 1;
          for (i4 = 8; i4 < 16; i4++) {
            u2 = u2 + (z4[i4] & 255) | 0;
            z4[i4] = u2 & 255;
            u2 >>>= 8;
          }
          b4 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b4 > 0) {
          crypto_core_salsa20(x5, z4, k6, sigma);
          for (i4 = 0; i4 < b4; i4++) c6[cpos + i4] = m3[mpos + i4] ^ x5[i4];
        }
        return 0;
      }
      function crypto_stream_salsa20(c6, cpos, b4, n5, k6) {
        var z4 = new Uint8Array(16), x5 = new Uint8Array(64);
        var u2, i4;
        for (i4 = 0; i4 < 16; i4++) z4[i4] = 0;
        for (i4 = 0; i4 < 8; i4++) z4[i4] = n5[i4];
        while (b4 >= 64) {
          crypto_core_salsa20(x5, z4, k6, sigma);
          for (i4 = 0; i4 < 64; i4++) c6[cpos + i4] = x5[i4];
          u2 = 1;
          for (i4 = 8; i4 < 16; i4++) {
            u2 = u2 + (z4[i4] & 255) | 0;
            z4[i4] = u2 & 255;
            u2 >>>= 8;
          }
          b4 -= 64;
          cpos += 64;
        }
        if (b4 > 0) {
          crypto_core_salsa20(x5, z4, k6, sigma);
          for (i4 = 0; i4 < b4; i4++) c6[cpos + i4] = x5[i4];
        }
        return 0;
      }
      function crypto_stream(c6, cpos, d4, n5, k6) {
        var s3 = new Uint8Array(32);
        crypto_core_hsalsa20(s3, n5, k6, sigma);
        var sn5 = new Uint8Array(8);
        for (var i4 = 0; i4 < 8; i4++) sn5[i4] = n5[i4 + 16];
        return crypto_stream_salsa20(c6, cpos, d4, sn5, s3);
      }
      function crypto_stream_xor(c6, cpos, m3, mpos, d4, n5, k6) {
        var s3 = new Uint8Array(32);
        crypto_core_hsalsa20(s3, n5, k6, sigma);
        var sn5 = new Uint8Array(8);
        for (var i4 = 0; i4 < 8; i4++) sn5[i4] = n5[i4 + 16];
        return crypto_stream_salsa20_xor(c6, cpos, m3, mpos, d4, sn5, s3);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m3, mpos, bytes2) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c6;
        var d0, d1, d22, d32, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h32 = this.h[3], h42 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes2 >= 16) {
          t0 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
          h22 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
          h32 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
          h42 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c6 = 0;
          d0 = c6;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h22 * (5 * r8);
          d0 += h32 * (5 * r7);
          d0 += h42 * (5 * r6);
          c6 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r22);
          d0 += h9 * (5 * r1);
          c6 += d0 >>> 13;
          d0 &= 8191;
          d1 = c6;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r9);
          d1 += h32 * (5 * r8);
          d1 += h42 * (5 * r7);
          c6 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r22);
          c6 += d1 >>> 13;
          d1 &= 8191;
          d22 = c6;
          d22 += h0 * r22;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h32 * (5 * r9);
          d22 += h42 * (5 * r8);
          c6 = d22 >>> 13;
          d22 &= 8191;
          d22 += h5 * (5 * r7);
          d22 += h6 * (5 * r6);
          d22 += h7 * (5 * r5);
          d22 += h8 * (5 * r4);
          d22 += h9 * (5 * r3);
          c6 += d22 >>> 13;
          d22 &= 8191;
          d32 = c6;
          d32 += h0 * r3;
          d32 += h1 * r22;
          d32 += h22 * r1;
          d32 += h32 * r0;
          d32 += h42 * (5 * r9);
          c6 = d32 >>> 13;
          d32 &= 8191;
          d32 += h5 * (5 * r8);
          d32 += h6 * (5 * r7);
          d32 += h7 * (5 * r6);
          d32 += h8 * (5 * r5);
          d32 += h9 * (5 * r4);
          c6 += d32 >>> 13;
          d32 &= 8191;
          d4 = c6;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h22 * r22;
          d4 += h32 * r1;
          d4 += h42 * r0;
          c6 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c6 += d4 >>> 13;
          d4 &= 8191;
          d5 = c6;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h22 * r3;
          d5 += h32 * r22;
          d5 += h42 * r1;
          c6 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c6 += d5 >>> 13;
          d5 &= 8191;
          d6 = c6;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h22 * r4;
          d6 += h32 * r3;
          d6 += h42 * r22;
          c6 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c6 += d6 >>> 13;
          d6 &= 8191;
          d7 = c6;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h22 * r5;
          d7 += h32 * r4;
          d7 += h42 * r3;
          c6 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r22;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c6 += d7 >>> 13;
          d7 &= 8191;
          d8 = c6;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h22 * r6;
          d8 += h32 * r5;
          d8 += h42 * r4;
          c6 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r22;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c6 += d8 >>> 13;
          d8 &= 8191;
          d9 = c6;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h22 * r7;
          d9 += h32 * r6;
          d9 += h42 * r5;
          c6 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r22;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c6 += d9 >>> 13;
          d9 &= 8191;
          c6 = (c6 << 2) + c6 | 0;
          c6 = c6 + d0 | 0;
          d0 = c6 & 8191;
          c6 = c6 >>> 13;
          d1 += c6;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h32 = d32;
          h42 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h22;
        this.h[3] = h32;
        this.h[4] = h42;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g3 = new Uint16Array(10);
        var c6, mask, f8, i4;
        if (this.leftover) {
          i4 = this.leftover;
          this.buffer[i4++] = 1;
          for (; i4 < 16; i4++) this.buffer[i4] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c6 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i4 = 2; i4 < 10; i4++) {
          this.h[i4] += c6;
          c6 = this.h[i4] >>> 13;
          this.h[i4] &= 8191;
        }
        this.h[0] += c6 * 5;
        c6 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c6;
        c6 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c6;
        g3[0] = this.h[0] + 5;
        c6 = g3[0] >>> 13;
        g3[0] &= 8191;
        for (i4 = 1; i4 < 10; i4++) {
          g3[i4] = this.h[i4] + c6;
          c6 = g3[i4] >>> 13;
          g3[i4] &= 8191;
        }
        g3[9] -= 1 << 13;
        mask = (c6 ^ 1) - 1;
        for (i4 = 0; i4 < 10; i4++) g3[i4] &= mask;
        mask = ~mask;
        for (i4 = 0; i4 < 10; i4++) this.h[i4] = this.h[i4] & mask | g3[i4];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f8 = this.h[0] + this.pad[0];
        this.h[0] = f8 & 65535;
        for (i4 = 1; i4 < 8; i4++) {
          f8 = (this.h[i4] + this.pad[i4] | 0) + (f8 >>> 16) | 0;
          this.h[i4] = f8 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m3, mpos, bytes2) {
        var i4, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes2)
            want = bytes2;
          for (i4 = 0; i4 < want; i4++)
            this.buffer[this.leftover + i4] = m3[mpos + i4];
          bytes2 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this.blocks(m3, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (i4 = 0; i4 < bytes2; i4++)
            this.buffer[this.leftover + i4] = m3[mpos + i4];
          this.leftover += bytes2;
        }
      };
      function crypto_onetimeauth(out, outpos, m3, mpos, n5, k6) {
        var s3 = new poly1305(k6);
        s3.update(m3, mpos, n5);
        s3.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h5, hpos, m3, mpos, n5, k6) {
        var x5 = new Uint8Array(16);
        crypto_onetimeauth(x5, 0, m3, mpos, n5, k6);
        return crypto_verify_16(h5, hpos, x5, 0);
      }
      function crypto_secretbox(c6, m3, d4, n5, k6) {
        var i4;
        if (d4 < 32) return -1;
        crypto_stream_xor(c6, 0, m3, 0, d4, n5, k6);
        crypto_onetimeauth(c6, 16, c6, 32, d4 - 32, c6);
        for (i4 = 0; i4 < 16; i4++) c6[i4] = 0;
        return 0;
      }
      function crypto_secretbox_open(m3, c6, d4, n5, k6) {
        var i4;
        var x5 = new Uint8Array(32);
        if (d4 < 32) return -1;
        crypto_stream(x5, 0, 32, n5, k6);
        if (crypto_onetimeauth_verify(c6, 16, c6, 32, d4 - 32, x5) !== 0) return -1;
        crypto_stream_xor(m3, 0, c6, 0, d4, n5, k6);
        for (i4 = 0; i4 < 32; i4++) m3[i4] = 0;
        return 0;
      }
      function set25519(r3, a3) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) r3[i4] = a3[i4] | 0;
      }
      function car25519(o4) {
        var i4, v6, c6 = 1;
        for (i4 = 0; i4 < 16; i4++) {
          v6 = o4[i4] + c6 + 65535;
          c6 = Math.floor(v6 / 65536);
          o4[i4] = v6 - c6 * 65536;
        }
        o4[0] += c6 - 1 + 37 * (c6 - 1);
      }
      function sel25519(p4, q, b4) {
        var t, c6 = ~(b4 - 1);
        for (var i4 = 0; i4 < 16; i4++) {
          t = c6 & (p4[i4] ^ q[i4]);
          p4[i4] ^= t;
          q[i4] ^= t;
        }
      }
      function pack25519(o4, n5) {
        var i4, j3, b4;
        var m3 = gf2(), t = gf2();
        for (i4 = 0; i4 < 16; i4++) t[i4] = n5[i4];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j3 = 0; j3 < 2; j3++) {
          m3[0] = t[0] - 65517;
          for (i4 = 1; i4 < 15; i4++) {
            m3[i4] = t[i4] - 65535 - (m3[i4 - 1] >> 16 & 1);
            m3[i4 - 1] &= 65535;
          }
          m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
          b4 = m3[15] >> 16 & 1;
          m3[14] &= 65535;
          sel25519(t, m3, 1 - b4);
        }
        for (i4 = 0; i4 < 16; i4++) {
          o4[2 * i4] = t[i4] & 255;
          o4[2 * i4 + 1] = t[i4] >> 8;
        }
      }
      function neq25519(a3, b4) {
        var c6 = new Uint8Array(32), d4 = new Uint8Array(32);
        pack25519(c6, a3);
        pack25519(d4, b4);
        return crypto_verify_32(c6, 0, d4, 0);
      }
      function par25519(a3) {
        var d4 = new Uint8Array(32);
        pack25519(d4, a3);
        return d4[0] & 1;
      }
      function unpack25519(o4, n5) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o4[i4] = n5[2 * i4] + (n5[2 * i4 + 1] << 8);
        o4[15] &= 32767;
      }
      function A4(o4, a3, b4) {
        for (var i4 = 0; i4 < 16; i4++) o4[i4] = a3[i4] + b4[i4];
      }
      function Z2(o4, a3, b4) {
        for (var i4 = 0; i4 < 16; i4++) o4[i4] = a3[i4] - b4[i4];
      }
      function M4(o4, a3, b4) {
        var v6, c6, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
        v6 = a3[0];
        t0 += v6 * b0;
        t1 += v6 * b1;
        t2 += v6 * b22;
        t3 += v6 * b32;
        t4 += v6 * b42;
        t5 += v6 * b5;
        t6 += v6 * b6;
        t7 += v6 * b7;
        t8 += v6 * b8;
        t9 += v6 * b9;
        t10 += v6 * b10;
        t11 += v6 * b11;
        t12 += v6 * b12;
        t13 += v6 * b13;
        t14 += v6 * b14;
        t15 += v6 * b15;
        v6 = a3[1];
        t1 += v6 * b0;
        t2 += v6 * b1;
        t3 += v6 * b22;
        t4 += v6 * b32;
        t5 += v6 * b42;
        t6 += v6 * b5;
        t7 += v6 * b6;
        t8 += v6 * b7;
        t9 += v6 * b8;
        t10 += v6 * b9;
        t11 += v6 * b10;
        t12 += v6 * b11;
        t13 += v6 * b12;
        t14 += v6 * b13;
        t15 += v6 * b14;
        t16 += v6 * b15;
        v6 = a3[2];
        t2 += v6 * b0;
        t3 += v6 * b1;
        t4 += v6 * b22;
        t5 += v6 * b32;
        t6 += v6 * b42;
        t7 += v6 * b5;
        t8 += v6 * b6;
        t9 += v6 * b7;
        t10 += v6 * b8;
        t11 += v6 * b9;
        t12 += v6 * b10;
        t13 += v6 * b11;
        t14 += v6 * b12;
        t15 += v6 * b13;
        t16 += v6 * b14;
        t17 += v6 * b15;
        v6 = a3[3];
        t3 += v6 * b0;
        t4 += v6 * b1;
        t5 += v6 * b22;
        t6 += v6 * b32;
        t7 += v6 * b42;
        t8 += v6 * b5;
        t9 += v6 * b6;
        t10 += v6 * b7;
        t11 += v6 * b8;
        t12 += v6 * b9;
        t13 += v6 * b10;
        t14 += v6 * b11;
        t15 += v6 * b12;
        t16 += v6 * b13;
        t17 += v6 * b14;
        t18 += v6 * b15;
        v6 = a3[4];
        t4 += v6 * b0;
        t5 += v6 * b1;
        t6 += v6 * b22;
        t7 += v6 * b32;
        t8 += v6 * b42;
        t9 += v6 * b5;
        t10 += v6 * b6;
        t11 += v6 * b7;
        t12 += v6 * b8;
        t13 += v6 * b9;
        t14 += v6 * b10;
        t15 += v6 * b11;
        t16 += v6 * b12;
        t17 += v6 * b13;
        t18 += v6 * b14;
        t19 += v6 * b15;
        v6 = a3[5];
        t5 += v6 * b0;
        t6 += v6 * b1;
        t7 += v6 * b22;
        t8 += v6 * b32;
        t9 += v6 * b42;
        t10 += v6 * b5;
        t11 += v6 * b6;
        t12 += v6 * b7;
        t13 += v6 * b8;
        t14 += v6 * b9;
        t15 += v6 * b10;
        t16 += v6 * b11;
        t17 += v6 * b12;
        t18 += v6 * b13;
        t19 += v6 * b14;
        t20 += v6 * b15;
        v6 = a3[6];
        t6 += v6 * b0;
        t7 += v6 * b1;
        t8 += v6 * b22;
        t9 += v6 * b32;
        t10 += v6 * b42;
        t11 += v6 * b5;
        t12 += v6 * b6;
        t13 += v6 * b7;
        t14 += v6 * b8;
        t15 += v6 * b9;
        t16 += v6 * b10;
        t17 += v6 * b11;
        t18 += v6 * b12;
        t19 += v6 * b13;
        t20 += v6 * b14;
        t21 += v6 * b15;
        v6 = a3[7];
        t7 += v6 * b0;
        t8 += v6 * b1;
        t9 += v6 * b22;
        t10 += v6 * b32;
        t11 += v6 * b42;
        t12 += v6 * b5;
        t13 += v6 * b6;
        t14 += v6 * b7;
        t15 += v6 * b8;
        t16 += v6 * b9;
        t17 += v6 * b10;
        t18 += v6 * b11;
        t19 += v6 * b12;
        t20 += v6 * b13;
        t21 += v6 * b14;
        t22 += v6 * b15;
        v6 = a3[8];
        t8 += v6 * b0;
        t9 += v6 * b1;
        t10 += v6 * b22;
        t11 += v6 * b32;
        t12 += v6 * b42;
        t13 += v6 * b5;
        t14 += v6 * b6;
        t15 += v6 * b7;
        t16 += v6 * b8;
        t17 += v6 * b9;
        t18 += v6 * b10;
        t19 += v6 * b11;
        t20 += v6 * b12;
        t21 += v6 * b13;
        t22 += v6 * b14;
        t23 += v6 * b15;
        v6 = a3[9];
        t9 += v6 * b0;
        t10 += v6 * b1;
        t11 += v6 * b22;
        t12 += v6 * b32;
        t13 += v6 * b42;
        t14 += v6 * b5;
        t15 += v6 * b6;
        t16 += v6 * b7;
        t17 += v6 * b8;
        t18 += v6 * b9;
        t19 += v6 * b10;
        t20 += v6 * b11;
        t21 += v6 * b12;
        t22 += v6 * b13;
        t23 += v6 * b14;
        t24 += v6 * b15;
        v6 = a3[10];
        t10 += v6 * b0;
        t11 += v6 * b1;
        t12 += v6 * b22;
        t13 += v6 * b32;
        t14 += v6 * b42;
        t15 += v6 * b5;
        t16 += v6 * b6;
        t17 += v6 * b7;
        t18 += v6 * b8;
        t19 += v6 * b9;
        t20 += v6 * b10;
        t21 += v6 * b11;
        t22 += v6 * b12;
        t23 += v6 * b13;
        t24 += v6 * b14;
        t25 += v6 * b15;
        v6 = a3[11];
        t11 += v6 * b0;
        t12 += v6 * b1;
        t13 += v6 * b22;
        t14 += v6 * b32;
        t15 += v6 * b42;
        t16 += v6 * b5;
        t17 += v6 * b6;
        t18 += v6 * b7;
        t19 += v6 * b8;
        t20 += v6 * b9;
        t21 += v6 * b10;
        t22 += v6 * b11;
        t23 += v6 * b12;
        t24 += v6 * b13;
        t25 += v6 * b14;
        t26 += v6 * b15;
        v6 = a3[12];
        t12 += v6 * b0;
        t13 += v6 * b1;
        t14 += v6 * b22;
        t15 += v6 * b32;
        t16 += v6 * b42;
        t17 += v6 * b5;
        t18 += v6 * b6;
        t19 += v6 * b7;
        t20 += v6 * b8;
        t21 += v6 * b9;
        t22 += v6 * b10;
        t23 += v6 * b11;
        t24 += v6 * b12;
        t25 += v6 * b13;
        t26 += v6 * b14;
        t27 += v6 * b15;
        v6 = a3[13];
        t13 += v6 * b0;
        t14 += v6 * b1;
        t15 += v6 * b22;
        t16 += v6 * b32;
        t17 += v6 * b42;
        t18 += v6 * b5;
        t19 += v6 * b6;
        t20 += v6 * b7;
        t21 += v6 * b8;
        t22 += v6 * b9;
        t23 += v6 * b10;
        t24 += v6 * b11;
        t25 += v6 * b12;
        t26 += v6 * b13;
        t27 += v6 * b14;
        t28 += v6 * b15;
        v6 = a3[14];
        t14 += v6 * b0;
        t15 += v6 * b1;
        t16 += v6 * b22;
        t17 += v6 * b32;
        t18 += v6 * b42;
        t19 += v6 * b5;
        t20 += v6 * b6;
        t21 += v6 * b7;
        t22 += v6 * b8;
        t23 += v6 * b9;
        t24 += v6 * b10;
        t25 += v6 * b11;
        t26 += v6 * b12;
        t27 += v6 * b13;
        t28 += v6 * b14;
        t29 += v6 * b15;
        v6 = a3[15];
        t15 += v6 * b0;
        t16 += v6 * b1;
        t17 += v6 * b22;
        t18 += v6 * b32;
        t19 += v6 * b42;
        t20 += v6 * b5;
        t21 += v6 * b6;
        t22 += v6 * b7;
        t23 += v6 * b8;
        t24 += v6 * b9;
        t25 += v6 * b10;
        t26 += v6 * b11;
        t27 += v6 * b12;
        t28 += v6 * b13;
        t29 += v6 * b14;
        t30 += v6 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c6 = 1;
        v6 = t0 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t0 = v6 - c6 * 65536;
        v6 = t1 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t1 = v6 - c6 * 65536;
        v6 = t2 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t2 = v6 - c6 * 65536;
        v6 = t3 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t3 = v6 - c6 * 65536;
        v6 = t4 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t4 = v6 - c6 * 65536;
        v6 = t5 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t5 = v6 - c6 * 65536;
        v6 = t6 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t6 = v6 - c6 * 65536;
        v6 = t7 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t7 = v6 - c6 * 65536;
        v6 = t8 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t8 = v6 - c6 * 65536;
        v6 = t9 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t9 = v6 - c6 * 65536;
        v6 = t10 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t10 = v6 - c6 * 65536;
        v6 = t11 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t11 = v6 - c6 * 65536;
        v6 = t12 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t12 = v6 - c6 * 65536;
        v6 = t13 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t13 = v6 - c6 * 65536;
        v6 = t14 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t14 = v6 - c6 * 65536;
        v6 = t15 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t15 = v6 - c6 * 65536;
        t0 += c6 - 1 + 37 * (c6 - 1);
        c6 = 1;
        v6 = t0 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t0 = v6 - c6 * 65536;
        v6 = t1 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t1 = v6 - c6 * 65536;
        v6 = t2 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t2 = v6 - c6 * 65536;
        v6 = t3 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t3 = v6 - c6 * 65536;
        v6 = t4 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t4 = v6 - c6 * 65536;
        v6 = t5 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t5 = v6 - c6 * 65536;
        v6 = t6 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t6 = v6 - c6 * 65536;
        v6 = t7 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t7 = v6 - c6 * 65536;
        v6 = t8 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t8 = v6 - c6 * 65536;
        v6 = t9 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t9 = v6 - c6 * 65536;
        v6 = t10 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t10 = v6 - c6 * 65536;
        v6 = t11 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t11 = v6 - c6 * 65536;
        v6 = t12 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t12 = v6 - c6 * 65536;
        v6 = t13 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t13 = v6 - c6 * 65536;
        v6 = t14 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t14 = v6 - c6 * 65536;
        v6 = t15 + c6 + 65535;
        c6 = Math.floor(v6 / 65536);
        t15 = v6 - c6 * 65536;
        t0 += c6 - 1 + 37 * (c6 - 1);
        o4[0] = t0;
        o4[1] = t1;
        o4[2] = t2;
        o4[3] = t3;
        o4[4] = t4;
        o4[5] = t5;
        o4[6] = t6;
        o4[7] = t7;
        o4[8] = t8;
        o4[9] = t9;
        o4[10] = t10;
        o4[11] = t11;
        o4[12] = t12;
        o4[13] = t13;
        o4[14] = t14;
        o4[15] = t15;
      }
      function S4(o4, a3) {
        M4(o4, a3, a3);
      }
      function inv25519(o4, i4) {
        var c6 = gf2();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c6[a3] = i4[a3];
        for (a3 = 253; a3 >= 0; a3--) {
          S4(c6, c6);
          if (a3 !== 2 && a3 !== 4) M4(c6, c6, i4);
        }
        for (a3 = 0; a3 < 16; a3++) o4[a3] = c6[a3];
      }
      function pow2523(o4, i4) {
        var c6 = gf2();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c6[a3] = i4[a3];
        for (a3 = 250; a3 >= 0; a3--) {
          S4(c6, c6);
          if (a3 !== 1) M4(c6, c6, i4);
        }
        for (a3 = 0; a3 < 16; a3++) o4[a3] = c6[a3];
      }
      function crypto_scalarmult(q, n5, p4) {
        var z4 = new Uint8Array(32);
        var x5 = new Float64Array(80), r3, i4;
        var a3 = gf2(), b4 = gf2(), c6 = gf2(), d4 = gf2(), e2 = gf2(), f8 = gf2();
        for (i4 = 0; i4 < 31; i4++) z4[i4] = n5[i4];
        z4[31] = n5[31] & 127 | 64;
        z4[0] &= 248;
        unpack25519(x5, p4);
        for (i4 = 0; i4 < 16; i4++) {
          b4[i4] = x5[i4];
          d4[i4] = a3[i4] = c6[i4] = 0;
        }
        a3[0] = d4[0] = 1;
        for (i4 = 254; i4 >= 0; --i4) {
          r3 = z4[i4 >>> 3] >>> (i4 & 7) & 1;
          sel25519(a3, b4, r3);
          sel25519(c6, d4, r3);
          A4(e2, a3, c6);
          Z2(a3, a3, c6);
          A4(c6, b4, d4);
          Z2(b4, b4, d4);
          S4(d4, e2);
          S4(f8, a3);
          M4(a3, c6, a3);
          M4(c6, b4, e2);
          A4(e2, a3, c6);
          Z2(a3, a3, c6);
          S4(b4, a3);
          Z2(c6, d4, f8);
          M4(a3, c6, _121665);
          A4(a3, a3, d4);
          M4(c6, c6, a3);
          M4(a3, d4, f8);
          M4(d4, b4, x5);
          S4(b4, e2);
          sel25519(a3, b4, r3);
          sel25519(c6, d4, r3);
        }
        for (i4 = 0; i4 < 16; i4++) {
          x5[i4 + 16] = a3[i4];
          x5[i4 + 32] = c6[i4];
          x5[i4 + 48] = b4[i4];
          x5[i4 + 64] = d4[i4];
        }
        var x32 = x5.subarray(32);
        var x16 = x5.subarray(16);
        inv25519(x32, x32);
        M4(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n5) {
        return crypto_scalarmult(q, n5, _9);
      }
      function crypto_box_keypair(y5, x5) {
        randombytes(x5, 32);
        return crypto_scalarmult_base(y5, x5);
      }
      function crypto_box_beforenm(k6, y5, x5) {
        var s3 = new Uint8Array(32);
        crypto_scalarmult(s3, x5, y5);
        return crypto_core_hsalsa20(k6, _0, s3, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c6, m3, d4, n5, y5, x5) {
        var k6 = new Uint8Array(32);
        crypto_box_beforenm(k6, y5, x5);
        return crypto_box_afternm(c6, m3, d4, n5, k6);
      }
      function crypto_box_open(m3, c6, d4, n5, y5, x5) {
        var k6 = new Uint8Array(32);
        crypto_box_beforenm(k6, y5, x5);
        return crypto_box_open_afternm(m3, c6, d4, n5, k6);
      }
      var K4 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m3, n5) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i4, j3, h5, l6, a3, b4, c6, d4;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n5 >= 128) {
          for (i4 = 0; i4 < 16; i4++) {
            j3 = 8 * i4 + pos;
            wh[i4] = m3[j3 + 0] << 24 | m3[j3 + 1] << 16 | m3[j3 + 2] << 8 | m3[j3 + 3];
            wl[i4] = m3[j3 + 4] << 24 | m3[j3 + 5] << 16 | m3[j3 + 6] << 8 | m3[j3 + 7];
          }
          for (i4 = 0; i4 < 80; i4++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h5 = ah7;
            l6 = al7;
            a3 = l6 & 65535;
            b4 = l6 >>> 16;
            c6 = h5 & 65535;
            d4 = h5 >>> 16;
            h5 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l6 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            h5 = ah4 & ah5 ^ ~ah4 & ah6;
            l6 = al4 & al5 ^ ~al4 & al6;
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            h5 = K4[i4 * 2];
            l6 = K4[i4 * 2 + 1];
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            h5 = wh[i4 % 16];
            l6 = wl[i4 % 16];
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            b4 += a3 >>> 16;
            c6 += b4 >>> 16;
            d4 += c6 >>> 16;
            th = c6 & 65535 | d4 << 16;
            tl = a3 & 65535 | b4 << 16;
            h5 = th;
            l6 = tl;
            a3 = l6 & 65535;
            b4 = l6 >>> 16;
            c6 = h5 & 65535;
            d4 = h5 >>> 16;
            h5 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l6 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            h5 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l6 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            b4 += a3 >>> 16;
            c6 += b4 >>> 16;
            d4 += c6 >>> 16;
            bh7 = c6 & 65535 | d4 << 16;
            bl7 = a3 & 65535 | b4 << 16;
            h5 = bh3;
            l6 = bl3;
            a3 = l6 & 65535;
            b4 = l6 >>> 16;
            c6 = h5 & 65535;
            d4 = h5 >>> 16;
            h5 = th;
            l6 = tl;
            a3 += l6 & 65535;
            b4 += l6 >>> 16;
            c6 += h5 & 65535;
            d4 += h5 >>> 16;
            b4 += a3 >>> 16;
            c6 += b4 >>> 16;
            d4 += c6 >>> 16;
            bh3 = c6 & 65535 | d4 << 16;
            bl3 = a3 & 65535 | b4 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i4 % 16 === 15) {
              for (j3 = 0; j3 < 16; j3++) {
                h5 = wh[j3];
                l6 = wl[j3];
                a3 = l6 & 65535;
                b4 = l6 >>> 16;
                c6 = h5 & 65535;
                d4 = h5 >>> 16;
                h5 = wh[(j3 + 9) % 16];
                l6 = wl[(j3 + 9) % 16];
                a3 += l6 & 65535;
                b4 += l6 >>> 16;
                c6 += h5 & 65535;
                d4 += h5 >>> 16;
                th = wh[(j3 + 1) % 16];
                tl = wl[(j3 + 1) % 16];
                h5 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l6 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a3 += l6 & 65535;
                b4 += l6 >>> 16;
                c6 += h5 & 65535;
                d4 += h5 >>> 16;
                th = wh[(j3 + 14) % 16];
                tl = wl[(j3 + 14) % 16];
                h5 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l6 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a3 += l6 & 65535;
                b4 += l6 >>> 16;
                c6 += h5 & 65535;
                d4 += h5 >>> 16;
                b4 += a3 >>> 16;
                c6 += b4 >>> 16;
                d4 += c6 >>> 16;
                wh[j3] = c6 & 65535 | d4 << 16;
                wl[j3] = a3 & 65535 | b4 << 16;
              }
            }
          }
          h5 = ah0;
          l6 = al0;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[0];
          l6 = hl[0];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[0] = ah0 = c6 & 65535 | d4 << 16;
          hl[0] = al0 = a3 & 65535 | b4 << 16;
          h5 = ah1;
          l6 = al1;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[1];
          l6 = hl[1];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[1] = ah1 = c6 & 65535 | d4 << 16;
          hl[1] = al1 = a3 & 65535 | b4 << 16;
          h5 = ah2;
          l6 = al2;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[2];
          l6 = hl[2];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[2] = ah2 = c6 & 65535 | d4 << 16;
          hl[2] = al2 = a3 & 65535 | b4 << 16;
          h5 = ah3;
          l6 = al3;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[3];
          l6 = hl[3];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[3] = ah3 = c6 & 65535 | d4 << 16;
          hl[3] = al3 = a3 & 65535 | b4 << 16;
          h5 = ah4;
          l6 = al4;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[4];
          l6 = hl[4];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[4] = ah4 = c6 & 65535 | d4 << 16;
          hl[4] = al4 = a3 & 65535 | b4 << 16;
          h5 = ah5;
          l6 = al5;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[5];
          l6 = hl[5];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[5] = ah5 = c6 & 65535 | d4 << 16;
          hl[5] = al5 = a3 & 65535 | b4 << 16;
          h5 = ah6;
          l6 = al6;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[6];
          l6 = hl[6];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[6] = ah6 = c6 & 65535 | d4 << 16;
          hl[6] = al6 = a3 & 65535 | b4 << 16;
          h5 = ah7;
          l6 = al7;
          a3 = l6 & 65535;
          b4 = l6 >>> 16;
          c6 = h5 & 65535;
          d4 = h5 >>> 16;
          h5 = hh[7];
          l6 = hl[7];
          a3 += l6 & 65535;
          b4 += l6 >>> 16;
          c6 += h5 & 65535;
          d4 += h5 >>> 16;
          b4 += a3 >>> 16;
          c6 += b4 >>> 16;
          d4 += c6 >>> 16;
          hh[7] = ah7 = c6 & 65535 | d4 << 16;
          hl[7] = al7 = a3 & 65535 | b4 << 16;
          pos += 128;
          n5 -= 128;
        }
        return n5;
      }
      function crypto_hash(out, m3, n5) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x5 = new Uint8Array(256), i4, b4 = n5;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m3, n5);
        n5 %= 128;
        for (i4 = 0; i4 < n5; i4++) x5[i4] = m3[b4 - n5 + i4];
        x5[n5] = 128;
        n5 = 256 - 128 * (n5 < 112 ? 1 : 0);
        x5[n5 - 9] = 0;
        ts64(x5, n5 - 8, b4 / 536870912 | 0, b4 << 3);
        crypto_hashblocks_hl(hh, hl, x5, n5);
        for (i4 = 0; i4 < 8; i4++) ts64(out, 8 * i4, hh[i4], hl[i4]);
        return 0;
      }
      function add4(p4, q) {
        var a3 = gf2(), b4 = gf2(), c6 = gf2(), d4 = gf2(), e2 = gf2(), f8 = gf2(), g3 = gf2(), h5 = gf2(), t = gf2();
        Z2(a3, p4[1], p4[0]);
        Z2(t, q[1], q[0]);
        M4(a3, a3, t);
        A4(b4, p4[0], p4[1]);
        A4(t, q[0], q[1]);
        M4(b4, b4, t);
        M4(c6, p4[3], q[3]);
        M4(c6, c6, D22);
        M4(d4, p4[2], q[2]);
        A4(d4, d4, d4);
        Z2(e2, b4, a3);
        Z2(f8, d4, c6);
        A4(g3, d4, c6);
        A4(h5, b4, a3);
        M4(p4[0], e2, f8);
        M4(p4[1], h5, g3);
        M4(p4[2], g3, f8);
        M4(p4[3], e2, h5);
      }
      function cswap(p4, q, b4) {
        var i4;
        for (i4 = 0; i4 < 4; i4++) {
          sel25519(p4[i4], q[i4], b4);
        }
      }
      function pack(r3, p4) {
        var tx = gf2(), ty = gf2(), zi4 = gf2();
        inv25519(zi4, p4[2]);
        M4(tx, p4[0], zi4);
        M4(ty, p4[1], zi4);
        pack25519(r3, ty);
        r3[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p4, q, s3) {
        var b4, i4;
        set25519(p4[0], gf0);
        set25519(p4[1], gf1);
        set25519(p4[2], gf1);
        set25519(p4[3], gf0);
        for (i4 = 255; i4 >= 0; --i4) {
          b4 = s3[i4 / 8 | 0] >> (i4 & 7) & 1;
          cswap(p4, q, b4);
          add4(q, p4);
          add4(p4, p4);
          cswap(p4, q, b4);
        }
      }
      function scalarbase(p4, s3) {
        var q = [gf2(), gf2(), gf2(), gf2()];
        set25519(q[0], X4);
        set25519(q[1], Y4);
        set25519(q[2], gf1);
        M4(q[3], X4, Y4);
        scalarmult(p4, q, s3);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d4 = new Uint8Array(64);
        var p4 = [gf2(), gf2(), gf2(), gf2()];
        var i4;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d4, sk, 32);
        d4[0] &= 248;
        d4[31] &= 127;
        d4[31] |= 64;
        scalarbase(p4, d4);
        pack(pk, p4);
        for (i4 = 0; i4 < 32; i4++) sk[i4 + 32] = pk[i4];
        return 0;
      }
      var L3 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r3, x5) {
        var carry, i4, j3, k6;
        for (i4 = 63; i4 >= 32; --i4) {
          carry = 0;
          for (j3 = i4 - 32, k6 = i4 - 12; j3 < k6; ++j3) {
            x5[j3] += carry - 16 * x5[i4] * L3[j3 - (i4 - 32)];
            carry = Math.floor((x5[j3] + 128) / 256);
            x5[j3] -= carry * 256;
          }
          x5[j3] += carry;
          x5[i4] = 0;
        }
        carry = 0;
        for (j3 = 0; j3 < 32; j3++) {
          x5[j3] += carry - (x5[31] >> 4) * L3[j3];
          carry = x5[j3] >> 8;
          x5[j3] &= 255;
        }
        for (j3 = 0; j3 < 32; j3++) x5[j3] -= carry * L3[j3];
        for (i4 = 0; i4 < 32; i4++) {
          x5[i4 + 1] += x5[i4] >> 8;
          r3[i4] = x5[i4] & 255;
        }
      }
      function reduce11(r3) {
        var x5 = new Float64Array(64), i4;
        for (i4 = 0; i4 < 64; i4++) x5[i4] = r3[i4];
        for (i4 = 0; i4 < 64; i4++) r3[i4] = 0;
        modL(r3, x5);
      }
      function crypto_sign(sm, m3, n5, sk) {
        var d4 = new Uint8Array(64), h5 = new Uint8Array(64), r3 = new Uint8Array(64);
        var i4, j3, x5 = new Float64Array(64);
        var p4 = [gf2(), gf2(), gf2(), gf2()];
        crypto_hash(d4, sk, 32);
        d4[0] &= 248;
        d4[31] &= 127;
        d4[31] |= 64;
        var smlen = n5 + 64;
        for (i4 = 0; i4 < n5; i4++) sm[64 + i4] = m3[i4];
        for (i4 = 0; i4 < 32; i4++) sm[32 + i4] = d4[32 + i4];
        crypto_hash(r3, sm.subarray(32), n5 + 32);
        reduce11(r3);
        scalarbase(p4, r3);
        pack(sm, p4);
        for (i4 = 32; i4 < 64; i4++) sm[i4] = sk[i4];
        crypto_hash(h5, sm, n5 + 64);
        reduce11(h5);
        for (i4 = 0; i4 < 64; i4++) x5[i4] = 0;
        for (i4 = 0; i4 < 32; i4++) x5[i4] = r3[i4];
        for (i4 = 0; i4 < 32; i4++) {
          for (j3 = 0; j3 < 32; j3++) {
            x5[i4 + j3] += h5[i4] * d4[j3];
          }
        }
        modL(sm.subarray(32), x5);
        return smlen;
      }
      function unpackneg(r3, p4) {
        var t = gf2(), chk = gf2(), num3 = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
        set25519(r3[2], gf1);
        unpack25519(r3[1], p4);
        S4(num3, r3[1]);
        M4(den, num3, D4);
        Z2(num3, num3, r3[2]);
        A4(den, r3[2], den);
        S4(den2, den);
        S4(den4, den2);
        M4(den6, den4, den2);
        M4(t, den6, num3);
        M4(t, t, den);
        pow2523(t, t);
        M4(t, t, num3);
        M4(t, t, den);
        M4(t, t, den);
        M4(r3[0], t, den);
        S4(chk, r3[0]);
        M4(chk, chk, den);
        if (neq25519(chk, num3)) M4(r3[0], r3[0], I4);
        S4(chk, r3[0]);
        M4(chk, chk, den);
        if (neq25519(chk, num3)) return -1;
        if (par25519(r3[0]) === p4[31] >> 7) Z2(r3[0], gf0, r3[0]);
        M4(r3[3], r3[0], r3[1]);
        return 0;
      }
      function crypto_sign_open(m3, sm, n5, pk) {
        var i4;
        var t = new Uint8Array(32), h5 = new Uint8Array(64);
        var p4 = [gf2(), gf2(), gf2(), gf2()], q = [gf2(), gf2(), gf2(), gf2()];
        if (n5 < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i4 = 0; i4 < n5; i4++) m3[i4] = sm[i4];
        for (i4 = 0; i4 < 32; i4++) m3[i4 + 32] = pk[i4];
        crypto_hash(h5, m3, n5);
        reduce11(h5);
        scalarmult(p4, q, h5);
        scalarbase(q, sm.subarray(32));
        add4(p4, q);
        pack(t, p4);
        n5 -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i4 = 0; i4 < n5; i4++) m3[i4] = 0;
          return -1;
        }
        for (i4 = 0; i4 < n5; i4++) m3[i4] = sm[i4 + 64];
        return n5;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl4.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf: gf2,
        D: D4,
        L: L3,
        pack25519,
        unpack25519,
        M: M4,
        A: A4,
        S: S4,
        Z: Z2,
        pow2523,
        add: add4,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k6, n5) {
        if (k6.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n5.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i4 = 0; i4 < arguments.length; i4++) {
          if (!(arguments[i4] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i4 = 0; i4 < arr.length; i4++) arr[i4] = 0;
      }
      nacl4.randomBytes = function(n5) {
        var b4 = new Uint8Array(n5);
        randombytes(b4, n5);
        return b4;
      };
      nacl4.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c6 = new Uint8Array(m3.length);
        for (var i4 = 0; i4 < msg.length; i4++) m3[i4 + crypto_secretbox_ZEROBYTES] = msg[i4];
        crypto_secretbox(c6, m3, m3.length, nonce, key);
        return c6.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl4.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c6 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m3 = new Uint8Array(c6.length);
        for (var i4 = 0; i4 < box.length; i4++) c6[i4 + crypto_secretbox_BOXZEROBYTES] = box[i4];
        if (c6.length < 32) return null;
        if (crypto_secretbox_open(m3, c6, c6.length, nonce, key) !== 0) return null;
        return m3.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl4.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl4.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl4.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl4.scalarMult = function(n5, p4) {
        checkArrayTypes(n5, p4);
        if (n5.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p4.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n5, p4);
        return q;
      };
      nacl4.scalarMult.base = function(n5) {
        checkArrayTypes(n5);
        if (n5.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n5);
        return q;
      };
      nacl4.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl4.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl4.box = function(msg, nonce, publicKey5, secretKey) {
        var k6 = nacl4.box.before(publicKey5, secretKey);
        return nacl4.secretbox(msg, nonce, k6);
      };
      nacl4.box.before = function(publicKey5, secretKey) {
        checkArrayTypes(publicKey5, secretKey);
        checkBoxLengths(publicKey5, secretKey);
        var k6 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k6, publicKey5, secretKey);
        return k6;
      };
      nacl4.box.after = nacl4.secretbox;
      nacl4.box.open = function(msg, nonce, publicKey5, secretKey) {
        var k6 = nacl4.box.before(publicKey5, secretKey);
        return nacl4.secretbox.open(msg, nonce, k6);
      };
      nacl4.box.open.after = nacl4.secretbox.open;
      nacl4.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl4.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl4.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl4.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl4.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl4.box.nonceLength = crypto_box_NONCEBYTES;
      nacl4.box.overheadLength = nacl4.secretbox.overheadLength;
      nacl4.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl4.sign.open = function(signedMsg, publicKey5) {
        checkArrayTypes(signedMsg, publicKey5);
        if (publicKey5.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey5);
        if (mlen < 0) return null;
        var m3 = new Uint8Array(mlen);
        for (var i4 = 0; i4 < m3.length; i4++) m3[i4] = tmp[i4];
        return m3;
      };
      nacl4.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl4.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i4 = 0; i4 < sig.length; i4++) sig[i4] = signedMsg[i4];
        return sig;
      };
      nacl4.sign.detached.verify = function(msg, sig, publicKey5) {
        checkArrayTypes(msg, sig, publicKey5);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey5.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i4;
        for (i4 = 0; i4 < crypto_sign_BYTES; i4++) sm[i4] = sig[i4];
        for (i4 = 0; i4 < msg.length; i4++) sm[i4 + crypto_sign_BYTES] = msg[i4];
        return crypto_sign_open(m3, sm, sm.length, publicKey5) >= 0;
      };
      nacl4.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl4.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i4 = 0; i4 < pk.length; i4++) pk[i4] = secretKey[32 + i4];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl4.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i4 = 0; i4 < 32; i4++) sk[i4] = seed[i4];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl4.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl4.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl4.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl4.sign.signatureLength = crypto_sign_BYTES;
      nacl4.hash = function(msg) {
        checkArrayTypes(msg);
        var h5 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h5, msg, msg.length);
        return h5;
      };
      nacl4.hash.hashLength = crypto_hash_BYTES;
      nacl4.verify = function(x5, y5) {
        checkArrayTypes(x5, y5);
        if (x5.length === 0 || y5.length === 0) return false;
        if (x5.length !== y5.length) return false;
        return vn5(x5, 0, y5, 0, x5.length) === 0 ? true : false;
      };
      nacl4.setPRNG = function(fn4) {
        randombytes = fn4;
      };
      (function() {
        var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto3 && crypto3.getRandomValues) {
          var QUOTA = 65536;
          nacl4.setPRNG(function(x5, n5) {
            var i4, v6 = new Uint8Array(n5);
            for (i4 = 0; i4 < n5; i4 += QUOTA) {
              crypto3.getRandomValues(v6.subarray(i4, i4 + Math.min(n5 - i4, QUOTA)));
            }
            for (i4 = 0; i4 < n5; i4++) x5[i4] = v6[i4];
            cleanup(v6);
          });
        } else if (typeof __require !== "undefined") {
          crypto3 = require_crypto();
          if (crypto3 && crypto3.randomBytes) {
            nacl4.setPRNG(function(x5, n5) {
              var i4, v6 = crypto3.randomBytes(n5);
              for (i4 = 0; i4 < n5; i4++) x5[i4] = v6[i4];
              cleanup(v6);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/@dynamic-labs/solana/package.js
var version = "4.57.1";

// node_modules/@dynamic-labs/solana-core/package.js
var version2 = "4.57.1";

// node_modules/@dynamic-labs/solana-core/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/solana-core/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_buffer = __toESM(require_buffer());
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_borsh = __toESM(require_lib());
var BufferLayout = __toESM(require_Layout());
var import_buffer_layout = __toESM(require_Layout());

// node_modules/@dynamic-labs/solana-core/node_modules/@solana/errors/dist/index.browser.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
var SOLANA_ERROR__INVALID_NONCE = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
var SolanaErrorMessages = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX = "i";
var TYPE = "t";
function getHumanReadableErrorMessage(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii3) => {
    if (ii3 === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = {
          [START_INDEX]: ii3,
          [TYPE]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii3,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii3,
            [TYPE]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii3,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii3,
            [TYPE]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX]: ii3,
            [TYPE]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii3);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage(code2, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code2}; Decode this error by running \`npx @solana/errors decode -- ${code2}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError = class extends Error {
  constructor(...[code2, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage(code2, context);
    super(message, errorOptions);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    __publicField(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    __publicField(this, "context");
    this.context = {
      __code: code2,
      ...context
    };
    this.name = "SolanaError";
  }
};

// node_modules/@dynamic-labs/solana-core/node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes2 = new Uint8Array(getEncodedSize(value, encoder));
      encoder.write(value, bytes2, 0);
      return bytes2;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes2, offset5 = 0) => decoder.read(bytes2, offset5)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec(encoder, decoder) {
  if (isFixedSize(encoder) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes2, offset5 = 0) {
  if (bytes2.length - offset5 <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes2, offset5 = 0) {
  const bytesLength = bytes2.length - offset5;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}

// node_modules/@dynamic-labs/solana-core/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec(codecDescription, min4, max4, value) {
  if (value < min4 || value > max4) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max: max4,
      min: min4,
      value
    });
  }
}
var Endian = ((Endian22) => {
  Endian22[Endian22["Little"] = 0] = "Little";
  Endian22[Endian22["Big"] = 1] = "Big";
  return Endian22;
})(Endian || {});
function isLittleEndian(config) {
  return (config == null ? void 0 : config.endian) === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value, bytes2, offset5) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes2.set(new Uint8Array(arrayBuffer), offset5);
      return offset5 + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes2, offset5 = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes2, offset5);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes2, offset5);
      const view = new DataView(toArrayBuffer(bytes2, offset5, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset5 + input.size];
    }
  });
}
function toArrayBuffer(bytes2, offset5, length2) {
  const bytesOffset = bytes2.byteOffset + (offset5 ?? 0);
  const bytesLength = length2 ?? bytes2.byteLength;
  return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le5) => view.setBigUint64(0, BigInt(value), le5),
  size: 8
});
var getU64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le5) => view.getBigUint64(0, le5),
  name: "u64",
  size: 8
});
var getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));

// node_modules/@dynamic-labs/solana-core/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_browser = __toESM(require_browser());
var generatePrivateKey = ed25519.utils.randomPrivateKey;
var generateKeypair = () => {
  const privateScalar = ed25519.utils.randomPrivateKey();
  const publicKey5 = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey5, 32);
  return {
    publicKey: publicKey5,
    secretKey
  };
};
var getPublicKey = ed25519.getPublicKey;
function isOnCurve(publicKey5) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey5);
    return true;
  } catch {
    return false;
  }
}
var sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
var verify = ed25519.verify;
var toBuffer = (arr) => {
  if (import_buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return import_buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return import_buffer.Buffer.from(arr);
  }
};
var Struct = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return import_buffer.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
  }
};
var SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _PublicKey;
var MAX_SEED_LENGTH = 32;
var PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
var uniquePublicKeyCounter = 1;
var PublicKey2 = class _PublicKey5 extends Struct {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs58.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn.default(decoded);
      } else {
        this._bn = new import_bn.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new _PublicKey5(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new _PublicKey5(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey5) {
    return this._bn.eq(publicKey5._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return import_bs58.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b4 = this._bn.toArrayLike(import_buffer.Buffer);
    if (b4.length === PUBLIC_KEY_LENGTH) {
      return b4;
    }
    const zeroPad = import_buffer.Buffer.alloc(32);
    b4.copy(zeroPad, 32 - b4.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = import_buffer.Buffer.concat([fromPublicKey.toBuffer(), import_buffer.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha2562(buffer);
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = import_buffer.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = import_buffer.Buffer.concat([buffer, toBuffer(seed)]);
    });
    buffer = import_buffer.Buffer.concat([buffer, programId.toBuffer(), import_buffer.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha2562(buffer);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(import_buffer.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new _PublicKey5(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
};
_PublicKey = PublicKey2;
PublicKey2.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey2, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey2("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 127;
var SIGNATURE_LENGTH_IN_BYTES = 64;
var TransactionExpiredBlockheightExceededError = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
var TransactionExpiredTimeoutError = class extends Error {
  constructor(signature4, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature4} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
var TransactionExpiredNonceInvalidError = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
var MessageAccountKeys = class {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
};
var publicKey = (property = "publicKey") => {
  return BufferLayout.blob(32, property);
};
var signature = (property = "signature") => {
  return BufferLayout.blob(64, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b4, offset5) => {
    const data = _decode(b4, offset5);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b4, offset5) => {
    const data = {
      chars: import_buffer.Buffer.from(str, "utf8")
    };
    return _encode(data, b4, offset5);
  };
  rslShim.alloc = (str) => {
    return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized = (property = "authorized") => {
  return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
function getAlloc(type3, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type3.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength(bytes2) {
  let len = 0;
  let size9 = 0;
  for (; ; ) {
    let elem6 = bytes2.shift();
    len |= (elem6 & 127) << size9 * 7;
    size9 += 1;
    if ((elem6 & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem6 = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem6);
      break;
    } else {
      elem6 |= 128;
      bytes2.push(elem6);
    }
  }
}
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var CompiledKeys = class _CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new _CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert2(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert2(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert2(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey2(address)), ...readonlySigners.map(([address]) => new PublicKey2(address)), ...writableNonSigners.map(([address]) => new PublicKey2(address)), ...readonlyNonSigners.map(([address]) => new PublicKey2(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey2(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert2(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
};
var END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.shift();
}
function guardedSplice(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.splice(...args);
}
var Message = class _Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey2(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs58.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs58.default.encode(ix.data)
    }));
    return new _Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_3, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs58.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: import_buffer.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: import_buffer.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = import_buffer.Buffer.alloc(PACKET_DATA_SIZE);
    import_buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
      const length3 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length3;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: import_buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: import_buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: import_buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: import_buffer.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
    };
    let signData = import_buffer.Buffer.alloc(2048);
    const length2 = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length2);
    return signData.slice(0, length2 + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift(byteArray);
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i4 = 0; i4 < accountCount; i4++) {
      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey2(import_buffer.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift(byteArray);
      const accountCount2 = decodeLength(byteArray);
      const accounts = guardedSplice(byteArray, 0, accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = guardedSplice(byteArray, 0, dataLength);
      const data = import_bs58.default.encode(import_buffer.Buffer.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs58.default.encode(import_buffer.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new _Message(messageArgs);
  }
};
var MessageV0 = class _MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup4 of this.addressTableLookups) {
      count += lookup4.readonlyIndexes.length + lookup4.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup4) => count + lookup4.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== void 0) {
        const [addressTableLookup, {
          writable,
          readonly: readonly3
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly3);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new _MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = BufferLayout.struct([BufferLayout.u8("prefix"), BufferLayout.struct([BufferLayout.u8("numRequiredSignatures"), BufferLayout.u8("numReadonlySignedAccounts"), BufferLayout.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout.blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    for (const lookup4 of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup4.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup4.readonlyIndexes.length);
      const addressTableLookupLayout = BufferLayout.struct([publicKey("accountKey"), BufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup4.writableIndexes.length, "writableIndexes"), BufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup4.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup4.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup4.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup4.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = guardedShift(byteArray);
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert2(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version11 = maskedPrefix;
    assert2(version11 === 0, `Expected versioned message with version 0 but found version ${version11}`);
    const header = {
      numRequiredSignatures: guardedShift(byteArray),
      numReadonlySignedAccounts: guardedShift(byteArray),
      numReadonlyUnsignedAccounts: guardedShift(byteArray)
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);
    for (let i4 = 0; i4 < staticAccountKeysLength; i4++) {
      staticAccountKeys.push(new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
    }
    const recentBlockhash = import_bs58.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift(byteArray);
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
      const dataLength = decodeLength(byteArray);
      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];
    for (let i4 = 0; i4 < addressTableLookupsCount; i4++) {
      const accountKey = new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new _MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
};
var VersionedMessage = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    if (maskedPrefix === prefix) {
      return "legacy";
    }
    return maskedPrefix;
  },
  deserialize: (serializedMessage) => {
    const version11 = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version11 === "legacy") {
      return Message.from(serializedMessage);
    }
    if (version11 === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version11} deserialization is not supported`);
    }
  }
};
var TransactionStatus = (function(TransactionStatus5) {
  TransactionStatus5[TransactionStatus5["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus5[TransactionStatus5["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus5[TransactionStatus5["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus5[TransactionStatus5["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus5;
})({});
var DEFAULT_SIGNATURE = import_buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
var TransactionInstruction = class {
  constructor(opts2) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = import_buffer.Buffer.alloc(0);
    this.programId = opts2.programId;
    this.keys = opts2.keys;
    if (opts2.data) {
      this.data = opts2.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
};
var Transaction2 = class _Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts2) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts2) {
      return;
    }
    if (opts2.feePayer) {
      this.feePayer = opts2.feePayer;
    }
    if (opts2.signatures) {
      this.signatures = opts2.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts2, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts2;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts2, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts2;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts2;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey5
      }) => {
        return publicKey5.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i4 = 0; i4 < instructions.length; i4++) {
      if (instructions[i4].programId === void 0) {
        throw new Error(`Transaction instruction index ${i4} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey2(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x5, y5) {
      if (x5.isSigner !== y5.isSigner) {
        return x5.isSigner ? -1 : 1;
      }
      if (x5.isWritable !== y5.isWritable) {
        return x5.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x5.pubkey.toBase58().localeCompare(y5.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x5) => {
      return x5.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature4 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.equals(signature4.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature4.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs58.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert2(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey5) => {
      const key = publicKey5.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature4 = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature4));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature4) {
    this._compile();
    this._addSignature(pubkey, signature4);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature4) {
    assert2(signature4.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = import_buffer.Buffer.from(signature4);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature: signature4,
      publicKey: publicKey5
    } of this.signatures) {
      if (signature4 === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey5);
        }
      } else {
        if (!verify(signature4, message, publicKey5.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey5);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = import_buffer.Buffer.alloc(transactionLength);
    assert2(signatures.length < 256);
    import_buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature4
    }, index) => {
      if (signature4 !== null) {
        assert2(signature4.length === 64, `signature has invalid length`);
        import_buffer.Buffer.from(signature4).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i4 = 0; i4 < signatureCount; i4++) {
      const signature4 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(import_bs58.default.encode(import_buffer.Buffer.from(signature4)));
    }
    return _Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message, signatures = []) {
    const transaction = new _Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature4, index) => {
      const sigPubkeyPair = {
        signature: signature4 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature4),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys4 = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys: keys4,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs58.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
};
var TransactionMessage = class _TransactionMessage {
  constructor(args) {
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }
  static decompile(message, args) {
    const {
      header,
      compiledInstructions,
      recentBlockhash
    } = message;
    const {
      numRequiredSignatures,
      numReadonlySignedAccounts,
      numReadonlyUnsignedAccounts
    } = header;
    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
    assert2(numWritableSignedAccounts > 0, "Message header is invalid");
    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
    assert2(numWritableUnsignedAccounts >= 0, "Message header is invalid");
    const accountKeys = message.getAccountKeys(args);
    const payerKey = accountKeys.get(0);
    if (payerKey === void 0) {
      throw new Error("Failed to decompile message because no account keys were found");
    }
    const instructions = [];
    for (const compiledIx of compiledInstructions) {
      const keys4 = [];
      for (const keyIndex of compiledIx.accountKeyIndexes) {
        const pubkey = accountKeys.get(keyIndex);
        if (pubkey === void 0) {
          throw new Error(`Failed to find key for account key index ${keyIndex}`);
        }
        const isSigner = keyIndex < numRequiredSignatures;
        let isWritable;
        if (isSigner) {
          isWritable = keyIndex < numWritableSignedAccounts;
        } else if (keyIndex < accountKeys.staticAccountKeys.length) {
          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
        } else {
          isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
          accountKeys.accountKeysFromLookups.writable.length;
        }
        keys4.push({
          pubkey,
          isSigner: keyIndex < header.numRequiredSignatures,
          isWritable
        });
      }
      const programId = accountKeys.get(compiledIx.programIdIndex);
      if (programId === void 0) {
        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
      }
      instructions.push(new TransactionInstruction({
        programId,
        data: toBuffer(compiledIx.data),
        keys: keys4
      }));
    }
    return new _TransactionMessage({
      payerKey,
      instructions,
      recentBlockhash
    });
  }
  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }
  compileToV0Message(addressLookupTableAccounts) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts
    });
  }
};
var VersionedTransaction2 = class _VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(message, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== void 0) {
      assert2(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i4 = 0; i4 < message.header.numRequiredSignatures; i4++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout.seq(signature(), this.signatures.length, "signatures"), BufferLayout.blob(serializedMessage.length, "serializedMessage")]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength(byteArray);
    for (let i4 = 0; i4 < signaturesLength; i4++) {
      signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
    }
    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
    return new _VersionedTransaction(message, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
      assert2(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey5, signature4) {
    assert2(signature4.byteLength === 64, "Signature must be 64 bytes long");
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey5));
    assert2(signerIndex >= 0, `Can not add signature; \`${publicKey5.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature4;
  }
};
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
var SYSVAR_CLOCK_PUBKEY = new PublicKey2("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey2("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey2("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey2("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey2("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey2("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey2("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey2("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey2("SysvarStakeHistory1111111111111111111111111");
var SendTransactionError = class extends Error {
  constructor({
    action,
    signature: signature4,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature4} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${/* @__PURE__ */ ((a3) => a3)(action)}'`;
      }
    }
    super(message);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature4;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
};
var SolanaJSONRPCError = class extends Error {
  constructor({
    code: code2,
    message,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message}` : message);
    this.code = void 0;
    this.data = void 0;
    this.code = code2;
    this.data = data;
    this.name = "SolanaJSONRPCError";
  }
};
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature4 = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature: signature4,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature: signature4
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature4, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature4 != null) {
      throw new SendTransactionError({
        action: "send",
        signature: signature4,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature4} failed (${JSON.stringify(status)})`);
  }
  return signature4;
}
function sleep(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function encodeData(type3, fields) {
  const allocLength = type3.layout.span >= 0 ? type3.layout.span : getAlloc(type3, fields);
  const data = import_buffer.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type3.index
  }, fields);
  type3.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
var NonceAccount = class _NonceAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
    return new _NonceAccount({
      authorizedPubkey: new PublicKey2(nonceAccount.authorizedPubkey),
      nonce: new PublicKey2(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
};
function u64(property) {
  const layout = (0, import_buffer_layout.blob)(8, property);
  const decode9 = layout.decode.bind(layout);
  const encode16 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec();
  bigIntLayout.decode = (buffer, offset5) => {
    const src2 = decode9(buffer, offset5);
    return codec.decode(src2);
  };
  bigIntLayout.encode = (bigInt, buffer, offset5) => {
    const src2 = codec.encode(bigInt);
    return encode16(src2, buffer, offset5);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
var SystemProgram = class _SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type3, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type3, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type3, {
        lamports: BigInt(params.lamports)
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type3, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type3, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type3, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys4 = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys4.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction2();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(_SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(_SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type3, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type3);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type3, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type3, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type3, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type3, {
        space: params.space
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
SystemProgram.programId = new PublicKey2("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
var Loader = class _Loader {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Amount of program data placed in each load Transaction
   */
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * // Every transaction requires two signatures (payer + program)
    (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
    1);
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction2();
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction2();
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction2();
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction2().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
    const chunkSize = _Loader.chunkSize;
    let offset5 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes2 = array2.slice(0, chunkSize);
      const data2 = import_buffer.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset: offset5,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction2().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1e3 / REQUESTS_PER_SECOND);
      }
      offset5 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
      const data2 = import_buffer.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
        // Finalize instruction
      }, data2);
      const transaction = new Transaction2().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
      }
    }
    return true;
  }
};
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey2("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs(x5) {
  return x5 && x5.__esModule && Object.prototype.hasOwnProperty.call(x5, "default") ? x5["default"] : x5;
}
var fastStableStringify$1;
var hasRequiredFastStableStringify;
function requireFastStableStringify() {
  if (hasRequiredFastStableStringify) return fastStableStringify$1;
  hasRequiredFastStableStringify = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys4 = [];
    for (var name2 in obj) {
      keys4.push(name2);
    }
    return keys4;
  };
  function stringify6(val, isArrayProp) {
    var i4, max4, str, keys4, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify6(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str = "[";
            max4 = val.length - 1;
            for (i4 = 0; i4 < max4; i4++) {
              str += stringify6(val[i4], true) + ",";
            }
            if (max4 > -1) {
              str += stringify6(val[i4], true);
            }
            return str + "]";
          } else if (toStr === "[object Object]") {
            keys4 = objKeys(val).sort();
            max4 = keys4.length;
            str = "";
            i4 = 0;
            while (i4 < max4) {
              key = keys4[i4];
              propVal = stringify6(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i4++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$1 = function(val) {
    var returnVal = stringify6(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$1;
}
var fastStableStringifyExports = requireFastStableStringify();
var fastStableStringify = getDefaultExportFromCjs(fastStableStringifyExports);
var MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(n5) {
  let trailingZeros3 = 0;
  while (n5 > 1) {
    n5 /= 2;
    trailingZeros3++;
  }
  return trailingZeros3;
}
function nextPowerOfTwo(n5) {
  if (n5 === 0) return 1;
  n5--;
  n5 |= n5 >> 1;
  n5 |= n5 >> 2;
  n5 |= n5 >> 4;
  n5 |= n5 >> 8;
  n5 |= n5 >> 16;
  n5 |= n5 >> 32;
  return n5 + 1;
}
var EpochSchedule = class {
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
};
var fetchImpl = globalThis.fetch;
var RpcWebSocketClient = class extends CommonClient {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = (url) => {
      const rpc3 = WebSocket2(url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1e3,
        ...options
      });
      if ("socket" in rpc3) {
        this.underlyingSocket = rpc3.socket;
      } else {
        this.underlyingSocket = rpc3;
      }
      return rpc3;
    };
    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = void 0;
  }
  call(...args) {
    var _a21;
    const readyState = (_a21 = this.underlyingSocket) == null ? void 0 : _a21.readyState;
    if (readyState === 1) {
      return super.call(...args);
    }
    return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
  notify(...args) {
    var _a21;
    const readyState = (_a21 = this.underlyingSocket) == null ? void 0 : _a21.readyState;
    if (readyState === 1) {
      return super.notify(...args);
    }
    return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
};
function decodeData(type3, data) {
  let decoded;
  try {
    decoded = type3.layout.decode(data);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (decoded.typeIndex !== type3.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type3.index}`);
  }
  return decoded;
}
var LOOKUP_TABLE_META_SIZE = 56;
var AddressLookupTableAccount = class {
  constructor(args) {
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  isActive() {
    const U64_MAX = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert2(serializedAddressesLen >= 0, "lookup table is invalid");
    assert2(serializedAddressesLen % 32 === 0, "lookup table is invalid");
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey2(meta.authority[0]) : void 0,
      addresses: addresses.map((address) => new PublicKey2(address))
    };
  }
};
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([
    BufferLayout.u32("typeIndex"),
    u64("deactivationSlot"),
    BufferLayout.nu64("lastExtendedSlot"),
    BufferLayout.u8("lastExtendedStartIndex"),
    BufferLayout.u8(),
    // option
    BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
  ])
};
var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  const matches = endpoint.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
  }
  const [
    _3,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to agave-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
var PublicKeyFromString = coerce(instance(PublicKey2), string(), (value) => new PublicKey2(value));
var RawAccountDataResult = tuple([string(), literal("base64")]);
var BufferFromRawAccountData = coerce(instance(import_buffer.Buffer), RawAccountDataResult, (value) => import_buffer.Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}
function applyDefaultMemcmpEncodingToFilters(filters) {
  return filters.map((filter10) => "memcmp" in filter10 ? {
    ...filter10,
    memcmp: {
      ...filter10.memcmp,
      encoding: filter10.memcmp.encoding ?? "base58"
    }
  } : filter10);
}
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
function versionedMessageFromResponse(version11, response) {
  if (version11 === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey2(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: import_bs58.default.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
var GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
var GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
}));
var GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});
var GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
var GetLeaderScheduleResult = record(string(), array(number()));
var TransactionErrorResult = nullable(union([type({}), string()]));
var SignatureStatusResult = type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = literal("receivedSignature");
var VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
var ParsedInstructionStruct = type({
  program: string(),
  programId: PublicKeyFromString,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct = type({
  programId: PublicKeyFromString,
  accounts: array(PublicKeyFromString),
  data: string()
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
  }))))
}));
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch3 = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent != null) {
      console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init4) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init4, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch3(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new import_browser.default(async (request2, callback) => {
    const options = {
      method: "POST",
      body: request2,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch3(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error) callback(err);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0) resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(number());
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(import_buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});
var SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
});
var SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
var SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct = union([literal(0), literal("legacy")]);
var RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
})));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
var PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(string());
var SendTransactionRpcResult = jsonRpcResult(string());
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});
var COMMON_HTTP_HEADERS = {
  "solana-client": `js/${"1.0.0-maintenance"}`
};
var Connection = class {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint, _commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    this.getBlockHeight = /* @__PURE__ */ (() => {
      const requestPromises = {};
      return async (commitmentOrConfig) => {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const requestHash = fastStableStringify(args);
        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
          try {
            const unsafeRes = await this._rpcRequest("getBlockHeight", args);
            const res = create(unsafeRes, jsonRpcResult(number()));
            if ("error" in res) {
              throw new SolanaJSONRPCError(res.error, "failed to get block height information");
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        })();
        return await requestPromises[requestHash];
      };
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch3;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch3 = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch3, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(publicKey5, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(publicKey5, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey5, commitmentOrConfig).then((x5) => x5.value).catch((e2) => {
      throw new Error("failed to get balance of account " + publicKey5.toBase58() + ": " + e2);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
    const res = create(unsafeRes, jsonRpcResult(nullable(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
    }
    return res.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
    }
    return res.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
    const res = create(unsafeRes, SlotRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get first available block");
    }
    return res.result;
  }
  /**
   * Fetch information about the current supply
   */
  async getSupply(config) {
    let configArg = {};
    if (typeof config === "string") {
      configArg = {
        commitment: config
      };
    } else if (config) {
      configArg = {
        ...config,
        commitment: config && config.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
    const res = create(unsafeRes, GetSupplyRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get supply");
    }
    return res.result;
  }
  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenSupply", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token supply");
    }
    return res.result;
  }
  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
    }
    return res.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */
  async getTokenAccountsByOwner(ownerAddress, filter10, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter10) {
      _args.push({
        mint: filter10.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter10.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(ownerAddress, filter10, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter10) {
      _args.push({
        mint: filter10.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter10.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(config) {
    const arg = {
      ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
    const res = create(unsafeRes, GetLargestAccountsRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
    const res = create(unsafeRes, GetTokenLargestAccountsResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(publicKey5, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(publicKey5, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(publicKey5, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey5, commitmentOrConfig);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get info about account " + publicKey5.toBase58() + ": " + e2);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const keys4 = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys4], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys4}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const keys4 = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys4], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys4}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   *
   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
   */
  async getStakeActivation(publicKey5, commitmentOrConfig, epoch) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, void 0, {
      ...config,
      epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
    });
    const unsafeRes = await this._rpcRequest("getStakeActivation", args);
    const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const {
      encoding,
      ...configWithoutEncoding
    } = config || {};
    const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
      ...configWithoutEncoding,
      ...configWithoutEncoding.filters ? {
        filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
      } : null
    });
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const baseSchema = array(KeyedAccountInfoResult);
    const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(strategy, commitment) {
    var _a21;
    let rawSignature;
    if (typeof strategy == "string") {
      rawSignature = strategy;
    } else {
      const config = strategy;
      if ((_a21 = config.abortSignal) == null ? void 0 : _a21.aborted) {
        return Promise.reject(config.abortSignal.reason);
      }
      rawSignature = config.signature;
    }
    let decodedSignature;
    try {
      decodedSignature = import_bs58.default.decode(rawSignature);
    } catch (err) {
      throw new Error("signature must be base58 encoded: " + rawSignature);
    }
    assert2(decodedSignature.length === 64, "signature has invalid length");
    if (typeof strategy === "string") {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ("lastValidBlockHeight" in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }
  getCancellationPromise(signal) {
    return new Promise((_3, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature: signature4
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature4, (result, context) => {
          signatureSubscriptionId = void 0;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
              if (nextState === "subscribed") {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (async () => {
          await subscriptionSetupPromise;
          if (done) return;
          const response = await this.getSignatureStatus(signature4);
          if (done) return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value == null ? void 0 : value.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case "confirmed":
              case "single":
              case "singleGossip": {
                if (value.confirmationStatus === "processed") {
                  return;
                }
                break;
              }
              case "finalized":
              case "max":
              case "root": {
                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                  return;
                }
                break;
              }
              // exhaust enums to ensure full coverage
              case "processed":
              case "recent":
            }
            done = true;
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = void 0;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = void 0;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature: signature4
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e6) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done) return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep(1e3);
          if (done) return;
          currentBlockHeight = await checkBlockHeight();
          if (done) return;
        }
        resolve({
          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature4
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError(signature4);
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature: signature4
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;
      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount == null ? void 0 : nonceAccount.nonce;
        } catch (e2) {
          return currentNonceValue;
        }
      };
      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done) return;
        while (true) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: TransactionStatus.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }
          await sleep(2e3);
          if (done) return;
          currentNonceValue = await getCurrentNonceValue();
          if (done) return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature4
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        let signatureStatus;
        while (true) {
          const status = await this.getSignatureStatus(signature4);
          if (status == null) {
            break;
          }
          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep(400);
            continue;
          }
          signatureStatus = status;
          break;
        }
        if (signatureStatus == null ? void 0 : signatureStatus.value) {
          const commitmentForStatus = commitment || "finalized";
          const {
            confirmationStatus
          } = signatureStatus.value;
          switch (commitmentForStatus) {
            case "processed":
            case "recent":
              if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature4);
              }
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature4);
              }
              break;
            case "finalized":
            case "max":
            case "root":
              if (confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature4);
              }
              break;
            default:
              /* @__PURE__ */ ((_3) => {
              })(commitmentForStatus);
          }
          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError(signature4);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature: signature4
  }) {
    let timeoutId;
    const expiryPromise = new Promise((resolve) => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
      switch (commitment) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
          break;
        }
      }
      timeoutId = setTimeout(() => resolve({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature4
    });
    let result;
    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError(signature4, outcome.timeoutMs / 1e3);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }
    return result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest("getClusterNodes", []);
    const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
    }
    return res.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
    const res = create(unsafeRes, GetVoteAccounts);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
    }
    return res.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getSlot", args);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot");
    }
    return res.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getSlotLeader", args);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
    }
    return res.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(startSlot, limit2) {
    const args = [startSlot, limit2];
    const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
    const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
    }
    return res.result;
  }
  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(signature4, config) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature4], config);
    assert2(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(signatures, config) {
    const params = [signatures];
    if (config) {
      params.push(config);
    }
    const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
    const res = create(unsafeRes, GetSignatureStatusesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signature status");
    }
    return res.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getTransactionCount", args);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
    }
    return res.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
    const res = create(unsafeRes, GetInflationGovernorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation");
    }
    return res.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
      ...config,
      epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
    });
    const unsafeRes = await this._rpcRequest("getInflationReward", args);
    const res = create(unsafeRes, GetInflationRewardResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
    }
    return res.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const unsafeRes = await this._rpcRequest("getInflationRate", []);
    const res = create(unsafeRes, GetInflationRateRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getEpochInfo", args);
    const res = create(unsafeRes, GetEpochInfoRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
    const res = create(unsafeRes, GetEpochScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
    }
    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
    const res = create(unsafeRes, GetLeaderScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
    }
    return res.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);
    const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
    const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    if ("error" in res) {
      console.warn("Unable to fetch minimum balance for rent exemption");
      return 0;
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(commitment) {
    const {
      context,
      value: {
        blockhash
      }
    } = await this.getLatestBlockhashAndContext(commitment);
    const feeCalculator = {
      get lamportsPerSignature() {
        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
      },
      toJSON() {
        return {};
      }
    };
    return {
      context,
      value: {
        blockhash,
        feeCalculator
      }
    };
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(limit2) {
    const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit2 ? [limit2] : []);
    const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
    }
    return res.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
    const res = create(unsafeRes, GetFeeCalculatorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(message, commitment) {
    const wireMessage = toBuffer(message.serialize()).toString("base64");
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
    }
    if (res.result === null) {
      throw new Error("invalid blockhash");
    }
    return res.result;
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(config) {
    var _a21;
    const accounts = (_a21 = config == null ? void 0 : config.lockedWritableAccounts) == null ? void 0 : _a21.map((key) => key.toBase58());
    const args = (accounts == null ? void 0 : accounts.length) ? [accounts] : [];
    const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
    const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get recent blockhash: " + e2);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get recent blockhash: " + e2);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
    const res = create(unsafeRes, GetLatestBlockhashRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
    }
    return res.result;
  }
  /**
   * Returns whether a blockhash is still valid or not
   */
  async isBlockhashValid(blockhash, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgs([blockhash], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
    const res = create(unsafeRes, IsBlockhashValidRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
    }
    return res.result;
  }
  /**
   * Fetch the node version
   */
  async getVersion() {
    const unsafeRes = await this._rpcRequest("getVersion", []);
    const res = create(unsafeRes, jsonRpcResult(VersionResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get version");
    }
    return res.result;
  }
  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest("getGenesisHash", []);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
    }
    return res.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config == null ? void 0 : config.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          const {
            result
          } = res;
          return result ? {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta,
              version: version11
            }) => ({
              meta,
              transaction: {
                ...transaction,
                message: versionedMessageFromResponse(version11, transaction.message)
              },
              version: version11
            }))
          } : null;
        }
      }
    } catch (e2) {
      throw new SolanaJSONRPCError(e2, "failed to get confirmed block");
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config == null ? void 0 : config.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetParsedBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
      }
    } catch (e2) {
      throw new SolanaJSONRPCError(e2, "failed to get block");
    }
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;
    if (typeof configOrCommitment === "string") {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c6,
        ...rest
      } = configOrCommitment;
      commitment = c6;
      extra = rest;
    }
    const args = this._buildArgs([], commitment, "base64", extra);
    const unsafeRes = await this._rpcRequest("getBlockProduction", args);
    const res = create(unsafeRes, BlockProductionResponseStruct);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block production information");
    }
    return res.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(signature4, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result) return result;
    return {
      ...result,
      transaction: {
        ...result.transaction,
        message: versionedMessageFromResponse(result.version, result.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(signature4, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature4) => {
      const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed", config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature4) => {
      const args = this._buildArgsAtLeastConfirmed([signature4], commitment, void 0, config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      const result = res2.result;
      if (!result) return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetConfirmedBlockRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    const block = {
      ...result,
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: {
            ...transaction,
            message
          }
        };
      })
    };
    return {
      ...block,
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction2.populate(transaction.message, transaction.signatures)
        };
      })
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest("getBlocks", args);
    const res = create(unsafeRes, jsonRpcResult(array(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get blocks");
    }
    return res.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(signature4, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result) return result;
    const message = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return {
      ...result,
      transaction: Transaction2.populate(message, signatures)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(signature4, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map((signature4) => {
      const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed");
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!("until" in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot("finalized");
    while (!("before" in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map((info) => info.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
   */
  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
    const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
    }
    return res.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
    const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
    }
    return res.result;
  }
  async getAddressLookupTable(accountKey, config) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config);
    let value = null;
    if (accountInfo !== null) {
      value = new AddressLookupTableAccount({
        key: accountKey,
        state: AddressLookupTableAccount.deserialize(accountInfo.data)
      });
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x5) => x5.value).catch((e2) => {
      throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e2);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(to5, lamports) {
    const unsafeRes = await this._rpcRequest("requestAirdrop", [to5.toBase58(), lamports]);
    const res = create(unsafeRes, RequestAirdropRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `airdrop to ${to5.toBase58()} failed`);
    }
    return res.result;
  }
  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      while (this._pollingBlockhash) {
        await sleep(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
      for (let i4 = 0; i4 < 50; i4++) {
        const latestBlockhash = await this.getLatestBlockhash("finalized");
        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        }
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(config) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig(config);
    const args = this._buildArgs([], commitment, "base64", configArg);
    const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
    }
    return res.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ("message" in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction2 = versionedTx.serialize();
      const encodedTransaction2 = import_buffer.Buffer.from(wireTransaction2).toString("base64");
      if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
        throw new Error("Invalid arguments");
      }
      const config2 = configOrSigners || {};
      config2.encoding = "base64";
      if (!("commitment" in config2)) {
        config2.commitment = this.commitment;
      }
      if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
        config2.innerInstructions = configOrSigners.innerInstructions;
      }
      const args2 = [encodedTransaction2, config2];
      const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
      const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
      if ("error" in res2) {
        throw new Error("failed to simulate transaction: " + res2.error.message);
      }
      return res2.result;
    }
    let transaction;
    if (transactionOrMessage instanceof Transaction2) {
      let originalTx = transactionOrMessage;
      transaction = new Transaction2();
      transaction.feePayer = originalTx.feePayer;
      transaction.instructions = transactionOrMessage.instructions;
      transaction.nonceInfo = originalTx.nonceInfo;
      transaction.signatures = originalTx.signatures;
    } else {
      transaction = Transaction2.populate(transactionOrMessage);
      transaction._message = transaction._json = void 0;
    }
    if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
      throw new Error("Invalid arguments");
    }
    const signers = configOrSigners;
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        if (!signers) break;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature4 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(signature4) && !this._blockhashInfo.transactionSignatures.includes(signature4)) {
          this._blockhashInfo.simulatedSignatures.push(signature4);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config.sigVerify = true;
    }
    if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
      config.innerInstructions = configOrSigners.innerInstructions;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError({
        action: "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Send a signed transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(transaction, signersOrOptions, options) {
    if ("version" in transaction) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const wireTransaction2 = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
    }
    if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
      throw new Error("Invalid arguments");
    }
    const signers = signersOrOptions;
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature4 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.transactionSignatures.includes(signature4)) {
          this._blockhashInfo.transactionSignatures.push(signature4);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString("base64");
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: "base64"
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries != null) {
      config.maxRetries = options.maxRetries;
    }
    if (options && options.minContextSlot != null) {
      config.minContextSlot = options.minContextSlot;
    }
    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("sendTransaction", args);
    const res = create(unsafeRes, SendTransactionRpcResult);
    if ("error" in res) {
      let logs = void 0;
      if ("data" in res.error) {
        logs = res.error.data.logs;
      }
      throw new SendTransactionError({
        action: skipPreflight ? "send" : "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5e3);
    this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error("ws error:", err.message);
  }
  /**
   * @internal
   */
  _wsOnClose(code2) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code2 === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
      this._setSubscription(hash, {
        ...subscription,
        state: "pending"
      });
    });
  }
  /**
   * @internal
   */
  _setSubscription(hash, nextSubscription) {
    var _a21;
    const prevState = (_a21 = this._subscriptionsByHash[hash]) == null ? void 0 : _a21.state;
    this._subscriptionsByHash[hash] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach((cb) => {
          try {
            cb(nextSubscription.state);
          } catch {
          }
        });
      }
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _a21;
    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash == null) {
      return () => {
      };
    }
    const stateChangeCallbacks = (_a21 = this._subscriptionStateChangeCallbacksByHash)[hash] || (_a21[hash] = /* @__PURE__ */ new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash];
      }
    };
  }
  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };
    await Promise.all(
      // Don't be tempted to change this to `Object.entries`. We call
      // `_updateSubscriptions` recursively when processing the state,
      // so it's important that we look up the *current* version of
      // each subscription, every time we process a hash.
      Object.keys(this._subscriptionsByHash).map(async (hash) => {
        const subscription = this._subscriptionsByHash[hash];
        if (subscription === void 0) {
          return;
        }
        switch (subscription.state) {
          case "pending":
          case "unsubscribed":
            if (subscription.callbacks.size === 0) {
              delete this._subscriptionsByHash[hash];
              if (subscription.state === "unsubscribed") {
                delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
              }
              await this._updateSubscriptions();
              return;
            }
            await (async () => {
              const {
                args,
                method
              } = subscription;
              try {
                this._setSubscription(hash, {
                  ...subscription,
                  state: "subscribing"
                });
                const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                this._setSubscription(hash, {
                  ...subscription,
                  serverSubscriptionId,
                  state: "subscribed"
                });
                this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                await this._updateSubscriptions();
              } catch (e2) {
                console.error(`Received ${e2 instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                  args,
                  error: e2
                });
                if (!isCurrentConnectionStillActive()) {
                  return;
                }
                this._setSubscription(hash, {
                  ...subscription,
                  state: "pending"
                });
                await this._updateSubscriptions();
              }
            })();
            break;
          case "subscribed":
            if (subscription.callbacks.size === 0) {
              await (async () => {
                const {
                  serverSubscriptionId,
                  unsubscribeMethod
                } = subscription;
                if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                  this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                } else {
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                  } catch (e2) {
                    if (e2 instanceof Error) {
                      console.error(`${unsubscribeMethod} error:`, e2.message);
                    }
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash, {
                      ...subscription,
                      state: "subscribed"
                    });
                    await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(hash, {
                  ...subscription,
                  state: "unsubscribed"
                });
                await this._updateSubscriptions();
              })();
            }
            break;
        }
      })
    );
  }
  /**
   * @internal
   */
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === void 0) {
      return;
    }
    callbacks.forEach((cb) => {
      try {
        cb(
          ...callbackArgs
        );
      } catch (e2) {
        console.error(e2);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, AccountNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(subscriptionConfig, args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash = fastStableStringify([subscriptionConfig.method, args]);
    const existingSubscription = this._subscriptionsByHash[hash];
    if (existingSubscription === void 0) {
      this._subscriptionsByHash[hash] = {
        ...subscriptionConfig,
        args,
        callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
        state: "pending"
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash];
      assert2(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };
    this._updateSubscriptions();
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onAccountChange(publicKey5, callback, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs(
      [publicKey5.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config
    );
    return this._makeSubscription({
      callback,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, ProgramAccountNotificationResult);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs(
      [programId.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config ? config : maybeFilters ? {
        filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(filter10, callback, commitment) {
    const args = this._buildArgs(
      [typeof filter10 === "object" ? {
        mentions: [filter10.toString()]
      } : filter10],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, args);
  }
  /**
   * Deregister a logs callback.
   *
   * @param clientSubscriptionId client subscription id to deregister.
   */
  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, LogsNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotUpdateNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
  }
  /**
   * @internal
   */
  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose2 = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    if (dispose2) {
      await dispose2();
    } else {
      console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
    }
  }
  _buildArgs(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding || extra) {
      let options = {};
      if (encoding) {
        options.encoding = encoding;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args, override, encoding, extra);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SignatureNotificationResult);
    if (result.value !== "receivedSignature") {
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
      type: "received"
    }, result.context] : [{
      type: "status",
      result: result.value
    }, result.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(signature4, callback, commitment) {
    const args = this._buildArgs(
      [signature4],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(signature4, callback, options) {
    const {
      commitment,
      ...extra
    } = {
      ...options,
      commitment: options && options.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    };
    const args = this._buildArgs([signature4], commitment, void 0, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        try {
          this.removeSignatureListener(clientSubscriptionId);
        } catch (_err) {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
  }
  /**
   * @internal
   */
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, RootNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
  }
};
var Keypair = class _Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair();
  }
  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  static generate() {
    return new _Keypair(generateKeypair());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey5 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);
      for (let ii3 = 0; ii3 < 32; ii3++) {
        if (publicKey5[ii3] !== computedPublicKey[ii3]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */
  static fromSeed(seed) {
    const publicKey5 = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey5, 32);
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */
  get publicKey() {
    return new PublicKey2(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
};
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("recentSlot"), BufferLayout.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
var AddressLookupTableProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey2.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type3, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys4 = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys: keys4,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static extendLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type3, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys4.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static closeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
};
AddressLookupTableProgram.programId = new PublicKey2("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), u64("microLamports")])
  }
});
var ComputeBudgetProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type3, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type3, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type3, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type3, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
};
ComputeBudgetProgram.programId = new PublicKey2("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
var Ed25519Program = class _Ed25519Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the ed25519 program
   */
  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      instructionIndex
    } = params;
    assert2(publicKey5.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey5.length} bytes`);
    assert2(signature4.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature4.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey5.length;
    const messageDataOffset = signatureOffset + signature4.length;
    const numSignatures = 1;
    const instructionData = import_buffer.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey5, publicKeyOffset);
    instructionData.fill(signature4, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: _Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey5 = keypair.publicKey.toBytes();
      const signature4 = sign(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program.programId = new PublicKey2("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign = (msgHash, privKey) => {
  const signature4 = secp256k1.sign(msgHash, privKey);
  return [signature4.toCompactRawBytes(), signature4.recovery];
};
secp256k1.utils.isValidPrivateKey;
var publicKeyCreate = secp256k1.getPublicKey;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
var Secp256k1Program = class _Secp256k1Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the secp256k1 program
   */
  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey5) {
    assert2(publicKey5.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey5.length} bytes`);
    try {
      return import_buffer.Buffer.from(keccak_256(toBuffer(publicKey5))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    } = params;
    return _Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey5),
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress3;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress3 = import_buffer.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress3 = import_buffer.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress3 = rawAddress;
    }
    assert2(ethAddress3.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress3.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress3.length;
    const messageDataOffset = signatureOffset + signature4.length + 1;
    const numSignatures = 1;
    const instructionData = import_buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature4),
      ethAddress: toBuffer(ethAddress3),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: _Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey5 = publicKeyCreate(
        privateKey,
        false
        /* isCompressed */
      ).slice(1);
      const messageHash = import_buffer.Buffer.from(keccak_256(toBuffer(message)));
      const [signature4, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program.programId = new PublicKey2("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
var STAKE_CONFIG_ID = new PublicKey2("StakeConfig11111111111111111111111111111111");
var Lockup = class {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey2.default);
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Stake program
   */
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: maybeLockup
    } = params;
    const lockup5 = maybeLockup || Lockup.default;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type3, {
      authorized: {
        staker: toBuffer(authorized5.staker.toBuffer()),
        withdrawer: toBuffer(authorized5.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup5.unixTimestamp,
        epoch: lockup5.epoch,
        custodian: toBuffer(lockup5.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction2();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction2();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type3);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type3, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type3, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type3, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params, rentExemptReserve) {
    const transaction = new Transaction2();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction2();
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type3);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type3);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram.programId = new PublicKey2("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var VoteProgram = class _VoteProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Vote program
   */
  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit5
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type3, {
      voteInit: {
        nodePubkey: toBuffer(voteInit5.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit5.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit5.authorizedWithdrawer.toBuffer()),
        commission: voteInit5.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction2();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type3, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type3, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return _VoteProgram.withdraw(params);
  }
  /**
   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
   */
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
    const data = encodeData(type3);
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
VoteProgram.programId = new PublicKey2("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3762;
var VALIDATOR_INFO_KEY = new PublicKey2("Va1idator1nfo111111111111111111111111111111");
var InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID = new PublicKey2("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout.u8("commission"),
  BufferLayout.nu64(),
  // votes.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
  BufferLayout.u8("rootSlotValid"),
  BufferLayout.nu64("rootSlot"),
  BufferLayout.nu64(),
  // authorizedVoters.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
  BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
  BufferLayout.nu64(),
  // epochCredits.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
  BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
]);

// node_modules/@dynamic-labs/solana-core/src/utils/createNonNativeTokenTransfer/createNonNativeTokenTransfer.js
var createNonNativeTokenTransfer = (_a21) => __awaiter(void 0, [_a21], void 0, function* ({ connection, fromAddress, toAddress, tokenAddress, amount, decimals, blockhash, lastValidBlockHeight }) {
  var _b, _c3;
  const fromPublicKey = new PublicKey2(fromAddress);
  const toPublicKey = new PublicKey2(toAddress);
  const tokenPublicKey = new PublicKey2(tokenAddress);
  const fromTokenAccount = (_c3 = (_b = yield connection.getTokenAccountsByOwner(fromPublicKey, {
    mint: tokenPublicKey
  })) === null || _b === void 0 ? void 0 : _b.value[0]) === null || _c3 === void 0 ? void 0 : _c3.pubkey;
  if (!fromTokenAccount)
    throw new Error("Source token account not found");
  let toTokenAccountPubkey;
  const instructions = [];
  try {
    toTokenAccountPubkey = yield getAssociatedTokenAddress(tokenPublicKey, toPublicKey);
    yield connection.getTokenAccountBalance(toTokenAccountPubkey);
  } catch (e2) {
    toTokenAccountPubkey = yield getAssociatedTokenAddress(tokenPublicKey, toPublicKey);
    instructions.push(createAssociatedTokenAccountInstruction(fromPublicKey, toTokenAccountPubkey, toPublicKey, tokenPublicKey));
  }
  instructions.push(createTransferInstruction(fromTokenAccount, toTokenAccountPubkey, fromPublicKey, BigInt(Number(amount) * Math.pow(10, decimals || 0))));
  const transaction = new Transaction2().add(...instructions);
  transaction.recentBlockhash = blockhash;
  transaction.lastValidBlockHeight = lastValidBlockHeight;
  transaction.feePayer = fromPublicKey;
  return transaction;
});

// node_modules/@dynamic-labs/solana-core/src/utils/createSolTransfer/createSolTransfer.js
var createSolTransfer = (_a21) => __awaiter(void 0, [_a21], void 0, function* ({ fromAddress, toAddress, amount, blockhash }) {
  const message = new TransactionMessage({
    instructions: [
      SystemProgram.transfer({
        fromPubkey: new PublicKey2(fromAddress),
        lamports: Math.round(solToLamports(amount)),
        toPubkey: new PublicKey2(toAddress)
      })
    ],
    payerKey: new PublicKey2(fromAddress),
    recentBlockhash: blockhash
  }).compileToV0Message();
  return new VersionedTransaction2(message);
});

// node_modules/@dynamic-labs/solana-core/src/wallet/SolanaWallet.js
var SolanaWallet = class extends Wallet {
  /**
   * Sends the native balance of the wallet to the given address.
   * @param amount - The amount of balance to send (in SOL).
   * @param toAddress - The address to send the balance to.
   * @returns The signature of the sent transaction.
   */
  sendBalance(_a21) {
    return __awaiter(this, arguments, void 0, function* ({ amount, toAddress, token }) {
      let transaction;
      const connection = yield this.getConnection();
      const signer = yield this.getSigner();
      const { blockhash, lastValidBlockHeight } = yield connection.getLatestBlockhash("finalized");
      if (token === null || token === void 0 ? void 0 : token.address) {
        transaction = yield createNonNativeTokenTransfer({
          amount: Number(amount),
          blockhash,
          connection,
          decimals: token.decimals,
          fromAddress: this.address,
          lastValidBlockHeight,
          toAddress,
          tokenAddress: token.address
        });
      } else {
        transaction = yield createSolTransfer({
          amount: Number(amount),
          blockhash,
          fromAddress: this.address,
          toAddress
        });
      }
      const { signature: signature4 } = yield signer.signAndSendTransaction(transaction);
      return signature4;
    });
  }
  /**
   * Retrieves the RPC connection
   * @returns A promise that resolves to the RPC connection
   */
  getConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      return this._connector.getWalletClient();
    });
  }
  /**
   * Retrieves the solana signer for the wallet.
   * @returns A promise that resolves to the signer,
   * or throws an error if the signer cannot be retrieved.
   */
  getSigner() {
    return __awaiter(this, void 0, void 0, function* () {
      const signer = yield this._connector.getSigner();
      if (!signer) {
        throw new Error("unable to retrieve Solana signer");
      }
      try {
        return cloneObjectWithOverrides(signer, {
          signAllTransactions: (transactions) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return signer.signAllTransactions(transactions);
          }),
          signAndSendTransaction: (transaction, ...args) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return signer.signAndSendTransaction(transaction, ...args);
          }),
          signMessage: (message, ...args) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return signer.signMessage(message, ...args);
          }),
          signTransaction: (transaction) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return signer.signTransaction(transaction);
          })
        });
      } catch (error) {
        logger.warn(`Failed to add logic to auto-sync the wallet. Signer might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
        return signer;
      }
    });
  }
};

// node_modules/@dynamic-labs/solana-core/src/utils/extractNonce/extractNonce.js
var extractNonce = (messageToSign) => {
  const regex = messageToSign.match(/Nonce: (.*)/);
  if (regex && regex.length === 2) {
    return regex[1];
  }
  return void 0;
};

// node_modules/@dynamic-labs/solana-core/src/utils/getOverrideRpcUrlForNetwork/getOverrideRpcUrlForNetwork.js
var getOverrideRpcUrlForNetwork = (connectionConfig, network) => {
  var _a21, _b, _c3, _d, _e6;
  const isSolanaNetwork = network.name.toLowerCase().includes("solana");
  const isEclipseNetwork = network.name.toLowerCase().includes("eclipse");
  let overrideRpcUrl;
  if (isSolanaNetwork) {
    overrideRpcUrl = (_b = (_a21 = connectionConfig === null || connectionConfig === void 0 ? void 0 : connectionConfig.customRpcUrls) === null || _a21 === void 0 ? void 0 : _a21.solana) === null || _b === void 0 ? void 0 : _b[0];
  }
  if (isEclipseNetwork) {
    overrideRpcUrl = (_d = (_c3 = connectionConfig === null || connectionConfig === void 0 ? void 0 : connectionConfig.customRpcUrls) === null || _c3 === void 0 ? void 0 : _c3.eclipse) === null || _d === void 0 ? void 0 : _d[0];
  }
  return overrideRpcUrl || ((_e6 = network.privateCustomerRpcUrls) === null || _e6 === void 0 ? void 0 : _e6[0]) || network.rpcUrls[0];
};

// node_modules/@dynamic-labs/solana-core/src/constants.js
var DYNAMIC_SVM_NETWORK_ID_LS_KEY = "dynamic_svm_network_id";

// node_modules/@dynamic-labs/solana-core/src/utils/getBackwardsCompatibleSolNetworks/getBackwardsCompatibleSolNetworks.js
var SOLANA_MAINNET_NETWORK = {
  blockExplorerUrls: ["https://explorer.solana.com"],
  chainId: "101",
  cluster: "mainnet",
  genesisHash: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  iconUrls: ["https://app.dynamic.xyz/assets/networks/solana.svg"],
  isTestnet: false,
  key: "solana",
  name: "Solana Mainnet",
  nativeCurrency: {
    decimals: 9,
    iconUrl: "https://app.dynamic.xyz/assets/networks/solana.svg",
    name: "Solana",
    pricingProviderTokenId: "solana",
    symbol: "SOL"
  },
  networkId: "101",
  rpcUrls: ["https://api.mainnet-beta.solana.com"],
  vanityName: "Solana"
};
var SOLANA_TESTNET_NETWORK = {
  blockExplorerUrls: ["https://explorer.solana.com/?cluster=testnet"],
  chainId: "102",
  cluster: "testnet",
  genesisHash: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  iconUrls: ["https://app.dynamic.xyz/assets/networks/solana.svg"],
  isTestnet: true,
  key: "solana",
  name: "Solana Testnet",
  nativeCurrency: {
    decimals: 9,
    iconUrl: "https://app.dynamic.xyz/assets/networks/solana.svg",
    name: "Solana",
    pricingProviderTokenId: "solana",
    symbol: "SOL"
  },
  networkId: "102",
  rpcUrls: ["https://api.testnet.solana.com"]
};
var SOLANA_DEVNET_NETWORK = {
  blockExplorerUrls: ["https://explorer.solana.com/?cluster=devnet"],
  chainId: "103",
  cluster: "devnet",
  genesisHash: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  iconUrls: ["https://app.dynamic.xyz/assets/networks/solana.svg"],
  isTestnet: true,
  key: "solana",
  name: "Solana Devnet",
  nativeCurrency: {
    decimals: 9,
    iconUrl: "https://app.dynamic.xyz/assets/networks/solana.svg",
    name: "Solana",
    pricingProviderTokenId: "solana",
    symbol: "SOL"
  },
  networkId: "103",
  rpcUrls: ["https://api.devnet.solana.com"]
};
var getBackwardsCompatibleSolNetworks = (originalSolNetworks, connectionConfig) => {
  if (!(originalSolNetworks === null || originalSolNetworks === void 0 ? void 0 : originalSolNetworks.length)) {
    return [];
  }
  if (originalSolNetworks.length > 1 || originalSolNetworks[0].chainId !== "101") {
    return originalSolNetworks;
  }
  const rpcUrl = getOverrideRpcUrlForNetwork(connectionConfig, originalSolNetworks[0]);
  if (rpcUrl.includes("testnet")) {
    return [
      Object.assign(Object.assign({}, SOLANA_TESTNET_NETWORK), { privateCustomerRpcUrls: [rpcUrl] })
    ];
  }
  if (rpcUrl.includes("devnet")) {
    return [
      Object.assign(Object.assign({}, SOLANA_DEVNET_NETWORK), { privateCustomerRpcUrls: [rpcUrl] })
    ];
  }
  if (rpcUrl.includes("mainnet")) {
    return [
      Object.assign(Object.assign({}, SOLANA_MAINNET_NETWORK), { privateCustomerRpcUrls: [rpcUrl] })
    ];
  }
  return originalSolNetworks;
};

// node_modules/@dynamic-labs/solana-core/src/connector/SolanaWalletConnector.js
var MEMO_PROGRAM_ID = new PublicKey2("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
var SolanaWalletConnector = class extends WalletConnectorBase {
  constructor(opts2) {
    var _a21;
    super(opts2);
    this.isHardwareWalletEnabled = false;
    this.verifiedCredentials = [];
    this.ChainWallet = SolanaWallet;
    this.supportedChains = ["SOL"];
    this.connectedChain = "SOL";
    this.solNetworks = getBackwardsCompatibleSolNetworks(opts2.solNetworks, opts2.connectionConfig);
    this.chainRpcProviders = opts2.chainRpcProviders;
    this.connectionConfig = opts2.connectionConfig;
    (_a21 = this.chainRpcProviders) === null || _a21 === void 0 ? void 0 : _a21.registerSolanaProviders(this.connectionConfig);
  }
  getNetworkId() {
    var _a21;
    const defaultChainId = (_a21 = this.solNetworks[0]) === null || _a21 === void 0 ? void 0 : _a21.networkId.toString();
    const storedChainId = localStorage.getItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY);
    return storedChainId !== null && storedChainId !== void 0 ? storedChainId : defaultChainId;
  }
  setNetworkId(networkId) {
    if (!networkId) {
      localStorage.removeItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY);
    } else {
      localStorage.setItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY, networkId);
    }
  }
  getSelectedNetwork() {
    const selectedNetwork = this.solNetworks.find((network) => network.networkId.toString() === this.getNetworkId());
    return selectedNetwork;
  }
  /**
   * @param returnDynamicNetworkId - If true, the dynamic network ID will be returned instead of the network cluster
   * @returns The network cluster (e.g. 'mainnet', 'testnet', 'devnet') or dynamic network (used for switching networks)
   */
  getNetwork() {
    return __awaiter(this, arguments, void 0, function* (returnDynamicNetworkId = false) {
      const network = this.getSelectedNetwork();
      if (!network) {
        return "";
      }
      const { networkId, genesisHash } = network;
      if (returnDynamicNetworkId) {
        return networkId.toString();
      }
      if (genesisHash === "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp") {
        return "mainnet";
      }
      if (genesisHash === "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z") {
        return "testnet";
      }
      if (genesisHash === "EtWTRABZaYq6iMfeYKouRu166VU2xqa1") {
        return "devnet";
      }
      return networkId.toString();
    });
  }
  switchNetwork(_a21) {
    return __awaiter(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId)
        return;
      const networkIdString = networkChainId.toString();
      const isNetworkIdValid = this.solNetworks.some((network) => network.networkId.toString() === networkIdString);
      if (!isNetworkIdValid) {
        return;
      }
      this.setNetworkId(networkIdString);
      this.emit("chainChange", { chain: networkIdString });
    });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      this.setNetworkId(null);
      const signer = yield this.getSigner();
      if (signer) {
        yield signer.disconnect();
      }
    });
  }
  getWalletClient() {
    var _a21;
    const network = this.getSelectedNetwork();
    if (!network) {
      throw new DynamicError("No enabled networks");
    }
    const rpcUrl = getOverrideRpcUrlForNetwork(this.connectionConfig, network);
    return new Connection(rpcUrl, (_a21 = this.connectionConfig) !== null && _a21 !== void 0 ? _a21 : "confirmed");
  }
  getPublicClient() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a21;
      const network = this.getSelectedNetwork();
      if (!network) {
        return;
      }
      const networkId = network.networkId.toString();
      const configurations = {
        cosmos: [],
        evm: void 0,
        solana: this.solNetworks,
        starknet: void 0
      };
      if (!this.chainRpcProviders)
        return void 0;
      const providers = this.chainRpcProviders.getProviders(configurations);
      return (_a21 = this.chainRpcProviders.getSolanaProviderByChainId(providers, networkId)) === null || _a21 === void 0 ? void 0 : _a21.provider;
    });
  }
  getBalance(address) {
    return __awaiter(this, void 0, void 0, function* () {
      const publicKey5 = new PublicKey2(address);
      const balance = this.lamportsToSol(yield this.getWalletClient().getBalance(publicKey5));
      return balance.toString();
    });
  }
  // Solana uses lamports as the smallest unit of currency. This converts lamports to SOL.
  lamportsToSol(lamports) {
    return lamports / 1e9;
  }
  canConnectWithHardwareWallet() {
    var _a21;
    return Boolean((_a21 = this.metadata.supportedHardwareWallets) === null || _a21 === void 0 ? void 0 : _a21.includes("ledger"));
  }
  signMessage(messageToSign) {
    const _super = Object.create(null, {
      signMessage: { get: () => super.signMessage }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (this.isHardwareWalletEnabled) {
        throw new NotSupportedError(`Message signing is currently not supported on ${this.name} hardware wallet.
          You can use signMessageViaTransaction instead to achieve similar functionality
          by signing a transaction with a memo instruction.
          You can read more about it here https://github.com/solana-labs/solana/issues/21366`);
      }
      return _super.signMessage.call(this, messageToSign);
    });
  }
  proveOwnership(address, messageToSign) {
    const _super = Object.create(null, {
      proveOwnership: { get: () => super.proveOwnership }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      if (this.isHardwareWalletEnabled) {
        const nonce = extractNonce(messageToSign);
        if (!nonce) {
          throw new DynamicError("Nonce missing");
        }
        return this.signMessageViaTransaction(nonce);
      }
      return _super.proveOwnership.call(this, address, messageToSign);
    });
  }
  signMessageViaTransaction(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      const address = yield this.getAddress();
      if (!address) {
        throw new DynamicError("Address missing");
      }
      const transaction = this.buildAuthTx(messageToSign);
      transaction.feePayer = new PublicKey2(address);
      transaction.recentBlockhash = (yield this.getWalletClient().getLatestBlockhash()).blockhash;
      const signer = yield this.getSigner();
      if (!signer) {
        throw new DynamicError("Signer not found");
      }
      const signedTransaction = yield signer.signTransaction(transaction);
      const serializedSignedTransaction = signedTransaction.serialize();
      return JSON.stringify({
        signedTransaction: {
          data: Array.from(serializedSignedTransaction),
          type: "Buffer"
        }
      });
    });
  }
  buildAuthTx(message) {
    const transaction = new Transaction2();
    transaction.add(new TransactionInstruction({
      data: Buffer.from(message, "utf8"),
      keys: [],
      programId: MEMO_PROGRAM_ID
    }));
    return transaction;
  }
  setVerifiedCredentials(verifiedCredentials) {
    this.verifiedCredentials = verifiedCredentials;
  }
  isLedgerAddress(address) {
    return isLedgerAddressViaVerifiedCredentials(address, this.verifiedCredentials);
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const network = this.getSelectedNetwork();
      if (!network) {
        return [];
      }
      return network.blockExplorerUrls;
    });
  }
  getEnabledNetworks() {
    return this.solNetworks;
  }
  supportsNetworkSwitching() {
    return true;
  }
};

// node_modules/@dynamic-labs/solana-core/src/rpc/RpcProviderSolana/RpcProviderSolana.js
ChainRpcProviders.getSolanaProviderByChainId = (rpcProviders, chainId) => {
  var _a21;
  const provider = (_a21 = rpcProviders["solana"]) === null || _a21 === void 0 ? void 0 : _a21.find((rpcProvider) => rpcProvider.chainId === chainId);
  return provider;
};
ChainRpcProviders.registerSolanaProviders = (connectionConfig) => {
  ChainRpcProviders.registerChainProviders(ProviderChain.SOLANA, (config) => {
    const rpcProviders = {};
    if (config === null || config === void 0 ? void 0 : config.solana) {
      rpcProviders.solana = config.solana.map((network) => {
        const rpcUrl = getOverrideRpcUrlForNetwork(connectionConfig, network);
        const provider = new Connection(rpcUrl, connectionConfig);
        return {
          chainId: network.chainId.toString(),
          chainName: network.name,
          provider
        };
      });
    }
    return rpcProviders.solana;
  });
};

// node_modules/@dynamic-labs/solana-core/src/utils/SolanaUiTransaction/SolanaUiTransaction.js
var LAMPORTS_PER_SOL = 1e9;
var SolanaUiTransaction = class {
  constructor({ onSubmit, from: from13, connection, multipleTransactions }) {
    this.chain = "SOL";
    this.data = void 0;
    this.fee = { gas: void 0 };
    this.formatNonNativeToken = (value, decimals) => (Number(value) / Number(Math.pow(10, decimals))).toString();
    this.from = from13;
    this.onSubmit = onSubmit;
    this.connection = connection;
    this.multipleTransactions = multipleTransactions;
  }
  fetchFee() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.fee.gas)
        return;
      let transactions = this.multipleTransactions;
      if (!transactions) {
        const tx = yield this.createTransactionSafe();
        if (!tx)
          return;
        transactions = tx instanceof Array ? tx : [tx];
      }
      const compiledMessages = yield Promise.all(transactions.map((tx) => __awaiter(this, void 0, void 0, function* () {
        if ("version" in tx) {
          return tx.message;
        }
        return tx.compileMessage();
      })));
      if (compiledMessages.some((msg) => !msg)) {
        throw new Error("Invalid transaction");
      }
      const getFeeWithRetry = (message) => __awaiter(this, void 0, void 0, function* () {
        let res = yield this.connection.getFeeForMessage(message, "confirmed");
        let retryCount = 0;
        while (res.value === null && retryCount < 5) {
          res = yield this.connection.getFeeForMessage(message, "confirmed");
          retryCount++;
        }
        return res.value ? BigInt(res.value) : BigInt(0);
      });
      const fees = yield Promise.all(compiledMessages.map((message) => getFeeWithRetry(message)));
      this.fee.gas = fees.reduce((acc, fee) => acc + fee, BigInt(0));
      if (this.fee.gas === BigInt(0)) {
        this.fee.gas = void 0;
      }
    });
  }
  // if one of the transactions is not sponsored,
  // then the simulation will have a solana transfer in it if it was successful
  isGasSponsored() {
    var _a21;
    if (!((_a21 = this.multipleTransactions) === null || _a21 === void 0 ? void 0 : _a21.length))
      return false;
    return this.multipleTransactions.every((tx) => {
      var _a22;
      if ("version" in tx) {
        return this.from !== tx.message.staticAccountKeys[0].toBase58();
      }
      if ("feePayer" in tx) {
        return this.from !== ((_a22 = tx.feePayer) === null || _a22 === void 0 ? void 0 : _a22.toBase58());
      }
      return false;
    });
  }
  parse(input) {
    const floatValue = parseFloat(input);
    const lamports = Math.round(floatValue * LAMPORTS_PER_SOL);
    return BigInt(lamports);
  }
  parseNonNativeToken(input, decimals) {
    return BigInt(Math.floor(Number(input) * Math.pow(10, decimals)));
  }
  format(value, { precision } = {}) {
    const solValue = Number(value) / LAMPORTS_PER_SOL;
    const decimalString = solValue.toLocaleString("fullwide", {
      maximumFractionDigits: 20,
      minimumFractionDigits: 0,
      useGrouping: false
    });
    return formatNumberText(decimalString, { precision });
  }
  submit() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.multipleTransactions) {
        return this.onSubmit();
      }
      const sendTransaction3 = yield this.createTransaction();
      return this.onSubmit(sendTransaction3);
    });
  }
  getBalance() {
    return __awaiter(this, void 0, void 0, function* () {
      const publicKey5 = new PublicKey2(this.from);
      const balance = yield this.connection.getBalance(publicKey5);
      return BigInt(balance);
    });
  }
  validateAddressFormat(address) {
    if (address === "dyn_send_transaction.multiple_recipients") {
      return true;
    }
    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
  }
  createTransaction() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a21;
      const { value, to: to5, nonNativeAddress: splTokenMintAddress, nonNativeValue } = this;
      if (!to5) {
        throw new Error("Destination is required");
      }
      if (this.multipleTransactions) {
        return this.multipleTransactions;
      }
      const sendTransaction3 = new Transaction2();
      const fromPubkey = new PublicKey2(this.from);
      const toPubkey = new PublicKey2(to5);
      if (splTokenMintAddress && nonNativeValue) {
        const tokenMintPubkey = new PublicKey2(splTokenMintAddress);
        const amount = nonNativeValue;
        const fromTokenAccount = (_a21 = (yield this.connection.getTokenAccountsByOwner(fromPubkey, {
          mint: tokenMintPubkey
        })).value[0]) === null || _a21 === void 0 ? void 0 : _a21.pubkey;
        if (!fromTokenAccount)
          throw new Error("Source token account not found");
        let toTokenAccountPubkey;
        try {
          toTokenAccountPubkey = yield getAssociatedTokenAddress(tokenMintPubkey, toPubkey);
          yield this.connection.getTokenAccountBalance(toTokenAccountPubkey);
        } catch (_b) {
          toTokenAccountPubkey = yield getAssociatedTokenAddress(tokenMintPubkey, toPubkey);
          sendTransaction3.add(createAssociatedTokenAccountInstruction(fromPubkey, toTokenAccountPubkey, toPubkey, tokenMintPubkey));
        }
        sendTransaction3.add(createTransferInstruction(fromTokenAccount, toTokenAccountPubkey, fromPubkey, amount));
      } else {
        const lamports = value !== null && value !== void 0 ? value : BigInt(0);
        sendTransaction3.add(SystemProgram.transfer({
          fromPubkey,
          lamports,
          toPubkey
        }));
      }
      const { blockhash } = yield this.connection.getLatestBlockhash();
      sendTransaction3.feePayer = new PublicKey2(this.from);
      sendTransaction3.recentBlockhash = blockhash;
      return sendTransaction3;
    });
  }
  createTransactionSafe() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.createTransaction();
      } catch (error) {
        return void 0;
      }
    });
  }
};

// node_modules/@dynamic-labs/solana-core/src/utils/isVersionedTransaction/isVersionedTransaction.js
var isVersionedTransaction = (transaction) => "version" in transaction;

// node_modules/@dynamic-labs/solana-core/src/utils/isTransactionSigned/isTransactionSigned.js
var isTxAlreadySigned = (transaction) => {
  let alreadySigned = false;
  if ("version" in transaction) {
    alreadySigned = transaction.signatures.some((sig) => !sig.every((byte) => byte === 0));
  } else {
    alreadySigned = transaction.signatures.some((sig) => sig.signature);
  }
  return alreadySigned;
};

// node_modules/@dynamic-labs/solana-core/src/wallet/isSolanaWallet/isSolanaWallet.js
var isSolanaWallet = (wallet) => ["SOL"].includes(wallet.chain);

// node_modules/@dynamic-labs/solana-core/src/index.js
assertPackageVersion("@dynamic-labs/solana-core", version2);

// node_modules/@dynamic-labs/solana/_virtual/_tslib.js
function __awaiter2(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_buffer2 = __toESM(require_buffer());

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/abstract/modular.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
function mod(a3, b4) {
  const result = a3 % b4;
  return result >= _0n ? result : b4 + result;
}
function pow2(x5, power, modulo) {
  let res = x5;
  while (power-- > _0n) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a3 = mod(number3, modulo);
  let b4 = modulo;
  let x5 = _0n, y5 = _1n, u2 = _1n, v6 = _0n;
  while (a3 !== _0n) {
    const q = b4 / a3;
    const r3 = b4 % a3;
    const m3 = x5 - u2 * q;
    const n5 = y5 - v6 * q;
    b4 = a3, a3 = r3, x5 = u2, y5 = v6, u2 = m3, v6 = n5;
  }
  const gcd2 = b4;
  if (gcd2 !== _1n)
    throw new Error("invert: does not exist");
  return mod(x5, modulo);
}
function sqrt3mod4(Fp3, n5) {
  const p1div4 = (Fp3.ORDER + _1n) / _4n;
  const root = Fp3.pow(n5, p1div4);
  if (!Fp3.eql(Fp3.sqr(root), n5))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod8(Fp3, n5) {
  const p5div8 = (Fp3.ORDER - _5n) / _8n;
  const n22 = Fp3.mul(n5, _2n);
  const v6 = Fp3.pow(n22, p5div8);
  const nv = Fp3.mul(n5, v6);
  const i4 = Fp3.mul(Fp3.mul(nv, _2n), v6);
  const root = Fp3.mul(nv, Fp3.sub(i4, Fp3.ONE));
  if (!Fp3.eql(Fp3.sqr(root), n5))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks(P4) {
  if (P4 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q6 = P4 - _1n;
  let S4 = 0;
  while (Q6 % _2n === _0n) {
    Q6 /= _2n;
    S4++;
  }
  let Z2 = _2n;
  const _Fp = Field(P4);
  while (FpLegendre(_Fp, Z2) === 1) {
    if (Z2++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S4 === 1)
    return sqrt3mod4;
  let cc3 = _Fp.pow(Z2, Q6);
  const Q1div2 = (Q6 + _1n) / _2n;
  return function tonelliSlow(Fp3, n5) {
    if (Fp3.is0(n5))
      return n5;
    if (FpLegendre(Fp3, n5) !== 1)
      throw new Error("Cannot find square root");
    let M4 = S4;
    let c6 = Fp3.mul(Fp3.ONE, cc3);
    let t = Fp3.pow(n5, Q6);
    let R3 = Fp3.pow(n5, Q1div2);
    while (!Fp3.eql(t, Fp3.ONE)) {
      if (Fp3.is0(t))
        return Fp3.ZERO;
      let i4 = 1;
      let t_tmp = Fp3.sqr(t);
      while (!Fp3.eql(t_tmp, Fp3.ONE)) {
        i4++;
        t_tmp = Fp3.sqr(t_tmp);
        if (i4 === M4)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n << BigInt(M4 - i4 - 1);
      const b4 = Fp3.pow(c6, exponent);
      M4 = i4;
      c6 = Fp3.sqr(b4);
      t = Fp3.mul(t, c6);
      R3 = Fp3.mul(R3, b4);
    }
    return R3;
  };
}
function FpSqrt(P4) {
  if (P4 % _4n === _3n)
    return sqrt3mod4;
  if (P4 % _8n === _5n)
    return sqrt5mod8;
  return tonelliShanks(P4);
}
var isNegativeLE = (num3, modulo) => (mod(num3, modulo) & _1n) === _1n;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts2 = FIELD_FIELDS.reduce((map36, val) => {
    map36[val] = "function";
    return map36;
  }, initial);
  _validateObject(field, opts2);
  return field;
}
function FpPow(Fp3, num3, power) {
  if (power < _0n)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n)
    return Fp3.ONE;
  if (power === _1n)
    return num3;
  let p4 = Fp3.ONE;
  let d4 = num3;
  while (power > _0n) {
    if (power & _1n)
      p4 = Fp3.mul(p4, d4);
    d4 = Fp3.sqr(d4);
    power >>= _1n;
  }
  return p4;
}
function FpInvertBatch(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num3, i4) => {
    if (Fp3.is0(num3))
      return acc;
    inverted[i4] = acc;
    return Fp3.mul(acc, num3);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num3, i4) => {
    if (Fp3.is0(num3))
      return acc;
    inverted[i4] = Fp3.mul(acc, inverted[i4]);
    return Fp3.mul(acc, num3);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp3, n5) {
  const p1mod2 = (Fp3.ORDER - _1n) / _2n;
  const powered = Fp3.pow(n5, p1mod2);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero7 = Fp3.eql(powered, Fp3.ZERO);
  const no5 = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero7 && !no5)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero7 ? 0 : -1;
}
function nLength(n5, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE6 = false, opts2 = {}) {
  if (ORDER <= _0n)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts2.sqrt || isLE6)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE6 = _opts.isLE;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts2.sqrt)
      _sqrt = opts2.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f8 = Object.freeze({
    ORDER,
    isLE: isLE6,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n,
    ONE: _1n,
    create: (num3) => mod(num3, ORDER),
    isValid: (num3) => {
      if (typeof num3 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num3);
      return _0n <= num3 && num3 < ORDER;
    },
    is0: (num3) => num3 === _0n,
    // is valid and invertible
    isValidNot0: (num3) => !f8.is0(num3) && f8.isValid(num3),
    isOdd: (num3) => (num3 & _1n) === _1n,
    neg: (num3) => mod(-num3, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num3) => mod(num3 * num3, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num3, power) => FpPow(f8, num3, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num3) => num3 * num3,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num3) => invert(num3, ORDER),
    sqrt: _sqrt || ((n5) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f8, n5);
    }),
    toBytes: (num3) => isLE6 ? numberToBytesLE(num3, BYTES) : numberToBytesBE(num3, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE6 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f8, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a3, b4, c6) => c6 ? b4 : a3
  });
  return Object.freeze(f8);
}
function FpSqrtEven(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp3.sqrt(elm);
  return Fp3.isOdd(root) ? Fp3.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length2 = getFieldBytesLength(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField(key, fieldOrder, isLE6 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num3 = isLE6 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num3, fieldOrder - _1n) + _1n;
  return isLE6 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/abstract/curve.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c6, property, points) {
  const getz = property === "pz" ? (p4) => p4.pz : (p4) => p4.ez;
  const toInv = FpInvertBatch(c6.Fp, points.map(getz));
  const affined = points.map((p4, i4) => p4.toAffine(toInv[i4]));
  return affined.map(c6.fromAffine);
}
function validateW(W5, bits) {
  if (!Number.isSafeInteger(W5) || W5 <= 0 || W5 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W5);
}
function calcWOpts(W5, scalarBits) {
  validateW(W5, scalarBits);
  const windows = Math.ceil(scalarBits / W5) + 1;
  const windowSize = 2 ** (W5 - 1);
  const maxNumber = 2 ** W5;
  const mask = bitMask(W5);
  const shiftBy = BigInt(W5);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n5, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n5 & mask);
  let nextN = n5 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n2;
  }
  const offsetStart = window2 * windowSize;
  const offset5 = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset: offset5, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c6) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p4, i4) => {
    if (!(p4 instanceof c6))
      throw new Error("invalid point at index " + i4);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s3, i4) => {
    if (!field.isValid(s3))
      throw new Error("invalid scalar at index " + i4);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P4) {
  return pointWindowSizes.get(P4) || 1;
}
function assert0(n5) {
  if (n5 !== _0n2)
    throw new Error("invalid wNAF");
}
function wNAF(c6, bits) {
  return {
    constTimeNegate: negateCt,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n5, p4 = c6.ZERO) {
      let d4 = elm;
      while (n5 > _0n2) {
        if (n5 & _1n2)
          p4 = p4.add(d4);
        d4 = d4.double();
        n5 >>= _1n2;
      }
      return p4;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W5) {
      const { windows, windowSize } = calcWOpts(W5, bits);
      const points = [];
      let p4 = elm;
      let base3 = p4;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p4;
        points.push(base3);
        for (let i4 = 1; i4 < windowSize; i4++) {
          base3 = base3.add(p4);
          points.push(base3);
        }
        p4 = base3.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W5, precomputes, n5) {
      let p4 = c6.ZERO;
      let f8 = c6.BASE;
      const wo5 = calcWOpts(W5, bits);
      for (let window2 = 0; window2 < wo5.windows; window2++) {
        const { nextN, offset: offset5, isZero, isNeg, isNegF, offsetF } = calcOffsets(n5, window2, wo5);
        n5 = nextN;
        if (isZero) {
          f8 = f8.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p4 = p4.add(negateCt(isNeg, precomputes[offset5]));
        }
      }
      assert0(n5);
      return { p: p4, f: f8 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W5, precomputes, n5, acc = c6.ZERO) {
      const wo5 = calcWOpts(W5, bits);
      for (let window2 = 0; window2 < wo5.windows; window2++) {
        if (n5 === _0n2)
          break;
        const { nextN, offset: offset5, isZero, isNeg } = calcOffsets(n5, window2, wo5);
        n5 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset5];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n5);
      return acc;
    },
    getPrecomputes(W5, P4, transform) {
      let comp = pointPrecomputes.get(P4);
      if (!comp) {
        comp = this.precomputeWindow(P4, W5);
        if (W5 !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(P4, comp);
        }
      }
      return comp;
    },
    wNAFCached(P4, n5, transform) {
      const W5 = getW(P4);
      return this.wNAF(W5, this.getPrecomputes(W5, P4, transform), n5);
    },
    wNAFCachedUnsafe(P4, n5, transform, prev) {
      const W5 = getW(P4);
      if (W5 === 1)
        return this.unsafeLadder(P4, n5, prev);
      return this.wNAFUnsafe(W5, this.getPrecomputes(W5, P4, transform), n5, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P4, W5) {
      validateW(W5, bits);
      pointWindowSizes.set(P4, W5);
      pointPrecomputes.delete(P4);
    }
  };
}
function mulEndoUnsafe(c6, point, k1, k22) {
  let acc = point;
  let p1 = c6.ZERO;
  let p22 = c6.ZERO;
  while (k1 > _0n2 || k22 > _0n2) {
    if (k1 & _1n2)
      p1 = p1.add(acc);
    if (k22 & _1n2)
      p22 = p22.add(acc);
    acc = acc.double();
    k1 >>= _1n2;
    k22 >>= _1n2;
  }
  return { p1, p2: p22 };
}
function pippenger(c6, fieldN, points, scalars) {
  validateMSMPoints(points, c6);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero7 = c6.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero7);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero7;
  for (let i4 = lastBits; i4 >= 0; i4 -= windowSize) {
    buckets.fill(zero7);
    for (let j3 = 0; j3 < slength; j3++) {
      const scalar = scalars[j3];
      const wbits2 = Number(scalar >> BigInt(i4) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j3]);
    }
    let resI = zero7;
    for (let j3 = buckets.length - 1, sumI = zero7; j3 > 0; j3--) {
      sumI = sumI.add(buckets[j3]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i4 !== 0)
      for (let j3 = 0; j3 < windowSize; j3++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order);
  }
}
function _createCurveFields(type3, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type3} CURVE object`);
  for (const p4 of ["p", "n", "h"]) {
    const val = CURVE[p4];
    if (!(typeof val === "bigint" && val > _0n2))
      throw new Error(`CURVE.${p4} must be positive bigint`);
  }
  const Fp3 = createField(CURVE.p, curveOpts.Fp);
  const Fn5 = createField(CURVE.n, curveOpts.Fn);
  const _b = type3 === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p4 of params) {
    if (!Fp3.isValid(CURVE[p4]))
      throw new Error(`CURVE.${p4} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp3, Fn: Fn5 };
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n2 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function isEdValidXY(Fp3, CURVE, x5, y5) {
  const x22 = Fp3.sqr(x5);
  const y22 = Fp3.sqr(y5);
  const left13 = Fp3.add(Fp3.mul(CURVE.a, x22), y22);
  const right13 = Fp3.add(Fp3.ONE, Fp3.mul(CURVE.d, Fp3.mul(x22, y22)));
  return Fp3.eql(left13, right13);
}
function edwards(CURVE, curveOpts = {}) {
  const { Fp: Fp3, Fn: Fn5 } = _createCurveFields("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn5.BYTES * 8) - _1n3;
  const modP3 = (n5) => Fp3.create(n5);
  const uvRatio3 = curveOpts.uvRatio || ((u2, v6) => {
    try {
      return { isValid: true, value: Fp3.sqrt(Fp3.div(u2, v6)) };
    } catch (e2) {
      return { isValid: false, value: _0n3 };
    }
  });
  if (!isEdValidXY(Fp3, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n5, banZero = false) {
    const min4 = banZero ? _1n3 : _0n3;
    aInRange("coordinate " + title, n5, min4, MASK);
    return n5;
  }
  function aextpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p4, iz) => {
    const { ex: x5, ey: y5, ez: z4 } = p4;
    const is0 = p4.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp3.inv(z4);
    const ax = modP3(x5 * iz);
    const ay = modP3(y5 * iz);
    const zz = modP3(z4 * iz);
    if (is0)
      return { x: _0n3, y: _1n3 };
    if (zz !== _1n3)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p4) => {
    const { a: a3, d: d4 } = CURVE;
    if (p4.is0())
      throw new Error("bad point: ZERO");
    const { ex: X4, ey: Y4, ez: Z2, et: T3 } = p4;
    const X22 = modP3(X4 * X4);
    const Y22 = modP3(Y4 * Y4);
    const Z22 = modP3(Z2 * Z2);
    const Z4 = modP3(Z22 * Z22);
    const aX2 = modP3(X22 * a3);
    const left13 = modP3(Z22 * modP3(aX2 + Y22));
    const right13 = modP3(Z4 + modP3(d4 * modP3(X22 * Y22)));
    if (left13 !== right13)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP3(X4 * Y4);
    const ZT = modP3(Z2 * T3);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point3 {
    constructor(ex, ey, ez, et) {
      this.ex = acoord("x", ex);
      this.ey = acoord("y", ey);
      this.ez = acoord("z", ez, true);
      this.et = acoord("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p4) {
      if (p4 instanceof Point3)
        throw new Error("extended point not allowed");
      const { x: x5, y: y5 } = p4 || {};
      acoord("x", x5);
      acoord("y", y5);
      return new Point3(x5, y5, _1n3, modP3(x5 * y5));
    }
    static normalizeZ(points) {
      return normalizeZ(Point3, "ez", points);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point3, Fn5, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X22, ey: Y22, ez: Z2 } = other;
      const X1Z2 = modP3(X1 * Z2);
      const X2Z1 = modP3(X22 * Z1);
      const Y1Z2 = modP3(Y1 * Z2);
      const Y2Z1 = modP3(Y22 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    negate() {
      return new Point3(modP3(-this.ex), this.ey, this.ez, modP3(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a3 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A4 = modP3(X1 * X1);
      const B3 = modP3(Y1 * Y1);
      const C4 = modP3(_2n2 * modP3(Z1 * Z1));
      const D4 = modP3(a3 * A4);
      const x1y1 = X1 + Y1;
      const E4 = modP3(modP3(x1y1 * x1y1) - A4 - B3);
      const G5 = D4 + B3;
      const F5 = G5 - C4;
      const H2 = D4 - B3;
      const X32 = modP3(E4 * F5);
      const Y32 = modP3(G5 * H2);
      const T3 = modP3(E4 * H2);
      const Z3 = modP3(F5 * G5);
      return new Point3(X32, Y32, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a: a3, d: d4 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X22, ey: Y22, ez: Z2, et: T22 } = other;
      const A4 = modP3(X1 * X22);
      const B3 = modP3(Y1 * Y22);
      const C4 = modP3(T1 * d4 * T22);
      const D4 = modP3(Z1 * Z2);
      const E4 = modP3((X1 + Y1) * (X22 + Y22) - A4 - B3);
      const F5 = D4 - C4;
      const G5 = D4 + C4;
      const H2 = modP3(B3 - a3 * A4);
      const X32 = modP3(E4 * F5);
      const Y32 = modP3(G5 * H2);
      const T3 = modP3(E4 * H2);
      const Z3 = modP3(F5 * G5);
      return new Point3(X32, Y32, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n5 = scalar;
      aInRange("scalar", n5, _1n3, CURVE_ORDER);
      const { p: p4, f: f8 } = wnaf.wNAFCached(this, n5, Point3.normalizeZ);
      return Point3.normalizeZ([p4, f8])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point3.ZERO) {
      const n5 = scalar;
      aInRange("scalar", n5, _0n3, CURVE_ORDER);
      if (n5 === _0n3)
        return Point3.ZERO;
      if (this.is0() || n5 === _1n3)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n5, Point3.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n3)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes2, zip215 = false) {
      abytes(bytes2);
      return this.fromHex(bytes2, zip215);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d: d4, a: a3 } = CURVE;
      const len = Fp3.BYTES;
      hex2 = ensureBytes("pointHex", hex2, len);
      abool("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y5 = bytesToNumberLE(normed);
      const max4 = zip215 ? MASK : Fp3.ORDER;
      aInRange("pointHex.y", y5, _0n3, max4);
      const y22 = modP3(y5 * y5);
      const u2 = modP3(y22 - _1n3);
      const v6 = modP3(d4 * y22 - a3);
      let { isValid, value: x5 } = uvRatio3(u2, v6);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x5 & _1n3) === _1n3;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x5 === _0n3 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x5 = modP3(-x5);
      return Point3.fromAffine({ x: x5, y: y5 });
    }
    static fromPrivateScalar(scalar) {
      return Point3.BASE.multiply(scalar);
    }
    toBytes() {
      const { x: x5, y: y5 } = this.toAffine();
      const bytes2 = numberToBytesLE(y5, Fp3.BYTES);
      bytes2[bytes2.length - 1] |= x5 & _1n3 ? 128 : 0;
      return bytes2;
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, _1n3, modP3(CURVE.Gx * CURVE.Gy));
  Point3.ZERO = new Point3(_0n3, _1n3, _1n3, _0n3);
  Point3.Fp = Fp3;
  Point3.Fn = Fn5;
  const wnaf = wNAF(Point3, Fn5.BYTES * 8);
  return Point3;
}
function eddsa(Point3, eddsaOpts) {
  _validateObject(eddsaOpts, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash, hash: cHash } = eddsaOpts;
  const { BASE: G5, Fp: Fp3, Fn: Fn5 } = Point3;
  const CURVE_ORDER = Fn5.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes3 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN3(a3) {
    return Fn5.create(a3);
  }
  function modN_LE(hash) {
    return modN3(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = Fp3.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head5 = adjustScalarBytes3(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head5);
    return { head: head5, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head: head5, prefix, scalar } = getPrivateScalar(key);
    const point = G5.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head: head5, prefix, scalar, point, pointBytes };
  }
  function getPublicKey5(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign5(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r3 = hashDomainToScalar(options.context, prefix, msg);
    const R3 = G5.multiply(r3).toBytes();
    const k6 = hashDomainToScalar(options.context, R3, pointBytes, msg);
    const s3 = modN3(r3 + k6 * scalar);
    aInRange("signature.s", s3, _0n3, CURVE_ORDER);
    const L3 = Fp3.BYTES;
    const res = concatBytes(R3, numberToBytesLE(s3, L3));
    return ensureBytes("result", res, L3 * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify5(sig, msg, publicKey5, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey5 = ensureBytes("publicKey", publicKey5, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s3 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A4, R3, SB;
    try {
      A4 = Point3.fromHex(publicKey5, zip215);
      R3 = Point3.fromHex(sig.slice(0, len), zip215);
      SB = G5.multiplyUnsafe(s3);
    } catch (error) {
      return false;
    }
    if (!zip215 && A4.isSmallOrder())
      return false;
    const k6 = hashDomainToScalar(context, R3.toBytes(), A4.toBytes(), msg);
    const RkA = R3.add(A4.multiplyUnsafe(k6));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G5.precompute(8);
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes_(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return { getPublicKey: getPublicKey5, sign: sign5, verify: verify5, utils, Point: Point3 };
}
function _eddsa_legacy_opts_to_new(c6) {
  const CURVE = {
    a: c6.a,
    d: c6.d,
    p: c6.Fp.ORDER,
    n: c6.n,
    h: c6.h,
    Gx: c6.Gx,
    Gy: c6.Gy
  };
  const Fp3 = c6.Fp;
  const Fn5 = Field(CURVE.n, c6.nBitLength, true);
  const curveOpts = { Fp: Fp3, Fn: Fn5, uvRatio: c6.uvRatio };
  const eddsaOpts = {
    hash: c6.hash,
    randomBytes: c6.randomBytes,
    adjustScalarBytes: c6.adjustScalarBytes,
    domain: c6.domain,
    prehash: c6.prehash,
    mapToCurve: c6.mapToCurve
  };
  return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c6, eddsa2) {
  const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c6 });
  return legacy;
}
function twistedEdwards(c6) {
  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c6);
  const Point3 = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point3, eddsaOpts);
  return _eddsa_new_output_to_legacy(c6, EDDSA);
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length2) {
  anum(value);
  anum(length2);
  if (value < 0 || value >= 1 << 8 * length2)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length: length2 }).fill(0);
  for (let i4 = length2 - 1; i4 >= 0; i4--) {
    res[i4] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a3, b4) {
  const arr = new Uint8Array(a3.length);
  for (let i4 = 0; i4 < a3.length; i4++) {
    arr[i4] = a3[i4] ^ b4[i4];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H2) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H2(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H2;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b4 = new Array(ell);
  const b_0 = H2(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b4[0] = H2(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i4 = 1; i4 <= ell; i4++) {
    const args = [strxor(b_0, b4[i4 - 1]), i2osp(i4 + 1, 1), DST_prime];
    b4[i4] = H2(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b4);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k6, H2) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k6 / 8);
    DST = H2.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H2.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p: p4, k: k6, m: m3, hash, expand: expand2, DST: _DST } = options;
  if (!isBytes(_DST) && typeof _DST !== "string")
    throw new Error("DST must be string or uint8array");
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes(_DST) : _DST;
  const log2p = p4.toString(2).length;
  const L3 = Math.ceil((log2p + k6) / 8);
  const len_in_bytes = count * m3 * L3;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand2 === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k6, hash);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u2 = new Array(count);
  for (let i4 = 0; i4 < count; i4++) {
    const e2 = new Array(m3);
    for (let j3 = 0; j3 < m3; j3++) {
      const elm_offset = L3 * (j3 + i4 * m3);
      const tv = prb.subarray(elm_offset, elm_offset + L3);
      e2[j3] = mod(os2ip(tv), p4);
    }
    u2[i4] = e2;
  }
  return u2;
}
function isogenyMap(field, map36) {
  const coeff = map36.map((i4) => Array.from(i4).reverse());
  return (x5, y5) => {
    const [xn5, xd, yn5, yd] = coeff.map((val) => val.reduce((acc, i4) => field.add(field.mul(acc, x5), i4)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x5 = field.mul(xn5, xd_inv);
    y5 = field.mul(y5, field.mul(yn5, yd_inv));
    return { x: x5, y: y5 };
  };
}
function createHasher2(Point3, mapToCurve, defaults3) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map36(num3) {
    return Point3.fromAffine(mapToCurve(num3));
  }
  function clear2(initial) {
    const P4 = initial.clearCofactor();
    if (P4.equals(Point3.ZERO))
      return Point3.ZERO;
    P4.assertValidity();
    return P4;
  }
  return {
    defaults: defaults3,
    hashToCurve(msg, options) {
      const dst = defaults3.DST ? defaults3.DST : {};
      const opts2 = Object.assign({}, defaults3, dst, options);
      const u2 = hash_to_field(msg, 2, opts2);
      const u0 = map36(u2[0]);
      const u1 = map36(u2[1]);
      return clear2(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const dst = defaults3.encodeDST ? defaults3.encodeDST : {};
      const opts2 = Object.assign({}, defaults3, dst, options);
      const u2 = hash_to_field(msg, 1, opts2);
      return clear2(map36(u2[0]));
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i4 of scalars)
        if (typeof i4 !== "bigint")
          throw new Error("expected array of bigints");
      return clear2(map36(scalars));
    }
  };
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P: P4, type: type3, adjustScalarBytes: adjustScalarBytes3, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type3 === "x25519";
  if (!is25519 && type3 !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n4 : BigInt(4) * _2n3 ** BigInt(445) - _1n4;
  const maxScalar = minScalar + maxAdded + _1n4;
  const modP3 = (n5) => mod(n5, P4);
  const GuBytes = encodeU(Gu);
  function encodeU(u2) {
    return numberToBytesLE(modP3(u2), fieldLen);
  }
  function decodeU(u2) {
    const _u = ensureBytes("u coordinate", u2, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP3(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes3(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u2) {
    const pu = montgomeryLadder(decodeU(u2), decodeScalar(scalar));
    if (pu === _0n4)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap10, x_2, x_3) {
    const dummy = modP3(swap10 * (x_2 - x_3));
    x_2 = modP3(x_2 - dummy);
    x_3 = modP3(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u2, scalar) {
    aInRange("u", u2, _0n4, P4);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k6 = scalar;
    const x_1 = u2;
    let x_2 = _1n4;
    let z_2 = _0n4;
    let x_3 = u2;
    let z_3 = _1n4;
    let swap10 = _0n4;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n4; t--) {
      const k_t = k6 >> t & _1n4;
      swap10 ^= k_t;
      ({ x_2, x_3 } = cswap(swap10, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap10, z_2, z_3));
      swap10 = k_t;
      const A4 = x_2 + z_2;
      const AA = modP3(A4 * A4);
      const B3 = x_2 - z_2;
      const BB = modP3(B3 * B3);
      const E4 = AA - BB;
      const C4 = x_3 + z_3;
      const D4 = x_3 - z_3;
      const DA = modP3(D4 * A4);
      const CB = modP3(C4 * B3);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP3(dacb * dacb);
      z_3 = modP3(x_1 * modP3(da_cb * da_cb));
      x_2 = modP3(AA * BB);
      z_2 = modP3(E4 * (AA + modP3(a24 * E4)));
    }
    ({ x_2, x_3 } = cswap(swap10, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap10, z_2, z_3));
    const z22 = powPminus2(z_2);
    return modP3(x_2 * z22);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey5) => scalarMult(privateKey, publicKey5),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
    GuBytes: GuBytes.slice()
  };
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/ed25519.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
var ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n3,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x5) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P4 = ed25519_CURVE.p;
  const x22 = x5 * x5 % P4;
  const b22 = x22 * x5 % P4;
  const b4 = pow2(b22, _2n4, P4) * b22 % P4;
  const b5 = pow2(b4, _1n5, P4) * x5 % P4;
  const b10 = pow2(b5, _5n2, P4) * b5 % P4;
  const b20 = pow2(b10, _10n, P4) * b10 % P4;
  const b40 = pow2(b20, _20n, P4) * b20 % P4;
  const b80 = pow2(b40, _40n, P4) * b40 % P4;
  const b160 = pow2(b80, _80n, P4) * b80 % P4;
  const b240 = pow2(b160, _80n, P4) * b80 % P4;
  const b250 = pow2(b240, _10n, P4) * b10 % P4;
  const pow_p_5_8 = pow2(b250, _2n4, P4) * x5 % P4;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u2, v6) {
  const P4 = ed25519_CURVE.p;
  const v34 = mod(v6 * v6 * v6, P4);
  const v7 = mod(v34 * v34 * v6, P4);
  const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
  let x5 = mod(u2 * v34 * pow3, P4);
  const vx2 = mod(v6 * x5 * x5, P4);
  const root1 = x5;
  const root2 = mod(x5 * ED25519_SQRT_M1, P4);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod(-u2, P4);
  const noRoot = vx2 === mod(-u2 * ED25519_SQRT_M1, P4);
  if (useRoot1)
    x5 = root1;
  if (useRoot2 || noRoot)
    x5 = root2;
  if (isNegativeLE(x5, P4))
    x5 = mod(-x5, P4);
  return { isValid: useRoot1 || useRoot2, value: x5 };
}
var Fp = (() => Field(ed25519_CURVE.p, void 0, true))();
var ed25519Defaults = (() => ({
  ...ed25519_CURVE,
  Fp,
  hash: sha512,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))();
var ed255192 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => {
  const P4 = ed25519_CURVE.p;
  return montgomery({
    P: P4,
    type: "x25519",
    powPminus2: (x5) => {
      const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_3(x5);
      return mod(pow2(pow_p_5_8, _3n2, P4) * b22, P4);
    },
    adjustScalarBytes
  });
})();
var ELL2_C1 = (() => (Fp.ORDER + _3n2) / _8n3)();
var ELL2_C2 = (() => Fp.pow(_2n4, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function map_to_curve_elligator2_curve25519(u2) {
  const ELL2_C4 = (Fp.ORDER - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u2);
  tv1 = Fp.mul(tv1, _2n4);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u2);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y23 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn5 = Fp.cmov(x2n, x1n, e3);
  let y5 = Fp.cmov(y23, y1, e3);
  let e4 = Fp.isOdd(y5);
  y5 = Fp.cmov(y5, Fp.neg(y5), e3 !== e4);
  return { xMn: xn5, xMd: xd, yMn: y5, yMd: _1n5 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u2) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u2);
  let xn5 = Fp.mul(xMn, yMd);
  xn5 = Fp.mul(xn5, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn5 = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e2 = Fp.eql(tv1, Fp.ZERO);
  xn5 = Fp.cmov(xn5, Fp.ZERO, e2);
  xd = Fp.cmov(xd, Fp.ONE, e2);
  yn5 = Fp.cmov(yn5, Fp.ONE, e2);
  yd = Fp.cmov(yd, Fp.ONE, e2);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn5, xd_inv), y: Fp.mul(yn5, yd_inv) };
}
var ed25519_hasher = (() => createHasher2(ed255192.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => ed25519_hasher.hashToCurve)();
var encodeToCurve = (() => ed25519_hasher.encodeToCurve)();
function aristp(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number3) => uvRatio(_1n5, number3);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes2) => ed255192.CURVE.Fp.create(bytesToNumberLE(bytes2) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d: d4 } = ed255192.CURVE;
  const P4 = ed255192.CURVE.Fp.ORDER;
  const mod4 = ed255192.CURVE.Fp.create;
  const r3 = mod4(SQRT_M1 * r0 * r0);
  const Ns3 = mod4((r3 + _1n5) * ONE_MINUS_D_SQ);
  let c6 = BigInt(-1);
  const D4 = mod4((c6 - d4 * r3) * mod4(r3 + d4));
  let { isValid: Ns_D_is_sq, value: s3 } = uvRatio(Ns3, D4);
  let s_ = mod4(s3 * r0);
  if (!isNegativeLE(s_, P4))
    s_ = mod4(-s_);
  if (!Ns_D_is_sq)
    s3 = s_;
  if (!Ns_D_is_sq)
    c6 = r3;
  const Nt5 = mod4(c6 * (r3 - _1n5) * D_MINUS_ONE_SQ - D4);
  const s22 = s3 * s3;
  const W0 = mod4((s3 + s3) * D4);
  const W1 = mod4(Nt5 * SQRT_AD_MINUS_ONE);
  const W22 = mod4(_1n5 - s22);
  const W32 = mod4(_1n5 + s22);
  return new ed255192.Point(mod4(W0 * W32), mod4(W22 * W1), mod4(W1 * W32), mod4(W0 * W22));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap26) {
    return new _RistPoint(ed255192.Point.fromAffine(ap26));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
   * the [website](https://ristretto.group/formulas/elligator.html).
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex2) {
    hex2 = ensureBytes("ristrettoHash", hex2, 64);
    const r1 = bytes255ToNumberLE(hex2.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r22 = bytes255ToNumberLE(hex2.slice(32, 64));
    const R22 = calcElligatorRistrettoMap(r22);
    return new _RistPoint(R1.add(R22));
  }
  static fromBytes(bytes2) {
    abytes(bytes2);
    return this.fromHex(bytes2);
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex2) {
    hex2 = ensureBytes("ristrettoHex", hex2, 32);
    const { a: a3, d: d4 } = ed255192.CURVE;
    const P4 = Fp.ORDER;
    const mod4 = Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s3 = bytes255ToNumberLE(hex2);
    if (!equalBytes(numberToBytesLE(s3, 32), hex2) || isNegativeLE(s3, P4))
      throw new Error(emsg);
    const s22 = mod4(s3 * s3);
    const u1 = mod4(_1n5 + a3 * s22);
    const u2 = mod4(_1n5 - a3 * s22);
    const u1_2 = mod4(u1 * u1);
    const u2_2 = mod4(u2 * u2);
    const v6 = mod4(a3 * d4 * u1_2 - u2_2);
    const { isValid, value: I4 } = invertSqrt(mod4(v6 * u2_2));
    const Dx = mod4(I4 * u2);
    const Dy = mod4(I4 * Dx * v6);
    let x5 = mod4((s3 + s3) * Dx);
    if (isNegativeLE(x5, P4))
      x5 = mod4(-x5);
    const y5 = mod4(u1 * Dy);
    const t = mod4(x5 * y5);
    if (!isValid || isNegativeLE(t, P4) || y5 === _0n5)
      throw new Error(emsg);
    return new _RistPoint(new ed255192.Point(x5, y5, _1n5, t));
  }
  static msm(points, scalars) {
    const Fn5 = Field(ed255192.CURVE.n, ed255192.CURVE.nBitLength);
    return pippenger(_RistPoint, Fn5, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { ex: x5, ey: y5, ez: z4, et: t } = this.ep;
    const P4 = Fp.ORDER;
    const mod4 = Fp.create;
    const u1 = mod4(mod4(z4 + y5) * mod4(z4 - y5));
    const u2 = mod4(x5 * y5);
    const u2sq = mod4(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod4(u1 * u2sq));
    const D1 = mod4(invsqrt * u1);
    const D22 = mod4(invsqrt * u2);
    const zInv = mod4(D1 * D22 * t);
    let D4;
    if (isNegativeLE(t * zInv, P4)) {
      let _x = mod4(y5 * SQRT_M1);
      let _y = mod4(x5 * SQRT_M1);
      x5 = _x;
      y5 = _y;
      D4 = mod4(D1 * INVSQRT_A_MINUS_D);
    } else {
      D4 = D22;
    }
    if (isNegativeLE(x5 * zInv, P4))
      y5 = mod4(-y5);
    let s3 = mod4((z4 - y5) * D4);
    if (isNegativeLE(s3, P4))
      s3 = mod4(-s3);
    return numberToBytesLE(s3, 32);
  }
  /** @deprecated use `toBytes` */
  toRawBytes() {
    return this.toBytes();
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    aristp(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X22, ey: Y22 } = other.ep;
    const mod4 = Fp.create;
    const one = mod4(X1 * Y22) === mod4(Y1 * X22);
    const two = mod4(Y1 * Y22) === mod4(X1 * X22);
    return one || two;
  }
  add(other) {
    aristp(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    aristp(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed255192.Point.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed255192.Point.ZERO);
  return RistPoint;
})();

// node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_bn2 = __toESM(require_bn());
var import_bs582 = __toESM(require_bs582());
var import_borsh2 = __toESM(require_lib());
var BufferLayout2 = __toESM(require_Layout());
var import_buffer_layout2 = __toESM(require_Layout());

// node_modules/@dynamic-labs/solana/node_modules/@solana/errors/dist/index.browser.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2 = 1;
var SOLANA_ERROR__INVALID_NONCE2 = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2 = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2 = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2 = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2 = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING2 = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING2 = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2 = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2 = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR2 = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2 = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2 = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2 = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2 = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2 = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2 = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2 = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2 = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR2 = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2 = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2 = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2 = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2 = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2 = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2 = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2 = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2 = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2 = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2 = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2 = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2 = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2 = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2 = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2 = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2 = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2 = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2 = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2 = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2 = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2 = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2 = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2 = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2 = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2 = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2 = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2 = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2 = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2 = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2 = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2 = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2 = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2 = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2 = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2 = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2 = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2 = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2 = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2 = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2 = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2 = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2 = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2 = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2 = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2 = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2 = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2 = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2 = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2 = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2 = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2 = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2 = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2 = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2 = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2 = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2 = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2 = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2 = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2 = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2 = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2 = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2 = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2 = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2 = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2 = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2 = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2 = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2 = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2 = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2 = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2 = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2 = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2 = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2 = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2 = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2 = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2 = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2 = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2 = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2 = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2 = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2 = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2 = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2 = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2 = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2 = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2 = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2 = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2 = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2 = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2 = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2 = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2 = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2 = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2 = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2 = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2 = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2 = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2 = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2 = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2 = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2 = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2 = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2 = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2 = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2 = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2 = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2 = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2 = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2 = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2 = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2 = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2 = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2 = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2 = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2 = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2 = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2 = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2 = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2 = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2 = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2 = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2 = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2 = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2 = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2 = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2 = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2 = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2 = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2 = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2 = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2 = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2 = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2 = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2 = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2 = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2 = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2 = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2 = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2 = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2 = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2 = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2 = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2 = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2 = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2 = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2 = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2 = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2 = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2 = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2 = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2 = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2 = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2 = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2 = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2 = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2 = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2 = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2 = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2 = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2 = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2 = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2 = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2 = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2 = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2 = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2 = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2 = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2 = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2 = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2 = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2 = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2 = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2 = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2 = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2 = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2 = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2 = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2 = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2 = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2 = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2 = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2 = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2 = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT2 = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2 = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2 = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2 = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2 = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW2 = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2 = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2 = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2 = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2 = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2 = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2 = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2 = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2 = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2 = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2 = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2 = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2 = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2 = 9900004;
var SolanaErrorMessages2 = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT2]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE2]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR2]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING2]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING2]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW2]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX2 = "i";
var TYPE2 = "t";
function getHumanReadableErrorMessage2(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages2[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE2] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX2] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE2] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX2], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii3) => {
    if (ii3 === 0) {
      state = {
        [START_INDEX2]: 0,
        [TYPE2]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE2]) {
      case 0:
        nextState = {
          [START_INDEX2]: ii3,
          [TYPE2]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX2]: ii3,
            [TYPE2]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX2]: ii3,
            [TYPE2]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX2]: ii3,
            [TYPE2]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX2]: ii3,
            [TYPE2]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX2]: ii3,
            [TYPE2]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii3);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage2(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage2(code2, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code2}; Decode this error by running \`npx @solana/errors decode -- ${code2}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError2 = class extends Error {
  constructor(...[code2, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage2(code2, context);
    super(message, errorOptions);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    __publicField(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    __publicField(this, "context");
    this.context = {
      __code: code2,
      ...context
    };
    this.name = "SolanaError";
  }
};

// node_modules/@dynamic-labs/solana/node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize2(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder2(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes2 = new Uint8Array(getEncodedSize2(value, encoder));
      encoder.write(value, bytes2, 0);
      return bytes2;
    }
  });
}
function createDecoder2(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes2, offset5 = 0) => decoder.read(bytes2, offset5)[0]
  });
}
function isFixedSize2(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec2(encoder, decoder) {
  if (isFixedSize2(encoder) !== isFixedSize2(decoder)) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2);
  }
  if (isFixedSize2(encoder) && isFixedSize2(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize2(encoder) && !isFixedSize2(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec2(codecDescription, bytes2, offset5 = 0) {
  if (bytes2.length - offset5 <= 0) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec2(codecDescription, expected, bytes2, offset5 = 0) {
  const bytesLength = bytes2.length - offset5;
  if (bytesLength < expected) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}

// node_modules/@dynamic-labs/solana/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec2(codecDescription, min4, max4, value) {
  if (value < min4 || value > max4) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2, {
      codecDescription,
      max: max4,
      min: min4,
      value
    });
  }
}
var Endian2 = ((Endian22) => {
  Endian22[Endian22["Little"] = 0] = "Little";
  Endian22[Endian22["Big"] = 1] = "Big";
  return Endian22;
})(Endian2 || {});
function isLittleEndian2(config) {
  return (config == null ? void 0 : config.endian) === 1 ? false : true;
}
function numberEncoderFactory2(input) {
  return createEncoder2({
    fixedSize: input.size,
    write(value, bytes2, offset5) {
      if (input.range) {
        assertNumberIsBetweenForCodec2(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian2(input.config));
      bytes2.set(new Uint8Array(arrayBuffer), offset5);
      return offset5 + input.size;
    }
  });
}
function numberDecoderFactory2(input) {
  return createDecoder2({
    fixedSize: input.size,
    read(bytes2, offset5 = 0) {
      assertByteArrayIsNotEmptyForCodec2(input.name, bytes2, offset5);
      assertByteArrayHasEnoughBytesForCodec2(input.name, input.size, bytes2, offset5);
      const view = new DataView(toArrayBuffer2(bytes2, offset5, input.size));
      return [input.get(view, isLittleEndian2(input.config)), offset5 + input.size];
    }
  });
}
function toArrayBuffer2(bytes2, offset5, length2) {
  const bytesOffset = bytes2.byteOffset + (offset5 ?? 0);
  const bytesLength = length2 ?? bytes2.byteLength;
  return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder2 = (config = {}) => numberEncoderFactory2({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le5) => view.setBigUint64(0, BigInt(value), le5),
  size: 8
});
var getU64Decoder2 = (config = {}) => numberDecoderFactory2({
  config,
  get: (view, le5) => view.getBigUint64(0, le5),
  name: "u64",
  size: 8
});
var getU64Codec2 = (config = {}) => combineCodec2(getU64Encoder2(config), getU64Decoder2(config));

// node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_browser2 = __toESM(require_browser());

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts2) {
  if (opts2.lowS !== void 0)
    abool("lowS", opts2.lowS);
  if (opts2.prehash !== void 0)
    abool("prehash", opts2.prehash);
}
var DERErr = class extends Error {
  constructor(m3 = "") {
    super(m3);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E4 } = DER;
      if (tag < 0 || tag > 256)
        throw new E4("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E4("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E4("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E4 } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E4("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E4("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length2 = 0;
      if (!isLong)
        length2 = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E4("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E4("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E4("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E4("tlv.decode(long): zero leftmost byte");
        for (const b4 of lengthBytes)
          length2 = length2 << 8 | b4;
        pos += lenLen;
        if (length2 < 128)
          throw new E4("tlv.decode(long): not minimal encoding");
      }
      const v6 = data.subarray(pos, pos + length2);
      if (v6.length !== length2)
        throw new E4("tlv.decode: wrong value length");
      return { v: v6, l: data.subarray(pos + length2) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num3) {
      const { Err: E4 } = DER;
      if (num3 < _0n6)
        throw new E4("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num3);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E4("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E4 } = DER;
      if (data[0] & 128)
        throw new E4("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E4("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex2) {
    const { Err: E4, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E4("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E4("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs2 = tlv.encode(2, int.encode(sig.r));
    const ss2 = tlv.encode(2, int.encode(sig.s));
    const seq5 = rs2 + ss2;
    return tlv.encode(48, seq5);
  }
};
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var _3n3 = BigInt(3);
var _4n2 = BigInt(4);
function _legacyHelperEquat(Fp3, a3, b4) {
  function weierstrassEquation(x5) {
    const x22 = Fp3.sqr(x5);
    const x32 = Fp3.mul(x22, x5);
    return Fp3.add(Fp3.add(x32, Fp3.mul(x5, a3)), b4);
  }
  return weierstrassEquation;
}
function _legacyHelperNormPriv(Fn5, allowedPrivateKeyLengths, wrapPrivateKey) {
  const { BYTES: expected } = Fn5;
  function normPrivateKeyToScalar(key) {
    let num3;
    if (typeof key === "bigint") {
      num3 = key;
    } else {
      let bytes2 = ensureBytes("private key", key);
      if (allowedPrivateKeyLengths) {
        if (!allowedPrivateKeyLengths.includes(bytes2.length * 2))
          throw new Error("invalid private key");
        const padded = new Uint8Array(expected);
        padded.set(bytes2, padded.length - bytes2.length);
        bytes2 = padded;
      }
      try {
        num3 = Fn5.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (wrapPrivateKey)
      num3 = Fn5.create(num3);
    if (!Fn5.isValidNot0(num3))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num3;
  }
  return normPrivateKeyToScalar;
}
function weierstrassN(CURVE, curveOpts = {}) {
  const { Fp: Fp3, Fn: Fn5 } = _createCurveFields("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp3.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp3.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes3(_c3, point, isCompressed) {
    const { x: x5, y: y5 } = point.toAffine();
    const bx = Fp3.toBytes(x5);
    abool("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp3.isOdd(y5);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp3.toBytes(y5));
    }
  }
  function pointFromBytes(bytes2) {
    abytes(bytes2);
    const L3 = Fp3.BYTES;
    const LC = L3 + 1;
    const LU = 2 * L3 + 1;
    const length2 = bytes2.length;
    const head5 = bytes2[0];
    const tail4 = bytes2.subarray(1);
    if (length2 === LC && (head5 === 2 || head5 === 3)) {
      const x5 = Fp3.fromBytes(tail4);
      if (!Fp3.isValid(x5))
        throw new Error("bad point: is not on curve, wrong x");
      const y22 = weierstrassEquation(x5);
      let y5;
      try {
        y5 = Fp3.sqrt(y22);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp3.isOdd(y5);
      const isHeadOdd = (head5 & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y5 = Fp3.neg(y5);
      return { x: x5, y: y5 };
    } else if (length2 === LU && head5 === 4) {
      const x5 = Fp3.fromBytes(tail4.subarray(L3 * 0, L3 * 1));
      const y5 = Fp3.fromBytes(tail4.subarray(L3 * 1, L3 * 2));
      if (!isValidXY(x5, y5))
        throw new Error("bad point: is not on curve");
      return { x: x5, y: y5 };
    } else {
      throw new Error(`bad point: got length ${length2}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes5 = curveOpts.toBytes || pointToBytes3;
  const fromBytes5 = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat(Fp3, CURVE.a, CURVE.b);
  function isValidXY(x5, y5) {
    const left13 = Fp3.sqr(y5);
    const right13 = weierstrassEquation(x5);
    return Fp3.eql(left13, right13);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp3.mul(Fp3.pow(CURVE.a, _3n3), _4n2);
  const _27b2 = Fp3.mul(Fp3.sqr(CURVE.b), BigInt(27));
  if (Fp3.is0(Fp3.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n5, banZero = false) {
    if (!Fp3.isValid(n5) || banZero && Fp3.is0(n5))
      throw new Error(`bad point coordinate ${title}`);
    return n5;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p4, iz) => {
    const { px: x5, py: y5, pz: z4 } = p4;
    if (Fp3.eql(z4, Fp3.ONE))
      return { x: x5, y: y5 };
    const is0 = p4.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z4);
    const ax = Fp3.mul(x5, iz);
    const ay = Fp3.mul(y5, iz);
    const zz = Fp3.mul(z4, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p4) => {
    if (p4.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp3.is0(p4.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x5, y: y5 } = p4.toAffine();
    if (!Fp3.isValid(x5) || !Fp3.isValid(y5))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x5, y5))
      throw new Error("bad point: equation left != right");
    if (!p4.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point3(Fp3.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point3 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(px, py, pz) {
      this.px = acoord("x", px);
      this.py = acoord("y", py, true);
      this.pz = acoord("z", pz);
      Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p4) {
      const { x: x5, y: y5 } = p4 || {};
      if (!p4 || !Fp3.isValid(x5) || !Fp3.isValid(y5))
        throw new Error("invalid affine point");
      if (p4 instanceof Point3)
        throw new Error("projective point not allowed");
      if (Fp3.is0(x5) && Fp3.is0(y5))
        return Point3.ZERO;
      return new Point3(x5, y5, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      return normalizeZ(Point3, "pz", points);
    }
    static fromBytes(bytes2) {
      abytes(bytes2);
      return Point3.fromHex(bytes2);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(hex2) {
      const P4 = Point3.fromAffine(fromBytes5(ensureBytes("pointHex", hex2)));
      P4.assertValidity();
      return P4;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(privateKey) {
      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn5, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    /** Multiscalar Multiplication */
    static msm(points, scalars) {
      return pippenger(Point3, Fn5, points, scalars);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_3n3);
      return this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y5 } = this.toAffine();
      if (!Fp3.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp3.isOdd(y5);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X22, Z1));
      const U22 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y22, Z1));
      return U1 && U22;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a3, b: b4 } = CURVE;
      const b32 = Fp3.mul(b4, _3n3);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp3.ZERO, Y32 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X32 = Fp3.mul(a3, Z3);
      Y32 = Fp3.mul(b32, t2);
      Y32 = Fp3.add(X32, Y32);
      X32 = Fp3.sub(t1, Y32);
      Y32 = Fp3.add(t1, Y32);
      Y32 = Fp3.mul(X32, Y32);
      X32 = Fp3.mul(t3, X32);
      Z3 = Fp3.mul(b32, Z3);
      t2 = Fp3.mul(a3, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a3, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y32 = Fp3.add(Y32, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X32 = Fp3.sub(X32, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X32, Y32, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z2 } = other;
      let X32 = Fp3.ZERO, Y32 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a3 = CURVE.a;
      const b32 = Fp3.mul(CURVE.b, _3n3);
      let t0 = Fp3.mul(X1, X22);
      let t1 = Fp3.mul(Y1, Y22);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X22, Y22);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X22, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X32 = Fp3.add(Y22, Z2);
      t5 = Fp3.mul(t5, X32);
      X32 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X32);
      Z3 = Fp3.mul(a3, t4);
      X32 = Fp3.mul(b32, t2);
      Z3 = Fp3.add(X32, Z3);
      X32 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y32 = Fp3.mul(X32, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a3, t2);
      t4 = Fp3.mul(b32, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a3, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y32 = Fp3.add(Y32, t0);
      t0 = Fp3.mul(t5, t4);
      X32 = Fp3.mul(t3, X32);
      X32 = Fp3.sub(X32, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X32, Y32, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn5.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul3 = (n5) => wnaf.wNAFCached(this, n5, Point3.normalizeZ);
      if (endo2) {
        const { k1neg, k1, k2neg, k2: k22 } = endo2.splitScalar(scalar);
        const { p: k1p, f: k1f } = mul3(k1);
        const { p: k2p, f: k2f } = mul3(k22);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p: p4, f: f8 } = mul3(scalar);
        point = p4;
        fake = f8;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc3) {
      const { endo: endo2 } = curveOpts;
      const p4 = this;
      if (!Fn5.isValid(sc3))
        throw new Error("invalid scalar: out of range");
      if (sc3 === _0n6 || p4.is0())
        return Point3.ZERO;
      if (sc3 === _1n6)
        return p4;
      if (wnaf.hasPrecomputes(this))
        return this.multiply(sc3);
      if (endo2) {
        const { k1neg, k1, k2neg, k2: k22 } = endo2.splitScalar(sc3);
        const { p1, p2: p22 } = mulEndoUnsafe(Point3, p4, k1, k22);
        return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
      } else {
        return wnaf.wNAFCachedUnsafe(p4, sc3);
      }
    }
    multiplyAndAddUnsafe(Q6, a3, b4) {
      const sum = this.multiplyUnsafe(a3).add(Q6.multiplyUnsafe(b4));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n6)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n6)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(cofactor);
    }
    toBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes5(Point3, this, isCompressed);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  Point3.Fp = Fp3;
  Point3.Fn = Fn5;
  const bits = Fn5.BITS;
  const wnaf = wNAF(Point3, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point3;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function ecdsa(Point3, ecdsaOpts, curveOpts = {}) {
  _validateObject(ecdsaOpts, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac(ecdsaOpts.hash, key, concatBytes(...msgs)));
  const { Fp: Fp3, Fn: Fn5 } = Point3;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn5;
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n6;
    return number3 > HALF;
  }
  function normalizeS(s3) {
    return isBiggerThanHalfOrder(s3) ? Fn5.neg(s3) : s3;
  }
  function aValidRS(title, num3) {
    if (!Fn5.isValidNot0(num3))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }
  class Signature {
    constructor(r3, s3, recovery) {
      aValidRS("r", r3);
      aValidRS("s", s3);
      this.r = r3;
      this.s = s3;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const L3 = Fn5.BYTES;
      const b4 = ensureBytes("compactSignature", hex2, L3 * 2);
      return new Signature(Fn5.fromBytes(b4.subarray(0, L3)), Fn5.fromBytes(b4.subarray(L3, L3 * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r3, s: s3 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r3, s3);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    // ProjPointType<bigint>
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp3.ORDER;
      const { r: r3, s: s3, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n5 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE_ORDER : r3;
      if (!Fp3.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x5 = Fp3.toBytes(radj);
      const R3 = Point3.fromHex(concatBytes(pprefix((rec & 1) === 0), x5));
      const ir4 = Fn5.inv(radj);
      const h5 = bits2int_modN(ensureBytes("msgHash", msgHash));
      const u1 = Fn5.create(-h5 * ir4);
      const u2 = Fn5.create(s3 * ir4);
      const Q6 = Point3.BASE.multiplyUnsafe(u1).add(R3.multiplyUnsafe(u2));
      if (Q6.is0())
        throw new Error("point at infinify");
      Q6.assertValidity();
      return Q6;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn5.neg(this.s), this.recovery) : this;
    }
    toBytes(format) {
      if (format === "compact")
        return concatBytes(Fn5.toBytes(this.r), Fn5.toBytes(this.s));
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn5, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const n5 = CURVE_ORDER;
      return mapHashToField(randomBytes_(getMinHashLength(n5)), n5);
    },
    precompute(windowSize = 8, point = Point3.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey5(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point3)
      return true;
    const arr = ensureBytes("key", item);
    const length2 = arr.length;
    const L3 = Fp3.BYTES;
    const LC = L3 + 1;
    const LU = 2 * L3 + 1;
    if (curveOpts.allowedPrivateKeyLengths || Fn5.BYTES === LC) {
      return void 0;
    } else {
      return length2 === LC || length2 === LU;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b4 = Point3.fromHex(publicB);
    return b4.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num3 = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - fnBits;
    return delta > 0 ? num3 >> BigInt(delta) : num3;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
    return Fn5.create(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num3) {
    aInRange("num < 2^" + fnBits, num3, _0n6, ORDER_MASK);
    return Fn5.toBytes(num3);
  }
  function prepSig(msgHash, privateKey, opts2 = defaultSigOpts) {
    if (["recovered", "canonical"].some((k6) => k6 in opts2))
      throw new Error("sign() legacy options not supported");
    const { hash } = ecdsaOpts;
    let { lowS, prehash, extraEntropy: ent } = opts2;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts2);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d4 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d4), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes_(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes(...seedArgs);
    const m3 = h1int;
    function k2sig(kBytes) {
      const k6 = bits2int(kBytes);
      if (!Fn5.isValidNot0(k6))
        return;
      const ik = Fn5.inv(k6);
      const q = Point3.BASE.multiply(k6).toAffine();
      const r3 = Fn5.create(q.x);
      if (r3 === _0n6)
        return;
      const s3 = Fn5.create(ik * Fn5.create(m3 + r3 * d4));
      if (s3 === _0n6)
        return;
      let recovery = (q.x === r3 ? 0 : 2) | Number(q.y & _1n6);
      let normS = s3;
      if (lowS && isBiggerThanHalfOrder(s3)) {
        normS = normalizeS(s3);
        recovery ^= 1;
      }
      return new Signature(r3, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign5(msgHash, privKey, opts2 = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts2);
    const drbg = createHmacDrbg(ecdsaOpts.hash.outputLen, Fn5.BYTES, hmac_);
    return drbg(seed, k2sig);
  }
  Point3.BASE.precompute(8);
  function verify5(signature4, msgHash, publicKey5, opts2 = defaultVerOpts) {
    const sg = signature4;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey5 = ensureBytes("publicKey", publicKey5);
    validateSigVerOpts(opts2);
    const { lowS, prehash, format } = opts2;
    if ("strict" in opts2)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && !["compact", "der", "js"].includes(format))
      throw new Error('format must be "compact", "der" or "js"');
    const isHex3 = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex3 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex3 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P4;
    try {
      if (isObj) {
        if (format === void 0 || format === "js") {
          _sig = new Signature(sg.r, sg.s);
        } else {
          throw new Error("invalid format");
        }
      }
      if (isHex3) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P4 = Point3.fromHex(publicKey5);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = ecdsaOpts.hash(msgHash);
    const { r: r3, s: s3 } = _sig;
    const h5 = bits2int_modN(msgHash);
    const is2 = Fn5.inv(s3);
    const u1 = Fn5.create(h5 * is2);
    const u2 = Fn5.create(r3 * is2);
    const R3 = Point3.BASE.multiplyUnsafe(u1).add(P4.multiplyUnsafe(u2));
    if (R3.is0())
      return false;
    const v6 = Fn5.create(R3.x);
    return v6 === r3;
  }
  return Object.freeze({
    getPublicKey: getPublicKey5,
    getSharedSecret,
    sign: sign5,
    verify: verify5,
    utils,
    Point: Point3,
    Signature
  });
}
function _weierstrass_legacy_opts_to_new(c6) {
  const CURVE = {
    a: c6.a,
    b: c6.b,
    p: c6.Fp.ORDER,
    n: c6.n,
    h: c6.h,
    Gx: c6.Gx,
    Gy: c6.Gy
  };
  const Fp3 = c6.Fp;
  const Fn5 = Field(CURVE.n, c6.nBitLength);
  const curveOpts = {
    Fp: Fp3,
    Fn: Fn5,
    allowedPrivateKeyLengths: c6.allowedPrivateKeyLengths,
    allowInfinityPoint: c6.allowInfinityPoint,
    endo: c6.endo,
    wrapPrivateKey: c6.wrapPrivateKey,
    isTorsionFree: c6.isTorsionFree,
    clearCofactor: c6.clearCofactor,
    fromBytes: c6.fromBytes,
    toBytes: c6.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c6) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c6);
  const ecdsaOpts = {
    hash: c6.hash,
    hmac: c6.hmac,
    randomBytes: c6.randomBytes,
    lowS: c6.lowS,
    bits2int: c6.bits2int,
    bits2int_modN: c6.bits2int_modN
  };
  return { CURVE, curveOpts, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c6, ecdsa2) {
  return Object.assign({}, ecdsa2, {
    ProjectivePoint: ecdsa2.Point,
    CURVE: c6
  });
}
function weierstrass(c6) {
  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c6);
  const Point3 = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point3, ecdsaOpts, curveOpts);
  return _ecdsa_new_output_to_legacy(c6, signs);
}
function SWUFpSqrtRatio(Fp3, Z2) {
  const q = Fp3.ORDER;
  let l6 = _0n6;
  for (let o4 = q - _1n6; o4 % _2n5 === _0n6; o4 /= _2n5)
    l6 += _1n6;
  const c1 = l6;
  const _2n_pow_c1_1 = _2n5 << c1 - _1n6 - _1n6;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n5;
  const c22 = (q - _1n6) / _2n_pow_c1;
  const c32 = (c22 - _1n6) / _2n5;
  const c42 = _2n_pow_c1 - _1n6;
  const c52 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z2, c22);
  const c7 = Fp3.pow(Z2, (c22 + _1n6) / _2n5);
  let sqrtRatio = (u2, v6) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v6, c42);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v6);
    let tv5 = Fp3.mul(u2, tv3);
    tv5 = Fp3.pow(tv5, c32);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v6);
    tv3 = Fp3.mul(tv5, u2);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c52);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i4 = c1; i4 > _1n6; i4--) {
      let tv52 = i4 - _2n5;
      tv52 = _2n5 << tv52 - _1n6;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n2 === _3n3) {
    const c12 = (Fp3.ORDER - _3n3) / _4n2;
    const c23 = Fp3.sqrt(Fp3.neg(Z2));
    sqrtRatio = (u2, v6) => {
      let tv1 = Fp3.sqr(v6);
      const tv2 = Fp3.mul(u2, v6);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y22 = Fp3.mul(y1, c23);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v6);
      const isQR = Fp3.eql(tv3, u2);
      let y5 = Fp3.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y5 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts2) {
  validateField(Fp3);
  const { A: A4, B: B3, Z: Z2 } = opts2;
  if (!Fp3.isValid(A4) || !Fp3.isValid(B3) || !Fp3.isValid(Z2))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, Z2);
  if (!Fp3.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u2) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x5, y5;
    tv1 = Fp3.sqr(u2);
    tv1 = Fp3.mul(tv1, Z2);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, B3);
    tv4 = Fp3.cmov(Z2, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, A4);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, A4);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, B3);
    tv2 = Fp3.add(tv2, tv5);
    x5 = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y5 = Fp3.mul(tv1, u2);
    y5 = Fp3.mul(y5, value);
    x5 = Fp3.cmov(x5, tv3, isValid);
    y5 = Fp3.cmov(y5, value, isValid);
    const e1 = Fp3.isOdd(u2) === Fp3.isOdd(y5);
    y5 = Fp3.cmov(Fp3.neg(y5), y5, e1);
    const tv4_inv = FpInvertBatch(Fp3, [tv4], true)[0];
    x5 = Fp3.mul(x5, tv4_inv);
    return { x: x5, y: y5 };
  };
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create6 = (hash) => weierstrass({ ...curveDef, hash });
  return { ...create6(defHash), create: create6 };
}

// node_modules/@dynamic-labs/solana/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n6 = BigInt(2);
var divNearest = (a3, b4) => (a3 + b4 / _2n6) / b4;
function sqrtMod(y5) {
  const P4 = secp256k1_CURVE.p;
  const _3n7 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y5 * y5 * y5 % P4;
  const b32 = b22 * b22 * y5 % P4;
  const b6 = pow2(b32, _3n7, P4) * b32 % P4;
  const b9 = pow2(b6, _3n7, P4) * b32 % P4;
  const b11 = pow2(b9, _2n6, P4) * b22 % P4;
  const b222 = pow2(b11, _11n, P4) * b11 % P4;
  const b44 = pow2(b222, _22n, P4) * b222 % P4;
  const b88 = pow2(b44, _44n, P4) * b44 % P4;
  const b176 = pow2(b88, _88n, P4) * b88 % P4;
  const b220 = pow2(b176, _44n, P4) * b44 % P4;
  const b223 = pow2(b220, _3n7, P4) * b32 % P4;
  const t1 = pow2(b223, _23n, P4) * b222 % P4;
  const t2 = pow2(t1, _6n, P4) * b22 % P4;
  const root = pow2(t2, _2n6, P4);
  if (!Fpk1.eql(Fpk1.sqr(root), y5))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
var secp256k12 = createCurve({
  ...secp256k1_CURVE,
  Fp: Fpk1,
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k6) => {
      const n5 = secp256k1_CURVE.n;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k6, n5);
      const c22 = divNearest(-b1 * k6, n5);
      let k1 = mod(k6 - c1 * a1 - c22 * a22, n5);
      let k22 = mod(-c1 * b1 - c22 * b22, n5);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n5 - k1;
      if (k2neg)
        k22 = n5 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k6);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c6) => c6.charCodeAt(0)));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var numTo32b = (n5) => numberToBytesBE(n5, 32);
var modP = (x5) => mod(x5, secp256k1_CURVE.p);
var modN = (x5) => mod(x5, secp256k1_CURVE.n);
var Point = (() => secp256k12.Point)();
var hasEven = (y5) => y5 % _2n6 === _0n7;
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k12.utils.normPrivateKeyToScalar(priv);
  let p4 = Point.fromPrivateKey(d_);
  const scalar = hasEven(p4.y) ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p4) };
}
function lift_x(x5) {
  aInRange("x", x5, _1n7, secp256k1_CURVE.p);
  const xx = modP(x5 * x5);
  const c6 = modP(xx * x5 + BigInt(7));
  let y5 = sqrtMod(c6);
  if (!hasEven(y5))
    y5 = modP(-y5);
  const p4 = Point.fromAffine({ x: x5, y: y5 });
  p4.assertValidity();
  return p4;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m3 = ensureBytes("message", message);
  const { bytes: px, scalar: d4 } = schnorrGetExtPubKey(privateKey);
  const a3 = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d4 ^ num(taggedHash("BIP0340/aux", a3)));
  const rand = taggedHash("BIP0340/nonce", t, px, m3);
  const k_ = modN(num(rand));
  if (k_ === _0n7)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k6 } = schnorrGetExtPubKey(k_);
  const e2 = challenge(rx, px, m3);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k6 + e2 * d4)), 32);
  if (!schnorrVerify(sig, m3, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature4, message, publicKey5) {
  const sig = ensureBytes("signature", signature4, 64);
  const m3 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey5, 32);
  try {
    const P4 = lift_x(num(pub));
    const r3 = num(sig.subarray(0, 32));
    if (!inRange(r3, _1n7, secp256k1_CURVE.p))
      return false;
    const s3 = num(sig.subarray(32, 64));
    if (!inRange(s3, _1n7, secp256k1_CURVE.n))
      return false;
    const e2 = challenge(numTo32b(r3), pointToBytes(P4), m3);
    const R3 = Point.BASE.multiplyUnsafe(s3).add(P4.multiplyUnsafe(modN(-e2)));
    const { x: x5, y: y5 } = R3.toAffine();
    if (R3.is0() || !hasEven(y5) || x5 !== r3)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k12.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i4) => i4.map((j3) => BigInt(j3)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k12.Point, (scalars) => {
  const { x: x5, y: y5 } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x5, y5);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve2 = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve2 = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@dynamic-labs/solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var generatePrivateKey2 = ed255192.utils.randomPrivateKey;
var generateKeypair2 = () => {
  const privateScalar = ed255192.utils.randomPrivateKey();
  const publicKey5 = getPublicKey2(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey5, 32);
  return {
    publicKey: publicKey5,
    secretKey
  };
};
var getPublicKey2 = ed255192.getPublicKey;
function isOnCurve2(publicKey5) {
  try {
    ed255192.ExtendedPoint.fromHex(publicKey5);
    return true;
  } catch {
    return false;
  }
}
var sign2 = (message, secretKey) => ed255192.sign(message, secretKey.slice(0, 32));
var verify2 = ed255192.verify;
var toBuffer2 = (arr) => {
  if (import_buffer2.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return import_buffer2.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return import_buffer2.Buffer.from(arr);
  }
};
var Struct2 = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return import_buffer2.Buffer.from((0, import_borsh2.serialize)(SOLANA_SCHEMA2, this));
  }
  static decode(data) {
    return (0, import_borsh2.deserialize)(SOLANA_SCHEMA2, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh2.deserializeUnchecked)(SOLANA_SCHEMA2, this, data);
  }
};
var SOLANA_SCHEMA2 = /* @__PURE__ */ new Map();
var _PublicKey2;
var MAX_SEED_LENGTH2 = 32;
var PUBLIC_KEY_LENGTH2 = 32;
function isPublicKeyData2(value) {
  return value._bn !== void 0;
}
var uniquePublicKeyCounter2 = 1;
var PublicKey3 = class _PublicKey5 extends Struct2 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData2(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs582.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH2) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn2.default(decoded);
      } else {
        this._bn = new import_bn2.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH2) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new _PublicKey5(uniquePublicKeyCounter2);
    uniquePublicKeyCounter2 += 1;
    return new _PublicKey5(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey5) {
    return this._bn.eq(publicKey5._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return import_bs582.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b4 = this._bn.toArrayLike(import_buffer2.Buffer);
    if (b4.length === PUBLIC_KEY_LENGTH2) {
      return b4;
    }
    const zeroPad = import_buffer2.Buffer.alloc(32);
    b4.copy(zeroPad, 32 - b4.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = import_buffer2.Buffer.concat([fromPublicKey.toBuffer(), import_buffer2.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha2562(buffer);
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = import_buffer2.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH2) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = import_buffer2.Buffer.concat([buffer, toBuffer2(seed)]);
    });
    buffer = import_buffer2.Buffer.concat([buffer, programId.toBuffer(), import_buffer2.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha2562(buffer);
    if (isOnCurve2(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(import_buffer2.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new _PublicKey5(pubkeyData);
    return isOnCurve2(pubkey.toBytes());
  }
};
_PublicKey2 = PublicKey3;
PublicKey3.default = new _PublicKey2("11111111111111111111111111111111");
SOLANA_SCHEMA2.set(PublicKey3, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID2 = new PublicKey3("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE2 = 1280 - 40 - 8;
var VERSION_PREFIX_MASK2 = 127;
var SIGNATURE_LENGTH_IN_BYTES2 = 64;
var TransactionExpiredBlockheightExceededError2 = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError2.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
var TransactionExpiredTimeoutError2 = class extends Error {
  constructor(signature4, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature4} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredTimeoutError2.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
var TransactionExpiredNonceInvalidError2 = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredNonceInvalidError2.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
var MessageAccountKeys2 = class {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
};
var publicKey2 = (property = "publicKey") => {
  return BufferLayout2.blob(32, property);
};
var signature2 = (property = "signature") => {
  return BufferLayout2.blob(64, property);
};
var rustString2 = (property = "string") => {
  const rsl = BufferLayout2.struct([BufferLayout2.u32("length"), BufferLayout2.u32("lengthPadding"), BufferLayout2.blob(BufferLayout2.offset(BufferLayout2.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b4, offset5) => {
    const data = _decode(b4, offset5);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b4, offset5) => {
    const data = {
      chars: import_buffer2.Buffer.from(str, "utf8")
    };
    return _encode(data, b4, offset5);
  };
  rslShim.alloc = (str) => {
    return BufferLayout2.u32().span + BufferLayout2.u32().span + import_buffer2.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized2 = (property = "authorized") => {
  return BufferLayout2.struct([publicKey2("staker"), publicKey2("withdrawer")], property);
};
var lockup2 = (property = "lockup") => {
  return BufferLayout2.struct([BufferLayout2.ns64("unixTimestamp"), BufferLayout2.ns64("epoch"), publicKey2("custodian")], property);
};
var voteInit2 = (property = "voteInit") => {
  return BufferLayout2.struct([publicKey2("nodePubkey"), publicKey2("authorizedVoter"), publicKey2("authorizedWithdrawer"), BufferLayout2.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs2 = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout2.struct([BufferLayout2.u32("voteAuthorizationType"), publicKey2("currentAuthorityDerivedKeyOwnerPubkey"), rustString2("currentAuthorityDerivedKeySeed"), publicKey2("newAuthorized")], property);
};
function getAlloc2(type3, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc2({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type3.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength2(bytes2) {
  let len = 0;
  let size9 = 0;
  for (; ; ) {
    let elem6 = bytes2.shift();
    len |= (elem6 & 127) << size9 * 7;
    size9 += 1;
    if ((elem6 & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength2(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem6 = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem6);
      break;
    } else {
      elem6 |= 128;
      bytes2.push(elem6);
    }
  }
}
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var CompiledKeys2 = class _CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new _CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert3(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert3(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert3(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey3(address)), ...readonlySigners.map(([address]) => new PublicKey3(address)), ...writableNonSigners.map(([address]) => new PublicKey3(address)), ...readonlyNonSigners.map(([address]) => new PublicKey3(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey3(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert3(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
};
var END_OF_BUFFER_ERROR_MESSAGE2 = "Reached end of buffer unexpectedly";
function guardedShift2(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE2);
  }
  return byteArray.shift();
}
function guardedSplice2(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE2);
  }
  return byteArray.splice(...args);
}
var Message2 = class _Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey3(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs582.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys2(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys2.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys2(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs582.default.encode(ix.data)
    }));
    return new _Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_3, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength2(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs582.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength2(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength2(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: import_buffer2.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: import_buffer2.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength2(instructionCount, instructions.length);
    let instructionBuffer = import_buffer2.Buffer.alloc(PACKET_DATA_SIZE2);
    import_buffer2.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout2.struct([BufferLayout2.u8("programIdIndex"), BufferLayout2.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout2.seq(BufferLayout2.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout2.blob(instruction.dataLength.length, "dataLength"), BufferLayout2.seq(BufferLayout2.u8("userdatum"), instruction.data.length, "data")]);
      const length3 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length3;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout2.struct([BufferLayout2.blob(1, "numRequiredSignatures"), BufferLayout2.blob(1, "numReadonlySignedAccounts"), BufferLayout2.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout2.blob(keyCount.length, "keyCount"), BufferLayout2.seq(publicKey2("key"), numKeys, "keys"), publicKey2("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: import_buffer2.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: import_buffer2.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer2(key.toBytes())),
      recentBlockhash: import_bs582.default.decode(this.recentBlockhash)
    };
    let signData = import_buffer2.Buffer.alloc(2048);
    const length2 = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length2);
    return signData.slice(0, length2 + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift2(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK2)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift2(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift2(byteArray);
    const accountCount = decodeLength2(byteArray);
    let accountKeys = [];
    for (let i4 = 0; i4 < accountCount; i4++) {
      const account = guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2);
      accountKeys.push(new PublicKey3(import_buffer2.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2);
    const instructionCount = decodeLength2(byteArray);
    let instructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift2(byteArray);
      const accountCount2 = decodeLength2(byteArray);
      const accounts = guardedSplice2(byteArray, 0, accountCount2);
      const dataLength = decodeLength2(byteArray);
      const dataSlice = guardedSplice2(byteArray, 0, dataLength);
      const data = import_bs582.default.encode(import_buffer2.Buffer.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs582.default.encode(import_buffer2.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new _Message(messageArgs);
  }
};
var MessageV02 = class _MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup4 of this.addressTableLookups) {
      count += lookup4.readonlyIndexes.length + lookup4.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys2(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup4) => count + lookup4.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys2.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== void 0) {
        const [addressTableLookup, {
          writable,
          readonly: readonly3
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly3);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys2(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new _MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength2(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength2(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength2(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = BufferLayout2.struct([BufferLayout2.u8("prefix"), BufferLayout2.struct([BufferLayout2.u8("numRequiredSignatures"), BufferLayout2.u8("numReadonlySignedAccounts"), BufferLayout2.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout2.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout2.seq(publicKey2(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey2("recentBlockhash"), BufferLayout2.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout2.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout2.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout2.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE2);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: import_bs582.default.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE2);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength2(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength2(encodedDataLength, instruction.data.length);
      const instructionLayout = BufferLayout2.struct([BufferLayout2.u8("programIdIndex"), BufferLayout2.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout2.seq(BufferLayout2.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout2.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout2.blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE2);
    for (const lookup4 of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength2(encodedWritableIndexesLength, lookup4.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength2(encodedReadonlyIndexesLength, lookup4.readonlyIndexes.length);
      const addressTableLookupLayout = BufferLayout2.struct([publicKey2("accountKey"), BufferLayout2.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout2.seq(BufferLayout2.u8(), lookup4.writableIndexes.length, "writableIndexes"), BufferLayout2.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout2.seq(BufferLayout2.u8(), lookup4.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup4.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup4.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup4.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = guardedShift2(byteArray);
    const maskedPrefix = prefix & VERSION_PREFIX_MASK2;
    assert3(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version11 = maskedPrefix;
    assert3(version11 === 0, `Expected versioned message with version 0 but found version ${version11}`);
    const header = {
      numRequiredSignatures: guardedShift2(byteArray),
      numReadonlySignedAccounts: guardedShift2(byteArray),
      numReadonlyUnsignedAccounts: guardedShift2(byteArray)
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength2(byteArray);
    for (let i4 = 0; i4 < staticAccountKeysLength; i4++) {
      staticAccountKeys.push(new PublicKey3(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2)));
    }
    const recentBlockhash = import_bs582.default.encode(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2));
    const instructionCount = decodeLength2(byteArray);
    const compiledInstructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift2(byteArray);
      const accountKeyIndexesLength = decodeLength2(byteArray);
      const accountKeyIndexes = guardedSplice2(byteArray, 0, accountKeyIndexesLength);
      const dataLength = decodeLength2(byteArray);
      const data = new Uint8Array(guardedSplice2(byteArray, 0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength2(byteArray);
    const addressTableLookups = [];
    for (let i4 = 0; i4 < addressTableLookupsCount; i4++) {
      const accountKey = new PublicKey3(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2));
      const writableIndexesLength = decodeLength2(byteArray);
      const writableIndexes = guardedSplice2(byteArray, 0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength2(byteArray);
      const readonlyIndexes = guardedSplice2(byteArray, 0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new _MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
};
var VersionedMessage2 = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK2;
    if (maskedPrefix === prefix) {
      return "legacy";
    }
    return maskedPrefix;
  },
  deserialize: (serializedMessage) => {
    const version11 = VersionedMessage2.deserializeMessageVersion(serializedMessage);
    if (version11 === "legacy") {
      return Message2.from(serializedMessage);
    }
    if (version11 === 0) {
      return MessageV02.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version11} deserialization is not supported`);
    }
  }
};
var TransactionStatus2 = (function(TransactionStatus5) {
  TransactionStatus5[TransactionStatus5["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus5[TransactionStatus5["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus5[TransactionStatus5["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus5[TransactionStatus5["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus5;
})({});
var DEFAULT_SIGNATURE2 = import_buffer2.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES2).fill(0);
var TransactionInstruction2 = class {
  constructor(opts2) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = import_buffer2.Buffer.alloc(0);
    this.programId = opts2.programId;
    this.keys = opts2.keys;
    if (opts2.data) {
      this.data = opts2.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
};
var Transaction3 = class _Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts2) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts2) {
      return;
    }
    if (opts2.feePayer) {
      this.feePayer = opts2.feePayer;
    }
    if (opts2.signatures) {
      this.signatures = opts2.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts2, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts2;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts2, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts2;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts2;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey5
      }) => {
        return publicKey5.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction2(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i4 = 0; i4 < instructions.length; i4++) {
      if (instructions[i4].programId === void 0) {
        throw new Error(`Transaction instruction index ${i4} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey3(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x5, y5) {
      if (x5.isSigner !== y5.isSigner) {
        return x5.isSigner ? -1 : 1;
      }
      if (x5.isWritable !== y5.isWritable) {
        return x5.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x5.pubkey.toBase58().localeCompare(y5.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x5) => {
      return x5.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature4 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.equals(signature4.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature4.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs582.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert3(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert3(keyIndex >= 0));
    });
    return new Message2({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey5) => {
      const key = publicKey5.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature4 = sign2(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer2(signature4));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature4) {
    this._compile();
    this._addSignature(pubkey, signature4);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature4) {
    assert3(signature4.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = import_buffer2.Buffer.from(signature4);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature: signature4,
      publicKey: publicKey5
    } of this.signatures) {
      if (signature4 === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey5);
        }
      } else {
        if (!verify2(signature4, message, publicKey5.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey5);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength2(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = import_buffer2.Buffer.alloc(transactionLength);
    assert3(signatures.length < 256);
    import_buffer2.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature4
    }, index) => {
      if (signature4 !== null) {
        assert3(signature4.length === 64, `signature has invalid length`);
        import_buffer2.Buffer.from(signature4).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert3(wireTransaction.length <= PACKET_DATA_SIZE2, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE2}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength2(byteArray);
    let signatures = [];
    for (let i4 = 0; i4 < signatureCount; i4++) {
      const signature4 = guardedSplice2(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES2);
      signatures.push(import_bs582.default.encode(import_buffer2.Buffer.from(signature4)));
    }
    return _Transaction.populate(Message2.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message, signatures = []) {
    const transaction = new _Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature4, index) => {
      const sigPubkeyPair = {
        signature: signature4 == import_bs582.default.encode(DEFAULT_SIGNATURE2) ? null : import_bs582.default.decode(signature4),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys4 = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction2({
        keys: keys4,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs582.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
};
var VersionedTransaction3 = class _VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(message, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== void 0) {
      assert3(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i4 = 0; i4 < message.header.numRequiredSignatures; i4++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES2));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength2(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = BufferLayout2.struct([BufferLayout2.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout2.seq(signature2(), this.signatures.length, "signatures"), BufferLayout2.blob(serializedMessage.length, "serializedMessage")]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength2(byteArray);
    for (let i4 = 0; i4 < signaturesLength; i4++) {
      signatures.push(new Uint8Array(guardedSplice2(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES2)));
    }
    const message = VersionedMessage2.deserialize(new Uint8Array(byteArray));
    return new _VersionedTransaction(message, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
      assert3(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign2(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey5, signature4) {
    assert3(signature4.byteLength === 64, "Signature must be 64 bytes long");
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey5));
    assert3(signerIndex >= 0, `Can not add signature; \`${publicKey5.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature4;
  }
};
var NUM_TICKS_PER_SECOND2 = 160;
var DEFAULT_TICKS_PER_SLOT2 = 64;
var NUM_SLOTS_PER_SECOND2 = NUM_TICKS_PER_SECOND2 / DEFAULT_TICKS_PER_SLOT2;
var MS_PER_SLOT2 = 1e3 / NUM_SLOTS_PER_SECOND2;
var SYSVAR_CLOCK_PUBKEY2 = new PublicKey3("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY2 = new PublicKey3("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY2 = new PublicKey3("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY2 = new PublicKey3("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY2 = new PublicKey3("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY2 = new PublicKey3("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY2 = new PublicKey3("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY2 = new PublicKey3("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY2 = new PublicKey3("SysvarStakeHistory1111111111111111111111111");
var SendTransactionError2 = class extends Error {
  constructor({
    action,
    signature: signature4,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature4} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${/* @__PURE__ */ ((a3) => a3)(action)}'`;
      }
    }
    super(message);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature4;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
};
async function sendAndConfirmTransaction2(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature4 = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature: signature4,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature: signature4
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature4, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature4 != null) {
      throw new SendTransactionError2({
        action: "send",
        signature: signature4,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature4} failed (${JSON.stringify(status)})`);
  }
  return signature4;
}
function sleep2(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function encodeData2(type3, fields) {
  const allocLength = type3.layout.span >= 0 ? type3.layout.span : getAlloc2(type3, fields);
  const data = import_buffer2.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type3.index
  }, fields);
  type3.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout2 = BufferLayout2.nu64("lamportsPerSignature");
var NonceAccountLayout2 = BufferLayout2.struct([BufferLayout2.u32("version"), BufferLayout2.u32("state"), publicKey2("authorizedPubkey"), publicKey2("nonce"), BufferLayout2.struct([FeeCalculatorLayout2], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH2 = NonceAccountLayout2.span;
function u642(property) {
  const layout = (0, import_buffer_layout2.blob)(8, property);
  const decode9 = layout.decode.bind(layout);
  const encode16 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec2();
  bigIntLayout.decode = (buffer, offset5) => {
    const src2 = decode9(buffer, offset5);
    return codec.decode(src2);
  };
  bigIntLayout.encode = (bigInt, buffer, offset5) => {
    const src2 = codec.encode(bigInt);
    return encode16(src2, buffer, offset5);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS2 = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports"), BufferLayout2.ns64("space"), publicKey2("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u642("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("base"), rustString2("seed"), BufferLayout2.ns64("lamports"), BufferLayout2.ns64("space"), publicKey2("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("base"), rustString2("seed"), BufferLayout2.ns64("space"), publicKey2("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("base"), rustString2("seed"), publicKey2("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u642("lamports"), rustString2("seed"), publicKey2("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  }
});
var SystemProgram2 = class _SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.Create;
    const data = encodeData2(type3, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer2(params.programId.toBuffer())
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.TransferWithSeed;
      data = encodeData2(type3, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.Transfer;
      data = encodeData2(type3, {
        lamports: BigInt(params.lamports)
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction2({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.AssignWithSeed;
      data = encodeData2(type3, {
        base: toBuffer2(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.Assign;
      data = encodeData2(type3, {
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction2({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.CreateWithSeed;
    const data = encodeData2(type3, {
      base: toBuffer2(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer2(params.programId.toBuffer())
    });
    let keys4 = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys4.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction2({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction3();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(_SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH2,
        programId: this.programId
      }));
    } else {
      transaction.add(_SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH2,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.InitializeNonceAccount;
    const data = encodeData2(type3, {
      authorized: toBuffer2(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.AdvanceNonceAccount;
    const data = encodeData2(type3);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.WithdrawNonceAccount;
    const data = encodeData2(type3, {
      lamports: params.lamports
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.AuthorizeNonceAccount;
    const data = encodeData2(type3, {
      authorized: toBuffer2(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.AllocateWithSeed;
      data = encodeData2(type3, {
        base: toBuffer2(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS2.Allocate;
      data = encodeData2(type3, {
        space: params.space
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction2({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
SystemProgram2.programId = new PublicKey3("11111111111111111111111111111111");
var CHUNK_SIZE2 = PACKET_DATA_SIZE2 - 300;
var Loader2 = class _Loader {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Amount of program data placed in each load Transaction
   */
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * // Every transaction requires two signatures (payer + program)
    (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
    1);
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction3();
          transaction.add(SystemProgram2.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction3();
          transaction.add(SystemProgram2.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction3();
          transaction.add(SystemProgram2.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction3().add(SystemProgram2.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction2(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.u32("offset"), BufferLayout2.u32("bytesLength"), BufferLayout2.u32("bytesLengthPadding"), BufferLayout2.seq(BufferLayout2.u8("byte"), BufferLayout2.offset(BufferLayout2.u32(), -8), "bytes")]);
    const chunkSize = _Loader.chunkSize;
    let offset5 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes2 = array2.slice(0, chunkSize);
      const data2 = import_buffer2.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset: offset5,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction3().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction2(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep2(1e3 / REQUESTS_PER_SECOND);
      }
      offset5 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout2.struct([BufferLayout2.u32("instruction")]);
      const data2 = import_buffer2.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
        // Finalize instruction
      }, data2);
      const transaction = new Transaction3().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY2,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT2 / 2)));
      }
    }
    return true;
  }
};
Loader2.chunkSize = CHUNK_SIZE2;
var BPF_LOADER_PROGRAM_ID2 = new PublicKey3("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs2(x5) {
  return x5 && x5.__esModule && Object.prototype.hasOwnProperty.call(x5, "default") ? x5["default"] : x5;
}
var fastStableStringify$12;
var hasRequiredFastStableStringify2;
function requireFastStableStringify2() {
  if (hasRequiredFastStableStringify2) return fastStableStringify$12;
  hasRequiredFastStableStringify2 = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys4 = [];
    for (var name2 in obj) {
      keys4.push(name2);
    }
    return keys4;
  };
  function stringify6(val, isArrayProp) {
    var i4, max4, str, keys4, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify6(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str = "[";
            max4 = val.length - 1;
            for (i4 = 0; i4 < max4; i4++) {
              str += stringify6(val[i4], true) + ",";
            }
            if (max4 > -1) {
              str += stringify6(val[i4], true);
            }
            return str + "]";
          } else if (toStr === "[object Object]") {
            keys4 = objKeys(val).sort();
            max4 = keys4.length;
            str = "";
            i4 = 0;
            while (i4 < max4) {
              key = keys4[i4];
              propVal = stringify6(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i4++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$12 = function(val) {
    var returnVal = stringify6(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$12;
}
var fastStableStringifyExports2 = requireFastStableStringify2();
var fastStableStringify2 = getDefaultExportFromCjs2(fastStableStringifyExports2);
var fetchImpl2 = globalThis.fetch;
var LookupTableMetaLayout2 = {
  index: 1,
  layout: BufferLayout2.struct([
    BufferLayout2.u32("typeIndex"),
    u642("deactivationSlot"),
    BufferLayout2.nu64("lastExtendedSlot"),
    BufferLayout2.u8("lastExtendedStartIndex"),
    BufferLayout2.u8(),
    // option
    BufferLayout2.seq(publicKey2(), BufferLayout2.offset(BufferLayout2.u8(), -1), "authority")
  ])
};
var PublicKeyFromString2 = coerce(instance(PublicKey3), string(), (value) => new PublicKey3(value));
var RawAccountDataResult2 = tuple([string(), literal("base64")]);
var BufferFromRawAccountData2 = coerce(instance(import_buffer2.Buffer), RawAccountDataResult2, (value) => import_buffer2.Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS2 = 30 * 1e3;
function createRpcResult2(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult2 = createRpcResult2(unknown());
function jsonRpcResult2(schema) {
  return coerce(createRpcResult2(schema), UnknownRpcResult2, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext2(value) {
  return jsonRpcResult2(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext2(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
var GetInflationGovernorResult2 = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
var GetInflationRewardResult2 = jsonRpcResult2(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
var GetRecentPrioritizationFeesResult2 = array(type({
  slot: number(),
  prioritizationFee: number()
}));
var GetInflationRateResult2 = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});
var GetEpochInfoResult2 = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult2 = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
var GetLeaderScheduleResult2 = record(string(), array(number()));
var TransactionErrorResult2 = nullable(union([type({}), string()]));
var SignatureStatusResult2 = type({
  err: TransactionErrorResult2
});
var SignatureReceivedResult2 = literal("receivedSignature");
var VersionResult2 = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
var ParsedInstructionStruct2 = type({
  program: string(),
  programId: PublicKeyFromString2,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct2 = type({
  programId: PublicKeyFromString2,
  accounts: array(PublicKeyFromString2),
  data: string()
});
var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct2, PartiallyDecodedInstructionStruct2]))
  }))))
}));
var BlockProductionResponseStruct2 = jsonRpcResultAndContext2(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
var GetInflationGovernorRpcResult2 = jsonRpcResult2(GetInflationGovernorResult2);
var GetInflationRateRpcResult2 = jsonRpcResult2(GetInflationRateResult2);
var GetRecentPrioritizationFeesRpcResult2 = jsonRpcResult2(GetRecentPrioritizationFeesResult2);
var GetEpochInfoRpcResult2 = jsonRpcResult2(GetEpochInfoResult2);
var GetEpochScheduleRpcResult2 = jsonRpcResult2(GetEpochScheduleResult2);
var GetLeaderScheduleRpcResult2 = jsonRpcResult2(GetLeaderScheduleResult2);
var SlotRpcResult2 = jsonRpcResult2(number());
var GetSupplyRpcResult2 = jsonRpcResultAndContext2(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString2)
}));
var TokenAmountResult2 = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult2 = jsonRpcResultAndContext2(array(type({
  address: PublicKeyFromString2,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner2 = jsonRpcResultAndContext2(array(type({
  pubkey: PublicKeyFromString2,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString2,
    lamports: number(),
    data: BufferFromRawAccountData2,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult2 = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
var GetParsedTokenAccountsByOwner2 = jsonRpcResultAndContext2(array(type({
  pubkey: PublicKeyFromString2,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString2,
    lamports: number(),
    data: ParsedAccountDataResult2,
    rentEpoch: number()
  })
})));
var GetLargestAccountsRpcResult2 = jsonRpcResultAndContext2(array(type({
  lamports: number(),
  address: PublicKeyFromString2
})));
var AccountInfoResult2 = type({
  executable: boolean(),
  owner: PublicKeyFromString2,
  lamports: number(),
  data: BufferFromRawAccountData2,
  rentEpoch: number()
});
var KeyedAccountInfoResult2 = type({
  pubkey: PublicKeyFromString2,
  account: AccountInfoResult2
});
var ParsedOrRawAccountData2 = coerce(union([instance(import_buffer2.Buffer), ParsedAccountDataResult2]), union([RawAccountDataResult2, ParsedAccountDataResult2]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData2);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult2 = type({
  executable: boolean(),
  owner: PublicKeyFromString2,
  lamports: number(),
  data: ParsedOrRawAccountData2,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult2 = type({
  pubkey: PublicKeyFromString2,
  account: ParsedAccountInfoResult2
});
var StakeActivationResult2 = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
var GetConfirmedSignaturesForAddress2RpcResult2 = jsonRpcResult2(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult2,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var GetSignaturesForAddressRpcResult2 = jsonRpcResult2(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult2,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var AccountNotificationResult2 = type({
  subscription: number(),
  result: notificationResultAndContext2(AccountInfoResult2)
});
var ProgramAccountInfoResult2 = type({
  pubkey: PublicKeyFromString2,
  account: AccountInfoResult2
});
var ProgramAccountNotificationResult2 = type({
  subscription: number(),
  result: notificationResultAndContext2(ProgramAccountInfoResult2)
});
var SlotInfoResult2 = type({
  parent: number(),
  slot: number(),
  root: number()
});
var SlotNotificationResult2 = type({
  subscription: number(),
  result: SlotInfoResult2
});
var SlotUpdateResult2 = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
var SlotUpdateNotificationResult2 = type({
  subscription: number(),
  result: SlotUpdateResult2
});
var SignatureNotificationResult2 = type({
  subscription: number(),
  result: notificationResultAndContext2(union([SignatureStatusResult2, SignatureReceivedResult2]))
});
var RootNotificationResult2 = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult2 = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult2 = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
var GetVoteAccounts2 = jsonRpcResult2(type({
  current: array(VoteAccountInfoResult2),
  delinquent: array(VoteAccountInfoResult2)
}));
var ConfirmationStatus2 = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse2 = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult2,
  confirmationStatus: optional(ConfirmationStatus2)
});
var GetSignatureStatusesRpcResult2 = jsonRpcResultAndContext2(array(nullable(SignatureStatusResponse2)));
var GetMinimumBalanceForRentExemptionRpcResult2 = jsonRpcResult2(number());
var AddressTableLookupStruct2 = type({
  accountKey: PublicKeyFromString2,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult2 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct2))
  })
});
var AnnotatedAccountKey2 = type({
  pubkey: PublicKeyFromString2,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult2 = type({
  accountKeys: array(AnnotatedAccountKey2),
  signatures: array(string())
});
var ParsedInstructionResult2 = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString2
});
var RawInstructionResult2 = type({
  accounts: array(PublicKeyFromString2),
  data: string(),
  programId: PublicKeyFromString2
});
var InstructionResult2 = union([RawInstructionResult2, ParsedInstructionResult2]);
var UnknownInstructionResult2 = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction2 = coerce(InstructionResult2, UnknownInstructionResult2, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult2);
  } else {
    return create(value, ParsedInstructionResult2);
  }
});
var ParsedConfirmedTransactionResult2 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey2),
    instructions: array(ParsedOrRawInstruction2),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct2)))
  })
});
var TokenBalanceResult2 = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult2
});
var LoadedAddressesResult2 = type({
  writable: array(PublicKeyFromString2),
  readonly: array(PublicKeyFromString2)
});
var ConfirmedTransactionMetaResult2 = type({
  err: TransactionErrorResult2,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult2))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult2))),
  loadedAddresses: optional(LoadedAddressesResult2),
  computeUnitsConsumed: optional(number())
});
var ParsedConfirmedTransactionMetaResult2 = type({
  err: TransactionErrorResult2,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction2)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult2))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult2))),
  loadedAddresses: optional(LoadedAddressesResult2),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct2 = union([literal(0), literal("legacy")]);
var RewardsResult2 = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
var GetBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult2,
    meta: nullable(ConfirmedTransactionMetaResult2),
    version: optional(TransactionVersionStruct2)
  })),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetNoneModeBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetAccountsModeBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult2,
    meta: nullable(ConfirmedTransactionMetaResult2),
    version: optional(TransactionVersionStruct2)
  })),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult2,
    meta: nullable(ParsedConfirmedTransactionMetaResult2),
    version: optional(TransactionVersionStruct2)
  })),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedAccountsModeBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult2,
    meta: nullable(ParsedConfirmedTransactionMetaResult2),
    version: optional(TransactionVersionStruct2)
  })),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedNoneModeBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetConfirmedBlockRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult2,
    meta: nullable(ConfirmedTransactionMetaResult2)
  })),
  rewards: optional(array(RewardsResult2)),
  blockTime: nullable(number())
})));
var GetBlockSignaturesRpcResult2 = jsonRpcResult2(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
var GetTransactionRpcResult2 = jsonRpcResult2(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult2),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult2,
  version: optional(TransactionVersionStruct2)
})));
var GetParsedTransactionRpcResult2 = jsonRpcResult2(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult2,
  meta: nullable(ParsedConfirmedTransactionMetaResult2),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct2)
})));
var GetLatestBlockhashRpcResult2 = jsonRpcResultAndContext2(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
var IsBlockhashValidRpcResult2 = jsonRpcResultAndContext2(boolean());
var PerfSampleResult2 = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
var GetRecentPerformanceSamplesRpcResult2 = jsonRpcResult2(array(PerfSampleResult2));
var GetFeeCalculatorRpcResult2 = jsonRpcResultAndContext2(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
var RequestAirdropRpcResult2 = jsonRpcResult2(string());
var SendTransactionRpcResult2 = jsonRpcResult2(string());
var LogsResult2 = type({
  err: TransactionErrorResult2,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult2 = type({
  result: notificationResultAndContext2(LogsResult2),
  subscription: number()
});
var Keypair2 = class _Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair2();
  }
  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  static generate() {
    return new _Keypair(generateKeypair2());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey5 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey2(privateScalar);
      for (let ii3 = 0; ii3 < 32; ii3++) {
        if (publicKey5[ii3] !== computedPublicKey[ii3]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */
  static fromSeed(seed) {
    const publicKey5 = getPublicKey2(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey5, 32);
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */
  get publicKey() {
    return new PublicKey3(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
};
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS2 = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u642("recentSlot"), BufferLayout2.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u642(), BufferLayout2.seq(publicKey2(), BufferLayout2.offset(BufferLayout2.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  }
});
var AddressLookupTableProgram2 = class {
  /**
   * @internal
   */
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey3.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder2().encode(params.recentSlot)], this.programId);
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CreateLookupTable;
    const data = encodeData2(type3, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys4 = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram2.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction2({
      programId: this.programId,
      keys: keys4,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.FreezeLookupTable;
    const data = encodeData2(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction2({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static extendLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.ExtendLookupTable;
    const data = encodeData2(type3, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys4.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram2.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction2({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.DeactivateLookupTable;
    const data = encodeData2(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction2({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static closeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CloseLookupTable;
    const data = encodeData2(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction2({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
};
AddressLookupTableProgram2.programId = new PublicKey3("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2 = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), BufferLayout2.u32("units"), BufferLayout2.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), BufferLayout2.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), BufferLayout2.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), u642("microLamports")])
  }
});
var ComputeBudgetProgram2 = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestUnits;
    const data = encodeData2(type3, params);
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestHeapFrame;
    const data = encodeData2(type3, params);
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitLimit;
    const data = encodeData2(type3, params);
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitPrice;
    const data = encodeData2(type3, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
};
ComputeBudgetProgram2.programId = new PublicKey3("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$12 = 64;
var PUBLIC_KEY_BYTES$12 = 32;
var SIGNATURE_BYTES2 = 64;
var ED25519_INSTRUCTION_LAYOUT2 = BufferLayout2.struct([BufferLayout2.u8("numSignatures"), BufferLayout2.u8("padding"), BufferLayout2.u16("signatureOffset"), BufferLayout2.u16("signatureInstructionIndex"), BufferLayout2.u16("publicKeyOffset"), BufferLayout2.u16("publicKeyInstructionIndex"), BufferLayout2.u16("messageDataOffset"), BufferLayout2.u16("messageDataSize"), BufferLayout2.u16("messageInstructionIndex")]);
var Ed25519Program2 = class _Ed25519Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the ed25519 program
   */
  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      instructionIndex
    } = params;
    assert3(publicKey5.length === PUBLIC_KEY_BYTES$12, `Public Key must be ${PUBLIC_KEY_BYTES$12} bytes but received ${publicKey5.length} bytes`);
    assert3(signature4.length === SIGNATURE_BYTES2, `Signature must be ${SIGNATURE_BYTES2} bytes but received ${signature4.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT2.span;
    const signatureOffset = publicKeyOffset + publicKey5.length;
    const messageDataOffset = signatureOffset + signature4.length;
    const numSignatures = 1;
    const instructionData = import_buffer2.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT2.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey5, publicKeyOffset);
    instructionData.fill(signature4, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction2({
      keys: [],
      programId: _Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert3(privateKey.length === PRIVATE_KEY_BYTES$12, `Private key must be ${PRIVATE_KEY_BYTES$12} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair2.fromSecretKey(privateKey);
      const publicKey5 = keypair.publicKey.toBytes();
      const signature4 = sign2(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program2.programId = new PublicKey3("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign2 = (msgHash, privKey) => {
  const signature4 = secp256k12.sign(msgHash, privKey);
  return [signature4.toCompactRawBytes(), signature4.recovery];
};
secp256k12.utils.isValidPrivateKey;
var publicKeyCreate2 = secp256k12.getPublicKey;
var PRIVATE_KEY_BYTES2 = 32;
var ETHEREUM_ADDRESS_BYTES2 = 20;
var PUBLIC_KEY_BYTES2 = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE2 = 11;
var SECP256K1_INSTRUCTION_LAYOUT2 = BufferLayout2.struct([BufferLayout2.u8("numSignatures"), BufferLayout2.u16("signatureOffset"), BufferLayout2.u8("signatureInstructionIndex"), BufferLayout2.u16("ethAddressOffset"), BufferLayout2.u8("ethAddressInstructionIndex"), BufferLayout2.u16("messageDataOffset"), BufferLayout2.u16("messageDataSize"), BufferLayout2.u8("messageInstructionIndex"), BufferLayout2.blob(20, "ethAddress"), BufferLayout2.blob(64, "signature"), BufferLayout2.u8("recoveryId")]);
var Secp256k1Program2 = class _Secp256k1Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the secp256k1 program
   */
  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey5) {
    assert3(publicKey5.length === PUBLIC_KEY_BYTES2, `Public key must be ${PUBLIC_KEY_BYTES2} bytes but received ${publicKey5.length} bytes`);
    try {
      return import_buffer2.Buffer.from(keccak_256(toBuffer2(publicKey5))).slice(-ETHEREUM_ADDRESS_BYTES2);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    } = params;
    return _Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey5),
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress3;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress3 = import_buffer2.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress3 = import_buffer2.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress3 = rawAddress;
    }
    assert3(ethAddress3.length === ETHEREUM_ADDRESS_BYTES2, `Address must be ${ETHEREUM_ADDRESS_BYTES2} bytes but received ${ethAddress3.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE2;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress3.length;
    const messageDataOffset = signatureOffset + signature4.length + 1;
    const numSignatures = 1;
    const instructionData = import_buffer2.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT2.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT2.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer2(signature4),
      ethAddress: toBuffer2(ethAddress3),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer2(message), SECP256K1_INSTRUCTION_LAYOUT2.span);
    return new TransactionInstruction2({
      keys: [],
      programId: _Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert3(pkey.length === PRIVATE_KEY_BYTES2, `Private key must be ${PRIVATE_KEY_BYTES2} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer2(pkey);
      const publicKey5 = publicKeyCreate2(
        privateKey,
        false
        /* isCompressed */
      ).slice(1);
      const messageHash = import_buffer2.Buffer.from(keccak_256(toBuffer2(message)));
      const [signature4, recoveryId] = ecdsaSign2(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program2.programId = new PublicKey3("KeccakSecp256k11111111111111111111111111111");
var _Lockup2;
var STAKE_CONFIG_ID2 = new PublicKey3("StakeConfig11111111111111111111111111111111");
var Lockup2 = class {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
_Lockup2 = Lockup2;
Lockup2.default = new _Lockup2(0, 0, PublicKey3.default);
var STAKE_INSTRUCTION_LAYOUTS2 = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), authorized2(), lockup2()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("newAuthorized"), BufferLayout2.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("newAuthorized"), BufferLayout2.u32("stakeAuthorizationType"), rustString2("authoritySeed"), publicKey2("authorityOwner")])
  }
});
var StakeAuthorizationLayout2 = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram2 = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Stake program
   */
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: maybeLockup
    } = params;
    const lockup5 = maybeLockup || Lockup2.default;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Initialize;
    const data = encodeData2(type3, {
      authorized: {
        staker: toBuffer2(authorized5.staker.toBuffer()),
        withdrawer: toBuffer2(authorized5.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup5.unixTimestamp,
        epoch: lockup5.epoch,
        custodian: toBuffer2(lockup5.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction3();
    transaction.add(SystemProgram2.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction3();
    transaction.add(SystemProgram2.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Delegate;
    const data = encodeData2(type3);
    return new Transaction3().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Authorize;
    const data = encodeData2(type3, {
      newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed;
    const data = encodeData2(type3, {
      newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer2(authorityOwner.toBuffer())
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Split;
    const data = encodeData2(type3, {
      lamports
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params, rentExemptReserve) {
    const transaction = new Transaction3();
    transaction.add(SystemProgram2.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction3();
    transaction.add(SystemProgram2.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram2.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Merge;
    const data = encodeData2(type3);
    return new Transaction3().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Withdraw;
    const data = encodeData2(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS2.Deactivate;
    const data = encodeData2(type3);
    return new Transaction3().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram2.programId = new PublicKey3("Stake11111111111111111111111111111111111111");
StakeProgram2.space = 200;
var VOTE_INSTRUCTION_LAYOUTS2 = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), voteInit2()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("newAuthorized"), BufferLayout2.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), voteAuthorizeWithSeedArgs2()])
  }
});
var VoteAuthorizationLayout2 = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var VoteProgram2 = class _VoteProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Vote program
   */
  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit5
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS2.InitializeAccount;
    const data = encodeData2(type3, {
      voteInit: {
        nodePubkey: toBuffer2(voteInit5.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer2(voteInit5.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer2(voteInit5.authorizedWithdrawer.toBuffer()),
        commission: voteInit5.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction3();
    transaction.add(SystemProgram2.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS2.Authorize;
    const data = encodeData2(type3, {
      newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed;
    const data = encodeData2(type3, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer2(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS2.Withdraw;
    const data = encodeData2(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return _VoteProgram.withdraw(params);
  }
  /**
   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
   */
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS2.UpdateValidatorIdentity;
    const data = encodeData2(type3);
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
VoteProgram2.programId = new PublicKey3("Vote111111111111111111111111111111111111111");
VoteProgram2.space = 3762;
var VALIDATOR_INFO_KEY2 = new PublicKey3("Va1idator1nfo111111111111111111111111111111");
var InfoString2 = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID2 = new PublicKey3("Vote111111111111111111111111111111111111111");
var VoteAccountLayout2 = BufferLayout2.struct([
  publicKey2("nodePubkey"),
  publicKey2("authorizedWithdrawer"),
  BufferLayout2.u8("commission"),
  BufferLayout2.nu64(),
  // votes.length
  BufferLayout2.seq(BufferLayout2.struct([BufferLayout2.nu64("slot"), BufferLayout2.u32("confirmationCount")]), BufferLayout2.offset(BufferLayout2.u32(), -8), "votes"),
  BufferLayout2.u8("rootSlotValid"),
  BufferLayout2.nu64("rootSlot"),
  BufferLayout2.nu64(),
  // authorizedVoters.length
  BufferLayout2.seq(BufferLayout2.struct([BufferLayout2.nu64("epoch"), publicKey2("authorizedVoter")]), BufferLayout2.offset(BufferLayout2.u32(), -8), "authorizedVoters"),
  BufferLayout2.struct([BufferLayout2.seq(BufferLayout2.struct([publicKey2("authorizedPubkey"), BufferLayout2.nu64("epochOfLastAuthorizedSwitch"), BufferLayout2.nu64("targetEpoch")]), 32, "buf"), BufferLayout2.nu64("idx"), BufferLayout2.u8("isEmpty")], "priorVoters"),
  BufferLayout2.nu64(),
  // epochCredits.length
  BufferLayout2.seq(BufferLayout2.struct([BufferLayout2.nu64("epoch"), BufferLayout2.nu64("credits"), BufferLayout2.nu64("prevCredits")]), BufferLayout2.offset(BufferLayout2.u32(), -8), "epochCredits"),
  BufferLayout2.struct([BufferLayout2.nu64("slot"), BufferLayout2.nu64("timestamp")], "lastTimestamp")
]);

// node_modules/@dynamic-labs/solana/node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f8) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f8) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f8 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f8.call(receiver, value) : f8 ? f8.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f8) {
  if (kind === "a" && !f8) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f8 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f8 : kind === "a" ? f8.call(receiver) : f8 ? f8.value : state.get(receiver);
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registered = /* @__PURE__ */ new Set();
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get: get2, on });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  var _a21;
  wallets2 = wallets2.filter((wallet) => !registered.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => registered.add(wallet));
  (_a21 = listeners["register"]) == null ? void 0 : _a21.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    var _a22;
    wallets2.forEach((wallet) => registered.delete(wallet));
    (_a22 = listeners["unregister"]) == null ? void 0 : _a22.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
function get2() {
  return [...registered];
}
function on(event, listener) {
  var _a21;
  ((_a21 = listeners[event]) == null ? void 0 : _a21.push(listener)) || (listeners[event] = [listener]);
  return function off() {
    var _a22;
    listeners[event] = (_a22 = listeners[event]) == null ? void 0 : _a22.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@dynamic-labs/solana/src/injected/walletStandard/findWalletProviderFromWalletStandard/findWalletProviderFromWalletStandard.js
var findWalletProviderFromWalletStandard = (injectConfig) => {
  const { walletStandardLocators } = injectConfig;
  if (!walletStandardLocators || walletStandardLocators.length === 0) {
    return void 0;
  }
  const wallets2 = getWallets().get();
  return walletStandardLocators.reduce((provider, walletStandardLocator) => {
    if (provider) {
      return provider;
    }
    const wallet = wallets2.find((w4) => w4.name === walletStandardLocator.name);
    if (!wallet)
      return void 0;
    return get(wallet, walletStandardLocator.locator);
  }, void 0);
};

// node_modules/@dynamic-labs/solana/src/utils/isSignedMessage.js
var isSignedMessage = (message) => Boolean(message) && message.signature !== void 0;

// node_modules/@dynamic-labs/solana/src/SolProviderHelper/SolProviderHelper.js
var SolProviderHelper = class {
  constructor(connector) {
    this.walletBookWallet = findWalletBookWallet(connector.walletBook, connector.key);
    this.connector = connector;
  }
  getInjectedConfig() {
    var _a21;
    const injectedConfig = (_a21 = this.walletBookWallet) === null || _a21 === void 0 ? void 0 : _a21.injectedConfig;
    return injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.find((c6) => c6.chain === this.connector.connectedChain.toLowerCase());
  }
  getInstalledProvider() {
    const config = this.getInjectedConfig();
    if (!config || !config.extensionLocators) {
      return void 0;
    }
    return this.installedProviderLookup(config.extensionLocators);
  }
  installedProviders() {
    var _a21, _b;
    const config = this.getInjectedConfig();
    if (!config)
      return [];
    const providers = [];
    if (config.windowLocations) {
      for (const windowLocation of config.windowLocations) {
        const foundProviders = getProvidersFromWindow(windowLocation);
        if (foundProviders && foundProviders.length) {
          providers.push(...foundProviders);
        }
      }
    }
    if (config.extensionLocators.length !== 0 && window.solana) {
      if (!window.solana.providers) {
        providers.push(window.solana);
      } else {
        window.solana.providers.forEach((provider) => providers.push(provider));
      }
    }
    if (((_b = (_a21 = config.walletStandardLocators) === null || _a21 === void 0 ? void 0 : _a21.length) !== null && _b !== void 0 ? _b : 0) > 0) {
      const walletStandardProvider = findWalletProviderFromWalletStandard(config);
      if (walletStandardProvider) {
        providers.push(walletStandardProvider);
      }
    }
    return providers;
  }
  installedProviderLookup(extensionLocators) {
    const allInstalledProviders = this.installedProviders();
    if (extensionLocators.length === 0) {
      return allInstalledProviders[0];
    }
    return ProviderLookup(allInstalledProviders, extensionLocators);
  }
  findProvider() {
    return this.connector.findProvider();
  }
  isInstalledHelper() {
    return this.findProvider() !== void 0;
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      const provider = this.findProvider();
      if (!provider) {
        return void 0;
      }
      yield provider.connect();
      return (_a21 = provider.publicKey) === null || _a21 === void 0 ? void 0 : _a21.toString();
    });
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      const provider = this.findProvider();
      if (!provider) {
        logger.error("No Solanaprovider found to connect", {
          connector: this.connector.name
        });
        return void 0;
      }
      try {
        if (!provider.isConnected) {
          yield provider.connect();
        }
        return provider;
      } catch (err) {
        logger.error("Error connecting to Solanaprovider", {
          connector: this.connector.name,
          error: err
        });
        return void 0;
      }
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const walletAddress = yield this.getAddress();
      if (!walletAddress)
        return void 0;
      const provider = this.findProvider();
      if (!provider)
        return void 0;
      const encodedMessage = new TextEncoder().encode(messageToSign);
      const signedMessage = yield provider.signMessage(encodedMessage, "utf8");
      if (!signedMessage)
        return void 0;
      return bufferToBase64(isSignedMessage(signedMessage) ? signedMessage.signature : signedMessage);
    });
  }
  handleAccountChange(walletConnector, web3Provider, address) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      if (!address) {
        yield web3Provider === null || web3Provider === void 0 ? void 0 : web3Provider.connect();
        if ((_a21 = web3Provider === null || web3Provider === void 0 ? void 0 : web3Provider.publicKey) === null || _a21 === void 0 ? void 0 : _a21.toString()) {
          walletConnector.emit("accountChange", {
            accounts: [web3Provider.publicKey.toString()]
          });
        }
        return;
      }
      if (address.toString()) {
        walletConnector.emit("accountChange", { accounts: [address.toString()] });
      }
    });
  }
  _setupEventListeners() {
    const provider = this.findProvider();
    if (!provider) {
      logger.warn("Provider not found", {
        connector: this.connector
      });
      return;
    }
    if (!provider.on) {
      logger.warn("Provider does not support event listeners", {
        connector: this.connector,
        provider
      });
      return;
    }
    provider.on("accountChanged", (publicKey5) => this.handleAccountChange(this.connector, provider, publicKey5));
    provider.on("disconnect", () => this.connector.emit("disconnect"));
  }
  _teardownEventListeners() {
    const provider = this.findProvider();
    if (!provider)
      return;
    provider.removeAllListeners();
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b;
      const provider = this.findProvider();
      if (!provider)
        return [];
      let connectionResult;
      try {
        if (!provider.isConnected) {
          connectionResult = yield provider.connect({ onlyIfTrusted: true });
        }
      } catch (e2) {
        return [];
      }
      const address = connectionResult === null || connectionResult === void 0 ? void 0 : connectionResult.address;
      if (address) {
        return [address];
      }
      try {
        const publicKey5 = (_a21 = connectionResult === null || connectionResult === void 0 ? void 0 : connectionResult.publicKey) !== null && _a21 !== void 0 ? _a21 : (_b = provider.publicKey) === null || _b === void 0 ? void 0 : _b.toString();
        if (publicKey5)
          return [publicKey5 === null || publicKey5 === void 0 ? void 0 : publicKey5.toString()];
      } catch (e2) {
        logger.debug("Error getting public key", {
          connector: this.connector,
          error: e2
        });
      }
      return [];
    });
  }
};

// node_modules/@dynamic-labs/solana/src/errors/SignMessageNotSupportedError.js
var SignMessageNotSupportedError = class extends NotSupportedError {
  constructor(walletName) {
    super(`Message signing is currently not supported on ${walletName} hardware wallet.
    You can use signMessageViaTransaction instead to achieve similar functionality
    by signing a transaction with a memo instruction.
    You can read more about it here https://github.com/solana-labs/solana/issues/21366`);
  }
};

// node_modules/@dynamic-labs/solana/src/utils/logger.js
var logger2 = new Logger("solana");

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to5, from13, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l6 = from13.length, ar3; i4 < l6; i4++) {
    if (ar3 || !(i4 in from13)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from13, 0, i4);
      ar3[i4] = from13[i4];
    }
  }
  return to5.concat(ar3 || Array.prototype.slice.call(from13));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BrowserInfo2(name2, version11, os2) {
      this.name = name2;
      this.version = version11;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  })()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function NodeInfo2(version11) {
      this.version = version11;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  })()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SearchBotDeviceInfo2(name2, version11, os2, bot) {
      this.name = name2;
      this.version = version11;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  })()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  })()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  })()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a21) {
    var browser = _a21[0], regex = _a21[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match14 = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match14[1] && match14[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version11 = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version11, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version11, os2);
}
function detectOS(ua2) {
  for (var ii3 = 0, count = operatingSystemRules.length; ii3 < count; ii3++) {
    var _a21 = operatingSystemRules[ii3], os2 = _a21[0], regex = _a21[1];
    var match14 = regex.exec(ua2);
    if (match14) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii3 = 0; ii3 < count; ii3++) {
    output2.push("0");
  }
  return output2;
}

// node_modules/@dynamic-labs/solana/node_modules/@walletconnect/utils/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count);
}

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
  size: 32
});

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4, E: E4 } = this;
    return [A4, B3, C4, D4, E4];
  }
  set(A4, B3, C4, D4, E4) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
    this.E = E4 | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4)
      SHA1_W[i4] = view.getUint32(offset5, false);
    for (let i4 = 16; i4 < 80; i4++)
      SHA1_W[i4] = rotl(SHA1_W[i4 - 3] ^ SHA1_W[i4 - 8] ^ SHA1_W[i4 - 14] ^ SHA1_W[i4 - 16], 1);
    let { A: A4, B: B3, C: C4, D: D4, E: E4 } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      let F5, K4;
      if (i4 < 20) {
        F5 = Chi(B3, C4, D4);
        K4 = 1518500249;
      } else if (i4 < 40) {
        F5 = B3 ^ C4 ^ D4;
        K4 = 1859775393;
      } else if (i4 < 60) {
        F5 = Maj(B3, C4, D4);
        K4 = 2400959708;
      } else {
        F5 = B3 ^ C4 ^ D4;
        K4 = 3395469782;
      }
      const T3 = rotl(A4, 5) + F5 + E4 + K4 + SHA1_W[i4] | 0;
      E4 = D4;
      D4 = C4;
      C4 = rotl(B3, 30);
      B3 = A4;
      A4 = T3;
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    E4 = E4 + this.E | 0;
    this.set(A4, B3, C4, D4, E4);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_3, i4) => Math.floor(p32 * Math.abs(Math.sin(i4 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4 } = this;
    return [A4, B3, C4, D4];
  }
  set(A4, B3, C4, D4) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4)
      MD5_W[i4] = view.getUint32(offset5, true);
    let { A: A4, B: B3, C: C4, D: D4 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      let F5, g3, s3;
      if (i4 < 16) {
        F5 = Chi(B3, C4, D4);
        g3 = i4;
        s3 = [7, 12, 17, 22];
      } else if (i4 < 32) {
        F5 = Chi(D4, B3, C4);
        g3 = (5 * i4 + 1) % 16;
        s3 = [5, 9, 14, 20];
      } else if (i4 < 48) {
        F5 = B3 ^ C4 ^ D4;
        g3 = (3 * i4 + 5) % 16;
        s3 = [4, 11, 16, 23];
      } else {
        F5 = C4 ^ (B3 | ~D4);
        g3 = 7 * i4 % 16;
        s3 = [6, 10, 15, 21];
      }
      F5 = F5 + A4 + K[i4] + MD5_W[g3];
      A4 = D4;
      D4 = C4;
      C4 = B3;
      B3 = B3 + rotl(F5, s3[i4 % 4]);
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    this.set(A4, B3, C4, D4);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_3, i4) => i4)))();
var Pi160 = (() => Id160.map((i4) => (9 * i4 + 5) % 16))();
var idxLR = (() => {
  const L3 = [Id160];
  const R3 = [Pi160];
  const res = [L3, R3];
  for (let i4 = 0; i4 < 4; i4++)
    for (let j3 of res)
      j3.push(j3[i4].map((k6) => Rho160[k6]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i4) => Uint8Array.from(i4));
var shiftsL160 = idxL.map((idx, i4) => idx.map((j3) => shifts160[i4][j3]));
var shiftsR160 = idxR.map((idx, i4) => idx.map((j3) => shifts160[i4][j3]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x5, y5, z4) {
  if (group === 0)
    return x5 ^ y5 ^ z4;
  if (group === 1)
    return x5 & y5 | ~x5 & z4;
  if (group === 2)
    return (x5 | ~y5) ^ z4;
  if (group === 3)
    return x5 & z4 | y5 & ~z4;
  return x5 ^ (y5 | ~z4);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4)
      BUF_160[i4] = view.getUint32(offset5, true);
    let al = this.h0 | 0, ar3 = al, bl = this.h1 | 0, br4 = bl, cl = this.h2 | 0, cr4 = cl, dl = this.h3 | 0, dr4 = dl, el = this.h4 | 0, er3 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr4 = idxR[group];
      const sl = shiftsL160[group], sr4 = shiftsR160[group];
      for (let i4 = 0; i4 < 16; i4++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i4]] + hbl, sl[i4]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i4 = 0; i4 < 16; i4++) {
        const tr4 = rotl(ar3 + ripemd_f(rGroup, br4, cr4, dr4) + BUF_160[rr4[i4]] + hbr, sr4[i4]) + er3 | 0;
        ar3 = er3, er3 = dr4, dr4 = rotl(cr4, 10) | 0, cr4 = br4, br4 = tr4;
      }
    }
    this.set(this.h1 + cl + dr4 | 0, this.h2 + dl + er3 | 0, this.h3 + el + ar3 | 0, this.h4 + al + br4 | 0, this.h0 + bl + cr4 | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@dynamic-labs/solana/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/Hash.js
function keccak2563(value, options = {}) {
  const { as: as16 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes2 = keccak_256(from(value));
  if (as16 === "Bytes")
    return bytes2;
  return fromBytes(bytes2);
}

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/internal/lru.js
var LruMap3 = class extends Map {
  constructor(size9) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size9;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap3(8192)
};
var checksum = caches.checksum;

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert4(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert4(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2563(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hash[i4 >> 1] >> 4 >= 8 && characters[i4]) {
      characters[i4] = characters[i4].toUpperCase();
    }
    if ((hash[i4 >> 1] & 15) >= 8 && characters[i4 + 1]) {
      characters[i4 + 1] = characters[i4 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset5) {
    if (offset5 < 0)
      throw new NegativeOffsetError({ offset: offset5 });
    const position = this.position - offset5;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset5) {
    if (offset5 < 0)
      throw new NegativeOffsetError({ offset: offset5 });
    const position = this.position + offset5;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length2, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length2 - 1);
    return this.bytes.subarray(position, position + length2);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length2, size9) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length2);
    this.position += size9 ?? length2;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError {
  constructor({ offset: offset5 }) {
    super(`Offset \`${offset5}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError {
  constructor({ length: length2, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length2}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError {
  constructor({ count, limit: limit2 }) {
    super(`Recursive read limit of \`${limit2}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@dynamic-labs/solana/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i4 = 0; i4 < types.length; i4++) {
    const type3 = types[i4];
    const value = values[i4];
    data.push(encodePacked2.encode(type3, value));
  }
  return concat(...data);
}
(function(encodePacked5) {
  function encode16(type3, value, isArray4 = false) {
    if (type3 === "address") {
      const address = value;
      assert4(address);
      return padLeft(address.toLowerCase(), isArray4 ? 32 : 0);
    }
    if (type3 === "string")
      return fromString2(value);
    if (type3 === "bytes")
      return value;
    if (type3 === "bool")
      return padLeft(fromBoolean(value), isArray4 ? 32 : 1);
    const intMatch = type3.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size9 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray4 ? 32 : size9,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type3.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size9] = bytesMatch;
      if (Number.parseInt(size9) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size9),
          value
        });
      return padRight(value, isArray4 ? 32 : 0);
    }
    const arrayMatch = type3.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i4 = 0; i4 < value.length; i4++) {
        data.push(encode16(childType, value[i4], true));
      }
      if (data.length === 0)
        return "0x";
      return concat(...data);
    }
    throw new InvalidTypeError(type3);
  }
  encodePacked5.encode = encode16;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError {
  constructor(type3) {
    super(`Type \`${type3}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/base-x/src/esm/index.js
function base(ALPHABET3) {
  if (ALPHABET3.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j3 = 0; j3 < BASE_MAP.length; j3++) {
    BASE_MAP[j3] = 255;
  }
  for (let i4 = 0; i4 < ALPHABET3.length; i4++) {
    const x5 = ALPHABET3.charAt(i4);
    const xc3 = x5.charCodeAt(0);
    if (BASE_MAP[xc3] !== 255) {
      throw new TypeError(x5 + " is ambiguous");
    }
    BASE_MAP[xc3] = i4;
  }
  const BASE = ALPHABET3.length;
  const LEADER = ALPHABET3.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode16(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length2 = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size9);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i4 = 0;
      for (let it1 = size9 - 1; (carry !== 0 || i4 < length2) && it1 !== -1; it1--, i4++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i4;
      pbegin++;
    }
    let it22 = size9 - length2;
    while (it22 !== size9 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size9; ++it22) {
      str += ALPHABET3.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size9 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size9);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i4 = 0;
      for (let it32 = size9 - 1; (carry !== 0 || i4 < length2) && it32 !== -1; it32--, i4++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i4;
      psz++;
    }
    let it4 = size9 - length2;
    while (it4 !== size9 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size9 - it4));
    let j3 = zeroes;
    while (it4 !== size9) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode9(string4) {
    const buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode16,
    decodeUnsafe,
    decode: decode9
  };
}
var esm_default = base;

// node_modules/@dynamic-labs/solana/node_modules/@walletconnect/utils/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs
function utf8Count(str) {
  const strLength = str.length;
  let byteLength = 0;
  let pos = 0;
  while (pos < strLength) {
    let value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output2, outputOffset) {
  const strLength = str.length;
  let offset5 = outputOffset;
  let pos = 0;
  while (pos < strLength) {
    let value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output2[offset5++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output2[offset5++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output2[offset5++] = value >> 12 & 15 | 224;
        output2[offset5++] = value >> 6 & 63 | 128;
      } else {
        output2[offset5++] = value >> 18 & 7 | 240;
        output2[offset5++] = value >> 12 & 63 | 128;
        output2[offset5++] = value >> 6 & 63 | 128;
      }
    }
    output2[offset5++] = value & 63 | 128;
  }
}
var sharedTextEncoder = new TextEncoder();
var TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output2, outputOffset) {
  sharedTextEncoder.encodeInto(str, output2.subarray(outputOffset));
}
function utf8Encode(str, output2, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output2, outputOffset);
  } else {
    utf8EncodeJs(str, output2, outputOffset);
  }
}
var CHUNK_SIZE3 = 4096;
function utf8DecodeJs(bytes2, inputOffset, byteLength) {
  let offset5 = inputOffset;
  const end = offset5 + byteLength;
  const units = [];
  let result = "";
  while (offset5 < end) {
    const byte1 = bytes2[offset5++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = bytes2[offset5++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = bytes2[offset5++] & 63;
      const byte3 = bytes2[offset5++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = bytes2[offset5++] & 63;
      const byte3 = bytes2[offset5++] & 63;
      const byte4 = bytes2[offset5++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE3) {
      result += String.fromCharCode(...units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode(...units);
  }
  return result;
}
var sharedTextDecoder = new TextDecoder();
var TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes2, inputOffset, byteLength) {
  const stringBytes = bytes2.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes2, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes2, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes2, inputOffset, byteLength);
  }
}

// node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs
var ExtData = class {
  constructor(type3, data) {
    this.type = type3;
    this.data = data;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs
var DecodeError = class _DecodeError extends Error {
  constructor(message) {
    super(message);
    const proto = Object.create(_DecodeError.prototype);
    Object.setPrototypeOf(this, proto);
    Object.defineProperty(this, "name", {
      configurable: true,
      enumerable: false,
      value: _DecodeError.name
    });
  }
};

// node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs
var UINT32_MAX = 4294967295;
function setUint64(view, offset5, value) {
  const high = value / 4294967296;
  const low = value;
  view.setUint32(offset5, high);
  view.setUint32(offset5 + 4, low);
}
function setInt64(view, offset5, value) {
  const high = Math.floor(value / 4294967296);
  const low = value;
  view.setUint32(offset5, high);
  view.setUint32(offset5 + 4, low);
}
function getInt64(view, offset5) {
  const high = view.getInt32(offset5);
  const low = view.getUint32(offset5 + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset5) {
  const high = view.getUint32(offset5);
  const low = view.getUint32(offset5 + 4);
  return high * 4294967296 + low;
}

// node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp({ sec, nsec }) {
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      const rv = new Uint8Array(4);
      const view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      const secHigh = sec / 4294967296;
      const secLow = sec & 4294967295;
      const rv = new Uint8Array(8);
      const view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    const rv = new Uint8Array(12);
    const view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  const msec = date.getTime();
  const sec = Math.floor(msec / 1e3);
  const nsec = (msec - sec * 1e3) * 1e6;
  const nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object2) {
  if (object2 instanceof Date) {
    const timeSpec = encodeDateToTimeSpec(object2);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      const sec = view.getUint32(0);
      const nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      const nsec30AndSecHigh2 = view.getUint32(0);
      const secLow32 = view.getUint32(4);
      const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      const nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      const sec = getInt64(view, 4);
      const nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
  }
}
function decodeTimestampExtension(data) {
  const timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};

// node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs
var ExtensionCodec = class {
  constructor() {
    this.builtInEncoders = [];
    this.builtInDecoders = [];
    this.encoders = [];
    this.decoders = [];
    this.register(timestampExtension);
  }
  register({ type: type3, encode: encode16, decode: decode9 }) {
    if (type3 >= 0) {
      this.encoders[type3] = encode16;
      this.decoders[type3] = decode9;
    } else {
      const index = -1 - type3;
      this.builtInEncoders[index] = encode16;
      this.builtInDecoders[index] = decode9;
    }
  }
  tryToEncode(object2, context) {
    for (let i4 = 0; i4 < this.builtInEncoders.length; i4++) {
      const encodeExt = this.builtInEncoders[i4];
      if (encodeExt != null) {
        const data = encodeExt(object2, context);
        if (data != null) {
          const type3 = -1 - i4;
          return new ExtData(type3, data);
        }
      }
    }
    for (let i4 = 0; i4 < this.encoders.length; i4++) {
      const encodeExt = this.encoders[i4];
      if (encodeExt != null) {
        const data = encodeExt(object2, context);
        if (data != null) {
          const type3 = i4;
          return new ExtData(type3, data);
        }
      }
    }
    if (object2 instanceof ExtData) {
      return object2;
    }
    return null;
  }
  decode(data, type3, context) {
    const decodeExt = type3 < 0 ? this.builtInDecoders[-1 - type3] : this.decoders[type3];
    if (decodeExt) {
      return decodeExt(data, type3, context);
    } else {
      return new ExtData(type3, data);
    }
  }
};
ExtensionCodec.defaultCodec = new ExtensionCodec();

// node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs
function isArrayBufferLike(buffer) {
  return buffer instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && buffer instanceof SharedArrayBuffer;
}
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (isArrayBufferLike(buffer)) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}

// node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = class _Encoder {
  constructor(options) {
    this.entered = false;
    this.extensionCodec = (options == null ? void 0 : options.extensionCodec) ?? ExtensionCodec.defaultCodec;
    this.context = options == null ? void 0 : options.context;
    this.useBigInt64 = (options == null ? void 0 : options.useBigInt64) ?? false;
    this.maxDepth = (options == null ? void 0 : options.maxDepth) ?? DEFAULT_MAX_DEPTH;
    this.initialBufferSize = (options == null ? void 0 : options.initialBufferSize) ?? DEFAULT_INITIAL_BUFFER_SIZE;
    this.sortKeys = (options == null ? void 0 : options.sortKeys) ?? false;
    this.forceFloat32 = (options == null ? void 0 : options.forceFloat32) ?? false;
    this.ignoreUndefined = (options == null ? void 0 : options.ignoreUndefined) ?? false;
    this.forceIntegerToFloat = (options == null ? void 0 : options.forceIntegerToFloat) ?? false;
    this.pos = 0;
    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
    this.bytes = new Uint8Array(this.view.buffer);
  }
  clone() {
    return new _Encoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat
    });
  }
  reinitializeState() {
    this.pos = 0;
  }
  /**
   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
   *
   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
   */
  encodeSharedRef(object2) {
    if (this.entered) {
      const instance2 = this.clone();
      return instance2.encodeSharedRef(object2);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.doEncode(object2, 1);
      return this.bytes.subarray(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  /**
   * @returns Encodes the object and returns a copy of the encoder's internal buffer.
   */
  encode(object2) {
    if (this.entered) {
      const instance2 = this.clone();
      return instance2.encode(object2);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.doEncode(object2, 1);
      return this.bytes.slice(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  doEncode(object2, depth) {
    if (depth > this.maxDepth) {
      throw new Error(`Too deep objects in depth ${depth}`);
    }
    if (object2 == null) {
      this.encodeNil();
    } else if (typeof object2 === "boolean") {
      this.encodeBoolean(object2);
    } else if (typeof object2 === "number") {
      if (!this.forceIntegerToFloat) {
        this.encodeNumber(object2);
      } else {
        this.encodeNumberAsFloat(object2);
      }
    } else if (typeof object2 === "string") {
      this.encodeString(object2);
    } else if (this.useBigInt64 && typeof object2 === "bigint") {
      this.encodeBigInt64(object2);
    } else {
      this.encodeObject(object2, depth);
    }
  }
  ensureBufferSizeToWrite(sizeToWrite) {
    const requiredSize = this.pos + sizeToWrite;
    if (this.view.byteLength < requiredSize) {
      this.resizeBuffer(requiredSize * 2);
    }
  }
  resizeBuffer(newSize) {
    const newBuffer = new ArrayBuffer(newSize);
    const newBytes = new Uint8Array(newBuffer);
    const newView = new DataView(newBuffer);
    newBytes.set(this.bytes);
    this.view = newView;
    this.bytes = newBytes;
  }
  encodeNil() {
    this.writeU8(192);
  }
  encodeBoolean(object2) {
    if (object2 === false) {
      this.writeU8(194);
    } else {
      this.writeU8(195);
    }
  }
  encodeNumber(object2) {
    if (!this.forceIntegerToFloat && Number.isSafeInteger(object2)) {
      if (object2 >= 0) {
        if (object2 < 128) {
          this.writeU8(object2);
        } else if (object2 < 256) {
          this.writeU8(204);
          this.writeU8(object2);
        } else if (object2 < 65536) {
          this.writeU8(205);
          this.writeU16(object2);
        } else if (object2 < 4294967296) {
          this.writeU8(206);
          this.writeU32(object2);
        } else if (!this.useBigInt64) {
          this.writeU8(207);
          this.writeU64(object2);
        } else {
          this.encodeNumberAsFloat(object2);
        }
      } else {
        if (object2 >= -32) {
          this.writeU8(224 | object2 + 32);
        } else if (object2 >= -128) {
          this.writeU8(208);
          this.writeI8(object2);
        } else if (object2 >= -32768) {
          this.writeU8(209);
          this.writeI16(object2);
        } else if (object2 >= -2147483648) {
          this.writeU8(210);
          this.writeI32(object2);
        } else if (!this.useBigInt64) {
          this.writeU8(211);
          this.writeI64(object2);
        } else {
          this.encodeNumberAsFloat(object2);
        }
      }
    } else {
      this.encodeNumberAsFloat(object2);
    }
  }
  encodeNumberAsFloat(object2) {
    if (this.forceFloat32) {
      this.writeU8(202);
      this.writeF32(object2);
    } else {
      this.writeU8(203);
      this.writeF64(object2);
    }
  }
  encodeBigInt64(object2) {
    if (object2 >= BigInt(0)) {
      this.writeU8(207);
      this.writeBigUint64(object2);
    } else {
      this.writeU8(211);
      this.writeBigInt64(object2);
    }
  }
  writeStringHeader(byteLength) {
    if (byteLength < 32) {
      this.writeU8(160 + byteLength);
    } else if (byteLength < 256) {
      this.writeU8(217);
      this.writeU8(byteLength);
    } else if (byteLength < 65536) {
      this.writeU8(218);
      this.writeU16(byteLength);
    } else if (byteLength < 4294967296) {
      this.writeU8(219);
      this.writeU32(byteLength);
    } else {
      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
    }
  }
  encodeString(object2) {
    const maxHeaderSize = 1 + 4;
    const byteLength = utf8Count(object2);
    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
    this.writeStringHeader(byteLength);
    utf8Encode(object2, this.bytes, this.pos);
    this.pos += byteLength;
  }
  encodeObject(object2, depth) {
    const ext = this.extensionCodec.tryToEncode(object2, this.context);
    if (ext != null) {
      this.encodeExtension(ext);
    } else if (Array.isArray(object2)) {
      this.encodeArray(object2, depth);
    } else if (ArrayBuffer.isView(object2)) {
      this.encodeBinary(object2);
    } else if (typeof object2 === "object") {
      this.encodeMap(object2, depth);
    } else {
      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object2)}`);
    }
  }
  encodeBinary(object2) {
    const size9 = object2.byteLength;
    if (size9 < 256) {
      this.writeU8(196);
      this.writeU8(size9);
    } else if (size9 < 65536) {
      this.writeU8(197);
      this.writeU16(size9);
    } else if (size9 < 4294967296) {
      this.writeU8(198);
      this.writeU32(size9);
    } else {
      throw new Error(`Too large binary: ${size9}`);
    }
    const bytes2 = ensureUint8Array(object2);
    this.writeU8a(bytes2);
  }
  encodeArray(object2, depth) {
    const size9 = object2.length;
    if (size9 < 16) {
      this.writeU8(144 + size9);
    } else if (size9 < 65536) {
      this.writeU8(220);
      this.writeU16(size9);
    } else if (size9 < 4294967296) {
      this.writeU8(221);
      this.writeU32(size9);
    } else {
      throw new Error(`Too large array: ${size9}`);
    }
    for (const item of object2) {
      this.doEncode(item, depth + 1);
    }
  }
  countWithoutUndefined(object2, keys4) {
    let count = 0;
    for (const key of keys4) {
      if (object2[key] !== void 0) {
        count++;
      }
    }
    return count;
  }
  encodeMap(object2, depth) {
    const keys4 = Object.keys(object2);
    if (this.sortKeys) {
      keys4.sort();
    }
    const size9 = this.ignoreUndefined ? this.countWithoutUndefined(object2, keys4) : keys4.length;
    if (size9 < 16) {
      this.writeU8(128 + size9);
    } else if (size9 < 65536) {
      this.writeU8(222);
      this.writeU16(size9);
    } else if (size9 < 4294967296) {
      this.writeU8(223);
      this.writeU32(size9);
    } else {
      throw new Error(`Too large map object: ${size9}`);
    }
    for (const key of keys4) {
      const value = object2[key];
      if (!(this.ignoreUndefined && value === void 0)) {
        this.encodeString(key);
        this.doEncode(value, depth + 1);
      }
    }
  }
  encodeExtension(ext) {
    if (typeof ext.data === "function") {
      const data = ext.data(this.pos + 6);
      const size10 = data.length;
      if (size10 >= 4294967296) {
        throw new Error(`Too large extension object: ${size10}`);
      }
      this.writeU8(201);
      this.writeU32(size10);
      this.writeI8(ext.type);
      this.writeU8a(data);
      return;
    }
    const size9 = ext.data.length;
    if (size9 === 1) {
      this.writeU8(212);
    } else if (size9 === 2) {
      this.writeU8(213);
    } else if (size9 === 4) {
      this.writeU8(214);
    } else if (size9 === 8) {
      this.writeU8(215);
    } else if (size9 === 16) {
      this.writeU8(216);
    } else if (size9 < 256) {
      this.writeU8(199);
      this.writeU8(size9);
    } else if (size9 < 65536) {
      this.writeU8(200);
      this.writeU16(size9);
    } else if (size9 < 4294967296) {
      this.writeU8(201);
      this.writeU32(size9);
    } else {
      throw new Error(`Too large extension object: ${size9}`);
    }
    this.writeI8(ext.type);
    this.writeU8a(ext.data);
  }
  writeU8(value) {
    this.ensureBufferSizeToWrite(1);
    this.view.setUint8(this.pos, value);
    this.pos++;
  }
  writeU8a(values) {
    const size9 = values.length;
    this.ensureBufferSizeToWrite(size9);
    this.bytes.set(values, this.pos);
    this.pos += size9;
  }
  writeI8(value) {
    this.ensureBufferSizeToWrite(1);
    this.view.setInt8(this.pos, value);
    this.pos++;
  }
  writeU16(value) {
    this.ensureBufferSizeToWrite(2);
    this.view.setUint16(this.pos, value);
    this.pos += 2;
  }
  writeI16(value) {
    this.ensureBufferSizeToWrite(2);
    this.view.setInt16(this.pos, value);
    this.pos += 2;
  }
  writeU32(value) {
    this.ensureBufferSizeToWrite(4);
    this.view.setUint32(this.pos, value);
    this.pos += 4;
  }
  writeI32(value) {
    this.ensureBufferSizeToWrite(4);
    this.view.setInt32(this.pos, value);
    this.pos += 4;
  }
  writeF32(value) {
    this.ensureBufferSizeToWrite(4);
    this.view.setFloat32(this.pos, value);
    this.pos += 4;
  }
  writeF64(value) {
    this.ensureBufferSizeToWrite(8);
    this.view.setFloat64(this.pos, value);
    this.pos += 8;
  }
  writeU64(value) {
    this.ensureBufferSizeToWrite(8);
    setUint64(this.view, this.pos, value);
    this.pos += 8;
  }
  writeI64(value) {
    this.ensureBufferSizeToWrite(8);
    setInt64(this.view, this.pos, value);
    this.pos += 8;
  }
  writeBigUint64(value) {
    this.ensureBufferSizeToWrite(8);
    this.view.setBigUint64(this.pos, value);
    this.pos += 8;
  }
  writeBigInt64(value) {
    this.ensureBufferSizeToWrite(8);
    this.view.setBigInt64(this.pos, value);
    this.pos += 8;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/encode.mjs
function encode4(value, options) {
  const encoder = new Encoder(options);
  return encoder.encodeSharedRef(value);
}

// node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}

// node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = class {
  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
    this.hit = 0;
    this.miss = 0;
    this.maxKeyLength = maxKeyLength;
    this.maxLengthPerKey = maxLengthPerKey;
    this.caches = [];
    for (let i4 = 0; i4 < this.maxKeyLength; i4++) {
      this.caches.push([]);
    }
  }
  canBeCached(byteLength) {
    return byteLength > 0 && byteLength <= this.maxKeyLength;
  }
  find(bytes2, inputOffset, byteLength) {
    const records = this.caches[byteLength - 1];
    FIND_CHUNK: for (const record3 of records) {
      const recordBytes = record3.bytes;
      for (let j3 = 0; j3 < byteLength; j3++) {
        if (recordBytes[j3] !== bytes2[inputOffset + j3]) {
          continue FIND_CHUNK;
        }
      }
      return record3.str;
    }
    return null;
  }
  store(bytes2, value) {
    const records = this.caches[bytes2.length - 1];
    const record3 = { bytes: bytes2, str: value };
    if (records.length >= this.maxLengthPerKey) {
      records[Math.random() * records.length | 0] = record3;
    } else {
      records.push(record3);
    }
  }
  decode(bytes2, inputOffset, byteLength) {
    const cachedValue = this.find(bytes2, inputOffset, byteLength);
    if (cachedValue != null) {
      this.hit++;
      return cachedValue;
    }
    this.miss++;
    const str = utf8DecodeJs(bytes2, inputOffset, byteLength);
    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes2, inputOffset, inputOffset + byteLength);
    this.store(slicedCopyOfBytes, str);
    return str;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs
var STATE_ARRAY = "array";
var STATE_MAP_KEY = "map_key";
var STATE_MAP_VALUE = "map_value";
var mapKeyConverter = (key) => {
  if (typeof key === "string" || typeof key === "number") {
    return key;
  }
  throw new DecodeError("The type of key must be string or number but " + typeof key);
};
var StackPool = class {
  constructor() {
    this.stack = [];
    this.stackHeadPosition = -1;
  }
  get length() {
    return this.stackHeadPosition + 1;
  }
  top() {
    return this.stack[this.stackHeadPosition];
  }
  pushArrayState(size9) {
    const state = this.getUninitializedStateFromPool();
    state.type = STATE_ARRAY;
    state.position = 0;
    state.size = size9;
    state.array = new Array(size9);
  }
  pushMapState(size9) {
    const state = this.getUninitializedStateFromPool();
    state.type = STATE_MAP_KEY;
    state.readCount = 0;
    state.size = size9;
    state.map = {};
  }
  getUninitializedStateFromPool() {
    this.stackHeadPosition++;
    if (this.stackHeadPosition === this.stack.length) {
      const partialState = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null
      };
      this.stack.push(partialState);
    }
    return this.stack[this.stackHeadPosition];
  }
  release(state) {
    const topStackState = this.stack[this.stackHeadPosition];
    if (topStackState !== state) {
      throw new Error("Invalid stack state. Released state is not on top of the stack.");
    }
    if (state.type === STATE_ARRAY) {
      const partialState = state;
      partialState.size = 0;
      partialState.array = void 0;
      partialState.position = 0;
      partialState.type = void 0;
    }
    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
      const partialState = state;
      partialState.size = 0;
      partialState.map = void 0;
      partialState.readCount = 0;
      partialState.type = void 0;
    }
    this.stackHeadPosition--;
  }
  reset() {
    this.stack.length = 0;
    this.stackHeadPosition = -1;
  }
};
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
  EMPTY_VIEW.getInt8(0);
} catch (e2) {
  if (!(e2 instanceof RangeError)) {
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
  }
}
var MORE_DATA = new RangeError("Insufficient data");
var sharedCachedKeyDecoder = new CachedKeyDecoder();
var Decoder = class _Decoder {
  constructor(options) {
    this.totalPos = 0;
    this.pos = 0;
    this.view = EMPTY_VIEW;
    this.bytes = EMPTY_BYTES;
    this.headByte = HEAD_BYTE_REQUIRED;
    this.stack = new StackPool();
    this.entered = false;
    this.extensionCodec = (options == null ? void 0 : options.extensionCodec) ?? ExtensionCodec.defaultCodec;
    this.context = options == null ? void 0 : options.context;
    this.useBigInt64 = (options == null ? void 0 : options.useBigInt64) ?? false;
    this.rawStrings = (options == null ? void 0 : options.rawStrings) ?? false;
    this.maxStrLength = (options == null ? void 0 : options.maxStrLength) ?? UINT32_MAX;
    this.maxBinLength = (options == null ? void 0 : options.maxBinLength) ?? UINT32_MAX;
    this.maxArrayLength = (options == null ? void 0 : options.maxArrayLength) ?? UINT32_MAX;
    this.maxMapLength = (options == null ? void 0 : options.maxMapLength) ?? UINT32_MAX;
    this.maxExtLength = (options == null ? void 0 : options.maxExtLength) ?? UINT32_MAX;
    this.keyDecoder = (options == null ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
    this.mapKeyConverter = (options == null ? void 0 : options.mapKeyConverter) ?? mapKeyConverter;
  }
  clone() {
    return new _Decoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder
    });
  }
  reinitializeState() {
    this.totalPos = 0;
    this.headByte = HEAD_BYTE_REQUIRED;
    this.stack.reset();
  }
  setBuffer(buffer) {
    const bytes2 = ensureUint8Array(buffer);
    this.bytes = bytes2;
    this.view = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    this.pos = 0;
  }
  appendBuffer(buffer) {
    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
      this.setBuffer(buffer);
    } else {
      const remainingData = this.bytes.subarray(this.pos);
      const newData = ensureUint8Array(buffer);
      const newBuffer = new Uint8Array(remainingData.length + newData.length);
      newBuffer.set(remainingData);
      newBuffer.set(newData, remainingData.length);
      this.setBuffer(newBuffer);
    }
  }
  hasRemaining(size9) {
    return this.view.byteLength - this.pos >= size9;
  }
  createExtraByteError(posToShow) {
    const { view, pos } = this;
    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
  }
  /**
   * @throws {@link DecodeError}
   * @throws {@link RangeError}
   */
  decode(buffer) {
    if (this.entered) {
      const instance2 = this.clone();
      return instance2.decode(buffer);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.setBuffer(buffer);
      const object2 = this.doDecodeSync();
      if (this.hasRemaining(1)) {
        throw this.createExtraByteError(this.pos);
      }
      return object2;
    } finally {
      this.entered = false;
    }
  }
  *decodeMulti(buffer) {
    if (this.entered) {
      const instance2 = this.clone();
      yield* instance2.decodeMulti(buffer);
      return;
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.setBuffer(buffer);
      while (this.hasRemaining(1)) {
        yield this.doDecodeSync();
      }
    } finally {
      this.entered = false;
    }
  }
  async decodeAsync(stream) {
    if (this.entered) {
      const instance2 = this.clone();
      return instance2.decodeAsync(stream);
    }
    try {
      this.entered = true;
      let decoded = false;
      let object2;
      for await (const buffer of stream) {
        if (decoded) {
          this.entered = false;
          throw this.createExtraByteError(this.totalPos);
        }
        this.appendBuffer(buffer);
        try {
          object2 = this.doDecodeSync();
          decoded = true;
        } catch (e2) {
          if (!(e2 instanceof RangeError)) {
            throw e2;
          }
        }
        this.totalPos += this.pos;
      }
      if (decoded) {
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.totalPos);
        }
        return object2;
      }
      const { headByte, pos, totalPos } = this;
      throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
    } finally {
      this.entered = false;
    }
  }
  decodeArrayStream(stream) {
    return this.decodeMultiAsync(stream, true);
  }
  decodeStream(stream) {
    return this.decodeMultiAsync(stream, false);
  }
  async *decodeMultiAsync(stream, isArray4) {
    if (this.entered) {
      const instance2 = this.clone();
      yield* instance2.decodeMultiAsync(stream, isArray4);
      return;
    }
    try {
      this.entered = true;
      let isArrayHeaderRequired = isArray4;
      let arrayItemsLeft = -1;
      for await (const buffer of stream) {
        if (isArray4 && arrayItemsLeft === 0) {
          throw this.createExtraByteError(this.totalPos);
        }
        this.appendBuffer(buffer);
        if (isArrayHeaderRequired) {
          arrayItemsLeft = this.readArraySize();
          isArrayHeaderRequired = false;
          this.complete();
        }
        try {
          while (true) {
            yield this.doDecodeSync();
            if (--arrayItemsLeft === 0) {
              break;
            }
          }
        } catch (e2) {
          if (!(e2 instanceof RangeError)) {
            throw e2;
          }
        }
        this.totalPos += this.pos;
      }
    } finally {
      this.entered = false;
    }
  }
  doDecodeSync() {
    DECODE: while (true) {
      const headByte = this.readHeadByte();
      let object2;
      if (headByte >= 224) {
        object2 = headByte - 256;
      } else if (headByte < 192) {
        if (headByte < 128) {
          object2 = headByte;
        } else if (headByte < 144) {
          const size9 = headByte - 128;
          if (size9 !== 0) {
            this.pushMapState(size9);
            this.complete();
            continue DECODE;
          } else {
            object2 = {};
          }
        } else if (headByte < 160) {
          const size9 = headByte - 144;
          if (size9 !== 0) {
            this.pushArrayState(size9);
            this.complete();
            continue DECODE;
          } else {
            object2 = [];
          }
        } else {
          const byteLength = headByte - 160;
          object2 = this.decodeString(byteLength, 0);
        }
      } else if (headByte === 192) {
        object2 = null;
      } else if (headByte === 194) {
        object2 = false;
      } else if (headByte === 195) {
        object2 = true;
      } else if (headByte === 202) {
        object2 = this.readF32();
      } else if (headByte === 203) {
        object2 = this.readF64();
      } else if (headByte === 204) {
        object2 = this.readU8();
      } else if (headByte === 205) {
        object2 = this.readU16();
      } else if (headByte === 206) {
        object2 = this.readU32();
      } else if (headByte === 207) {
        if (this.useBigInt64) {
          object2 = this.readU64AsBigInt();
        } else {
          object2 = this.readU64();
        }
      } else if (headByte === 208) {
        object2 = this.readI8();
      } else if (headByte === 209) {
        object2 = this.readI16();
      } else if (headByte === 210) {
        object2 = this.readI32();
      } else if (headByte === 211) {
        if (this.useBigInt64) {
          object2 = this.readI64AsBigInt();
        } else {
          object2 = this.readI64();
        }
      } else if (headByte === 217) {
        const byteLength = this.lookU8();
        object2 = this.decodeString(byteLength, 1);
      } else if (headByte === 218) {
        const byteLength = this.lookU16();
        object2 = this.decodeString(byteLength, 2);
      } else if (headByte === 219) {
        const byteLength = this.lookU32();
        object2 = this.decodeString(byteLength, 4);
      } else if (headByte === 220) {
        const size9 = this.readU16();
        if (size9 !== 0) {
          this.pushArrayState(size9);
          this.complete();
          continue DECODE;
        } else {
          object2 = [];
        }
      } else if (headByte === 221) {
        const size9 = this.readU32();
        if (size9 !== 0) {
          this.pushArrayState(size9);
          this.complete();
          continue DECODE;
        } else {
          object2 = [];
        }
      } else if (headByte === 222) {
        const size9 = this.readU16();
        if (size9 !== 0) {
          this.pushMapState(size9);
          this.complete();
          continue DECODE;
        } else {
          object2 = {};
        }
      } else if (headByte === 223) {
        const size9 = this.readU32();
        if (size9 !== 0) {
          this.pushMapState(size9);
          this.complete();
          continue DECODE;
        } else {
          object2 = {};
        }
      } else if (headByte === 196) {
        const size9 = this.lookU8();
        object2 = this.decodeBinary(size9, 1);
      } else if (headByte === 197) {
        const size9 = this.lookU16();
        object2 = this.decodeBinary(size9, 2);
      } else if (headByte === 198) {
        const size9 = this.lookU32();
        object2 = this.decodeBinary(size9, 4);
      } else if (headByte === 212) {
        object2 = this.decodeExtension(1, 0);
      } else if (headByte === 213) {
        object2 = this.decodeExtension(2, 0);
      } else if (headByte === 214) {
        object2 = this.decodeExtension(4, 0);
      } else if (headByte === 215) {
        object2 = this.decodeExtension(8, 0);
      } else if (headByte === 216) {
        object2 = this.decodeExtension(16, 0);
      } else if (headByte === 199) {
        const size9 = this.lookU8();
        object2 = this.decodeExtension(size9, 1);
      } else if (headByte === 200) {
        const size9 = this.lookU16();
        object2 = this.decodeExtension(size9, 2);
      } else if (headByte === 201) {
        const size9 = this.lookU32();
        object2 = this.decodeExtension(size9, 4);
      } else {
        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
      }
      this.complete();
      const stack = this.stack;
      while (stack.length > 0) {
        const state = stack.top();
        if (state.type === STATE_ARRAY) {
          state.array[state.position] = object2;
          state.position++;
          if (state.position === state.size) {
            object2 = state.array;
            stack.release(state);
          } else {
            continue DECODE;
          }
        } else if (state.type === STATE_MAP_KEY) {
          if (object2 === "__proto__") {
            throw new DecodeError("The key __proto__ is not allowed");
          }
          state.key = this.mapKeyConverter(object2);
          state.type = STATE_MAP_VALUE;
          continue DECODE;
        } else {
          state.map[state.key] = object2;
          state.readCount++;
          if (state.readCount === state.size) {
            object2 = state.map;
            stack.release(state);
          } else {
            state.key = null;
            state.type = STATE_MAP_KEY;
            continue DECODE;
          }
        }
      }
      return object2;
    }
  }
  readHeadByte() {
    if (this.headByte === HEAD_BYTE_REQUIRED) {
      this.headByte = this.readU8();
    }
    return this.headByte;
  }
  complete() {
    this.headByte = HEAD_BYTE_REQUIRED;
  }
  readArraySize() {
    const headByte = this.readHeadByte();
    switch (headByte) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (headByte < 160) {
          return headByte - 144;
        } else {
          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
        }
      }
    }
  }
  pushMapState(size9) {
    if (size9 > this.maxMapLength) {
      throw new DecodeError(`Max length exceeded: map length (${size9}) > maxMapLengthLength (${this.maxMapLength})`);
    }
    this.stack.pushMapState(size9);
  }
  pushArrayState(size9) {
    if (size9 > this.maxArrayLength) {
      throw new DecodeError(`Max length exceeded: array length (${size9}) > maxArrayLength (${this.maxArrayLength})`);
    }
    this.stack.pushArrayState(size9);
  }
  decodeString(byteLength, headerOffset) {
    if (!this.rawStrings || this.stateIsMapKey()) {
      return this.decodeUtf8String(byteLength, headerOffset);
    }
    return this.decodeBinary(byteLength, headerOffset);
  }
  /**
   * @throws {@link RangeError}
   */
  decodeUtf8String(byteLength, headerOffset) {
    var _a21;
    if (byteLength > this.maxStrLength) {
      throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
    }
    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
      throw MORE_DATA;
    }
    const offset5 = this.pos + headerOffset;
    let object2;
    if (this.stateIsMapKey() && ((_a21 = this.keyDecoder) == null ? void 0 : _a21.canBeCached(byteLength))) {
      object2 = this.keyDecoder.decode(this.bytes, offset5, byteLength);
    } else {
      object2 = utf8Decode(this.bytes, offset5, byteLength);
    }
    this.pos += headerOffset + byteLength;
    return object2;
  }
  stateIsMapKey() {
    if (this.stack.length > 0) {
      const state = this.stack.top();
      return state.type === STATE_MAP_KEY;
    }
    return false;
  }
  /**
   * @throws {@link RangeError}
   */
  decodeBinary(byteLength, headOffset) {
    if (byteLength > this.maxBinLength) {
      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
    }
    if (!this.hasRemaining(byteLength + headOffset)) {
      throw MORE_DATA;
    }
    const offset5 = this.pos + headOffset;
    const object2 = this.bytes.subarray(offset5, offset5 + byteLength);
    this.pos += headOffset + byteLength;
    return object2;
  }
  decodeExtension(size9, headOffset) {
    if (size9 > this.maxExtLength) {
      throw new DecodeError(`Max length exceeded: ext length (${size9}) > maxExtLength (${this.maxExtLength})`);
    }
    const extType = this.view.getInt8(this.pos + headOffset);
    const data = this.decodeBinary(
      size9,
      headOffset + 1
      /* extType */
    );
    return this.extensionCodec.decode(data, extType, this.context);
  }
  lookU8() {
    return this.view.getUint8(this.pos);
  }
  lookU16() {
    return this.view.getUint16(this.pos);
  }
  lookU32() {
    return this.view.getUint32(this.pos);
  }
  readU8() {
    const value = this.view.getUint8(this.pos);
    this.pos++;
    return value;
  }
  readI8() {
    const value = this.view.getInt8(this.pos);
    this.pos++;
    return value;
  }
  readU16() {
    const value = this.view.getUint16(this.pos);
    this.pos += 2;
    return value;
  }
  readI16() {
    const value = this.view.getInt16(this.pos);
    this.pos += 2;
    return value;
  }
  readU32() {
    const value = this.view.getUint32(this.pos);
    this.pos += 4;
    return value;
  }
  readI32() {
    const value = this.view.getInt32(this.pos);
    this.pos += 4;
    return value;
  }
  readU64() {
    const value = getUint64(this.view, this.pos);
    this.pos += 8;
    return value;
  }
  readI64() {
    const value = getInt64(this.view, this.pos);
    this.pos += 8;
    return value;
  }
  readU64AsBigInt() {
    const value = this.view.getBigUint64(this.pos);
    this.pos += 8;
    return value;
  }
  readI64AsBigInt() {
    const value = this.view.getBigInt64(this.pos);
    this.pos += 8;
    return value;
  }
  readF32() {
    const value = this.view.getFloat32(this.pos);
    this.pos += 4;
    return value;
  }
  readF64() {
    const value = this.view.getFloat64(this.pos);
    this.pos += 8;
    return value;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/decode.mjs
function decode2(buffer, options) {
  const decoder = new Decoder(options);
  return decoder.decode(buffer);
}

// node_modules/@scure/base/lib/esm/index.js
function isBytes3(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes2(b4, ...lengths) {
  if (!isBytes3(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function isArrayOf(isString4, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString4) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n5) {
  if (!Number.isSafeInteger(n5))
    throw new Error(`invalid integer: ${n5}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a3) => a3;
  const wrap = (a3, b4) => (c6) => a3(b4(c6));
  const encode16 = args.map((x5) => x5.encode).reduceRight(wrap, id);
  const decode9 = args.map((x5) => x5.decode).reduce(wrap, id);
  return { encode: encode16, decode: decode9 };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l6, i4) => [l6, i4]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i4) => {
        if (!Number.isSafeInteger(i4) || i4 < 0 || i4 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i4}". Allowed: ${letters}`);
        return lettersA[i4];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i4 = indexes.get(letter);
        if (i4 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i4;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from13) => {
      astrArr("join.decode", from13);
      return from13.join(separator);
    },
    decode: (to5) => {
      astr("join.decode", to5);
      return to5.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last5 = end - 1;
        const byte = last5 * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn4) {
  afn(fn4);
  return { encode: (from13) => from13, decode: (to5) => fn4(to5) };
}
function convertRadix(data, from13, to5) {
  if (from13 < 2)
    throw new Error(`convertRadix: invalid from=${from13}, base cannot be less than 2`);
  if (to5 < 2)
    throw new Error(`convertRadix: invalid to=${to5}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d4) => {
    anumber2(d4);
    if (d4 < 0 || d4 >= from13)
      throw new Error(`invalid integer: ${d4}`);
    return d4;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i4 = pos; i4 < dlen; i4++) {
      const digit = digits[i4];
      const fromCarry = from13 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from13 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to5;
      carry = digitBase % to5;
      const rounded = Math.floor(div);
      digits[i4] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to5 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i4;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i4 = 0; i4 < data.length - 1 && data[i4] === 0; i4++)
    res.push(0);
  return res.reverse();
}
var gcd = (a3, b4) => b4 === 0 ? a3 : gcd(b4, a3 % b4);
var radix2carry = (from13, to5) => from13 + (to5 - gcd(from13, to5));
var powers = (() => {
  let res = [];
  for (let i4 = 0; i4 < 40; i4++)
    res.push(2 ** i4);
  return res;
})();
function convertRadix2(data, from13, to5, padding2) {
  aArr(data);
  if (from13 <= 0 || from13 > 32)
    throw new Error(`convertRadix2: wrong from=${from13}`);
  if (to5 <= 0 || to5 > 32)
    throw new Error(`convertRadix2: wrong to=${to5}`);
  if (radix2carry(from13, to5) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from13} to=${to5} carryBits=${radix2carry(from13, to5)}`);
  }
  let carry = 0;
  let pos = 0;
  const max4 = powers[from13];
  const mask = powers[to5] - 1;
  const res = [];
  for (const n5 of data) {
    anumber2(n5);
    if (n5 >= max4)
      throw new Error(`convertRadix2: invalid data word=${n5} from=${from13}`);
    carry = carry << from13 | n5;
    if (pos + from13 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from13}`);
    pos += from13;
    for (; pos >= to5; pos -= to5)
      res.push((carry >> pos - to5 & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to5 - pos & mask;
  if (!padding2 && pos >= from13)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num3) {
  anumber2(num3);
  const _256 = 2 ** 8;
  return {
    encode: (bytes2) => {
      if (!isBytes3(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), _256, num3);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num3, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes3(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn4) {
  afn(fn4);
  return function(...args) {
    try {
      return fn4.apply(null, args);
    } catch (e2) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s3) => s3.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s3, isUrl) => {
  astr("base64", s3);
  const re2 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet3 = isUrl ? "base64url" : "base64";
  if (s3.length > 0 && !re2.test(s3))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s3, { alphabet: alphabet3, lastChunkHandling: "strict" });
};
var base64 = hasBase64Builtin ? {
  encode(b4) {
    abytes2(b4);
    return b4.toBase64();
  },
  decode(s3) {
    return decodeBase64Builtin(s3, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b4) {
    abytes2(b4);
    return b4.toBase64({ alphabet: "base64url" });
  },
  decode(s3) {
    return decodeBase64Builtin(s3, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b4 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i4 = 0; i4 < POLYMOD_GENERATORS.length; i4++) {
    if ((b4 >> i4 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i4];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i4 = 0; i4 < len; i4++) {
    const c6 = prefix.charCodeAt(i4);
    if (c6 < 33 || c6 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c6 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i4 = 0; i4 < len; i4++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i4) & 31;
  for (let v6 of words)
    chk = bech32Polymod(chk) ^ v6;
  for (let i4 = 0; i4 < 6; i4++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode16(prefix, words, limit2 = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes3(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode9(str, limit2 = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit2 !== false && slen > limit2)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode9);
  function decodeToBytes(str) {
    const { prefix, words } = decode9(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes2) {
    return encode16(prefix, toWords(bytes2));
  }
  return {
    encode: encode16,
    decode: decode9,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s3) {
    astr("hex", s3);
    return Uint8Array.fromHex(s3);
  }
};
var hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s3) => {
  if (typeof s3 !== "string" || s3.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s3} with length ${s3.length}`);
  return s3.toLowerCase();
}));

// node_modules/@walletconnect/relay-auth/dist/index.es.js
var import_time = __toESM(require_cjs());

// node_modules/@walletconnect/safe-json/dist/esm/index.js
var JSONStringify = (data) => JSON.stringify(data, (_3, value) => typeof value === "bigint" ? value.toString() + "n" : value);
var JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_3, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a21) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}

// node_modules/@walletconnect/relay-auth/dist/index.es.js
function En(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function fe(t, ...e2) {
  if (!En(t)) throw new Error("Uint8Array expected");
  if (e2.length > 0 && !e2.includes(t.length)) throw new Error("Uint8Array expected of length " + e2 + ", got length=" + t.length);
}
function De(t, e2 = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e2 && t.finished) throw new Error("Hash#digest() has already been called");
}
function gn(t, e2) {
  fe(t);
  const n5 = e2.outputLen;
  if (t.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
var it = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var _t = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
function yn(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function de(t) {
  return typeof t == "string" && (t = yn(t)), fe(t), t;
}
var xn = class {
  clone() {
    return this._cloneInto();
  }
};
function Bn(t) {
  const e2 = (r3) => t().update(de(r3)).digest(), n5 = t();
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = () => t(), e2;
}
function he(t = 32) {
  if (it && typeof it.getRandomValues == "function") return it.getRandomValues(new Uint8Array(t));
  if (it && typeof it.randomBytes == "function") return it.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
function Cn(t, e2, n5, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e2, n5, r3);
  const o4 = BigInt(32), s3 = BigInt(4294967295), a3 = Number(n5 >> o4 & s3), u2 = Number(n5 & s3), i4 = r3 ? 4 : 0, D4 = r3 ? 0 : 4;
  t.setUint32(e2 + i4, a3, r3), t.setUint32(e2 + D4, u2, r3);
}
var An = class extends xn {
  constructor(e2, n5, r3, o4) {
    super(), this.blockLen = e2, this.outputLen = n5, this.padOffset = r3, this.isLE = o4, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e2), this.view = _t(this.buffer);
  }
  update(e2) {
    De(this);
    const { view: n5, buffer: r3, blockLen: o4 } = this;
    e2 = de(e2);
    const s3 = e2.length;
    for (let a3 = 0; a3 < s3; ) {
      const u2 = Math.min(o4 - this.pos, s3 - a3);
      if (u2 === o4) {
        const i4 = _t(e2);
        for (; o4 <= s3 - a3; a3 += o4) this.process(i4, a3);
        continue;
      }
      r3.set(e2.subarray(a3, a3 + u2), this.pos), this.pos += u2, a3 += u2, this.pos === o4 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    De(this), gn(e2, this), this.finished = true;
    const { buffer: n5, view: r3, blockLen: o4, isLE: s3 } = this;
    let { pos: a3 } = this;
    n5[a3++] = 128, this.buffer.subarray(a3).fill(0), this.padOffset > o4 - a3 && (this.process(r3, 0), a3 = 0);
    for (let l6 = a3; l6 < o4; l6++) n5[l6] = 0;
    Cn(r3, o4 - 8, BigInt(this.length * 8), s3), this.process(r3, 0);
    const u2 = _t(e2), i4 = this.outputLen;
    if (i4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const D4 = i4 / 4, c6 = this.get();
    if (D4 > c6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l6 = 0; l6 < D4; l6++) u2.setUint32(4 * l6, c6[l6], s3);
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: n5, buffer: r3, length: o4, finished: s3, destroyed: a3, pos: u2 } = this;
    return e2.length = o4, e2.pos = u2, e2.finished = s3, e2.destroyed = a3, o4 % n5 && e2.buffer.set(r3), e2;
  }
};
var wt = BigInt(2 ** 32 - 1);
var St = BigInt(32);
function le(t, e2 = false) {
  return e2 ? { h: Number(t & wt), l: Number(t >> St & wt) } : { h: Number(t >> St & wt) | 0, l: Number(t & wt) | 0 };
}
function mn(t, e2 = false) {
  let n5 = new Uint32Array(t.length), r3 = new Uint32Array(t.length);
  for (let o4 = 0; o4 < t.length; o4++) {
    const { h: s3, l: a3 } = le(t[o4], e2);
    [n5[o4], r3[o4]] = [s3, a3];
  }
  return [n5, r3];
}
var _n = (t, e2) => BigInt(t >>> 0) << St | BigInt(e2 >>> 0);
var Sn = (t, e2, n5) => t >>> n5;
var vn = (t, e2, n5) => t << 32 - n5 | e2 >>> n5;
var In = (t, e2, n5) => t >>> n5 | e2 << 32 - n5;
var Un = (t, e2, n5) => t << 32 - n5 | e2 >>> n5;
var Tn = (t, e2, n5) => t << 64 - n5 | e2 >>> n5 - 32;
var Fn = (t, e2, n5) => t >>> n5 - 32 | e2 << 64 - n5;
var Nn = (t, e2) => e2;
var Ln = (t, e2) => t;
var On = (t, e2, n5) => t << n5 | e2 >>> 32 - n5;
var Hn = (t, e2, n5) => e2 << n5 | t >>> 32 - n5;
var zn = (t, e2, n5) => e2 << n5 - 32 | t >>> 64 - n5;
var Mn = (t, e2, n5) => t << n5 - 32 | e2 >>> 64 - n5;
function qn(t, e2, n5, r3) {
  const o4 = (e2 >>> 0) + (r3 >>> 0);
  return { h: t + n5 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var $n = (t, e2, n5) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0);
var kn = (t, e2, n5, r3) => e2 + n5 + r3 + (t / 2 ** 32 | 0) | 0;
var Rn = (t, e2, n5, r3) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0) + (r3 >>> 0);
var jn = (t, e2, n5, r3, o4) => e2 + n5 + r3 + o4 + (t / 2 ** 32 | 0) | 0;
var Zn = (t, e2, n5, r3, o4) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0) + (r3 >>> 0) + (o4 >>> 0);
var Gn = (t, e2, n5, r3, o4, s3) => e2 + n5 + r3 + o4 + s3 + (t / 2 ** 32 | 0) | 0;
var x = { fromBig: le, split: mn, toBig: _n, shrSH: Sn, shrSL: vn, rotrSH: In, rotrSL: Un, rotrBH: Tn, rotrBL: Fn, rotr32H: Nn, rotr32L: Ln, rotlSH: On, rotlSL: Hn, rotlBH: zn, rotlBL: Mn, add: qn, add3L: $n, add3H: kn, add4L: Rn, add4H: jn, add5H: Gn, add5L: Zn };
var [Vn, Yn] = (() => x.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t))))();
var P = new Uint32Array(80);
var Q = new Uint32Array(80);
var Jn = class extends An {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e2, Al: n5, Bh: r3, Bl: o4, Ch: s3, Cl: a3, Dh: u2, Dl: i4, Eh: D4, El: c6, Fh: l6, Fl: p4, Gh: w4, Gl: h5, Hh: g3, Hl: S4 } = this;
    return [e2, n5, r3, o4, s3, a3, u2, i4, D4, c6, l6, p4, w4, h5, g3, S4];
  }
  set(e2, n5, r3, o4, s3, a3, u2, i4, D4, c6, l6, p4, w4, h5, g3, S4) {
    this.Ah = e2 | 0, this.Al = n5 | 0, this.Bh = r3 | 0, this.Bl = o4 | 0, this.Ch = s3 | 0, this.Cl = a3 | 0, this.Dh = u2 | 0, this.Dl = i4 | 0, this.Eh = D4 | 0, this.El = c6 | 0, this.Fh = l6 | 0, this.Fl = p4 | 0, this.Gh = w4 | 0, this.Gl = h5 | 0, this.Hh = g3 | 0, this.Hl = S4 | 0;
  }
  process(e2, n5) {
    for (let d4 = 0; d4 < 16; d4++, n5 += 4) P[d4] = e2.getUint32(n5), Q[d4] = e2.getUint32(n5 += 4);
    for (let d4 = 16; d4 < 80; d4++) {
      const m3 = P[d4 - 15] | 0, F5 = Q[d4 - 15] | 0, q = x.rotrSH(m3, F5, 1) ^ x.rotrSH(m3, F5, 8) ^ x.shrSH(m3, F5, 7), z4 = x.rotrSL(m3, F5, 1) ^ x.rotrSL(m3, F5, 8) ^ x.shrSL(m3, F5, 7), I4 = P[d4 - 2] | 0, O5 = Q[d4 - 2] | 0, ot3 = x.rotrSH(I4, O5, 19) ^ x.rotrBH(I4, O5, 61) ^ x.shrSH(I4, O5, 6), tt3 = x.rotrSL(I4, O5, 19) ^ x.rotrBL(I4, O5, 61) ^ x.shrSL(I4, O5, 6), st = x.add4L(z4, tt3, Q[d4 - 7], Q[d4 - 16]), at3 = x.add4H(st, q, ot3, P[d4 - 7], P[d4 - 16]);
      P[d4] = at3 | 0, Q[d4] = st | 0;
    }
    let { Ah: r3, Al: o4, Bh: s3, Bl: a3, Ch: u2, Cl: i4, Dh: D4, Dl: c6, Eh: l6, El: p4, Fh: w4, Fl: h5, Gh: g3, Gl: S4, Hh: v6, Hl: L3 } = this;
    for (let d4 = 0; d4 < 80; d4++) {
      const m3 = x.rotrSH(l6, p4, 14) ^ x.rotrSH(l6, p4, 18) ^ x.rotrBH(l6, p4, 41), F5 = x.rotrSL(l6, p4, 14) ^ x.rotrSL(l6, p4, 18) ^ x.rotrBL(l6, p4, 41), q = l6 & w4 ^ ~l6 & g3, z4 = p4 & h5 ^ ~p4 & S4, I4 = x.add5L(L3, F5, z4, Yn[d4], Q[d4]), O5 = x.add5H(I4, v6, m3, q, Vn[d4], P[d4]), ot3 = I4 | 0, tt3 = x.rotrSH(r3, o4, 28) ^ x.rotrBH(r3, o4, 34) ^ x.rotrBH(r3, o4, 39), st = x.rotrSL(r3, o4, 28) ^ x.rotrBL(r3, o4, 34) ^ x.rotrBL(r3, o4, 39), at3 = r3 & s3 ^ r3 & u2 ^ s3 & u2, Ct4 = o4 & a3 ^ o4 & i4 ^ a3 & i4;
      v6 = g3 | 0, L3 = S4 | 0, g3 = w4 | 0, S4 = h5 | 0, w4 = l6 | 0, h5 = p4 | 0, { h: l6, l: p4 } = x.add(D4 | 0, c6 | 0, O5 | 0, ot3 | 0), D4 = u2 | 0, c6 = i4 | 0, u2 = s3 | 0, i4 = a3 | 0, s3 = r3 | 0, a3 = o4 | 0;
      const At4 = x.add3L(ot3, st, Ct4);
      r3 = x.add3H(At4, O5, tt3, at3), o4 = At4 | 0;
    }
    ({ h: r3, l: o4 } = x.add(this.Ah | 0, this.Al | 0, r3 | 0, o4 | 0)), { h: s3, l: a3 } = x.add(this.Bh | 0, this.Bl | 0, s3 | 0, a3 | 0), { h: u2, l: i4 } = x.add(this.Ch | 0, this.Cl | 0, u2 | 0, i4 | 0), { h: D4, l: c6 } = x.add(this.Dh | 0, this.Dl | 0, D4 | 0, c6 | 0), { h: l6, l: p4 } = x.add(this.Eh | 0, this.El | 0, l6 | 0, p4 | 0), { h: w4, l: h5 } = x.add(this.Fh | 0, this.Fl | 0, w4 | 0, h5 | 0), { h: g3, l: S4 } = x.add(this.Gh | 0, this.Gl | 0, g3 | 0, S4 | 0), { h: v6, l: L3 } = x.add(this.Hh | 0, this.Hl | 0, v6 | 0, L3 | 0), this.set(r3, o4, s3, a3, u2, i4, D4, c6, l6, p4, w4, h5, g3, S4, v6, L3);
  }
  roundClean() {
    P.fill(0), Q.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Kn = Bn(() => new Jn());
var vt = BigInt(0);
var be = BigInt(1);
var Wn = BigInt(2);
function It(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ut(t) {
  if (!It(t)) throw new Error("Uint8Array expected");
}
function Tt(t, e2) {
  if (typeof e2 != "boolean") throw new Error(t + " boolean expected, got " + e2);
}
var Xn = Array.from({ length: 256 }, (t, e2) => e2.toString(16).padStart(2, "0"));
function Ft(t) {
  Ut(t);
  let e2 = "";
  for (let n5 = 0; n5 < t.length; n5++) e2 += Xn[t[n5]];
  return e2;
}
function pe(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? vt : BigInt("0x" + t);
}
var K2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function we(t) {
  if (t >= K2._0 && t <= K2._9) return t - K2._0;
  if (t >= K2.A && t <= K2.F) return t - (K2.A - 10);
  if (t >= K2.a && t <= K2.f) return t - (K2.a - 10);
}
function Ee(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e2 = t.length, n5 = e2 / 2;
  if (e2 % 2) throw new Error("hex string expected, got unpadded hex of length " + e2);
  const r3 = new Uint8Array(n5);
  for (let o4 = 0, s3 = 0; o4 < n5; o4++, s3 += 2) {
    const a3 = we(t.charCodeAt(s3)), u2 = we(t.charCodeAt(s3 + 1));
    if (a3 === void 0 || u2 === void 0) {
      const i4 = t[s3] + t[s3 + 1];
      throw new Error('hex string expected, got non-hex character "' + i4 + '" at index ' + s3);
    }
    r3[o4] = a3 * 16 + u2;
  }
  return r3;
}
function Pn(t) {
  return pe(Ft(t));
}
function Et(t) {
  return Ut(t), pe(Ft(Uint8Array.from(t).reverse()));
}
function ge(t, e2) {
  return Ee(t.toString(16).padStart(e2 * 2, "0"));
}
function Nt(t, e2) {
  return ge(t, e2).reverse();
}
function W(t, e2, n5) {
  let r3;
  if (typeof e2 == "string") try {
    r3 = Ee(e2);
  } catch (s3) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s3);
  }
  else if (It(e2)) r3 = Uint8Array.from(e2);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o4 = r3.length;
  if (typeof n5 == "number" && o4 !== n5) throw new Error(t + " of length " + n5 + " expected, got " + o4);
  return r3;
}
function ye(...t) {
  let e2 = 0;
  for (let r3 = 0; r3 < t.length; r3++) {
    const o4 = t[r3];
    Ut(o4), e2 += o4.length;
  }
  const n5 = new Uint8Array(e2);
  for (let r3 = 0, o4 = 0; r3 < t.length; r3++) {
    const s3 = t[r3];
    n5.set(s3, o4), o4 += s3.length;
  }
  return n5;
}
var Lt = (t) => typeof t == "bigint" && vt <= t;
function Qn(t, e2, n5) {
  return Lt(t) && Lt(e2) && Lt(n5) && e2 <= t && t < n5;
}
function ft(t, e2, n5, r3) {
  if (!Qn(e2, n5, r3)) throw new Error("expected valid " + t + ": " + n5 + " <= n < " + r3 + ", got " + e2);
}
function tr(t) {
  let e2;
  for (e2 = 0; t > vt; t >>= be, e2 += 1) ;
  return e2;
}
var er = (t) => (Wn << BigInt(t - 1)) - be;
var nr = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || It(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e2) => e2.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Ot(t, e2, n5 = {}) {
  const r3 = (o4, s3, a3) => {
    const u2 = nr[s3];
    if (typeof u2 != "function") throw new Error("invalid validator function");
    const i4 = t[o4];
    if (!(a3 && i4 === void 0) && !u2(i4, t)) throw new Error("param " + String(o4) + " is invalid. Expected " + s3 + ", got " + i4);
  };
  for (const [o4, s3] of Object.entries(e2)) r3(o4, s3, false);
  for (const [o4, s3] of Object.entries(n5)) r3(o4, s3, true);
  return t;
}
function xe(t) {
  const e2 = /* @__PURE__ */ new WeakMap();
  return (n5, ...r3) => {
    const o4 = e2.get(n5);
    if (o4 !== void 0) return o4;
    const s3 = t(n5, ...r3);
    return e2.set(n5, s3), s3;
  };
}
var M = BigInt(0);
var N = BigInt(1);
var nt = BigInt(2);
var rr = BigInt(3);
var Ht = BigInt(4);
var Be = BigInt(5);
var Ce = BigInt(8);
function H(t, e2) {
  const n5 = t % e2;
  return n5 >= M ? n5 : e2 + n5;
}
function or(t, e2, n5) {
  if (e2 < M) throw new Error("invalid exponent, negatives unsupported");
  if (n5 <= M) throw new Error("invalid modulus");
  if (n5 === N) return M;
  let r3 = N;
  for (; e2 > M; ) e2 & N && (r3 = r3 * t % n5), t = t * t % n5, e2 >>= N;
  return r3;
}
function J(t, e2, n5) {
  let r3 = t;
  for (; e2-- > M; ) r3 *= r3, r3 %= n5;
  return r3;
}
function Ae(t, e2) {
  if (t === M) throw new Error("invert: expected non-zero number");
  if (e2 <= M) throw new Error("invert: expected positive modulus, got " + e2);
  let n5 = H(t, e2), r3 = e2, o4 = M, s3 = N;
  for (; n5 !== M; ) {
    const u2 = r3 / n5, i4 = r3 % n5, D4 = o4 - s3 * u2;
    r3 = n5, n5 = i4, o4 = s3, s3 = D4;
  }
  if (r3 !== N) throw new Error("invert: does not exist");
  return H(o4, e2);
}
function sr(t) {
  const e2 = (t - N) / nt;
  let n5, r3, o4;
  for (n5 = t - N, r3 = 0; n5 % nt === M; n5 /= nt, r3++) ;
  for (o4 = nt; o4 < t && or(o4, e2, t) !== t - N; o4++) if (o4 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r3 === 1) {
    const a3 = (t + N) / Ht;
    return function(i4, D4) {
      const c6 = i4.pow(D4, a3);
      if (!i4.eql(i4.sqr(c6), D4)) throw new Error("Cannot find square root");
      return c6;
    };
  }
  const s3 = (n5 + N) / nt;
  return function(u2, i4) {
    if (u2.pow(i4, e2) === u2.neg(u2.ONE)) throw new Error("Cannot find square root");
    let D4 = r3, c6 = u2.pow(u2.mul(u2.ONE, o4), n5), l6 = u2.pow(i4, s3), p4 = u2.pow(i4, n5);
    for (; !u2.eql(p4, u2.ONE); ) {
      if (u2.eql(p4, u2.ZERO)) return u2.ZERO;
      let w4 = 1;
      for (let g3 = u2.sqr(p4); w4 < D4 && !u2.eql(g3, u2.ONE); w4++) g3 = u2.sqr(g3);
      const h5 = u2.pow(c6, N << BigInt(D4 - w4 - 1));
      c6 = u2.sqr(h5), l6 = u2.mul(l6, h5), p4 = u2.mul(p4, c6), D4 = w4;
    }
    return l6;
  };
}
function ir(t) {
  if (t % Ht === rr) {
    const e2 = (t + N) / Ht;
    return function(r3, o4) {
      const s3 = r3.pow(o4, e2);
      if (!r3.eql(r3.sqr(s3), o4)) throw new Error("Cannot find square root");
      return s3;
    };
  }
  if (t % Ce === Be) {
    const e2 = (t - Be) / Ce;
    return function(r3, o4) {
      const s3 = r3.mul(o4, nt), a3 = r3.pow(s3, e2), u2 = r3.mul(o4, a3), i4 = r3.mul(r3.mul(u2, nt), a3), D4 = r3.mul(u2, r3.sub(i4, r3.ONE));
      if (!r3.eql(r3.sqr(D4), o4)) throw new Error("Cannot find square root");
      return D4;
    };
  }
  return sr(t);
}
var ur = (t, e2) => (H(t, e2) & N) === N;
var cr = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function ar(t) {
  const e2 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n5 = cr.reduce((r3, o4) => (r3[o4] = "function", r3), e2);
  return Ot(t, n5);
}
function fr(t, e2, n5) {
  if (n5 < M) throw new Error("invalid exponent, negatives unsupported");
  if (n5 === M) return t.ONE;
  if (n5 === N) return e2;
  let r3 = t.ONE, o4 = e2;
  for (; n5 > M; ) n5 & N && (r3 = t.mul(r3, o4)), o4 = t.sqr(o4), n5 >>= N;
  return r3;
}
function Dr(t, e2) {
  const n5 = new Array(e2.length), r3 = e2.reduce((s3, a3, u2) => t.is0(a3) ? s3 : (n5[u2] = s3, t.mul(s3, a3)), t.ONE), o4 = t.inv(r3);
  return e2.reduceRight((s3, a3, u2) => t.is0(a3) ? s3 : (n5[u2] = t.mul(s3, n5[u2]), t.mul(s3, a3)), o4), n5;
}
function me(t, e2) {
  const n5 = e2 !== void 0 ? e2 : t.toString(2).length, r3 = Math.ceil(n5 / 8);
  return { nBitLength: n5, nByteLength: r3 };
}
function _e(t, e2, n5 = false, r3 = {}) {
  if (t <= M) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o4, nByteLength: s3 } = me(t, e2);
  if (s3 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a3;
  const u2 = Object.freeze({ ORDER: t, isLE: n5, BITS: o4, BYTES: s3, MASK: er(o4), ZERO: M, ONE: N, create: (i4) => H(i4, t), isValid: (i4) => {
    if (typeof i4 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof i4);
    return M <= i4 && i4 < t;
  }, is0: (i4) => i4 === M, isOdd: (i4) => (i4 & N) === N, neg: (i4) => H(-i4, t), eql: (i4, D4) => i4 === D4, sqr: (i4) => H(i4 * i4, t), add: (i4, D4) => H(i4 + D4, t), sub: (i4, D4) => H(i4 - D4, t), mul: (i4, D4) => H(i4 * D4, t), pow: (i4, D4) => fr(u2, i4, D4), div: (i4, D4) => H(i4 * Ae(D4, t), t), sqrN: (i4) => i4 * i4, addN: (i4, D4) => i4 + D4, subN: (i4, D4) => i4 - D4, mulN: (i4, D4) => i4 * D4, inv: (i4) => Ae(i4, t), sqrt: r3.sqrt || ((i4) => (a3 || (a3 = ir(t)), a3(u2, i4))), invertBatch: (i4) => Dr(u2, i4), cmov: (i4, D4, c6) => c6 ? D4 : i4, toBytes: (i4) => n5 ? Nt(i4, s3) : ge(i4, s3), fromBytes: (i4) => {
    if (i4.length !== s3) throw new Error("Field.fromBytes: expected " + s3 + " bytes, got " + i4.length);
    return n5 ? Et(i4) : Pn(i4);
  } });
  return Object.freeze(u2);
}
var Se = BigInt(0);
var gt = BigInt(1);
function zt(t, e2) {
  const n5 = e2.negate();
  return t ? n5 : e2;
}
function ve(t, e2) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e2) throw new Error("invalid window size, expected [1.." + e2 + "], got W=" + t);
}
function Mt(t, e2) {
  ve(t, e2);
  const n5 = Math.ceil(e2 / t) + 1, r3 = 2 ** (t - 1);
  return { windows: n5, windowSize: r3 };
}
function dr(t, e2) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n5, r3) => {
    if (!(n5 instanceof e2)) throw new Error("invalid point at index " + r3);
  });
}
function hr(t, e2) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n5, r3) => {
    if (!e2.isValid(n5)) throw new Error("invalid scalar at index " + r3);
  });
}
var qt = /* @__PURE__ */ new WeakMap();
var Ie = /* @__PURE__ */ new WeakMap();
function $t(t) {
  return Ie.get(t) || 1;
}
function lr(t, e2) {
  return { constTimeNegate: zt, hasPrecomputes(n5) {
    return $t(n5) !== 1;
  }, unsafeLadder(n5, r3, o4 = t.ZERO) {
    let s3 = n5;
    for (; r3 > Se; ) r3 & gt && (o4 = o4.add(s3)), s3 = s3.double(), r3 >>= gt;
    return o4;
  }, precomputeWindow(n5, r3) {
    const { windows: o4, windowSize: s3 } = Mt(r3, e2), a3 = [];
    let u2 = n5, i4 = u2;
    for (let D4 = 0; D4 < o4; D4++) {
      i4 = u2, a3.push(i4);
      for (let c6 = 1; c6 < s3; c6++) i4 = i4.add(u2), a3.push(i4);
      u2 = i4.double();
    }
    return a3;
  }, wNAF(n5, r3, o4) {
    const { windows: s3, windowSize: a3 } = Mt(n5, e2);
    let u2 = t.ZERO, i4 = t.BASE;
    const D4 = BigInt(2 ** n5 - 1), c6 = 2 ** n5, l6 = BigInt(n5);
    for (let p4 = 0; p4 < s3; p4++) {
      const w4 = p4 * a3;
      let h5 = Number(o4 & D4);
      o4 >>= l6, h5 > a3 && (h5 -= c6, o4 += gt);
      const g3 = w4, S4 = w4 + Math.abs(h5) - 1, v6 = p4 % 2 !== 0, L3 = h5 < 0;
      h5 === 0 ? i4 = i4.add(zt(v6, r3[g3])) : u2 = u2.add(zt(L3, r3[S4]));
    }
    return { p: u2, f: i4 };
  }, wNAFUnsafe(n5, r3, o4, s3 = t.ZERO) {
    const { windows: a3, windowSize: u2 } = Mt(n5, e2), i4 = BigInt(2 ** n5 - 1), D4 = 2 ** n5, c6 = BigInt(n5);
    for (let l6 = 0; l6 < a3; l6++) {
      const p4 = l6 * u2;
      if (o4 === Se) break;
      let w4 = Number(o4 & i4);
      if (o4 >>= c6, w4 > u2 && (w4 -= D4, o4 += gt), w4 === 0) continue;
      let h5 = r3[p4 + Math.abs(w4) - 1];
      w4 < 0 && (h5 = h5.negate()), s3 = s3.add(h5);
    }
    return s3;
  }, getPrecomputes(n5, r3, o4) {
    let s3 = qt.get(r3);
    return s3 || (s3 = this.precomputeWindow(r3, n5), n5 !== 1 && qt.set(r3, o4(s3))), s3;
  }, wNAFCached(n5, r3, o4) {
    const s3 = $t(n5);
    return this.wNAF(s3, this.getPrecomputes(s3, n5, o4), r3);
  }, wNAFCachedUnsafe(n5, r3, o4, s3) {
    const a3 = $t(n5);
    return a3 === 1 ? this.unsafeLadder(n5, r3, s3) : this.wNAFUnsafe(a3, this.getPrecomputes(a3, n5, o4), r3, s3);
  }, setWindowSize(n5, r3) {
    ve(r3, e2), Ie.set(n5, r3), qt.delete(n5);
  } };
}
function br(t, e2, n5, r3) {
  if (dr(n5, t), hr(r3, e2), n5.length !== r3.length) throw new Error("arrays of points and scalars must have equal length");
  const o4 = t.ZERO, s3 = tr(BigInt(n5.length)), a3 = s3 > 12 ? s3 - 3 : s3 > 4 ? s3 - 2 : s3 ? 2 : 1, u2 = (1 << a3) - 1, i4 = new Array(u2 + 1).fill(o4), D4 = Math.floor((e2.BITS - 1) / a3) * a3;
  let c6 = o4;
  for (let l6 = D4; l6 >= 0; l6 -= a3) {
    i4.fill(o4);
    for (let w4 = 0; w4 < r3.length; w4++) {
      const h5 = r3[w4], g3 = Number(h5 >> BigInt(l6) & BigInt(u2));
      i4[g3] = i4[g3].add(n5[w4]);
    }
    let p4 = o4;
    for (let w4 = i4.length - 1, h5 = o4; w4 > 0; w4--) h5 = h5.add(i4[w4]), p4 = p4.add(h5);
    if (c6 = c6.add(p4), l6 !== 0) for (let w4 = 0; w4 < a3; w4++) c6 = c6.double();
  }
  return c6;
}
function pr(t) {
  return ar(t.Fp), Ot(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...me(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
var G = BigInt(0);
var j = BigInt(1);
var yt = BigInt(2);
var wr = BigInt(8);
var Er = { zip215: true };
function gr(t) {
  const e2 = pr(t);
  return Ot(t, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e2 });
}
function yr(t) {
  const e2 = gr(t), { Fp: n5, n: r3, prehash: o4, hash: s3, randomBytes: a3, nByteLength: u2, h: i4 } = e2, D4 = yt << BigInt(u2 * 8) - j, c6 = n5.create, l6 = _e(e2.n, e2.nBitLength), p4 = e2.uvRatio || ((y5, f8) => {
    try {
      return { isValid: true, value: n5.sqrt(y5 * n5.inv(f8)) };
    } catch {
      return { isValid: false, value: G };
    }
  }), w4 = e2.adjustScalarBytes || ((y5) => y5), h5 = e2.domain || ((y5, f8, b4) => {
    if (Tt("phflag", b4), f8.length || b4) throw new Error("Contexts/pre-hash are not supported");
    return y5;
  });
  function g3(y5, f8) {
    ft("coordinate " + y5, f8, G, D4);
  }
  function S4(y5) {
    if (!(y5 instanceof d4)) throw new Error("ExtendedPoint expected");
  }
  const v6 = xe((y5, f8) => {
    const { ex: b4, ey: E4, ez: B3 } = y5, C4 = y5.is0();
    f8 == null && (f8 = C4 ? wr : n5.inv(B3));
    const A4 = c6(b4 * f8), U3 = c6(E4 * f8), _3 = c6(B3 * f8);
    if (C4) return { x: G, y: j };
    if (_3 !== j) throw new Error("invZ was invalid");
    return { x: A4, y: U3 };
  }), L3 = xe((y5) => {
    const { a: f8, d: b4 } = e2;
    if (y5.is0()) throw new Error("bad point: ZERO");
    const { ex: E4, ey: B3, ez: C4, et: A4 } = y5, U3 = c6(E4 * E4), _3 = c6(B3 * B3), T3 = c6(C4 * C4), $3 = c6(T3 * T3), R3 = c6(U3 * f8), V3 = c6(T3 * c6(R3 + _3)), Y4 = c6($3 + c6(b4 * c6(U3 * _3)));
    if (V3 !== Y4) throw new Error("bad point: equation left != right (1)");
    const Z2 = c6(E4 * B3), X4 = c6(C4 * A4);
    if (Z2 !== X4) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class d4 {
    constructor(f8, b4, E4, B3) {
      this.ex = f8, this.ey = b4, this.ez = E4, this.et = B3, g3("x", f8), g3("y", b4), g3("z", E4), g3("t", B3), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f8) {
      if (f8 instanceof d4) throw new Error("extended point not allowed");
      const { x: b4, y: E4 } = f8 || {};
      return g3("x", b4), g3("y", E4), new d4(b4, E4, j, c6(b4 * E4));
    }
    static normalizeZ(f8) {
      const b4 = n5.invertBatch(f8.map((E4) => E4.ez));
      return f8.map((E4, B3) => E4.toAffine(b4[B3])).map(d4.fromAffine);
    }
    static msm(f8, b4) {
      return br(d4, l6, f8, b4);
    }
    _setWindowSize(f8) {
      q.setWindowSize(this, f8);
    }
    assertValidity() {
      L3(this);
    }
    equals(f8) {
      S4(f8);
      const { ex: b4, ey: E4, ez: B3 } = this, { ex: C4, ey: A4, ez: U3 } = f8, _3 = c6(b4 * U3), T3 = c6(C4 * B3), $3 = c6(E4 * U3), R3 = c6(A4 * B3);
      return _3 === T3 && $3 === R3;
    }
    is0() {
      return this.equals(d4.ZERO);
    }
    negate() {
      return new d4(c6(-this.ex), this.ey, this.ez, c6(-this.et));
    }
    double() {
      const { a: f8 } = e2, { ex: b4, ey: E4, ez: B3 } = this, C4 = c6(b4 * b4), A4 = c6(E4 * E4), U3 = c6(yt * c6(B3 * B3)), _3 = c6(f8 * C4), T3 = b4 + E4, $3 = c6(c6(T3 * T3) - C4 - A4), R3 = _3 + A4, V3 = R3 - U3, Y4 = _3 - A4, Z2 = c6($3 * V3), X4 = c6(R3 * Y4), et = c6($3 * Y4), pt4 = c6(V3 * R3);
      return new d4(Z2, X4, pt4, et);
    }
    add(f8) {
      S4(f8);
      const { a: b4, d: E4 } = e2, { ex: B3, ey: C4, ez: A4, et: U3 } = this, { ex: _3, ey: T3, ez: $3, et: R3 } = f8;
      if (b4 === BigInt(-1)) {
        const re2 = c6((C4 - B3) * (T3 + _3)), oe = c6((C4 + B3) * (T3 - _3)), mt4 = c6(oe - re2);
        if (mt4 === G) return this.double();
        const se4 = c6(A4 * yt * R3), ie4 = c6(U3 * yt * $3), ue4 = ie4 + se4, ce4 = oe + re2, ae4 = ie4 - se4, Dn3 = c6(ue4 * mt4), dn3 = c6(ce4 * ae4), hn3 = c6(ue4 * ae4), ln3 = c6(mt4 * ce4);
        return new d4(Dn3, dn3, ln3, hn3);
      }
      const V3 = c6(B3 * _3), Y4 = c6(C4 * T3), Z2 = c6(U3 * E4 * R3), X4 = c6(A4 * $3), et = c6((B3 + C4) * (_3 + T3) - V3 - Y4), pt4 = X4 - Z2, ee3 = X4 + Z2, ne4 = c6(Y4 - b4 * V3), un3 = c6(et * pt4), cn4 = c6(ee3 * ne4), an3 = c6(et * ne4), fn4 = c6(pt4 * ee3);
      return new d4(un3, cn4, fn4, an3);
    }
    subtract(f8) {
      return this.add(f8.negate());
    }
    wNAF(f8) {
      return q.wNAFCached(this, f8, d4.normalizeZ);
    }
    multiply(f8) {
      const b4 = f8;
      ft("scalar", b4, j, r3);
      const { p: E4, f: B3 } = this.wNAF(b4);
      return d4.normalizeZ([E4, B3])[0];
    }
    multiplyUnsafe(f8, b4 = d4.ZERO) {
      const E4 = f8;
      return ft("scalar", E4, G, r3), E4 === G ? F5 : this.is0() || E4 === j ? this : q.wNAFCachedUnsafe(this, E4, d4.normalizeZ, b4);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i4).is0();
    }
    isTorsionFree() {
      return q.unsafeLadder(this, r3).is0();
    }
    toAffine(f8) {
      return v6(this, f8);
    }
    clearCofactor() {
      const { h: f8 } = e2;
      return f8 === j ? this : this.multiplyUnsafe(f8);
    }
    static fromHex(f8, b4 = false) {
      const { d: E4, a: B3 } = e2, C4 = n5.BYTES;
      f8 = W("pointHex", f8, C4), Tt("zip215", b4);
      const A4 = f8.slice(), U3 = f8[C4 - 1];
      A4[C4 - 1] = U3 & -129;
      const _3 = Et(A4), T3 = b4 ? D4 : n5.ORDER;
      ft("pointHex.y", _3, G, T3);
      const $3 = c6(_3 * _3), R3 = c6($3 - j), V3 = c6(E4 * $3 - B3);
      let { isValid: Y4, value: Z2 } = p4(R3, V3);
      if (!Y4) throw new Error("Point.fromHex: invalid y coordinate");
      const X4 = (Z2 & j) === j, et = (U3 & 128) !== 0;
      if (!b4 && Z2 === G && et) throw new Error("Point.fromHex: x=0 and x_0=1");
      return et !== X4 && (Z2 = c6(-Z2)), d4.fromAffine({ x: Z2, y: _3 });
    }
    static fromPrivateKey(f8) {
      return O5(f8).point;
    }
    toRawBytes() {
      const { x: f8, y: b4 } = this.toAffine(), E4 = Nt(b4, n5.BYTES);
      return E4[E4.length - 1] |= f8 & j ? 128 : 0, E4;
    }
    toHex() {
      return Ft(this.toRawBytes());
    }
  }
  d4.BASE = new d4(e2.Gx, e2.Gy, j, c6(e2.Gx * e2.Gy)), d4.ZERO = new d4(G, j, j, G);
  const { BASE: m3, ZERO: F5 } = d4, q = lr(d4, u2 * 8);
  function z4(y5) {
    return H(y5, r3);
  }
  function I4(y5) {
    return z4(Et(y5));
  }
  function O5(y5) {
    const f8 = n5.BYTES;
    y5 = W("private key", y5, f8);
    const b4 = W("hashed private key", s3(y5), 2 * f8), E4 = w4(b4.slice(0, f8)), B3 = b4.slice(f8, 2 * f8), C4 = I4(E4), A4 = m3.multiply(C4), U3 = A4.toRawBytes();
    return { head: E4, prefix: B3, scalar: C4, point: A4, pointBytes: U3 };
  }
  function ot3(y5) {
    return O5(y5).pointBytes;
  }
  function tt3(y5 = new Uint8Array(), ...f8) {
    const b4 = ye(...f8);
    return I4(s3(h5(b4, W("context", y5), !!o4)));
  }
  function st(y5, f8, b4 = {}) {
    y5 = W("message", y5), o4 && (y5 = o4(y5));
    const { prefix: E4, scalar: B3, pointBytes: C4 } = O5(f8), A4 = tt3(b4.context, E4, y5), U3 = m3.multiply(A4).toRawBytes(), _3 = tt3(b4.context, U3, C4, y5), T3 = z4(A4 + _3 * B3);
    ft("signature.s", T3, G, r3);
    const $3 = ye(U3, Nt(T3, n5.BYTES));
    return W("result", $3, n5.BYTES * 2);
  }
  const at3 = Er;
  function Ct4(y5, f8, b4, E4 = at3) {
    const { context: B3, zip215: C4 } = E4, A4 = n5.BYTES;
    y5 = W("signature", y5, 2 * A4), f8 = W("message", f8), b4 = W("publicKey", b4, A4), C4 !== void 0 && Tt("zip215", C4), o4 && (f8 = o4(f8));
    const U3 = Et(y5.slice(A4, 2 * A4));
    let _3, T3, $3;
    try {
      _3 = d4.fromHex(b4, C4), T3 = d4.fromHex(y5.slice(0, A4), C4), $3 = m3.multiplyUnsafe(U3);
    } catch {
      return false;
    }
    if (!C4 && _3.isSmallOrder()) return false;
    const R3 = tt3(B3, T3.toRawBytes(), _3.toRawBytes(), f8);
    return T3.add(_3.multiplyUnsafe(R3)).subtract($3).clearCofactor().equals(d4.ZERO);
  }
  return m3._setWindowSize(8), { CURVE: e2, getPublicKey: ot3, sign: st, verify: Ct4, ExtendedPoint: d4, utils: { getExtendedPublicKey: O5, randomPrivateKey: () => a3(n5.BYTES), precompute(y5 = 8, f8 = d4.BASE) {
    return f8._setWindowSize(y5), f8.multiply(BigInt(3)), f8;
  } } };
}
BigInt(0), BigInt(1);
var kt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var Ue = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
var xr = BigInt(1);
var Te = BigInt(2);
BigInt(3);
var Br = BigInt(5);
var Cr = BigInt(8);
function Ar(t) {
  const e2 = BigInt(10), n5 = BigInt(20), r3 = BigInt(40), o4 = BigInt(80), s3 = kt, u2 = t * t % s3 * t % s3, i4 = J(u2, Te, s3) * u2 % s3, D4 = J(i4, xr, s3) * t % s3, c6 = J(D4, Br, s3) * D4 % s3, l6 = J(c6, e2, s3) * c6 % s3, p4 = J(l6, n5, s3) * l6 % s3, w4 = J(p4, r3, s3) * p4 % s3, h5 = J(w4, o4, s3) * w4 % s3, g3 = J(h5, o4, s3) * w4 % s3, S4 = J(g3, e2, s3) * c6 % s3;
  return { pow_p_5_8: J(S4, Te, s3) * t % s3, b2: u2 };
}
function mr(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
function _r(t, e2) {
  const n5 = kt, r3 = H(e2 * e2 * e2, n5), o4 = H(r3 * r3 * e2, n5), s3 = Ar(t * o4).pow_p_5_8;
  let a3 = H(t * r3 * s3, n5);
  const u2 = H(e2 * a3 * a3, n5), i4 = a3, D4 = H(a3 * Ue, n5), c6 = u2 === t, l6 = u2 === H(-t, n5), p4 = u2 === H(-t * Ue, n5);
  return c6 && (a3 = i4), (l6 || p4) && (a3 = D4), ur(a3, n5) && (a3 = H(-a3, n5)), { isValid: c6 || l6, value: a3 };
}
var Sr = (() => _e(kt, void 0, true))();
var vr = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: Sr, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: Cr, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Kn, randomBytes: he, adjustScalarBytes: mr, uvRatio: _r }))();
var Rt = (() => yr(vr))();
var jt = "EdDSA";
var Zt = "JWT";
var ut = ".";
var Dt = "base64url";
var Gt = "utf8";
var xt = "utf8";
var Vt = ":";
var Yt = "did";
var Jt = "key";
var dt = "base58btc";
var Kt = "z";
var Wt = "K36";
var Ne = 32;
function Xt(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Le(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Oe(t, e2) {
  e2 || (e2 = t.reduce((o4, s3) => o4 + s3.length, 0));
  const n5 = Le(e2);
  let r3 = 0;
  for (const o4 of t) n5.set(o4, r3), r3 += o4.length;
  return Xt(n5);
}
function Ir(t, e2) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n5 = new Uint8Array(256), r3 = 0; r3 < n5.length; r3++) n5[r3] = 255;
  for (var o4 = 0; o4 < t.length; o4++) {
    var s3 = t.charAt(o4), a3 = s3.charCodeAt(0);
    if (n5[a3] !== 255) throw new TypeError(s3 + " is ambiguous");
    n5[a3] = o4;
  }
  var u2 = t.length, i4 = t.charAt(0), D4 = Math.log(u2) / Math.log(256), c6 = Math.log(256) / Math.log(u2);
  function l6(h5) {
    if (h5 instanceof Uint8Array || (ArrayBuffer.isView(h5) ? h5 = new Uint8Array(h5.buffer, h5.byteOffset, h5.byteLength) : Array.isArray(h5) && (h5 = Uint8Array.from(h5))), !(h5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (h5.length === 0) return "";
    for (var g3 = 0, S4 = 0, v6 = 0, L3 = h5.length; v6 !== L3 && h5[v6] === 0; ) v6++, g3++;
    for (var d4 = (L3 - v6) * c6 + 1 >>> 0, m3 = new Uint8Array(d4); v6 !== L3; ) {
      for (var F5 = h5[v6], q = 0, z4 = d4 - 1; (F5 !== 0 || q < S4) && z4 !== -1; z4--, q++) F5 += 256 * m3[z4] >>> 0, m3[z4] = F5 % u2 >>> 0, F5 = F5 / u2 >>> 0;
      if (F5 !== 0) throw new Error("Non-zero carry");
      S4 = q, v6++;
    }
    for (var I4 = d4 - S4; I4 !== d4 && m3[I4] === 0; ) I4++;
    for (var O5 = i4.repeat(g3); I4 < d4; ++I4) O5 += t.charAt(m3[I4]);
    return O5;
  }
  function p4(h5) {
    if (typeof h5 != "string") throw new TypeError("Expected String");
    if (h5.length === 0) return new Uint8Array();
    var g3 = 0;
    if (h5[g3] !== " ") {
      for (var S4 = 0, v6 = 0; h5[g3] === i4; ) S4++, g3++;
      for (var L3 = (h5.length - g3) * D4 + 1 >>> 0, d4 = new Uint8Array(L3); h5[g3]; ) {
        var m3 = n5[h5.charCodeAt(g3)];
        if (m3 === 255) return;
        for (var F5 = 0, q = L3 - 1; (m3 !== 0 || F5 < v6) && q !== -1; q--, F5++) m3 += u2 * d4[q] >>> 0, d4[q] = m3 % 256 >>> 0, m3 = m3 / 256 >>> 0;
        if (m3 !== 0) throw new Error("Non-zero carry");
        v6 = F5, g3++;
      }
      if (h5[g3] !== " ") {
        for (var z4 = L3 - v6; z4 !== L3 && d4[z4] === 0; ) z4++;
        for (var I4 = new Uint8Array(S4 + (L3 - z4)), O5 = S4; z4 !== L3; ) I4[O5++] = d4[z4++];
        return I4;
      }
    }
  }
  function w4(h5) {
    var g3 = p4(h5);
    if (g3) return g3;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: l6, decodeUnsafe: p4, decode: w4 };
}
var Ur = Ir;
var Tr = Ur;
var He = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Fr = (t) => new TextEncoder().encode(t);
var Nr = (t) => new TextDecoder().decode(t);
var Lr = class {
  constructor(e2, n5, r3) {
    this.name = e2, this.prefix = n5, this.baseEncode = r3;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Or = class {
  constructor(e2, n5, r3) {
    if (this.name = e2, this.prefix = n5, n5.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = n5.codePointAt(0), this.baseDecode = r3;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return ze(this, e2);
  }
};
var Hr = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return ze(this, e2);
  }
  decode(e2) {
    const n5 = e2[0], r3 = this.decoders[n5];
    if (r3) return r3.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ze = (t, e2) => new Hr({ ...t.decoders || { [t.prefix]: t }, ...e2.decoders || { [e2.prefix]: e2 } });
var zr = class {
  constructor(e2, n5, r3, o4) {
    this.name = e2, this.prefix = n5, this.baseEncode = r3, this.baseDecode = o4, this.encoder = new Lr(e2, n5, r3), this.decoder = new Or(e2, n5, o4);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var Bt = ({ name: t, prefix: e2, encode: n5, decode: r3 }) => new zr(t, e2, n5, r3);
var ht = ({ prefix: t, name: e2, alphabet: n5 }) => {
  const { encode: r3, decode: o4 } = Tr(n5, e2);
  return Bt({ prefix: t, name: e2, encode: r3, decode: (s3) => He(o4(s3)) });
};
var Mr = (t, e2, n5, r3) => {
  const o4 = {};
  for (let c6 = 0; c6 < e2.length; ++c6) o4[e2[c6]] = c6;
  let s3 = t.length;
  for (; t[s3 - 1] === "="; ) --s3;
  const a3 = new Uint8Array(s3 * n5 / 8 | 0);
  let u2 = 0, i4 = 0, D4 = 0;
  for (let c6 = 0; c6 < s3; ++c6) {
    const l6 = o4[t[c6]];
    if (l6 === void 0) throw new SyntaxError(`Non-${r3} character`);
    i4 = i4 << n5 | l6, u2 += n5, u2 >= 8 && (u2 -= 8, a3[D4++] = 255 & i4 >> u2);
  }
  if (u2 >= n5 || 255 & i4 << 8 - u2) throw new SyntaxError("Unexpected end of data");
  return a3;
};
var qr = (t, e2, n5) => {
  const r3 = e2[e2.length - 1] === "=", o4 = (1 << n5) - 1;
  let s3 = "", a3 = 0, u2 = 0;
  for (let i4 = 0; i4 < t.length; ++i4) for (u2 = u2 << 8 | t[i4], a3 += 8; a3 > n5; ) a3 -= n5, s3 += e2[o4 & u2 >> a3];
  if (a3 && (s3 += e2[o4 & u2 << n5 - a3]), r3) for (; s3.length * n5 & 7; ) s3 += "=";
  return s3;
};
var k = ({ name: t, prefix: e2, bitsPerChar: n5, alphabet: r3 }) => Bt({ prefix: e2, name: t, encode(o4) {
  return qr(o4, r3, n5);
}, decode(o4) {
  return Mr(o4, r3, n5, t);
} });
var $r = Bt({ prefix: "\0", name: "identity", encode: (t) => Nr(t), decode: (t) => Fr(t) });
var kr = Object.freeze({ __proto__: null, identity: $r });
var Rr = k({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jr = Object.freeze({ __proto__: null, base2: Rr });
var Zr = k({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gr = Object.freeze({ __proto__: null, base8: Zr });
var Vr = ht({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Yr = Object.freeze({ __proto__: null, base10: Vr });
var Jr = k({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Kr = k({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Wr = Object.freeze({ __proto__: null, base16: Jr, base16upper: Kr });
var Xr = k({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Pr = k({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Qr = k({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var to = k({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var eo = k({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var no = k({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ro = k({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var oo = k({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var so = k({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var io = Object.freeze({ __proto__: null, base32: Xr, base32upper: Pr, base32pad: Qr, base32padupper: to, base32hex: eo, base32hexupper: no, base32hexpad: ro, base32hexpadupper: oo, base32z: so });
var uo = ht({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var co = ht({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ao = Object.freeze({ __proto__: null, base36: uo, base36upper: co });
var fo = ht({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Do = ht({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ho = Object.freeze({ __proto__: null, base58btc: fo, base58flickr: Do });
var lo = k({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var bo = k({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var po = k({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var wo = k({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Eo = Object.freeze({ __proto__: null, base64: lo, base64pad: bo, base64url: po, base64urlpad: wo });
var Me = Array.from("");
var go = Me.reduce((t, e2, n5) => (t[n5] = e2, t), []);
var yo = Me.reduce((t, e2, n5) => (t[e2.codePointAt(0)] = n5, t), []);
function xo(t) {
  return t.reduce((e2, n5) => (e2 += go[n5], e2), "");
}
function Bo(t) {
  const e2 = [];
  for (const n5 of t) {
    const r3 = yo[n5.codePointAt(0)];
    if (r3 === void 0) throw new Error(`Non-base256emoji character: ${n5}`);
    e2.push(r3);
  }
  return new Uint8Array(e2);
}
var Co = Bt({ prefix: "", name: "base256emoji", encode: xo, decode: Bo });
var Ao = Object.freeze({ __proto__: null, base256emoji: Co });
var mo = $e;
var qe = 128;
var _o = 127;
var So = ~_o;
var vo = Math.pow(2, 31);
function $e(t, e2, n5) {
  e2 = e2 || [], n5 = n5 || 0;
  for (var r3 = n5; t >= vo; ) e2[n5++] = t & 255 | qe, t /= 128;
  for (; t & So; ) e2[n5++] = t & 255 | qe, t >>>= 7;
  return e2[n5] = t | 0, $e.bytes = n5 - r3 + 1, e2;
}
var Io = Pt;
var Uo = 128;
var ke = 127;
function Pt(t, r3) {
  var n5 = 0, r3 = r3 || 0, o4 = 0, s3 = r3, a3, u2 = t.length;
  do {
    if (s3 >= u2) throw Pt.bytes = 0, new RangeError("Could not decode varint");
    a3 = t[s3++], n5 += o4 < 28 ? (a3 & ke) << o4 : (a3 & ke) * Math.pow(2, o4), o4 += 7;
  } while (a3 >= Uo);
  return Pt.bytes = s3 - r3, n5;
}
var To = Math.pow(2, 7);
var Fo = Math.pow(2, 14);
var No = Math.pow(2, 21);
var Lo = Math.pow(2, 28);
var Oo = Math.pow(2, 35);
var Ho = Math.pow(2, 42);
var zo = Math.pow(2, 49);
var Mo = Math.pow(2, 56);
var qo = Math.pow(2, 63);
var $o = function(t) {
  return t < To ? 1 : t < Fo ? 2 : t < No ? 3 : t < Lo ? 4 : t < Oo ? 5 : t < Ho ? 6 : t < zo ? 7 : t < Mo ? 8 : t < qo ? 9 : 10;
};
var ko = { encode: mo, decode: Io, encodingLength: $o };
var Re = ko;
var je = (t, e2, n5 = 0) => (Re.encode(t, e2, n5), e2);
var Ze = (t) => Re.encodingLength(t);
var Qt = (t, e2) => {
  const n5 = e2.byteLength, r3 = Ze(t), o4 = r3 + Ze(n5), s3 = new Uint8Array(o4 + n5);
  return je(t, s3, 0), je(n5, s3, r3), s3.set(e2, o4), new Ro(t, n5, e2, s3);
};
var Ro = class {
  constructor(e2, n5, r3, o4) {
    this.code = e2, this.size = n5, this.digest = r3, this.bytes = o4;
  }
};
var Ge = ({ name: t, code: e2, encode: n5 }) => new jo(t, e2, n5);
var jo = class {
  constructor(e2, n5, r3) {
    this.name = e2, this.code = n5, this.encode = r3;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const n5 = this.encode(e2);
      return n5 instanceof Uint8Array ? Qt(this.code, n5) : n5.then((r3) => Qt(this.code, r3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Ve = (t) => async (e2) => new Uint8Array(await crypto.subtle.digest(t, e2));
var Zo = Ge({ name: "sha2-256", code: 18, encode: Ve("SHA-256") });
var Go = Ge({ name: "sha2-512", code: 19, encode: Ve("SHA-512") });
var Vo = Object.freeze({ __proto__: null, sha256: Zo, sha512: Go });
var Ye = 0;
var Yo = "identity";
var Je = He;
var Jo = (t) => Qt(Ye, Je(t));
var Ko = { code: Ye, name: Yo, encode: Je, digest: Jo };
var Wo = Object.freeze({ __proto__: null, identity: Ko });
new TextEncoder(), new TextDecoder();
var Ke = { ...kr, ...jr, ...Gr, ...Yr, ...Wr, ...io, ...ao, ...ho, ...Eo, ...Ao };
({ ...Vo, ...Wo });
function We(t, e2, n5, r3) {
  return { name: t, prefix: e2, encoder: { name: t, prefix: e2, encode: n5 }, decoder: { decode: r3 } };
}
var Xe = We("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1)));
var te = We("ascii", "a", (t) => {
  let e2 = "a";
  for (let n5 = 0; n5 < t.length; n5++) e2 += String.fromCharCode(t[n5]);
  return e2;
}, (t) => {
  t = t.substring(1);
  const e2 = Le(t.length);
  for (let n5 = 0; n5 < t.length; n5++) e2[n5] = t.charCodeAt(n5);
  return e2;
});
var Pe = { utf8: Xe, "utf-8": Xe, hex: Ke.base16, latin1: te, ascii: te, binary: te, ...Ke };
function ct(t, e2 = "utf8") {
  const n5 = Pe[e2];
  if (!n5) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : n5.encoder.encode(t).substring(1);
}
function rt(t, e2 = "utf8") {
  const n5 = Pe[e2];
  if (!n5) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt(globalThis.Buffer.from(t, "utf-8")) : n5.decoder.decode(`${n5.prefix}${t}`);
}
function lt(t) {
  return safeJsonParse(ct(rt(t, Dt), Gt));
}
function bt(t) {
  return ct(rt(safeJsonStringify(t), Gt), Dt);
}
function Qe(t) {
  const e2 = rt(Wt, dt), n5 = Kt + ct(Oe([e2, t]), dt);
  return [Yt, Jt, n5].join(Vt);
}
function en(t) {
  return ct(t, Dt);
}
function nn(t) {
  return rt(t, Dt);
}
function rn(t) {
  return rt([bt(t.header), bt(t.payload)].join(ut), xt);
}
function on2(t) {
  return [bt(t.header), bt(t.payload), en(t.signature)].join(ut);
}
function sn(t) {
  const e2 = t.split(ut), n5 = lt(e2[0]), r3 = lt(e2[1]), o4 = nn(e2[2]), s3 = rt(e2.slice(0, 2).join(ut), xt);
  return { header: n5, payload: r3, signature: o4, data: s3 };
}
function Po(t = he(Ne)) {
  const e2 = Rt.getPublicKey(t);
  return { secretKey: Oe([t, e2]), publicKey: e2 };
}
async function Qo(t, e2, n5, r3, o4 = (0, import_time.fromMiliseconds)(Date.now())) {
  const s3 = { alg: jt, typ: Zt }, a3 = Qe(r3.publicKey), u2 = o4 + n5, i4 = { iss: a3, sub: t, aud: e2, iat: o4, exp: u2 }, D4 = rn({ header: s3, payload: i4 }), c6 = Rt.sign(D4, r3.secretKey.slice(0, 32));
  return on2({ header: s3, payload: i4, signature: c6 });
}

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size9 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size9));
  }
  return new Uint8Array(size9);
}

// node_modules/uint8arrays/esm/src/concat.js
function concat4(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset5 = 0;
  for (const arr of arrays) {
    output2.set(arr, offset5);
    offset5 += arr.length;
  }
  return asUint8Array(output2);
}

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/multiformats/esm/vendor/base-x.js
function base2(ALPHABET3, name2) {
  if (ALPHABET3.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
    BASE_MAP[j3] = 255;
  }
  for (var i4 = 0; i4 < ALPHABET3.length; i4++) {
    var x5 = ALPHABET3.charAt(i4);
    var xc3 = x5.charCodeAt(0);
    if (BASE_MAP[xc3] !== 255) {
      throw new TypeError(x5 + " is ambiguous");
    }
    BASE_MAP[xc3] = i4;
  }
  var BASE = ALPHABET3.length;
  var LEADER = ALPHABET3.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode16(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size9 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size9);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i5 = 0;
      for (var it1 = size9 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i5;
      pbegin++;
    }
    var it22 = size9 - length2;
    while (it22 !== size9 && b58[it22] === 0) {
      it22++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it22 < size9; ++it22) {
      str += ALPHABET3.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size9 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size9);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i5 = 0;
      for (var it32 = size9 - 1; (carry !== 0 || i5 < length2) && it32 !== -1; it32--, i5++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i5;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size9 - length2;
    while (it4 !== size9 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size9 - it4));
    var j4 = zeroes;
    while (it4 !== size9) {
      vch[j4++] = b256[it4++];
    }
    return vch;
  }
  function decode9(string4) {
    var buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode16,
    decodeUnsafe,
    decode: decode9
  };
}
var src = base2;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa2, bb) => {
  if (aa2 === bb)
    return true;
  if (aa2.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii3 = 0; ii3 < aa2.byteLength; ii3++) {
    if (aa2[ii3] !== bb[ii3]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array")
    return o4;
  if (o4 instanceof ArrayBuffer)
    return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4)) {
    return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString5 = (str) => new TextEncoder().encode(str);
var toString2 = (b4) => new TextDecoder().decode(b4);

// node_modules/multiformats/esm/src/bases/base.js
var Encoder2 = class {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left13, right13) => new ComposedDecoder({
  ...left13.decoders || { [left13.prefix]: left13 },
  ...right13.decoders || { [right13.prefix]: right13 }
});
var Codec = class {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name2, prefix, baseEncode);
    this.decoder = new Decoder2(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from7 = ({ name: name2, prefix, encode: encode16, decode: decode9 }) => new Codec(name2, prefix, encode16, decode9);
var baseX = ({ prefix, name: name2, alphabet: alphabet3 }) => {
  const { encode: encode16, decode: decode9 } = base_x_default(alphabet3, name2);
  return from7({
    prefix,
    name: name2,
    encode: encode16,
    decode: (text) => coerce2(decode9(text))
  });
};
var decode3 = (string4, alphabet3, bitsPerChar, name2) => {
  const codes = {};
  for (let i4 = 0; i4 < alphabet3.length; ++i4) {
    codes[alphabet3[i4]] = i4;
  }
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i4 = 0; i4 < end; ++i4) {
    const value = codes[string4[i4]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode5 = (data, alphabet3, bitsPerChar) => {
  const pad3 = alphabet3[alphabet3.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i4 = 0; i4 < data.length; ++i4) {
    buffer = buffer << 8 | data[i4];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet3[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet3[mask & buffer << bitsPerChar - bits];
  }
  if (pad3) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet3 }) => {
  return from7({
    prefix,
    name: name2,
    encode(input) {
      return encode5(input, alphabet3, bitsPerChar);
    },
    decode(input) {
      return decode3(input, alphabet3, bitsPerChar, name2);
    }
  });
};

// node_modules/multiformats/esm/src/bases/identity.js
var identity = from7({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString2(buf),
  decode: (str) => fromString5(str)
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base162,
  base16upper: () => base16upper
});
var base162 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base322 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr2
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base642,
  base64pad: () => base64pad,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad
});
var base642 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet2 = Array.from("");
var alphabetBytesToChars = alphabet2.reduce((p4, c6, i4) => {
  p4[i4] = c6;
  return p4;
}, []);
var alphabetCharsToBytes = alphabet2.reduce((p4, c6, i4) => {
  p4[c6.codePointAt(0)] = i4;
  return p4;
}, []);
function encode6(data) {
  return data.reduce((p4, c6) => {
    p4 += alphabetBytesToChars[c6];
    return p4;
  }, "");
}
function decode4(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from7({
  prefix: "",
  name: "base256emoji",
  encode: encode6,
  decode: decode4
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2564,
  sha512: () => sha5122
});

// node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode7;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode7(num3, out, offset5) {
  out = out || [];
  offset5 = offset5 || 0;
  var oldOffset = offset5;
  while (num3 >= INT) {
    out[offset5++] = num3 & 255 | MSB;
    num3 /= 128;
  }
  while (num3 & MSBALL) {
    out[offset5++] = num3 & 255 | MSB;
    num3 >>>= 7;
  }
  out[offset5] = num3 | 0;
  encode7.bytes = offset5 - oldOffset + 1;
  return out;
}
var decode5 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset5) {
  var res = 0, offset5 = offset5 || 0, shift = 0, counter = offset5, b4, l6 = buf.length;
  do {
    if (counter >= l6) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b4 = buf[counter++];
    res += shift < 28 ? (b4 & REST$1) << shift : (b4 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b4 >= MSB$1);
  read.bytes = counter - offset5;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode5,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/multiformats/esm/src/varint.js
var decode6 = (data, offset5 = 0) => {
  const code2 = varint_default.decode(data, offset5);
  return [
    code2,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset5 = 0) => {
  varint_default.encode(int, target, offset5);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/multiformats/esm/src/hashes/digest.js
var create3 = (code2, digest2) => {
  const size9 = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size9);
  const bytes2 = new Uint8Array(digestOffset + size9);
  encodeTo(code2, bytes2, 0);
  encodeTo(size9, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest(code2, size9, digest2, bytes2);
};
var decode7 = (multihash) => {
  const bytes2 = coerce2(multihash);
  const [code2, sizeOffset] = decode6(bytes2);
  const [size9, digestOffset] = decode6(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size9) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size9, digest2, bytes2);
};
var equals2 = (a3, b4) => {
  if (a3 === b4) {
    return true;
  } else {
    return a3.code === b4.code && a3.size === b4.size && equals(a3.bytes, b4.bytes);
  }
};
var Digest = class {
  constructor(code2, size9, digest2, bytes2) {
    this.code = code2;
    this.size = size9;
    this.digest = digest2;
    this.bytes = bytes2;
  }
};

// node_modules/multiformats/esm/src/hashes/hasher.js
var from8 = ({ name: name2, code: code2, encode: encode16 }) => new Hasher(name2, code2, encode16);
var Hasher = class {
  constructor(name2, code2, encode16) {
    this.name = name2;
    this.code = code2;
    this.encode = encode16;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest2) => create3(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
var sha2564 = from8({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha5122 = from8({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode8 = coerce2;
var digest = (input) => create3(code, encode8(input));
var identity2 = {
  code,
  name,
  encode: encode8,
  digest
};

// node_modules/multiformats/esm/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version11, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version11;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create3(code2, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version11, _baseCache } = this;
    switch (version11) {
      case 0:
        return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes2, _baseCache, base3 || base322.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version11, code: code2, multihash, bytes: bytes2 } = value;
      return new _CID(version11, code2, multihash, bytes2 || encodeCID(version11, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version11, multihash, code: code2 } = value;
      const digest2 = decode7(multihash);
      return _CID.create(version11, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version11, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version11) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version11, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID(version11, code2, digest2.bytes);
        return new _CID(version11, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return _CID.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset5 = 0;
    const next = () => {
      const [i4, length2] = decode6(initialBytes.subarray(offset5));
      offset5 += length2;
      return i4;
    };
    let version11 = next();
    let codec = DAG_PB_CODE;
    if (version11 === 18) {
      version11 = 0;
      offset5 = 0;
    } else if (version11 === 1) {
      codec = next();
    }
    if (version11 !== 0 && version11 !== 1) {
      throw new RangeError(`Invalid CID version ${version11}`);
    }
    const prefixSize = offset5;
    const multihashCode = next();
    const digestSize = next();
    const size9 = offset5 + digestSize;
    const multihashSize = size9 - prefixSize;
    return {
      version: version11,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size9
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base3);
    const cid = _CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base3 || base322;
      return [
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version11, code2, multihash) => {
  const codeOffset = encodingLength(version11);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version11, bytes2, 0);
  encodeTo(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version3 = "0.0.0-dev";
var deprecate = (range3, message) => {
  if (range3.test(version3)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports2
};

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode16, decode9) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode16
    },
    decoder: { decode: decode9 }
  };
}
var string2 = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i4 = 0; i4 < buf.length; i4++) {
    string4 += String.fromCharCode(buf[i4]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i4 = 0; i4 < str.length; i4++) {
    buf[i4] = str.charCodeAt(i4);
  }
  return buf;
});
var BASES = {
  utf8: string2,
  "utf-8": string2,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/uint8arrays/esm/src/from-string.js
function fromString6(string4, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string4, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string4}`);
}

// node_modules/uint8arrays/esm/src/to-string.js
function toString3(array2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array2).substring(1);
}

// node_modules/@walletconnect/relay-api/dist/index.es.js
var C = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };

// node_modules/@dynamic-labs/solana/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
var Be2 = BigInt(2 ** 32 - 1);
var yr2 = BigInt(32);
function mr2(t, e2 = false) {
  return e2 ? { h: Number(t & Be2), l: Number(t >> yr2 & Be2) } : { h: Number(t >> yr2 & Be2) | 0, l: Number(t & Be2) | 0 };
}
function wr2(t, e2 = false) {
  const n5 = t.length;
  let r3 = new Uint32Array(n5), o4 = new Uint32Array(n5);
  for (let s3 = 0; s3 < n5; s3++) {
    const { h: i4, l: f8 } = mr2(t[s3], e2);
    [r3[s3], o4[s3]] = [i4, f8];
  }
  return [r3, o4];
}
var xr2 = (t, e2, n5) => t >>> n5;
var vr2 = (t, e2, n5) => t << 32 - n5 | e2 >>> n5;
var At = (t, e2, n5) => t >>> n5 | e2 << 32 - n5;
var St2 = (t, e2, n5) => t << 32 - n5 | e2 >>> n5;
var se = (t, e2, n5) => t << 64 - n5 | e2 >>> n5 - 32;
var ie = (t, e2, n5) => t >>> n5 - 32 | e2 << 64 - n5;
var bi = (t, e2) => e2;
var yi = (t, e2) => t;
var mi = (t, e2, n5) => t << n5 | e2 >>> 32 - n5;
var wi = (t, e2, n5) => e2 << n5 | t >>> 32 - n5;
var xi = (t, e2, n5) => e2 << n5 - 32 | t >>> 64 - n5;
var vi = (t, e2, n5) => t << n5 - 32 | e2 >>> 64 - n5;
function dt2(t, e2, n5, r3) {
  const o4 = (e2 >>> 0) + (r3 >>> 0);
  return { h: t + n5 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var tn = (t, e2, n5) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0);
var en2 = (t, e2, n5, r3) => e2 + n5 + r3 + (t / 2 ** 32 | 0) | 0;
var Ei = (t, e2, n5, r3) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0) + (r3 >>> 0);
var Bi = (t, e2, n5, r3, o4) => e2 + n5 + r3 + o4 + (t / 2 ** 32 | 0) | 0;
var Ii = (t, e2, n5, r3, o4) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0) + (r3 >>> 0) + (o4 >>> 0);
var Ai = (t, e2, n5, r3, o4, s3) => e2 + n5 + r3 + o4 + s3 + (t / 2 ** 32 | 0) | 0;
var Gt2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn2(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function at(t, ...e2) {
  if (!nn2(t)) throw new Error("Uint8Array expected");
  if (e2.length > 0 && !e2.includes(t.length)) throw new Error("Uint8Array expected of length " + e2 + ", got length=" + t.length);
}
function rn2(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t.outputLen), mt(t.blockLen);
}
function Nt2(t, e2 = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e2 && t.finished) throw new Error("Hash#digest() has already been called");
}
function on3(t, e2) {
  at(t);
  const n5 = e2.outputLen;
  if (t.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function fe2(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function ut2(...t) {
  for (let e2 = 0; e2 < t.length; e2++) t[e2].fill(0);
}
function sn2(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function gt2(t, e2) {
  return t << 32 - e2 | t >>> e2;
}
var Er2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br2(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt2 = Er2 ? (t) => t : (t) => Br2(t);
function Si(t) {
  for (let e2 = 0; e2 < t.length; e2++) t[e2] = Br2(t[e2]);
  return t;
}
var Ot2 = Er2 ? (t) => t : Si;
var Ir2 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni = Array.from({ length: 256 }, (t, e2) => e2.toString(16).padStart(2, "0"));
function ce(t) {
  if (at(t), Ir2) return t.toHex();
  let e2 = "";
  for (let n5 = 0; n5 < t.length; n5++) e2 += Ni[t[n5]];
  return e2;
}
var xt2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar2(t) {
  if (t >= xt2._0 && t <= xt2._9) return t - xt2._0;
  if (t >= xt2.A && t <= xt2.F) return t - (xt2.A - 10);
  if (t >= xt2.a && t <= xt2.f) return t - (xt2.a - 10);
}
function fn(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (Ir2) return Uint8Array.fromHex(t);
  const e2 = t.length, n5 = e2 / 2;
  if (e2 % 2) throw new Error("hex string expected, got unpadded hex of length " + e2);
  const r3 = new Uint8Array(n5);
  for (let o4 = 0, s3 = 0; o4 < n5; o4++, s3 += 2) {
    const i4 = Ar2(t.charCodeAt(s3)), f8 = Ar2(t.charCodeAt(s3 + 1));
    if (i4 === void 0 || f8 === void 0) {
      const a3 = t[s3] + t[s3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a3 + '" at index ' + s3);
    }
    r3[o4] = i4 * 16 + f8;
  }
  return r3;
}
function Oi(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ht2(t) {
  return typeof t == "string" && (t = Oi(t)), at(t), t;
}
function Ht2(...t) {
  let e2 = 0;
  for (let r3 = 0; r3 < t.length; r3++) {
    const o4 = t[r3];
    at(o4), e2 += o4.length;
  }
  const n5 = new Uint8Array(e2);
  for (let r3 = 0, o4 = 0; r3 < t.length; r3++) {
    const s3 = t[r3];
    n5.set(s3, o4), o4 += s3.length;
  }
  return n5;
}
var Ie2 = class {
};
function ae(t) {
  const e2 = (r3) => t().update(ht2(r3)).digest(), n5 = t();
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = () => t(), e2;
}
function Ui(t) {
  const e2 = (r3, o4) => t(o4).update(ht2(r3)).digest(), n5 = t({});
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = (r3) => t(r3), e2;
}
function Zt2(t = 32) {
  if (Gt2 && typeof Gt2.getRandomValues == "function") return Gt2.getRandomValues(new Uint8Array(t));
  if (Gt2 && typeof Gt2.randomBytes == "function") return Uint8Array.from(Gt2.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i = BigInt(0);
var ue = BigInt(1);
var Ti = BigInt(2);
var Ri = BigInt(7);
var $i = BigInt(256);
var Ci = BigInt(113);
var Sr2 = [];
var Nr2 = [];
var Or2 = [];
for (let t = 0, e2 = ue, n5 = 1, r3 = 0; t < 24; t++) {
  [n5, r3] = [r3, (2 * n5 + 3 * r3) % 5], Sr2.push(2 * (5 * r3 + n5)), Nr2.push((t + 1) * (t + 2) / 2 % 64);
  let o4 = _i;
  for (let s3 = 0; s3 < 7; s3++) e2 = (e2 << ue ^ (e2 >> Ri) * Ci) % $i, e2 & Ti && (o4 ^= ue << (ue << BigInt(s3)) - ue);
  Or2.push(o4);
}
var Ur2 = wr2(Or2, true);
var Li = Ur2[0];
var ji = Ur2[1];
var _r2 = (t, e2, n5) => n5 > 32 ? xi(t, e2, n5) : mi(t, e2, n5);
var Tr2 = (t, e2, n5) => n5 > 32 ? vi(t, e2, n5) : wi(t, e2, n5);
function ki(t, e2 = 24) {
  const n5 = new Uint32Array(10);
  for (let r3 = 24 - e2; r3 < 24; r3++) {
    for (let i4 = 0; i4 < 10; i4++) n5[i4] = t[i4] ^ t[i4 + 10] ^ t[i4 + 20] ^ t[i4 + 30] ^ t[i4 + 40];
    for (let i4 = 0; i4 < 10; i4 += 2) {
      const f8 = (i4 + 8) % 10, a3 = (i4 + 2) % 10, l6 = n5[a3], c6 = n5[a3 + 1], u2 = _r2(l6, c6, 1) ^ n5[f8], h5 = Tr2(l6, c6, 1) ^ n5[f8 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) t[i4 + g3] ^= u2, t[i4 + g3 + 1] ^= h5;
    }
    let o4 = t[2], s3 = t[3];
    for (let i4 = 0; i4 < 24; i4++) {
      const f8 = Nr2[i4], a3 = _r2(o4, s3, f8), l6 = Tr2(o4, s3, f8), c6 = Sr2[i4];
      o4 = t[c6], s3 = t[c6 + 1], t[c6] = a3, t[c6 + 1] = l6;
    }
    for (let i4 = 0; i4 < 50; i4 += 10) {
      for (let f8 = 0; f8 < 10; f8++) n5[f8] = t[i4 + f8];
      for (let f8 = 0; f8 < 10; f8++) t[i4 + f8] ^= ~n5[(f8 + 2) % 10] & n5[(f8 + 4) % 10];
    }
    t[0] ^= Li[r3], t[1] ^= ji[r3];
  }
  ut2(n5);
}
var qn2 = class _qn extends Ie2 {
  constructor(e2, n5, r3, o4 = false, s3 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e2, this.suffix = n5, this.outputLen = r3, this.enableXOF = o4, this.rounds = s3, mt(r3), !(0 < e2 && e2 < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe2(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot2(this.state32), ki(this.state32, this.rounds), Ot2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e2) {
    Nt2(this), e2 = ht2(e2), at(e2);
    const { blockLen: n5, state: r3 } = this, o4 = e2.length;
    for (let s3 = 0; s3 < o4; ) {
      const i4 = Math.min(n5 - this.pos, o4 - s3);
      for (let f8 = 0; f8 < i4; f8++) r3[this.pos++] ^= e2[s3++];
      this.pos === n5 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e2, suffix: n5, pos: r3, blockLen: o4 } = this;
    e2[r3] ^= n5, (n5 & 128) !== 0 && r3 === o4 - 1 && this.keccak(), e2[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(e2) {
    Nt2(this, false), at(e2), this.finish();
    const n5 = this.state, { blockLen: r3 } = this;
    for (let o4 = 0, s3 = e2.length; o4 < s3; ) {
      this.posOut >= r3 && this.keccak();
      const i4 = Math.min(r3 - this.posOut, s3 - o4);
      e2.set(n5.subarray(this.posOut, this.posOut + i4), o4), this.posOut += i4, o4 += i4;
    }
    return e2;
  }
  xofInto(e2) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e2);
  }
  xof(e2) {
    return mt(e2), this.xofInto(new Uint8Array(e2));
  }
  digestInto(e2) {
    if (on3(e2, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e2), this.destroy(), e2;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut2(this.state);
  }
  _cloneInto(e2) {
    const { blockLen: n5, suffix: r3, outputLen: o4, rounds: s3, enableXOF: i4 } = this;
    return e2 || (e2 = new _qn(n5, r3, o4, i4, s3)), e2.state32.set(this.state32), e2.pos = this.pos, e2.posOut = this.posOut, e2.finished = this.finished, e2.rounds = s3, e2.suffix = r3, e2.outputLen = o4, e2.enableXOF = i4, e2.destroyed = this.destroyed, e2;
  }
};
var Pi = (t, e2, n5) => ae(() => new qn2(e2, t, n5));
var Hi = Pi(1, 136, 256 / 8);
function Di(t, e2, n5, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e2, n5, r3);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i4 = Number(n5 >> o4 & s3), f8 = Number(n5 & s3), a3 = r3 ? 4 : 0, l6 = r3 ? 0 : 4;
  t.setUint32(e2 + a3, i4, r3), t.setUint32(e2 + l6, f8, r3);
}
function Mi(t, e2, n5) {
  return t & e2 ^ ~t & n5;
}
function Vi(t, e2, n5) {
  return t & e2 ^ t & n5 ^ e2 & n5;
}
var Rr2 = class extends Ie2 {
  constructor(e2, n5, r3, o4) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e2, this.outputLen = n5, this.padOffset = r3, this.isLE = o4, this.buffer = new Uint8Array(e2), this.view = sn2(this.buffer);
  }
  update(e2) {
    Nt2(this), e2 = ht2(e2), at(e2);
    const { view: n5, buffer: r3, blockLen: o4 } = this, s3 = e2.length;
    for (let i4 = 0; i4 < s3; ) {
      const f8 = Math.min(o4 - this.pos, s3 - i4);
      if (f8 === o4) {
        const a3 = sn2(e2);
        for (; o4 <= s3 - i4; i4 += o4) this.process(a3, i4);
        continue;
      }
      r3.set(e2.subarray(i4, i4 + f8), this.pos), this.pos += f8, i4 += f8, this.pos === o4 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    Nt2(this), on3(e2, this), this.finished = true;
    const { buffer: n5, view: r3, blockLen: o4, isLE: s3 } = this;
    let { pos: i4 } = this;
    n5[i4++] = 128, ut2(this.buffer.subarray(i4)), this.padOffset > o4 - i4 && (this.process(r3, 0), i4 = 0);
    for (let u2 = i4; u2 < o4; u2++) n5[u2] = 0;
    Di(r3, o4 - 8, BigInt(this.length * 8), s3), this.process(r3, 0);
    const f8 = sn2(e2), a3 = this.outputLen;
    if (a3 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l6 = a3 / 4, c6 = this.get();
    if (l6 > c6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u2 = 0; u2 < l6; u2++) f8.setUint32(4 * u2, c6[u2], s3);
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: n5, buffer: r3, length: o4, finished: s3, destroyed: i4, pos: f8 } = this;
    return e2.destroyed = i4, e2.finished = s3, e2.length = o4, e2.pos = f8, o4 % n5 && e2.buffer.set(r3), e2;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut2 = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W2 = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t2 = new Uint32Array(64);
var Ki = class extends Rr2 {
  constructor(e2 = 32) {
    super(64, e2, 8, false), this.A = Ut2[0] | 0, this.B = Ut2[1] | 0, this.C = Ut2[2] | 0, this.D = Ut2[3] | 0, this.E = Ut2[4] | 0, this.F = Ut2[5] | 0, this.G = Ut2[6] | 0, this.H = Ut2[7] | 0;
  }
  get() {
    const { A: e2, B: n5, C: r3, D: o4, E: s3, F: i4, G: f8, H: a3 } = this;
    return [e2, n5, r3, o4, s3, i4, f8, a3];
  }
  set(e2, n5, r3, o4, s3, i4, f8, a3) {
    this.A = e2 | 0, this.B = n5 | 0, this.C = r3 | 0, this.D = o4 | 0, this.E = s3 | 0, this.F = i4 | 0, this.G = f8 | 0, this.H = a3 | 0;
  }
  process(e2, n5) {
    for (let u2 = 0; u2 < 16; u2++, n5 += 4) _t2[u2] = e2.getUint32(n5, false);
    for (let u2 = 16; u2 < 64; u2++) {
      const h5 = _t2[u2 - 15], g3 = _t2[u2 - 2], w4 = gt2(h5, 7) ^ gt2(h5, 18) ^ h5 >>> 3, y5 = gt2(g3, 17) ^ gt2(g3, 19) ^ g3 >>> 10;
      _t2[u2] = y5 + _t2[u2 - 7] + w4 + _t2[u2 - 16] | 0;
    }
    let { A: r3, B: o4, C: s3, D: i4, E: f8, F: a3, G: l6, H: c6 } = this;
    for (let u2 = 0; u2 < 64; u2++) {
      const h5 = gt2(f8, 6) ^ gt2(f8, 11) ^ gt2(f8, 25), g3 = c6 + h5 + Mi(f8, a3, l6) + qi[u2] + _t2[u2] | 0, y5 = (gt2(r3, 2) ^ gt2(r3, 13) ^ gt2(r3, 22)) + Vi(r3, o4, s3) | 0;
      c6 = l6, l6 = a3, a3 = f8, f8 = i4 + g3 | 0, i4 = s3, s3 = o4, o4 = r3, r3 = g3 + y5 | 0;
    }
    r3 = r3 + this.A | 0, o4 = o4 + this.B | 0, s3 = s3 + this.C | 0, i4 = i4 + this.D | 0, f8 = f8 + this.E | 0, a3 = a3 + this.F | 0, l6 = l6 + this.G | 0, c6 = c6 + this.H | 0, this.set(r3, o4, s3, i4, f8, a3, l6, c6);
  }
  roundClean() {
    ut2(_t2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut2(this.buffer);
  }
};
var $r2 = wr2(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var Fi = $r2[0];
var zi = $r2[1];
var Tt2 = new Uint32Array(80);
var Rt2 = new Uint32Array(80);
var cn = class extends Rr2 {
  constructor(e2 = 64) {
    super(128, e2, 16, false), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
  }
  get() {
    const { Ah: e2, Al: n5, Bh: r3, Bl: o4, Ch: s3, Cl: i4, Dh: f8, Dl: a3, Eh: l6, El: c6, Fh: u2, Fl: h5, Gh: g3, Gl: w4, Hh: y5, Hl: x5 } = this;
    return [e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5];
  }
  set(e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5) {
    this.Ah = e2 | 0, this.Al = n5 | 0, this.Bh = r3 | 0, this.Bl = o4 | 0, this.Ch = s3 | 0, this.Cl = i4 | 0, this.Dh = f8 | 0, this.Dl = a3 | 0, this.Eh = l6 | 0, this.El = c6 | 0, this.Fh = u2 | 0, this.Fl = h5 | 0, this.Gh = g3 | 0, this.Gl = w4 | 0, this.Hh = y5 | 0, this.Hl = x5 | 0;
  }
  process(e2, n5) {
    for (let L3 = 0; L3 < 16; L3++, n5 += 4) Tt2[L3] = e2.getUint32(n5), Rt2[L3] = e2.getUint32(n5 += 4);
    for (let L3 = 16; L3 < 80; L3++) {
      const V3 = Tt2[L3 - 15] | 0, _3 = Rt2[L3 - 15] | 0, k6 = At(V3, _3, 1) ^ At(V3, _3, 8) ^ xr2(V3, _3, 7), j3 = St2(V3, _3, 1) ^ St2(V3, _3, 8) ^ vr2(V3, _3, 7), $3 = Tt2[L3 - 2] | 0, d4 = Rt2[L3 - 2] | 0, m3 = At($3, d4, 19) ^ se($3, d4, 61) ^ xr2($3, d4, 6), p4 = St2($3, d4, 19) ^ ie($3, d4, 61) ^ vr2($3, d4, 6), b4 = Ei(j3, p4, Rt2[L3 - 7], Rt2[L3 - 16]), v6 = Bi(b4, k6, m3, Tt2[L3 - 7], Tt2[L3 - 16]);
      Tt2[L3] = v6 | 0, Rt2[L3] = b4 | 0;
    }
    let { Ah: r3, Al: o4, Bh: s3, Bl: i4, Ch: f8, Cl: a3, Dh: l6, Dl: c6, Eh: u2, El: h5, Fh: g3, Fl: w4, Gh: y5, Gl: x5, Hh: R3, Hl: M4 } = this;
    for (let L3 = 0; L3 < 80; L3++) {
      const V3 = At(u2, h5, 14) ^ At(u2, h5, 18) ^ se(u2, h5, 41), _3 = St2(u2, h5, 14) ^ St2(u2, h5, 18) ^ ie(u2, h5, 41), k6 = u2 & g3 ^ ~u2 & y5, j3 = h5 & w4 ^ ~h5 & x5, $3 = Ii(M4, _3, j3, zi[L3], Rt2[L3]), d4 = Ai($3, R3, V3, k6, Fi[L3], Tt2[L3]), m3 = $3 | 0, p4 = At(r3, o4, 28) ^ se(r3, o4, 34) ^ se(r3, o4, 39), b4 = St2(r3, o4, 28) ^ ie(r3, o4, 34) ^ ie(r3, o4, 39), v6 = r3 & s3 ^ r3 & f8 ^ s3 & f8, B3 = o4 & i4 ^ o4 & a3 ^ i4 & a3;
      R3 = y5 | 0, M4 = x5 | 0, y5 = g3 | 0, x5 = w4 | 0, g3 = u2 | 0, w4 = h5 | 0, { h: u2, l: h5 } = dt2(l6 | 0, c6 | 0, d4 | 0, m3 | 0), l6 = f8 | 0, c6 = a3 | 0, f8 = s3 | 0, a3 = i4 | 0, s3 = r3 | 0, i4 = o4 | 0;
      const E4 = tn(m3, b4, B3);
      r3 = en2(E4, d4, p4, v6), o4 = E4 | 0;
    }
    ({ h: r3, l: o4 } = dt2(this.Ah | 0, this.Al | 0, r3 | 0, o4 | 0)), { h: s3, l: i4 } = dt2(this.Bh | 0, this.Bl | 0, s3 | 0, i4 | 0), { h: f8, l: a3 } = dt2(this.Ch | 0, this.Cl | 0, f8 | 0, a3 | 0), { h: l6, l: c6 } = dt2(this.Dh | 0, this.Dl | 0, l6 | 0, c6 | 0), { h: u2, l: h5 } = dt2(this.Eh | 0, this.El | 0, u2 | 0, h5 | 0), { h: g3, l: w4 } = dt2(this.Fh | 0, this.Fl | 0, g3 | 0, w4 | 0), { h: y5, l: x5 } = dt2(this.Gh | 0, this.Gl | 0, y5 | 0, x5 | 0), { h: R3, l: M4 } = dt2(this.Hh | 0, this.Hl | 0, R3 | 0, M4 | 0), this.set(r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5, R3, M4);
  }
  roundClean() {
    ut2(Tt2, Rt2);
  }
  destroy() {
    ut2(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi = class extends cn {
  constructor() {
    super(48), this.Ah = W2[0] | 0, this.Al = W2[1] | 0, this.Bh = W2[2] | 0, this.Bl = W2[3] | 0, this.Ch = W2[4] | 0, this.Cl = W2[5] | 0, this.Dh = W2[6] | 0, this.Dl = W2[7] | 0, this.Eh = W2[8] | 0, this.El = W2[9] | 0, this.Fh = W2[10] | 0, this.Fl = W2[11] | 0, this.Gh = W2[12] | 0, this.Gl = W2[13] | 0, this.Hh = W2[14] | 0, this.Hl = W2[15] | 0;
  }
};
var X = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi = class extends cn {
  constructor() {
    super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Ae2 = ae(() => new Ki());
var Wi = ae(() => new cn());
var Yi = ae(() => new Gi());
var Xi = ae(() => new Zi());
var Ji = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N10 = new Uint32Array(32);
function $t2(t, e2, n5, r3, o4, s3) {
  const i4 = o4[s3], f8 = o4[s3 + 1];
  let a3 = N10[2 * t], l6 = N10[2 * t + 1], c6 = N10[2 * e2], u2 = N10[2 * e2 + 1], h5 = N10[2 * n5], g3 = N10[2 * n5 + 1], w4 = N10[2 * r3], y5 = N10[2 * r3 + 1], x5 = tn(a3, c6, i4);
  l6 = en2(x5, l6, u2, f8), a3 = x5 | 0, { Dh: y5, Dl: w4 } = { Dh: y5 ^ l6, Dl: w4 ^ a3 }, { Dh: y5, Dl: w4 } = { Dh: bi(y5, w4), Dl: yi(y5) }, { h: g3, l: h5 } = dt2(g3, h5, y5, w4), { Bh: u2, Bl: c6 } = { Bh: u2 ^ g3, Bl: c6 ^ h5 }, { Bh: u2, Bl: c6 } = { Bh: At(u2, c6, 24), Bl: St2(u2, c6, 24) }, N10[2 * t] = a3, N10[2 * t + 1] = l6, N10[2 * e2] = c6, N10[2 * e2 + 1] = u2, N10[2 * n5] = h5, N10[2 * n5 + 1] = g3, N10[2 * r3] = w4, N10[2 * r3 + 1] = y5;
}
function Ct(t, e2, n5, r3, o4, s3) {
  const i4 = o4[s3], f8 = o4[s3 + 1];
  let a3 = N10[2 * t], l6 = N10[2 * t + 1], c6 = N10[2 * e2], u2 = N10[2 * e2 + 1], h5 = N10[2 * n5], g3 = N10[2 * n5 + 1], w4 = N10[2 * r3], y5 = N10[2 * r3 + 1], x5 = tn(a3, c6, i4);
  l6 = en2(x5, l6, u2, f8), a3 = x5 | 0, { Dh: y5, Dl: w4 } = { Dh: y5 ^ l6, Dl: w4 ^ a3 }, { Dh: y5, Dl: w4 } = { Dh: At(y5, w4, 16), Dl: St2(y5, w4, 16) }, { h: g3, l: h5 } = dt2(g3, h5, y5, w4), { Bh: u2, Bl: c6 } = { Bh: u2 ^ g3, Bl: c6 ^ h5 }, { Bh: u2, Bl: c6 } = { Bh: se(u2, c6, 63), Bl: ie(u2, c6, 63) }, N10[2 * t] = a3, N10[2 * t + 1] = l6, N10[2 * e2] = c6, N10[2 * e2 + 1] = u2, N10[2 * n5] = h5, N10[2 * n5 + 1] = g3, N10[2 * r3] = w4, N10[2 * r3 + 1] = y5;
}
function Qi(t, e2 = {}, n5, r3, o4) {
  if (mt(n5), t < 0 || t > n5) throw new Error("outputLen bigger than keyLen");
  const { key: s3, salt: i4, personalization: f8 } = e2;
  if (s3 !== void 0 && (s3.length < 1 || s3.length > n5)) throw new Error("key length must be undefined or 1.." + n5);
  if (i4 !== void 0 && i4.length !== r3) throw new Error("salt must be undefined or " + r3);
  if (f8 !== void 0 && f8.length !== o4) throw new Error("personalization must be undefined or " + o4);
}
var tf = class extends Ie2 {
  constructor(e2, n5) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e2), mt(n5), this.blockLen = e2, this.outputLen = n5, this.buffer = new Uint8Array(e2), this.buffer32 = fe2(this.buffer);
  }
  update(e2) {
    Nt2(this), e2 = ht2(e2), at(e2);
    const { blockLen: n5, buffer: r3, buffer32: o4 } = this, s3 = e2.length, i4 = e2.byteOffset, f8 = e2.buffer;
    for (let a3 = 0; a3 < s3; ) {
      this.pos === n5 && (Ot2(o4), this.compress(o4, 0, false), Ot2(o4), this.pos = 0);
      const l6 = Math.min(n5 - this.pos, s3 - a3), c6 = i4 + a3;
      if (l6 === n5 && !(c6 % 4) && a3 + l6 < s3) {
        const u2 = new Uint32Array(f8, c6, Math.floor((s3 - a3) / 4));
        Ot2(u2);
        for (let h5 = 0; a3 + n5 < s3; h5 += o4.length, a3 += n5) this.length += n5, this.compress(u2, h5, false);
        Ot2(u2);
        continue;
      }
      r3.set(e2.subarray(a3, a3 + l6), this.pos), this.pos += l6, this.length += l6, a3 += l6;
    }
    return this;
  }
  digestInto(e2) {
    Nt2(this), on3(e2, this);
    const { pos: n5, buffer32: r3 } = this;
    this.finished = true, ut2(this.buffer.subarray(n5)), Ot2(r3), this.compress(r3, 0, true), Ot2(r3);
    const o4 = fe2(e2);
    this.get().forEach((s3, i4) => o4[i4] = wt2(s3));
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(e2) {
    const { buffer: n5, length: r3, finished: o4, destroyed: s3, outputLen: i4, pos: f8 } = this;
    return e2 || (e2 = new this.constructor({ dkLen: i4 })), e2.set(...this.get()), e2.buffer.set(n5), e2.destroyed = s3, e2.finished = o4, e2.length = r3, e2.pos = f8, e2.outputLen = i4, e2;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef = class extends tf {
  constructor(e2 = {}) {
    const n5 = e2.dkLen === void 0 ? 64 : e2.dkLen;
    super(128, n5), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n5, e2, 64, 16, 16);
    let { key: r3, personalization: o4, salt: s3 } = e2, i4 = 0;
    if (r3 !== void 0 && (r3 = ht2(r3), i4 = r3.length), this.v0l ^= this.outputLen | i4 << 8 | 65536 | 1 << 24, s3 !== void 0) {
      s3 = ht2(s3);
      const f8 = fe2(s3);
      this.v4l ^= wt2(f8[0]), this.v4h ^= wt2(f8[1]), this.v5l ^= wt2(f8[2]), this.v5h ^= wt2(f8[3]);
    }
    if (o4 !== void 0) {
      o4 = ht2(o4);
      const f8 = fe2(o4);
      this.v6l ^= wt2(f8[0]), this.v6h ^= wt2(f8[1]), this.v7l ^= wt2(f8[2]), this.v7h ^= wt2(f8[3]);
    }
    if (r3 !== void 0) {
      const f8 = new Uint8Array(this.blockLen);
      f8.set(r3), this.update(f8);
    }
  }
  get() {
    let { v0l: e2, v0h: n5, v1l: r3, v1h: o4, v2l: s3, v2h: i4, v3l: f8, v3h: a3, v4l: l6, v4h: c6, v5l: u2, v5h: h5, v6l: g3, v6h: w4, v7l: y5, v7h: x5 } = this;
    return [e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5];
  }
  set(e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5) {
    this.v0l = e2 | 0, this.v0h = n5 | 0, this.v1l = r3 | 0, this.v1h = o4 | 0, this.v2l = s3 | 0, this.v2h = i4 | 0, this.v3l = f8 | 0, this.v3h = a3 | 0, this.v4l = l6 | 0, this.v4h = c6 | 0, this.v5l = u2 | 0, this.v5h = h5 | 0, this.v6l = g3 | 0, this.v6h = w4 | 0, this.v7l = y5 | 0, this.v7h = x5 | 0;
  }
  compress(e2, n5, r3) {
    this.get().forEach((a3, l6) => N10[l6] = a3), N10.set(F, 16);
    let { h: o4, l: s3 } = mr2(BigInt(this.length));
    N10[24] = F[8] ^ s3, N10[25] = F[9] ^ o4, r3 && (N10[28] = ~N10[28], N10[29] = ~N10[29]);
    let i4 = 0;
    const f8 = Ji;
    for (let a3 = 0; a3 < 12; a3++) $t2(0, 4, 8, 12, e2, n5 + 2 * f8[i4++]), Ct(0, 4, 8, 12, e2, n5 + 2 * f8[i4++]), $t2(1, 5, 9, 13, e2, n5 + 2 * f8[i4++]), Ct(1, 5, 9, 13, e2, n5 + 2 * f8[i4++]), $t2(2, 6, 10, 14, e2, n5 + 2 * f8[i4++]), Ct(2, 6, 10, 14, e2, n5 + 2 * f8[i4++]), $t2(3, 7, 11, 15, e2, n5 + 2 * f8[i4++]), Ct(3, 7, 11, 15, e2, n5 + 2 * f8[i4++]), $t2(0, 5, 10, 15, e2, n5 + 2 * f8[i4++]), Ct(0, 5, 10, 15, e2, n5 + 2 * f8[i4++]), $t2(1, 6, 11, 12, e2, n5 + 2 * f8[i4++]), Ct(1, 6, 11, 12, e2, n5 + 2 * f8[i4++]), $t2(2, 7, 8, 13, e2, n5 + 2 * f8[i4++]), Ct(2, 7, 8, 13, e2, n5 + 2 * f8[i4++]), $t2(3, 4, 9, 14, e2, n5 + 2 * f8[i4++]), Ct(3, 4, 9, 14, e2, n5 + 2 * f8[i4++]);
    this.v0l ^= N10[0] ^ N10[16], this.v0h ^= N10[1] ^ N10[17], this.v1l ^= N10[2] ^ N10[18], this.v1h ^= N10[3] ^ N10[19], this.v2l ^= N10[4] ^ N10[20], this.v2h ^= N10[5] ^ N10[21], this.v3l ^= N10[6] ^ N10[22], this.v3h ^= N10[7] ^ N10[23], this.v4l ^= N10[8] ^ N10[24], this.v4h ^= N10[9] ^ N10[25], this.v5l ^= N10[10] ^ N10[26], this.v5h ^= N10[11] ^ N10[27], this.v6l ^= N10[12] ^ N10[28], this.v6h ^= N10[13] ^ N10[29], this.v7l ^= N10[14] ^ N10[30], this.v7h ^= N10[15] ^ N10[31], ut2(N10);
  }
  destroy() {
    this.destroyed = true, ut2(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf = Ui((t) => new ef(t));
function Qr2(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function bn2(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function yn2(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function nt2(t, ...e2) {
  if (!Qr2(t)) throw new Error("Uint8Array expected");
  if (e2.length > 0 && !e2.includes(t.length)) throw new Error("Uint8Array expected of length " + e2 + ", got length=" + t.length);
}
function to2(t, e2 = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e2 && t.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t, e2) {
  nt2(t);
  const n5 = e2.outputLen;
  if (t.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function jt2(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Wt2(...t) {
  for (let e2 = 0; e2 < t.length; e2++) t[e2].fill(0);
}
function Nf(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Of = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function mn2(t) {
  if (typeof t == "string") t = Uf(t);
  else if (Qr2(t)) t = wn(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function _f(t, e2) {
  if (e2 == null || typeof e2 != "object") throw new Error("options must be defined");
  return Object.assign(t, e2);
}
function Tf(t, e2) {
  if (t.length !== e2.length) return false;
  let n5 = 0;
  for (let r3 = 0; r3 < t.length; r3++) n5 |= t[r3] ^ e2[r3];
  return n5 === 0;
}
var Rf = (t, e2) => {
  function n5(r3, ...o4) {
    if (nt2(r3), !Of) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const c6 = o4[0];
      if (!c6) throw new Error("nonce / iv required");
      t.varSizeNonce ? nt2(c6) : nt2(c6, t.nonceLength);
    }
    const s3 = t.tagLength;
    s3 && o4[1] !== void 0 && nt2(o4[1]);
    const i4 = e2(r3, ...o4), f8 = (c6, u2) => {
      if (u2 !== void 0) {
        if (c6 !== 2) throw new Error("cipher output not supported");
        nt2(u2);
      }
    };
    let a3 = false;
    return { encrypt(c6, u2) {
      if (a3) throw new Error("cannot encrypt() twice with same key + nonce");
      return a3 = true, nt2(c6), f8(i4.encrypt.length, u2), i4.encrypt(c6, u2);
    }, decrypt(c6, u2) {
      if (nt2(c6), s3 && c6.length < s3) throw new Error("invalid ciphertext length: smaller than tagLength=" + s3);
      return f8(i4.decrypt.length, u2), i4.decrypt(c6, u2);
    } };
  }
  return Object.assign(n5, t), n5;
};
function eo2(t, e2, n5 = true) {
  if (e2 === void 0) return new Uint8Array(t);
  if (e2.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e2.length);
  if (n5 && !Cf(e2)) throw new Error("invalid output, must be aligned");
  return e2;
}
function no2(t, e2, n5, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e2, n5, r3);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i4 = Number(n5 >> o4 & s3), f8 = Number(n5 & s3), a3 = r3 ? 4 : 0, l6 = r3 ? 0 : 4;
  t.setUint32(e2 + a3, i4, r3), t.setUint32(e2 + l6, f8, r3);
}
function $f(t, e2, n5) {
  bn2(n5);
  const r3 = new Uint8Array(16), o4 = Nf(r3);
  return no2(o4, 0, BigInt(e2), n5), no2(o4, 8, BigInt(t), n5), r3;
}
function Cf(t) {
  return t.byteOffset % 4 === 0;
}
function wn(t) {
  return Uint8Array.from(t);
}
var ro2 = (t) => Uint8Array.from(t.split("").map((e2) => e2.charCodeAt(0)));
var Lf = ro2("expand 16-byte k");
var jf = ro2("expand 32-byte k");
var kf = jt2(Lf);
var Pf = jt2(jf);
function D(t, e2) {
  return t << e2 | t >>> 32 - e2;
}
function xn2(t) {
  return t.byteOffset % 4 === 0;
}
var Ue2 = 64;
var Hf = 16;
var oo2 = 2 ** 32 - 1;
var so2 = new Uint32Array();
function Df(t, e2, n5, r3, o4, s3, i4, f8) {
  const a3 = o4.length, l6 = new Uint8Array(Ue2), c6 = jt2(l6), u2 = xn2(o4) && xn2(s3), h5 = u2 ? jt2(o4) : so2, g3 = u2 ? jt2(s3) : so2;
  for (let w4 = 0; w4 < a3; i4++) {
    if (t(e2, n5, r3, c6, i4, f8), i4 >= oo2) throw new Error("arx: counter overflow");
    const y5 = Math.min(Ue2, a3 - w4);
    if (u2 && y5 === Ue2) {
      const x5 = w4 / 4;
      if (w4 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R3 = 0, M4; R3 < Hf; R3++) M4 = x5 + R3, g3[M4] = h5[M4] ^ c6[R3];
      w4 += Ue2;
      continue;
    }
    for (let x5 = 0, R3; x5 < y5; x5++) R3 = w4 + x5, s3[R3] = o4[R3] ^ l6[x5];
    w4 += y5;
  }
}
function Mf(t, e2) {
  const { allowShortKeys: n5, extendNonceFn: r3, counterLength: o4, counterRight: s3, rounds: i4 } = _f({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e2);
  if (typeof t != "function") throw new Error("core must be a function");
  return yn2(o4), yn2(i4), bn2(s3), bn2(n5), (f8, a3, l6, c6, u2 = 0) => {
    nt2(f8), nt2(a3), nt2(l6);
    const h5 = l6.length;
    if (c6 === void 0 && (c6 = new Uint8Array(h5)), nt2(c6), yn2(u2), u2 < 0 || u2 >= oo2) throw new Error("arx: counter overflow");
    if (c6.length < h5) throw new Error(`arx: output (${c6.length}) is shorter than data (${h5})`);
    const g3 = [];
    let w4 = f8.length, y5, x5;
    if (w4 === 32) g3.push(y5 = wn(f8)), x5 = Pf;
    else if (w4 === 16 && n5) y5 = new Uint8Array(32), y5.set(f8), y5.set(f8, 16), x5 = kf, g3.push(y5);
    else throw new Error(`arx: invalid 32-byte key, got length=${w4}`);
    xn2(a3) || g3.push(a3 = wn(a3));
    const R3 = jt2(y5);
    if (r3) {
      if (a3.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r3(x5, R3, jt2(a3.subarray(0, 16)), R3), a3 = a3.subarray(16);
    }
    const M4 = 16 - o4;
    if (M4 !== a3.length) throw new Error(`arx: nonce must be ${M4} or 16 bytes`);
    if (M4 !== 12) {
      const V3 = new Uint8Array(12);
      V3.set(a3, s3 ? 0 : 12 - a3.length), a3 = V3, g3.push(a3);
    }
    const L3 = jt2(a3);
    return Df(t, x5, R3, L3, l6, c6, u2, i4), Wt2(...g3), c6;
  };
}
var G2 = (t, e2) => t[e2++] & 255 | (t[e2++] & 255) << 8;
var Vf = class {
  constructor(e2) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e2 = mn2(e2), nt2(e2, 32);
    const n5 = G2(e2, 0), r3 = G2(e2, 2), o4 = G2(e2, 4), s3 = G2(e2, 6), i4 = G2(e2, 8), f8 = G2(e2, 10), a3 = G2(e2, 12), l6 = G2(e2, 14);
    this.r[0] = n5 & 8191, this.r[1] = (n5 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s3 << 9) & 8191, this.r[4] = (s3 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, this.r[6] = (i4 >>> 14 | f8 << 2) & 8191, this.r[7] = (f8 >>> 11 | a3 << 5) & 8065, this.r[8] = (a3 >>> 8 | l6 << 8) & 8191, this.r[9] = l6 >>> 5 & 127;
    for (let c6 = 0; c6 < 8; c6++) this.pad[c6] = G2(e2, 16 + 2 * c6);
  }
  process(e2, n5, r3 = false) {
    const o4 = r3 ? 0 : 2048, { h: s3, r: i4 } = this, f8 = i4[0], a3 = i4[1], l6 = i4[2], c6 = i4[3], u2 = i4[4], h5 = i4[5], g3 = i4[6], w4 = i4[7], y5 = i4[8], x5 = i4[9], R3 = G2(e2, n5 + 0), M4 = G2(e2, n5 + 2), L3 = G2(e2, n5 + 4), V3 = G2(e2, n5 + 6), _3 = G2(e2, n5 + 8), k6 = G2(e2, n5 + 10), j3 = G2(e2, n5 + 12), $3 = G2(e2, n5 + 14);
    let d4 = s3[0] + (R3 & 8191), m3 = s3[1] + ((R3 >>> 13 | M4 << 3) & 8191), p4 = s3[2] + ((M4 >>> 10 | L3 << 6) & 8191), b4 = s3[3] + ((L3 >>> 7 | V3 << 9) & 8191), v6 = s3[4] + ((V3 >>> 4 | _3 << 12) & 8191), B3 = s3[5] + (_3 >>> 1 & 8191), E4 = s3[6] + ((_3 >>> 14 | k6 << 2) & 8191), I4 = s3[7] + ((k6 >>> 11 | j3 << 5) & 8191), S4 = s3[8] + ((j3 >>> 8 | $3 << 8) & 8191), O5 = s3[9] + ($3 >>> 5 | o4), A4 = 0, T3 = A4 + d4 * f8 + m3 * (5 * x5) + p4 * (5 * y5) + b4 * (5 * w4) + v6 * (5 * g3);
    A4 = T3 >>> 13, T3 &= 8191, T3 += B3 * (5 * h5) + E4 * (5 * u2) + I4 * (5 * c6) + S4 * (5 * l6) + O5 * (5 * a3), A4 += T3 >>> 13, T3 &= 8191;
    let U3 = A4 + d4 * a3 + m3 * f8 + p4 * (5 * x5) + b4 * (5 * y5) + v6 * (5 * w4);
    A4 = U3 >>> 13, U3 &= 8191, U3 += B3 * (5 * g3) + E4 * (5 * h5) + I4 * (5 * u2) + S4 * (5 * c6) + O5 * (5 * l6), A4 += U3 >>> 13, U3 &= 8191;
    let C4 = A4 + d4 * l6 + m3 * a3 + p4 * f8 + b4 * (5 * x5) + v6 * (5 * y5);
    A4 = C4 >>> 13, C4 &= 8191, C4 += B3 * (5 * w4) + E4 * (5 * g3) + I4 * (5 * h5) + S4 * (5 * u2) + O5 * (5 * c6), A4 += C4 >>> 13, C4 &= 8191;
    let H2 = A4 + d4 * c6 + m3 * l6 + p4 * a3 + b4 * f8 + v6 * (5 * x5);
    A4 = H2 >>> 13, H2 &= 8191, H2 += B3 * (5 * y5) + E4 * (5 * w4) + I4 * (5 * g3) + S4 * (5 * h5) + O5 * (5 * u2), A4 += H2 >>> 13, H2 &= 8191;
    let q = A4 + d4 * u2 + m3 * c6 + p4 * l6 + b4 * a3 + v6 * f8;
    A4 = q >>> 13, q &= 8191, q += B3 * (5 * x5) + E4 * (5 * y5) + I4 * (5 * w4) + S4 * (5 * g3) + O5 * (5 * h5), A4 += q >>> 13, q &= 8191;
    let P4 = A4 + d4 * h5 + m3 * u2 + p4 * c6 + b4 * l6 + v6 * a3;
    A4 = P4 >>> 13, P4 &= 8191, P4 += B3 * f8 + E4 * (5 * x5) + I4 * (5 * y5) + S4 * (5 * w4) + O5 * (5 * g3), A4 += P4 >>> 13, P4 &= 8191;
    let K4 = A4 + d4 * g3 + m3 * h5 + p4 * u2 + b4 * c6 + v6 * l6;
    A4 = K4 >>> 13, K4 &= 8191, K4 += B3 * a3 + E4 * f8 + I4 * (5 * x5) + S4 * (5 * y5) + O5 * (5 * w4), A4 += K4 >>> 13, K4 &= 8191;
    let et = A4 + d4 * w4 + m3 * g3 + p4 * h5 + b4 * u2 + v6 * c6;
    A4 = et >>> 13, et &= 8191, et += B3 * l6 + E4 * a3 + I4 * f8 + S4 * (5 * x5) + O5 * (5 * y5), A4 += et >>> 13, et &= 8191;
    let Z2 = A4 + d4 * y5 + m3 * w4 + p4 * g3 + b4 * h5 + v6 * u2;
    A4 = Z2 >>> 13, Z2 &= 8191, Z2 += B3 * c6 + E4 * l6 + I4 * a3 + S4 * f8 + O5 * (5 * x5), A4 += Z2 >>> 13, Z2 &= 8191;
    let z4 = A4 + d4 * x5 + m3 * y5 + p4 * w4 + b4 * g3 + v6 * h5;
    A4 = z4 >>> 13, z4 &= 8191, z4 += B3 * u2 + E4 * c6 + I4 * l6 + S4 * a3 + O5 * f8, A4 += z4 >>> 13, z4 &= 8191, A4 = (A4 << 2) + A4 | 0, A4 = A4 + T3 | 0, T3 = A4 & 8191, A4 = A4 >>> 13, U3 += A4, s3[0] = T3, s3[1] = U3, s3[2] = C4, s3[3] = H2, s3[4] = q, s3[5] = P4, s3[6] = K4, s3[7] = et, s3[8] = Z2, s3[9] = z4;
  }
  finalize() {
    const { h: e2, pad: n5 } = this, r3 = new Uint16Array(10);
    let o4 = e2[1] >>> 13;
    e2[1] &= 8191;
    for (let f8 = 2; f8 < 10; f8++) e2[f8] += o4, o4 = e2[f8] >>> 13, e2[f8] &= 8191;
    e2[0] += o4 * 5, o4 = e2[0] >>> 13, e2[0] &= 8191, e2[1] += o4, o4 = e2[1] >>> 13, e2[1] &= 8191, e2[2] += o4, r3[0] = e2[0] + 5, o4 = r3[0] >>> 13, r3[0] &= 8191;
    for (let f8 = 1; f8 < 10; f8++) r3[f8] = e2[f8] + o4, o4 = r3[f8] >>> 13, r3[f8] &= 8191;
    r3[9] -= 8192;
    let s3 = (o4 ^ 1) - 1;
    for (let f8 = 0; f8 < 10; f8++) r3[f8] &= s3;
    s3 = ~s3;
    for (let f8 = 0; f8 < 10; f8++) e2[f8] = e2[f8] & s3 | r3[f8];
    e2[0] = (e2[0] | e2[1] << 13) & 65535, e2[1] = (e2[1] >>> 3 | e2[2] << 10) & 65535, e2[2] = (e2[2] >>> 6 | e2[3] << 7) & 65535, e2[3] = (e2[3] >>> 9 | e2[4] << 4) & 65535, e2[4] = (e2[4] >>> 12 | e2[5] << 1 | e2[6] << 14) & 65535, e2[5] = (e2[6] >>> 2 | e2[7] << 11) & 65535, e2[6] = (e2[7] >>> 5 | e2[8] << 8) & 65535, e2[7] = (e2[8] >>> 8 | e2[9] << 5) & 65535;
    let i4 = e2[0] + n5[0];
    e2[0] = i4 & 65535;
    for (let f8 = 1; f8 < 8; f8++) i4 = (e2[f8] + n5[f8] | 0) + (i4 >>> 16) | 0, e2[f8] = i4 & 65535;
    Wt2(r3);
  }
  update(e2) {
    to2(this), e2 = mn2(e2), nt2(e2);
    const { buffer: n5, blockLen: r3 } = this, o4 = e2.length;
    for (let s3 = 0; s3 < o4; ) {
      const i4 = Math.min(r3 - this.pos, o4 - s3);
      if (i4 === r3) {
        for (; r3 <= o4 - s3; s3 += r3) this.process(e2, s3);
        continue;
      }
      n5.set(e2.subarray(s3, s3 + i4), this.pos), this.pos += i4, s3 += i4, this.pos === r3 && (this.process(n5, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e2) {
    to2(this), Sf(e2, this), this.finished = true;
    const { buffer: n5, h: r3 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n5[o4++] = 1; o4 < 16; o4++) n5[o4] = 0;
      this.process(n5, 0, true);
    }
    this.finalize();
    let s3 = 0;
    for (let i4 = 0; i4 < 8; i4++) e2[s3++] = r3[i4] >>> 0, e2[s3++] = r3[i4] >>> 8;
    return e2;
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
};
function qf(t) {
  const e2 = (r3, o4) => t(o4).update(mn2(r3)).digest(), n5 = t(new Uint8Array(32));
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = (r3) => t(r3), e2;
}
var Kf = qf((t) => new Vf(t));
function Ff(t, e2, n5, r3, o4, s3 = 20) {
  let i4 = t[0], f8 = t[1], a3 = t[2], l6 = t[3], c6 = e2[0], u2 = e2[1], h5 = e2[2], g3 = e2[3], w4 = e2[4], y5 = e2[5], x5 = e2[6], R3 = e2[7], M4 = o4, L3 = n5[0], V3 = n5[1], _3 = n5[2], k6 = i4, j3 = f8, $3 = a3, d4 = l6, m3 = c6, p4 = u2, b4 = h5, v6 = g3, B3 = w4, E4 = y5, I4 = x5, S4 = R3, O5 = M4, A4 = L3, T3 = V3, U3 = _3;
  for (let H2 = 0; H2 < s3; H2 += 2) k6 = k6 + m3 | 0, O5 = D(O5 ^ k6, 16), B3 = B3 + O5 | 0, m3 = D(m3 ^ B3, 12), k6 = k6 + m3 | 0, O5 = D(O5 ^ k6, 8), B3 = B3 + O5 | 0, m3 = D(m3 ^ B3, 7), j3 = j3 + p4 | 0, A4 = D(A4 ^ j3, 16), E4 = E4 + A4 | 0, p4 = D(p4 ^ E4, 12), j3 = j3 + p4 | 0, A4 = D(A4 ^ j3, 8), E4 = E4 + A4 | 0, p4 = D(p4 ^ E4, 7), $3 = $3 + b4 | 0, T3 = D(T3 ^ $3, 16), I4 = I4 + T3 | 0, b4 = D(b4 ^ I4, 12), $3 = $3 + b4 | 0, T3 = D(T3 ^ $3, 8), I4 = I4 + T3 | 0, b4 = D(b4 ^ I4, 7), d4 = d4 + v6 | 0, U3 = D(U3 ^ d4, 16), S4 = S4 + U3 | 0, v6 = D(v6 ^ S4, 12), d4 = d4 + v6 | 0, U3 = D(U3 ^ d4, 8), S4 = S4 + U3 | 0, v6 = D(v6 ^ S4, 7), k6 = k6 + p4 | 0, U3 = D(U3 ^ k6, 16), I4 = I4 + U3 | 0, p4 = D(p4 ^ I4, 12), k6 = k6 + p4 | 0, U3 = D(U3 ^ k6, 8), I4 = I4 + U3 | 0, p4 = D(p4 ^ I4, 7), j3 = j3 + b4 | 0, O5 = D(O5 ^ j3, 16), S4 = S4 + O5 | 0, b4 = D(b4 ^ S4, 12), j3 = j3 + b4 | 0, O5 = D(O5 ^ j3, 8), S4 = S4 + O5 | 0, b4 = D(b4 ^ S4, 7), $3 = $3 + v6 | 0, A4 = D(A4 ^ $3, 16), B3 = B3 + A4 | 0, v6 = D(v6 ^ B3, 12), $3 = $3 + v6 | 0, A4 = D(A4 ^ $3, 8), B3 = B3 + A4 | 0, v6 = D(v6 ^ B3, 7), d4 = d4 + m3 | 0, T3 = D(T3 ^ d4, 16), E4 = E4 + T3 | 0, m3 = D(m3 ^ E4, 12), d4 = d4 + m3 | 0, T3 = D(T3 ^ d4, 8), E4 = E4 + T3 | 0, m3 = D(m3 ^ E4, 7);
  let C4 = 0;
  r3[C4++] = i4 + k6 | 0, r3[C4++] = f8 + j3 | 0, r3[C4++] = a3 + $3 | 0, r3[C4++] = l6 + d4 | 0, r3[C4++] = c6 + m3 | 0, r3[C4++] = u2 + p4 | 0, r3[C4++] = h5 + b4 | 0, r3[C4++] = g3 + v6 | 0, r3[C4++] = w4 + B3 | 0, r3[C4++] = y5 + E4 | 0, r3[C4++] = x5 + I4 | 0, r3[C4++] = R3 + S4 | 0, r3[C4++] = M4 + O5 | 0, r3[C4++] = L3 + A4 | 0, r3[C4++] = V3 + T3 | 0, r3[C4++] = _3 + U3 | 0;
}
var zf = Mf(Ff, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf = new Uint8Array(16);
var io2 = (t, e2) => {
  t.update(e2);
  const n5 = e2.length % 16;
  n5 && t.update(Gf.subarray(n5));
};
var Zf = new Uint8Array(32);
function fo2(t, e2, n5, r3, o4) {
  const s3 = t(e2, n5, Zf), i4 = Kf.create(s3);
  o4 && io2(i4, o4), io2(i4, r3);
  const f8 = $f(r3.length, o4 ? o4.length : 0, true);
  i4.update(f8);
  const a3 = i4.digest();
  return Wt2(s3, f8), a3;
}
var Wf = (t) => (e2, n5, r3) => ({ encrypt(s3, i4) {
  const f8 = s3.length;
  i4 = eo2(f8 + 16, i4, false), i4.set(s3);
  const a3 = i4.subarray(0, -16);
  t(e2, n5, a3, a3, 1);
  const l6 = fo2(t, e2, n5, a3, r3);
  return i4.set(l6, f8), Wt2(l6), i4;
}, decrypt(s3, i4) {
  i4 = eo2(s3.length - 16, i4, false);
  const f8 = s3.subarray(0, -16), a3 = s3.subarray(-16), l6 = fo2(t, e2, n5, f8, r3);
  if (!Tf(a3, l6)) throw new Error("invalid tag");
  return i4.set(s3.subarray(0, -16)), t(e2, n5, i4, i4, 1), Wt2(l6), i4;
} });
var co2 = Rf({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf(zf));
var ao2 = class extends Ie2 {
  constructor(e2, n5) {
    super(), this.finished = false, this.destroyed = false, rn2(e2);
    const r3 = ht2(n5);
    if (this.iHash = e2.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s3 = new Uint8Array(o4);
    s3.set(r3.length > o4 ? e2.create().update(r3).digest() : r3);
    for (let i4 = 0; i4 < s3.length; i4++) s3[i4] ^= 54;
    this.iHash.update(s3), this.oHash = e2.create();
    for (let i4 = 0; i4 < s3.length; i4++) s3[i4] ^= 106;
    this.oHash.update(s3), ut2(s3);
  }
  update(e2) {
    return Nt2(this), this.iHash.update(e2), this;
  }
  digestInto(e2) {
    Nt2(this), at(e2, this.outputLen), this.finished = true, this.iHash.digestInto(e2), this.oHash.update(e2), this.oHash.digestInto(e2), this.destroy();
  }
  digest() {
    const e2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e2), e2;
  }
  _cloneInto(e2) {
    e2 || (e2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n5, iHash: r3, finished: o4, destroyed: s3, blockLen: i4, outputLen: f8 } = this;
    return e2 = e2, e2.finished = o4, e2.destroyed = s3, e2.blockLen = i4, e2.outputLen = f8, e2.oHash = n5._cloneInto(e2.oHash), e2.iHash = r3._cloneInto(e2.iHash), e2;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e2 = (t, e2, n5) => new ao2(t, e2).update(n5).digest();
_e2.create = (t, e2) => new ao2(t, e2);
var vn2 = Uint8Array.from([0]);
var uo2 = Uint8Array.of();
var En2 = BigInt(0);
var Bn2 = BigInt(1);
function Re2(t, e2) {
  if (typeof e2 != "boolean") throw new Error(t + " boolean expected, got " + e2);
}
function $e2(t) {
  const e2 = t.toString(16);
  return e2.length & 1 ? "0" + e2 : e2;
}
function lo2(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? En2 : BigInt("0x" + t);
}
function Ce2(t) {
  return lo2(ce(t));
}
function Le2(t) {
  return at(t), lo2(ce(Uint8Array.from(t).reverse()));
}
function In2(t, e2) {
  return fn(t.toString(16).padStart(e2 * 2, "0"));
}
function An2(t, e2) {
  return In2(t, e2).reverse();
}
function rt2(t, e2, n5) {
  let r3;
  if (typeof e2 == "string") try {
    r3 = fn(e2);
  } catch (s3) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s3);
  }
  else if (nn2(e2)) r3 = Uint8Array.from(e2);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o4 = r3.length;
  if (typeof n5 == "number" && o4 !== n5) throw new Error(t + " of length " + n5 + " expected, got " + o4);
  return r3;
}
var Sn2 = (t) => typeof t == "bigint" && En2 <= t;
function Qf(t, e2, n5) {
  return Sn2(t) && Sn2(e2) && Sn2(n5) && e2 <= t && t < n5;
}
function Nn2(t, e2, n5, r3) {
  if (!Qf(e2, n5, r3)) throw new Error("expected valid " + t + ": " + n5 + " <= n < " + r3 + ", got " + e2);
}
function tc(t) {
  let e2;
  for (e2 = 0; t > En2; t >>= Bn2, e2 += 1) ;
  return e2;
}
var je2 = (t) => (Bn2 << BigInt(t)) - Bn2;
function ec(t, e2, n5) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e2 != "number" || e2 < 2) throw new Error("qByteLen must be a number");
  if (typeof n5 != "function") throw new Error("hmacFn must be a function");
  const r3 = (g3) => new Uint8Array(g3), o4 = (g3) => Uint8Array.of(g3);
  let s3 = r3(t), i4 = r3(t), f8 = 0;
  const a3 = () => {
    s3.fill(1), i4.fill(0), f8 = 0;
  }, l6 = (...g3) => n5(i4, s3, ...g3), c6 = (g3 = r3(0)) => {
    i4 = l6(o4(0), g3), s3 = l6(), g3.length !== 0 && (i4 = l6(o4(1), g3), s3 = l6());
  }, u2 = () => {
    if (f8++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g3 = 0;
    const w4 = [];
    for (; g3 < e2; ) {
      s3 = l6();
      const y5 = s3.slice();
      w4.push(y5), g3 += s3.length;
    }
    return Ht2(...w4);
  };
  return (g3, w4) => {
    a3(), c6(g3);
    let y5;
    for (; !(y5 = w4(u2())); ) c6();
    return a3(), y5;
  };
}
function ke2(t, e2, n5 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r3(o4, s3, i4) {
    const f8 = t[o4];
    if (i4 && f8 === void 0) return;
    const a3 = typeof f8;
    if (a3 !== s3 || f8 === null) throw new Error(`param "${o4}" is invalid: expected ${s3}, got ${a3}`);
  }
  Object.entries(e2).forEach(([o4, s3]) => r3(o4, s3, false)), Object.entries(n5).forEach(([o4, s3]) => r3(o4, s3, true));
}
function ho2(t) {
  const e2 = /* @__PURE__ */ new WeakMap();
  return (n5, ...r3) => {
    const o4 = e2.get(n5);
    if (o4 !== void 0) return o4;
    const s3 = t(n5, ...r3);
    return e2.set(n5, s3), s3;
  };
}
var ot = BigInt(0);
var Q2 = BigInt(1);
var Dt2 = BigInt(2);
var nc = BigInt(3);
var po2 = BigInt(4);
var go2 = BigInt(5);
var bo2 = BigInt(8);
function lt2(t, e2) {
  const n5 = t % e2;
  return n5 >= ot ? n5 : e2 + n5;
}
function pt(t, e2, n5) {
  let r3 = t;
  for (; e2-- > ot; ) r3 *= r3, r3 %= n5;
  return r3;
}
function yo2(t, e2) {
  if (t === ot) throw new Error("invert: expected non-zero number");
  if (e2 <= ot) throw new Error("invert: expected positive modulus, got " + e2);
  let n5 = lt2(t, e2), r3 = e2, o4 = ot, s3 = Q2;
  for (; n5 !== ot; ) {
    const f8 = r3 / n5, a3 = r3 % n5, l6 = o4 - s3 * f8;
    r3 = n5, n5 = a3, o4 = s3, s3 = l6;
  }
  if (r3 !== Q2) throw new Error("invert: does not exist");
  return lt2(o4, e2);
}
function mo2(t, e2) {
  const n5 = (t.ORDER + Q2) / po2, r3 = t.pow(e2, n5);
  if (!t.eql(t.sqr(r3), e2)) throw new Error("Cannot find square root");
  return r3;
}
function rc(t, e2) {
  const n5 = (t.ORDER - go2) / bo2, r3 = t.mul(e2, Dt2), o4 = t.pow(r3, n5), s3 = t.mul(e2, o4), i4 = t.mul(t.mul(s3, Dt2), o4), f8 = t.mul(s3, t.sub(i4, t.ONE));
  if (!t.eql(t.sqr(f8), e2)) throw new Error("Cannot find square root");
  return f8;
}
function oc(t) {
  if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e2 = t - Q2, n5 = 0;
  for (; e2 % Dt2 === ot; ) e2 /= Dt2, n5++;
  let r3 = Dt2;
  const o4 = Yt2(t);
  for (; xo2(o4, r3) === 1; ) if (r3++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n5 === 1) return mo2;
  let s3 = o4.pow(r3, e2);
  const i4 = (e2 + Q2) / Dt2;
  return function(a3, l6) {
    if (a3.is0(l6)) return l6;
    if (xo2(a3, l6) !== 1) throw new Error("Cannot find square root");
    let c6 = n5, u2 = a3.mul(a3.ONE, s3), h5 = a3.pow(l6, e2), g3 = a3.pow(l6, i4);
    for (; !a3.eql(h5, a3.ONE); ) {
      if (a3.is0(h5)) return a3.ZERO;
      let w4 = 1, y5 = a3.sqr(h5);
      for (; !a3.eql(y5, a3.ONE); ) if (w4++, y5 = a3.sqr(y5), w4 === c6) throw new Error("Cannot find square root");
      const x5 = Q2 << BigInt(c6 - w4 - 1), R3 = a3.pow(u2, x5);
      c6 = w4, u2 = a3.sqr(R3), h5 = a3.mul(h5, u2), g3 = a3.mul(g3, R3);
    }
    return g3;
  };
}
function sc(t) {
  return t % po2 === nc ? mo2 : t % bo2 === go2 ? rc : oc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc(t) {
  const e2 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n5 = ic.reduce((r3, o4) => (r3[o4] = "function", r3), e2);
  return ke2(t, n5), t;
}
function cc(t, e2, n5) {
  if (n5 < ot) throw new Error("invalid exponent, negatives unsupported");
  if (n5 === ot) return t.ONE;
  if (n5 === Q2) return e2;
  let r3 = t.ONE, o4 = e2;
  for (; n5 > ot; ) n5 & Q2 && (r3 = t.mul(r3, o4)), o4 = t.sqr(o4), n5 >>= Q2;
  return r3;
}
function wo2(t, e2, n5 = false) {
  const r3 = new Array(e2.length).fill(n5 ? t.ZERO : void 0), o4 = e2.reduce((i4, f8, a3) => t.is0(f8) ? i4 : (r3[a3] = i4, t.mul(i4, f8)), t.ONE), s3 = t.inv(o4);
  return e2.reduceRight((i4, f8, a3) => t.is0(f8) ? i4 : (r3[a3] = t.mul(i4, r3[a3]), t.mul(i4, f8)), s3), r3;
}
function xo2(t, e2) {
  const n5 = (t.ORDER - Q2) / Dt2, r3 = t.pow(e2, n5), o4 = t.eql(r3, t.ONE), s3 = t.eql(r3, t.ZERO), i4 = t.eql(r3, t.neg(t.ONE));
  if (!o4 && !s3 && !i4) throw new Error("invalid Legendre symbol result");
  return o4 ? 1 : s3 ? 0 : -1;
}
function ac(t, e2) {
  e2 !== void 0 && mt(e2);
  const n5 = e2 !== void 0 ? e2 : t.toString(2).length, r3 = Math.ceil(n5 / 8);
  return { nBitLength: n5, nByteLength: r3 };
}
function Yt2(t, e2, n5 = false, r3 = {}) {
  if (t <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o4, s3;
  if (typeof e2 == "object" && e2 != null) {
    if (r3.sqrt || n5) throw new Error("cannot specify opts in two arguments");
    const c6 = e2;
    c6.BITS && (o4 = c6.BITS), c6.sqrt && (s3 = c6.sqrt), typeof c6.isLE == "boolean" && (n5 = c6.isLE);
  } else typeof e2 == "number" && (o4 = e2), r3.sqrt && (s3 = r3.sqrt);
  const { nBitLength: i4, nByteLength: f8 } = ac(t, o4);
  if (f8 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a3;
  const l6 = Object.freeze({ ORDER: t, isLE: n5, BITS: i4, BYTES: f8, MASK: je2(i4), ZERO: ot, ONE: Q2, create: (c6) => lt2(c6, t), isValid: (c6) => {
    if (typeof c6 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c6);
    return ot <= c6 && c6 < t;
  }, is0: (c6) => c6 === ot, isValidNot0: (c6) => !l6.is0(c6) && l6.isValid(c6), isOdd: (c6) => (c6 & Q2) === Q2, neg: (c6) => lt2(-c6, t), eql: (c6, u2) => c6 === u2, sqr: (c6) => lt2(c6 * c6, t), add: (c6, u2) => lt2(c6 + u2, t), sub: (c6, u2) => lt2(c6 - u2, t), mul: (c6, u2) => lt2(c6 * u2, t), pow: (c6, u2) => cc(l6, c6, u2), div: (c6, u2) => lt2(c6 * yo2(u2, t), t), sqrN: (c6) => c6 * c6, addN: (c6, u2) => c6 + u2, subN: (c6, u2) => c6 - u2, mulN: (c6, u2) => c6 * u2, inv: (c6) => yo2(c6, t), sqrt: s3 || ((c6) => (a3 || (a3 = sc(t)), a3(l6, c6))), toBytes: (c6) => n5 ? An2(c6, f8) : In2(c6, f8), fromBytes: (c6) => {
    if (c6.length !== f8) throw new Error("Field.fromBytes: expected " + f8 + " bytes, got " + c6.length);
    return n5 ? Le2(c6) : Ce2(c6);
  }, invertBatch: (c6) => wo2(l6, c6), cmov: (c6, u2, h5) => h5 ? u2 : c6 });
  return Object.freeze(l6);
}
function vo2(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e2 = t.toString(2).length;
  return Math.ceil(e2 / 8);
}
function Eo2(t) {
  const e2 = vo2(t);
  return e2 + Math.ceil(e2 / 2);
}
function uc(t, e2, n5 = false) {
  const r3 = t.length, o4 = vo2(e2), s3 = Eo2(e2);
  if (r3 < 16 || r3 < s3 || r3 > 1024) throw new Error("expected " + s3 + "-1024 bytes of input, got " + r3);
  const i4 = n5 ? Le2(t) : Ce2(t), f8 = lt2(i4, e2 - Q2) + Q2;
  return n5 ? An2(f8, o4) : In2(f8, o4);
}
var Xt2 = BigInt(0);
var Mt2 = BigInt(1);
function le2(t, e2) {
  const n5 = e2.negate();
  return t ? n5 : e2;
}
function lc(t, e2, n5) {
  const r3 = e2 === "pz" ? (i4) => i4.pz : (i4) => i4.ez, o4 = wo2(t.Fp, n5.map(r3));
  return n5.map((i4, f8) => i4.toAffine(o4[f8])).map(t.fromAffine);
}
function Bo2(t, e2) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e2) throw new Error("invalid window size, expected [1.." + e2 + "], got W=" + t);
}
function On2(t, e2) {
  Bo2(t, e2);
  const n5 = Math.ceil(e2 / t) + 1, r3 = 2 ** (t - 1), o4 = 2 ** t, s3 = je2(t), i4 = BigInt(t);
  return { windows: n5, windowSize: r3, mask: s3, maxNumber: o4, shiftBy: i4 };
}
function Io2(t, e2, n5) {
  const { windowSize: r3, mask: o4, maxNumber: s3, shiftBy: i4 } = n5;
  let f8 = Number(t & o4), a3 = t >> i4;
  f8 > r3 && (f8 -= s3, a3 += Mt2);
  const l6 = e2 * r3, c6 = l6 + Math.abs(f8) - 1, u2 = f8 === 0, h5 = f8 < 0, g3 = e2 % 2 !== 0;
  return { nextN: a3, offset: c6, isZero: u2, isNeg: h5, isNegF: g3, offsetF: l6 };
}
function dc(t, e2) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n5, r3) => {
    if (!(n5 instanceof e2)) throw new Error("invalid point at index " + r3);
  });
}
function hc(t, e2) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n5, r3) => {
    if (!e2.isValid(n5)) throw new Error("invalid scalar at index " + r3);
  });
}
var Un2 = /* @__PURE__ */ new WeakMap();
var Ao2 = /* @__PURE__ */ new WeakMap();
function _n2(t) {
  return Ao2.get(t) || 1;
}
function So2(t) {
  if (t !== Xt2) throw new Error("invalid wNAF");
}
function pc(t, e2) {
  return { constTimeNegate: le2, hasPrecomputes(n5) {
    return _n2(n5) !== 1;
  }, unsafeLadder(n5, r3, o4 = t.ZERO) {
    let s3 = n5;
    for (; r3 > Xt2; ) r3 & Mt2 && (o4 = o4.add(s3)), s3 = s3.double(), r3 >>= Mt2;
    return o4;
  }, precomputeWindow(n5, r3) {
    const { windows: o4, windowSize: s3 } = On2(r3, e2), i4 = [];
    let f8 = n5, a3 = f8;
    for (let l6 = 0; l6 < o4; l6++) {
      a3 = f8, i4.push(a3);
      for (let c6 = 1; c6 < s3; c6++) a3 = a3.add(f8), i4.push(a3);
      f8 = a3.double();
    }
    return i4;
  }, wNAF(n5, r3, o4) {
    let s3 = t.ZERO, i4 = t.BASE;
    const f8 = On2(n5, e2);
    for (let a3 = 0; a3 < f8.windows; a3++) {
      const { nextN: l6, offset: c6, isZero: u2, isNeg: h5, isNegF: g3, offsetF: w4 } = Io2(o4, a3, f8);
      o4 = l6, u2 ? i4 = i4.add(le2(g3, r3[w4])) : s3 = s3.add(le2(h5, r3[c6]));
    }
    return So2(o4), { p: s3, f: i4 };
  }, wNAFUnsafe(n5, r3, o4, s3 = t.ZERO) {
    const i4 = On2(n5, e2);
    for (let f8 = 0; f8 < i4.windows && o4 !== Xt2; f8++) {
      const { nextN: a3, offset: l6, isZero: c6, isNeg: u2 } = Io2(o4, f8, i4);
      if (o4 = a3, !c6) {
        const h5 = r3[l6];
        s3 = s3.add(u2 ? h5.negate() : h5);
      }
    }
    return So2(o4), s3;
  }, getPrecomputes(n5, r3, o4) {
    let s3 = Un2.get(r3);
    return s3 || (s3 = this.precomputeWindow(r3, n5), n5 !== 1 && (typeof o4 == "function" && (s3 = o4(s3)), Un2.set(r3, s3))), s3;
  }, wNAFCached(n5, r3, o4) {
    const s3 = _n2(n5);
    return this.wNAF(s3, this.getPrecomputes(s3, n5, o4), r3);
  }, wNAFCachedUnsafe(n5, r3, o4, s3) {
    const i4 = _n2(n5);
    return i4 === 1 ? this.unsafeLadder(n5, r3, s3) : this.wNAFUnsafe(i4, this.getPrecomputes(i4, n5, o4), r3, s3);
  }, setWindowSize(n5, r3) {
    Bo2(r3, e2), Ao2.set(n5, r3), Un2.delete(n5);
  } };
}
function gc(t, e2, n5, r3) {
  let o4 = e2, s3 = t.ZERO, i4 = t.ZERO;
  for (; n5 > Xt2 || r3 > Xt2; ) n5 & Mt2 && (s3 = s3.add(o4)), r3 & Mt2 && (i4 = i4.add(o4)), o4 = o4.double(), n5 >>= Mt2, r3 >>= Mt2;
  return { p1: s3, p2: i4 };
}
function bc(t, e2, n5, r3) {
  dc(n5, t), hc(r3, e2);
  const o4 = n5.length, s3 = r3.length;
  if (o4 !== s3) throw new Error("arrays of points and scalars must have equal length");
  const i4 = t.ZERO, f8 = tc(BigInt(o4));
  let a3 = 1;
  f8 > 12 ? a3 = f8 - 3 : f8 > 4 ? a3 = f8 - 2 : f8 > 0 && (a3 = 2);
  const l6 = je2(a3), c6 = new Array(Number(l6) + 1).fill(i4), u2 = Math.floor((e2.BITS - 1) / a3) * a3;
  let h5 = i4;
  for (let g3 = u2; g3 >= 0; g3 -= a3) {
    c6.fill(i4);
    for (let y5 = 0; y5 < s3; y5++) {
      const x5 = r3[y5], R3 = Number(x5 >> BigInt(g3) & l6);
      c6[R3] = c6[R3].add(n5[y5]);
    }
    let w4 = i4;
    for (let y5 = c6.length - 1, x5 = i4; y5 > 0; y5--) x5 = x5.add(c6[y5]), w4 = w4.add(x5);
    if (h5 = h5.add(w4), g3 !== 0) for (let y5 = 0; y5 < a3; y5++) h5 = h5.double();
  }
  return h5;
}
function No2(t, e2) {
  if (e2) {
    if (e2.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc(e2), e2;
  } else return Yt2(t);
}
function yc(t, e2, n5 = {}) {
  if (!e2 || typeof e2 != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f8 of ["p", "n", "h"]) {
    const a3 = e2[f8];
    if (!(typeof a3 == "bigint" && a3 > Xt2)) throw new Error(`CURVE.${f8} must be positive bigint`);
  }
  const r3 = No2(e2.p, n5.Fp), o4 = No2(e2.n, n5.Fn), i4 = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f8 of i4) if (!r3.isValid(e2[f8])) throw new Error(`CURVE.${f8} must be valid field element of CURVE.Fp`);
  return { Fp: r3, Fn: o4 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de2 = BigInt(0);
var Jt2 = BigInt(1);
var Pe2 = BigInt(2);
function mc(t) {
  return ke2(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function wc(t) {
  const e2 = mc(t), { P: n5, type: r3, adjustScalarBytes: o4, powPminus2: s3, randomBytes: i4 } = e2, f8 = r3 === "x25519";
  if (!f8 && r3 !== "x448") throw new Error("invalid type");
  const a3 = i4 || Zt2, l6 = f8 ? 255 : 448, c6 = f8 ? 32 : 56, u2 = BigInt(f8 ? 9 : 5), h5 = BigInt(f8 ? 121665 : 39081), g3 = f8 ? Pe2 ** BigInt(254) : Pe2 ** BigInt(447), w4 = f8 ? BigInt(8) * Pe2 ** BigInt(251) - Jt2 : BigInt(4) * Pe2 ** BigInt(445) - Jt2, y5 = g3 + w4 + Jt2, x5 = (d4) => lt2(d4, n5), R3 = M4(u2);
  function M4(d4) {
    return An2(x5(d4), c6);
  }
  function L3(d4) {
    const m3 = rt2("u coordinate", d4, c6);
    return f8 && (m3[31] &= 127), x5(Le2(m3));
  }
  function V3(d4) {
    return Le2(o4(rt2("scalar", d4, c6)));
  }
  function _3(d4, m3) {
    const p4 = $3(L3(m3), V3(d4));
    if (p4 === de2) throw new Error("invalid private or public key received");
    return M4(p4);
  }
  function k6(d4) {
    return _3(d4, R3);
  }
  function j3(d4, m3, p4) {
    const b4 = x5(d4 * (m3 - p4));
    return m3 = x5(m3 - b4), p4 = x5(p4 + b4), { x_2: m3, x_3: p4 };
  }
  function $3(d4, m3) {
    Nn2("u", d4, de2, n5), Nn2("scalar", m3, g3, y5);
    const p4 = m3, b4 = d4;
    let v6 = Jt2, B3 = de2, E4 = d4, I4 = Jt2, S4 = de2;
    for (let A4 = BigInt(l6 - 1); A4 >= de2; A4--) {
      const T3 = p4 >> A4 & Jt2;
      S4 ^= T3, { x_2: v6, x_3: E4 } = j3(S4, v6, E4), { x_2: B3, x_3: I4 } = j3(S4, B3, I4), S4 = T3;
      const U3 = v6 + B3, C4 = x5(U3 * U3), H2 = v6 - B3, q = x5(H2 * H2), P4 = C4 - q, K4 = E4 + I4, et = E4 - I4, Z2 = x5(et * U3), z4 = x5(K4 * H2), Ft3 = Z2 + z4, yt3 = Z2 - z4;
      E4 = x5(Ft3 * Ft3), I4 = x5(b4 * x5(yt3 * yt3)), v6 = x5(C4 * q), B3 = x5(P4 * (C4 + x5(h5 * P4)));
    }
    ({ x_2: v6, x_3: E4 } = j3(S4, v6, E4)), { x_2: B3, x_3: I4 } = j3(S4, B3, I4);
    const O5 = s3(B3);
    return x5(v6 * O5);
  }
  return { scalarMult: _3, scalarMultBase: k6, getSharedSecret: (d4, m3) => _3(d4, m3), getPublicKey: (d4) => k6(d4), utils: { randomPrivateKey: () => a3(c6) }, GuBytes: R3.slice() };
}
BigInt(0);
var xc = BigInt(1);
var Oo2 = BigInt(2);
var vc = BigInt(3);
var Ec = BigInt(5);
var Bc = BigInt(8);
var Uo2 = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic(t) {
  const e2 = BigInt(10), n5 = BigInt(20), r3 = BigInt(40), o4 = BigInt(80), s3 = Uo2.p, f8 = t * t % s3 * t % s3, a3 = pt(f8, Oo2, s3) * f8 % s3, l6 = pt(a3, xc, s3) * t % s3, c6 = pt(l6, Ec, s3) * l6 % s3, u2 = pt(c6, e2, s3) * c6 % s3, h5 = pt(u2, n5, s3) * u2 % s3, g3 = pt(h5, r3, s3) * h5 % s3, w4 = pt(g3, o4, s3) * g3 % s3, y5 = pt(w4, o4, s3) * g3 % s3, x5 = pt(y5, e2, s3) * c6 % s3;
  return { pow_p_5_8: pt(x5, Oo2, s3) * t % s3, b2: f8 };
}
function Ac(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Tn2 = (() => {
  const t = Uo2.p;
  return wc({ P: t, type: "x25519", powPminus2: (e2) => {
    const { pow_p_5_8: n5, b2: r3 } = Ic(e2);
    return lt2(pt(n5, vc, t) * r3, t);
  }, adjustScalarBytes: Ac });
})();
function _o2(t) {
  t.lowS !== void 0 && Re2("lowS", t.lowS), t.prehash !== void 0 && Re2("prehash", t.prehash);
}
var Sc = class extends Error {
  constructor(e2 = "") {
    super(e2);
  }
};
var vt2 = { Err: Sc, _tlv: { encode: (t, e2) => {
  const { Err: n5 } = vt2;
  if (t < 0 || t > 256) throw new n5("tlv.encode: wrong tag");
  if (e2.length & 1) throw new n5("tlv.encode: unpadded data");
  const r3 = e2.length / 2, o4 = $e2(r3);
  if (o4.length / 2 & 128) throw new n5("tlv.encode: long form length too big");
  const s3 = r3 > 127 ? $e2(o4.length / 2 | 128) : "";
  return $e2(t) + s3 + o4 + e2;
}, decode(t, e2) {
  const { Err: n5 } = vt2;
  let r3 = 0;
  if (t < 0 || t > 256) throw new n5("tlv.encode: wrong tag");
  if (e2.length < 2 || e2[r3++] !== t) throw new n5("tlv.decode: wrong tlv");
  const o4 = e2[r3++], s3 = !!(o4 & 128);
  let i4 = 0;
  if (!s3) i4 = o4;
  else {
    const a3 = o4 & 127;
    if (!a3) throw new n5("tlv.decode(long): indefinite length not supported");
    if (a3 > 4) throw new n5("tlv.decode(long): byte length is too big");
    const l6 = e2.subarray(r3, r3 + a3);
    if (l6.length !== a3) throw new n5("tlv.decode: length bytes not complete");
    if (l6[0] === 0) throw new n5("tlv.decode(long): zero leftmost byte");
    for (const c6 of l6) i4 = i4 << 8 | c6;
    if (r3 += a3, i4 < 128) throw new n5("tlv.decode(long): not minimal encoding");
  }
  const f8 = e2.subarray(r3, r3 + i4);
  if (f8.length !== i4) throw new n5("tlv.decode: wrong value length");
  return { v: f8, l: e2.subarray(r3 + i4) };
} }, _int: { encode(t) {
  const { Err: e2 } = vt2;
  if (t < he2) throw new e2("integer: negative integers are not allowed");
  let n5 = $e2(t);
  if (Number.parseInt(n5[0], 16) & 8 && (n5 = "00" + n5), n5.length & 1) throw new e2("unexpected DER parsing assertion: unpadded hex");
  return n5;
}, decode(t) {
  const { Err: e2 } = vt2;
  if (t[0] & 128) throw new e2("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e2("invalid signature integer: unnecessary leading zero");
  return Ce2(t);
} }, toSig(t) {
  const { Err: e2, _int: n5, _tlv: r3 } = vt2, o4 = rt2("signature", t), { v: s3, l: i4 } = r3.decode(48, o4);
  if (i4.length) throw new e2("invalid signature: left bytes after parsing");
  const { v: f8, l: a3 } = r3.decode(2, s3), { v: l6, l: c6 } = r3.decode(2, a3);
  if (c6.length) throw new e2("invalid signature: left bytes after parsing");
  return { r: n5.decode(f8), s: n5.decode(l6) };
}, hexFromSig(t) {
  const { _tlv: e2, _int: n5 } = vt2, r3 = e2.encode(2, n5.encode(t.r)), o4 = e2.encode(2, n5.encode(t.s)), s3 = r3 + o4;
  return e2.encode(48, s3);
} };
var he2 = BigInt(0);
var pe2 = BigInt(1);
var Nc = BigInt(2);
var He2 = BigInt(3);
var Oc = BigInt(4);
function Uc(t, e2, n5) {
  function r3(o4) {
    const s3 = t.sqr(o4), i4 = t.mul(s3, o4);
    return t.add(t.add(i4, t.mul(o4, e2)), n5);
  }
  return r3;
}
function To2(t, e2, n5) {
  const { BYTES: r3 } = t;
  function o4(s3) {
    let i4;
    if (typeof s3 == "bigint") i4 = s3;
    else {
      let f8 = rt2("private key", s3);
      if (e2) {
        if (!e2.includes(f8.length * 2)) throw new Error("invalid private key");
        const a3 = new Uint8Array(r3);
        a3.set(f8, a3.length - f8.length), f8 = a3;
      }
      try {
        i4 = t.fromBytes(f8);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r3}, got ${typeof s3}`);
      }
    }
    if (n5 && (i4 = t.create(i4)), !t.isValidNot0(i4)) throw new Error("invalid private key: out of range [1..N-1]");
    return i4;
  }
  return o4;
}
function _c(t, e2 = {}) {
  const { Fp: n5, Fn: r3 } = yc("weierstrass", t, e2), { h: o4, n: s3 } = t;
  ke2(e2, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i4 } = e2;
  if (i4 && (!n5.is0(t.a) || typeof i4.beta != "bigint" || typeof i4.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f8() {
    if (!n5.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a3($3, d4, m3) {
    const { x: p4, y: b4 } = d4.toAffine(), v6 = n5.toBytes(p4);
    if (Re2("isCompressed", m3), m3) {
      f8();
      const B3 = !n5.isOdd(b4);
      return Ht2(Ro2(B3), v6);
    } else return Ht2(Uint8Array.of(4), v6, n5.toBytes(b4));
  }
  function l6($3) {
    at($3);
    const d4 = n5.BYTES, m3 = d4 + 1, p4 = 2 * d4 + 1, b4 = $3.length, v6 = $3[0], B3 = $3.subarray(1);
    if (b4 === m3 && (v6 === 2 || v6 === 3)) {
      const E4 = n5.fromBytes(B3);
      if (!n5.isValid(E4)) throw new Error("bad point: is not on curve, wrong x");
      const I4 = h5(E4);
      let S4;
      try {
        S4 = n5.sqrt(I4);
      } catch (T3) {
        const U3 = T3 instanceof Error ? ": " + T3.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U3);
      }
      f8();
      const O5 = n5.isOdd(S4);
      return (v6 & 1) === 1 !== O5 && (S4 = n5.neg(S4)), { x: E4, y: S4 };
    } else if (b4 === p4 && v6 === 4) {
      const E4 = n5.fromBytes(B3.subarray(d4 * 0, d4 * 1)), I4 = n5.fromBytes(B3.subarray(d4 * 1, d4 * 2));
      if (!g3(E4, I4)) throw new Error("bad point: is not on curve");
      return { x: E4, y: I4 };
    } else throw new Error(`bad point: got length ${b4}, expected compressed=${m3} or uncompressed=${p4}`);
  }
  const c6 = e2.toBytes || a3, u2 = e2.fromBytes || l6, h5 = Uc(n5, t.a, t.b);
  function g3($3, d4) {
    const m3 = n5.sqr(d4), p4 = h5($3);
    return n5.eql(m3, p4);
  }
  if (!g3(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
  const w4 = n5.mul(n5.pow(t.a, He2), Oc), y5 = n5.mul(n5.sqr(t.b), BigInt(27));
  if (n5.is0(n5.add(w4, y5))) throw new Error("bad curve params: a or b");
  function x5($3, d4, m3 = false) {
    if (!n5.isValid(d4) || m3 && n5.is0(d4)) throw new Error(`bad point coordinate ${$3}`);
    return d4;
  }
  function R3($3) {
    if (!($3 instanceof _3)) throw new Error("ProjectivePoint expected");
  }
  const M4 = ho2(($3, d4) => {
    const { px: m3, py: p4, pz: b4 } = $3;
    if (n5.eql(b4, n5.ONE)) return { x: m3, y: p4 };
    const v6 = $3.is0();
    d4 == null && (d4 = v6 ? n5.ONE : n5.inv(b4));
    const B3 = n5.mul(m3, d4), E4 = n5.mul(p4, d4), I4 = n5.mul(b4, d4);
    if (v6) return { x: n5.ZERO, y: n5.ZERO };
    if (!n5.eql(I4, n5.ONE)) throw new Error("invZ was invalid");
    return { x: B3, y: E4 };
  }), L3 = ho2(($3) => {
    if ($3.is0()) {
      if (e2.allowInfinityPoint && !n5.is0($3.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d4, y: m3 } = $3.toAffine();
    if (!n5.isValid(d4) || !n5.isValid(m3)) throw new Error("bad point: x or y not field elements");
    if (!g3(d4, m3)) throw new Error("bad point: equation left != right");
    if (!$3.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V3($3, d4, m3, p4, b4) {
    return m3 = new _3(n5.mul(m3.px, $3), m3.py, m3.pz), d4 = le2(p4, d4), m3 = le2(b4, m3), d4.add(m3);
  }
  class _3 {
    constructor(d4, m3, p4) {
      this.px = x5("x", d4), this.py = x5("y", m3, true), this.pz = x5("z", p4), Object.freeze(this);
    }
    static fromAffine(d4) {
      const { x: m3, y: p4 } = d4 || {};
      if (!d4 || !n5.isValid(m3) || !n5.isValid(p4)) throw new Error("invalid affine point");
      if (d4 instanceof _3) throw new Error("projective point not allowed");
      return n5.is0(m3) && n5.is0(p4) ? _3.ZERO : new _3(m3, p4, n5.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d4) {
      return lc(_3, "pz", d4);
    }
    static fromBytes(d4) {
      return at(d4), _3.fromHex(d4);
    }
    static fromHex(d4) {
      const m3 = _3.fromAffine(u2(rt2("pointHex", d4)));
      return m3.assertValidity(), m3;
    }
    static fromPrivateKey(d4) {
      const m3 = To2(r3, e2.allowedPrivateKeyLengths, e2.wrapPrivateKey);
      return _3.BASE.multiply(m3(d4));
    }
    static msm(d4, m3) {
      return bc(_3, r3, d4, m3);
    }
    precompute(d4 = 8, m3 = true) {
      return j3.setWindowSize(this, d4), m3 || this.multiply(He2), this;
    }
    _setWindowSize(d4) {
      this.precompute(d4);
    }
    assertValidity() {
      L3(this);
    }
    hasEvenY() {
      const { y: d4 } = this.toAffine();
      if (!n5.isOdd) throw new Error("Field doesn't support isOdd");
      return !n5.isOdd(d4);
    }
    equals(d4) {
      R3(d4);
      const { px: m3, py: p4, pz: b4 } = this, { px: v6, py: B3, pz: E4 } = d4, I4 = n5.eql(n5.mul(m3, E4), n5.mul(v6, b4)), S4 = n5.eql(n5.mul(p4, E4), n5.mul(B3, b4));
      return I4 && S4;
    }
    negate() {
      return new _3(this.px, n5.neg(this.py), this.pz);
    }
    double() {
      const { a: d4, b: m3 } = t, p4 = n5.mul(m3, He2), { px: b4, py: v6, pz: B3 } = this;
      let E4 = n5.ZERO, I4 = n5.ZERO, S4 = n5.ZERO, O5 = n5.mul(b4, b4), A4 = n5.mul(v6, v6), T3 = n5.mul(B3, B3), U3 = n5.mul(b4, v6);
      return U3 = n5.add(U3, U3), S4 = n5.mul(b4, B3), S4 = n5.add(S4, S4), E4 = n5.mul(d4, S4), I4 = n5.mul(p4, T3), I4 = n5.add(E4, I4), E4 = n5.sub(A4, I4), I4 = n5.add(A4, I4), I4 = n5.mul(E4, I4), E4 = n5.mul(U3, E4), S4 = n5.mul(p4, S4), T3 = n5.mul(d4, T3), U3 = n5.sub(O5, T3), U3 = n5.mul(d4, U3), U3 = n5.add(U3, S4), S4 = n5.add(O5, O5), O5 = n5.add(S4, O5), O5 = n5.add(O5, T3), O5 = n5.mul(O5, U3), I4 = n5.add(I4, O5), T3 = n5.mul(v6, B3), T3 = n5.add(T3, T3), O5 = n5.mul(T3, U3), E4 = n5.sub(E4, O5), S4 = n5.mul(T3, A4), S4 = n5.add(S4, S4), S4 = n5.add(S4, S4), new _3(E4, I4, S4);
    }
    add(d4) {
      R3(d4);
      const { px: m3, py: p4, pz: b4 } = this, { px: v6, py: B3, pz: E4 } = d4;
      let I4 = n5.ZERO, S4 = n5.ZERO, O5 = n5.ZERO;
      const A4 = t.a, T3 = n5.mul(t.b, He2);
      let U3 = n5.mul(m3, v6), C4 = n5.mul(p4, B3), H2 = n5.mul(b4, E4), q = n5.add(m3, p4), P4 = n5.add(v6, B3);
      q = n5.mul(q, P4), P4 = n5.add(U3, C4), q = n5.sub(q, P4), P4 = n5.add(m3, b4);
      let K4 = n5.add(v6, E4);
      return P4 = n5.mul(P4, K4), K4 = n5.add(U3, H2), P4 = n5.sub(P4, K4), K4 = n5.add(p4, b4), I4 = n5.add(B3, E4), K4 = n5.mul(K4, I4), I4 = n5.add(C4, H2), K4 = n5.sub(K4, I4), O5 = n5.mul(A4, P4), I4 = n5.mul(T3, H2), O5 = n5.add(I4, O5), I4 = n5.sub(C4, O5), O5 = n5.add(C4, O5), S4 = n5.mul(I4, O5), C4 = n5.add(U3, U3), C4 = n5.add(C4, U3), H2 = n5.mul(A4, H2), P4 = n5.mul(T3, P4), C4 = n5.add(C4, H2), H2 = n5.sub(U3, H2), H2 = n5.mul(A4, H2), P4 = n5.add(P4, H2), U3 = n5.mul(C4, P4), S4 = n5.add(S4, U3), U3 = n5.mul(K4, P4), I4 = n5.mul(q, I4), I4 = n5.sub(I4, U3), U3 = n5.mul(q, C4), O5 = n5.mul(K4, O5), O5 = n5.add(O5, U3), new _3(I4, S4, O5);
    }
    subtract(d4) {
      return this.add(d4.negate());
    }
    is0() {
      return this.equals(_3.ZERO);
    }
    multiply(d4) {
      const { endo: m3 } = e2;
      if (!r3.isValidNot0(d4)) throw new Error("invalid scalar: out of range");
      let p4, b4;
      const v6 = (B3) => j3.wNAFCached(this, B3, _3.normalizeZ);
      if (m3) {
        const { k1neg: B3, k1: E4, k2neg: I4, k2: S4 } = m3.splitScalar(d4), { p: O5, f: A4 } = v6(E4), { p: T3, f: U3 } = v6(S4);
        b4 = A4.add(U3), p4 = V3(m3.beta, O5, T3, B3, I4);
      } else {
        const { p: B3, f: E4 } = v6(d4);
        p4 = B3, b4 = E4;
      }
      return _3.normalizeZ([p4, b4])[0];
    }
    multiplyUnsafe(d4) {
      const { endo: m3 } = e2, p4 = this;
      if (!r3.isValid(d4)) throw new Error("invalid scalar: out of range");
      if (d4 === he2 || p4.is0()) return _3.ZERO;
      if (d4 === pe2) return p4;
      if (j3.hasPrecomputes(this)) return this.multiply(d4);
      if (m3) {
        const { k1neg: b4, k1: v6, k2neg: B3, k2: E4 } = m3.splitScalar(d4), { p1: I4, p2: S4 } = gc(_3, p4, v6, E4);
        return V3(m3.beta, I4, S4, b4, B3);
      } else return j3.wNAFCachedUnsafe(p4, d4);
    }
    multiplyAndAddUnsafe(d4, m3, p4) {
      const b4 = this.multiplyUnsafe(m3).add(d4.multiplyUnsafe(p4));
      return b4.is0() ? void 0 : b4;
    }
    toAffine(d4) {
      return M4(this, d4);
    }
    isTorsionFree() {
      const { isTorsionFree: d4 } = e2;
      return o4 === pe2 ? true : d4 ? d4(_3, this) : j3.wNAFCachedUnsafe(this, s3).is0();
    }
    clearCofactor() {
      const { clearCofactor: d4 } = e2;
      return o4 === pe2 ? this : d4 ? d4(_3, this) : this.multiplyUnsafe(o4);
    }
    toBytes(d4 = true) {
      return Re2("isCompressed", d4), this.assertValidity(), c6(_3, this, d4);
    }
    toRawBytes(d4 = true) {
      return this.toBytes(d4);
    }
    toHex(d4 = true) {
      return ce(this.toBytes(d4));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _3.BASE = new _3(t.Gx, t.Gy, n5.ONE), _3.ZERO = new _3(n5.ZERO, n5.ONE, n5.ZERO), _3.Fp = n5, _3.Fn = r3;
  const k6 = r3.BITS, j3 = pc(_3, e2.endo ? Math.ceil(k6 / 2) : k6);
  return _3;
}
function Ro2(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Tc(t, e2, n5 = {}) {
  ke2(e2, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r3 = e2.randomBytes || Zt2, o4 = e2.hmac || ((p4, ...b4) => _e2(e2.hash, p4, Ht2(...b4))), { Fp: s3, Fn: i4 } = t, { ORDER: f8, BITS: a3 } = i4;
  function l6(p4) {
    const b4 = f8 >> pe2;
    return p4 > b4;
  }
  function c6(p4) {
    return l6(p4) ? i4.neg(p4) : p4;
  }
  function u2(p4, b4) {
    if (!i4.isValidNot0(b4)) throw new Error(`invalid signature ${p4}: out of range 1..CURVE.n`);
  }
  class h5 {
    constructor(b4, v6, B3) {
      u2("r", b4), u2("s", v6), this.r = b4, this.s = v6, B3 != null && (this.recovery = B3), Object.freeze(this);
    }
    static fromCompact(b4) {
      const v6 = i4.BYTES, B3 = rt2("compactSignature", b4, v6 * 2);
      return new h5(i4.fromBytes(B3.subarray(0, v6)), i4.fromBytes(B3.subarray(v6, v6 * 2)));
    }
    static fromDER(b4) {
      const { r: v6, s: B3 } = vt2.toSig(rt2("DER", b4));
      return new h5(v6, B3);
    }
    assertValidity() {
    }
    addRecoveryBit(b4) {
      return new h5(this.r, this.s, b4);
    }
    recoverPublicKey(b4) {
      const v6 = s3.ORDER, { r: B3, s: E4, recovery: I4 } = this;
      if (I4 == null || ![0, 1, 2, 3].includes(I4)) throw new Error("recovery id invalid");
      if (f8 * Nc < v6 && I4 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O5 = I4 === 2 || I4 === 3 ? B3 + f8 : B3;
      if (!s3.isValid(O5)) throw new Error("recovery id 2 or 3 invalid");
      const A4 = s3.toBytes(O5), T3 = t.fromHex(Ht2(Ro2((I4 & 1) === 0), A4)), U3 = i4.inv(O5), C4 = L3(rt2("msgHash", b4)), H2 = i4.create(-C4 * U3), q = i4.create(E4 * U3), P4 = t.BASE.multiplyUnsafe(H2).add(T3.multiplyUnsafe(q));
      if (P4.is0()) throw new Error("point at infinify");
      return P4.assertValidity(), P4;
    }
    hasHighS() {
      return l6(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h5(this.r, i4.neg(this.s), this.recovery) : this;
    }
    toBytes(b4) {
      if (b4 === "compact") return Ht2(i4.toBytes(this.r), i4.toBytes(this.s));
      if (b4 === "der") return fn(vt2.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce(this.toBytes("compact"));
    }
  }
  const g3 = To2(i4, n5.allowedPrivateKeyLengths, n5.wrapPrivateKey), w4 = { isValidPrivateKey(p4) {
    try {
      return g3(p4), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g3, randomPrivateKey: () => {
    const p4 = f8;
    return uc(r3(Eo2(p4)), p4);
  }, precompute(p4 = 8, b4 = t.BASE) {
    return b4.precompute(p4, false);
  } };
  function y5(p4, b4 = true) {
    return t.fromPrivateKey(p4).toBytes(b4);
  }
  function x5(p4) {
    if (typeof p4 == "bigint") return false;
    if (p4 instanceof t) return true;
    const v6 = rt2("key", p4).length, B3 = s3.BYTES, E4 = B3 + 1, I4 = 2 * B3 + 1;
    if (!(n5.allowedPrivateKeyLengths || i4.BYTES === E4)) return v6 === E4 || v6 === I4;
  }
  function R3(p4, b4, v6 = true) {
    if (x5(p4) === true) throw new Error("first arg must be private key");
    if (x5(b4) === false) throw new Error("second arg must be public key");
    return t.fromHex(b4).multiply(g3(p4)).toBytes(v6);
  }
  const M4 = e2.bits2int || function(p4) {
    if (p4.length > 8192) throw new Error("input is too large");
    const b4 = Ce2(p4), v6 = p4.length * 8 - a3;
    return v6 > 0 ? b4 >> BigInt(v6) : b4;
  }, L3 = e2.bits2int_modN || function(p4) {
    return i4.create(M4(p4));
  }, V3 = je2(a3);
  function _3(p4) {
    return Nn2("num < 2^" + a3, p4, he2, V3), i4.toBytes(p4);
  }
  function k6(p4, b4, v6 = j3) {
    if (["recovered", "canonical"].some((q) => q in v6)) throw new Error("sign() legacy options not supported");
    const { hash: B3 } = e2;
    let { lowS: E4, prehash: I4, extraEntropy: S4 } = v6;
    E4 == null && (E4 = true), p4 = rt2("msgHash", p4), _o2(v6), I4 && (p4 = rt2("prehashed msgHash", B3(p4)));
    const O5 = L3(p4), A4 = g3(b4), T3 = [_3(A4), _3(O5)];
    if (S4 != null && S4 !== false) {
      const q = S4 === true ? r3(s3.BYTES) : S4;
      T3.push(rt2("extraEntropy", q));
    }
    const U3 = Ht2(...T3), C4 = O5;
    function H2(q) {
      const P4 = M4(q);
      if (!i4.isValidNot0(P4)) return;
      const K4 = i4.inv(P4), et = t.BASE.multiply(P4).toAffine(), Z2 = i4.create(et.x);
      if (Z2 === he2) return;
      const z4 = i4.create(K4 * i4.create(C4 + Z2 * A4));
      if (z4 === he2) return;
      let Ft3 = (et.x === Z2 ? 0 : 2) | Number(et.y & pe2), yt3 = z4;
      return E4 && l6(z4) && (yt3 = c6(z4), Ft3 ^= 1), new h5(Z2, yt3, Ft3);
    }
    return { seed: U3, k2sig: H2 };
  }
  const j3 = { lowS: e2.lowS, prehash: false }, $3 = { lowS: e2.lowS, prehash: false };
  function d4(p4, b4, v6 = j3) {
    const { seed: B3, k2sig: E4 } = k6(p4, b4, v6);
    return ec(e2.hash.outputLen, i4.BYTES, o4)(B3, E4);
  }
  t.BASE.precompute(8);
  function m3(p4, b4, v6, B3 = $3) {
    const E4 = p4;
    b4 = rt2("msgHash", b4), v6 = rt2("publicKey", v6), _o2(B3);
    const { lowS: I4, prehash: S4, format: O5 } = B3;
    if ("strict" in B3) throw new Error("options.strict was renamed to lowS");
    if (O5 !== void 0 && !["compact", "der", "js"].includes(O5)) throw new Error('format must be "compact", "der" or "js"');
    const A4 = typeof E4 == "string" || nn2(E4), T3 = !A4 && !O5 && typeof E4 == "object" && E4 !== null && typeof E4.r == "bigint" && typeof E4.s == "bigint";
    if (!A4 && !T3) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U3, C4;
    try {
      if (T3) if (O5 === void 0 || O5 === "js") U3 = new h5(E4.r, E4.s);
      else throw new Error("invalid format");
      if (A4) {
        try {
          O5 !== "compact" && (U3 = h5.fromDER(E4));
        } catch (yt3) {
          if (!(yt3 instanceof vt2.Err)) throw yt3;
        }
        !U3 && O5 !== "der" && (U3 = h5.fromCompact(E4));
      }
      C4 = t.fromHex(v6);
    } catch {
      return false;
    }
    if (!U3 || I4 && U3.hasHighS()) return false;
    S4 && (b4 = e2.hash(b4));
    const { r: H2, s: q } = U3, P4 = L3(b4), K4 = i4.inv(q), et = i4.create(P4 * K4), Z2 = i4.create(H2 * K4), z4 = t.BASE.multiplyUnsafe(et).add(C4.multiplyUnsafe(Z2));
    return z4.is0() ? false : i4.create(z4.x) === H2;
  }
  return Object.freeze({ getPublicKey: y5, getSharedSecret: R3, sign: d4, verify: m3, utils: w4, Point: t, Signature: h5 });
}
function Rc(t) {
  const e2 = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n5 = t.Fp, r3 = Yt2(e2.n, t.nBitLength), o4 = { Fp: n5, Fn: r3, allowedPrivateKeyLengths: t.allowedPrivateKeyLengths, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, wrapPrivateKey: t.wrapPrivateKey, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e2, curveOpts: o4 };
}
function $c(t) {
  const { CURVE: e2, curveOpts: n5 } = Rc(t), r3 = { hash: t.hash, hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e2, curveOpts: n5, ecdsaOpts: r3 };
}
function Cc(t, e2) {
  return Object.assign({}, e2, { ProjectivePoint: e2.Point, CURVE: t });
}
function Lc(t) {
  const { CURVE: e2, curveOpts: n5, ecdsaOpts: r3 } = $c(t), o4 = _c(e2, n5), s3 = Tc(o4, r3, n5);
  return Cc(t, s3);
}
function Rn2(t, e2) {
  const n5 = (r3) => Lc({ ...t, hash: r3 });
  return { ...n5(e2), create: n5 };
}
var $o2 = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co2 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo2 = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc = Yt2($o2.p);
var kc = Yt2(Co2.p);
var Pc = Yt2(Lo2.p);
var Hc = Rn2({ ...$o2, Fp: jc, lowS: false }, Ae2);
Rn2({ ...Co2, Fp: kc, lowS: false }, Yi), Rn2({ ...Lo2, Fp: Pc, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi);
var Jo2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };

// node_modules/@dynamic-labs/solana/src/walletConnect/SolanaWalletConnectConnector/SolanaWalletConnectConnector.js
var import_bs585 = __toESM(require_bs583(), 1);

// node_modules/@dynamic-labs/solana/node_modules/eventemitter3/index.mjs
var import_index3 = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index3.default;

// node_modules/@dynamic-labs/wallet-connect/package.js
var version4 = "4.57.1";

// node_modules/@dynamic-labs/wallet-connect/_virtual/_tslib.js
function __awaiter4(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents = class {
};

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var n = class extends IEvents {
  constructor(e2) {
    super();
  }
};
var s = import_time3.FIVE_SECONDS;
var r = { pulse: "heartbeat_pulse" };
var i = class _i4 extends n {
  constructor(e2) {
    super(e2), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e2 == null ? void 0 : e2.interval) || s;
  }
  static async init(e2) {
    const t = new _i4(e2);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time3.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r.pulse);
  }
};

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type3 = typeof value;
  return value === null || type3 !== "object" && type3 !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify3(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify3(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c6) => c6.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a21;
  if (!key) {
    return "";
  }
  return ((_a21 = key.split("?")[0]) == null ? void 0 : _a21.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys4) {
  return normalizeKey(keys4.join(":"));
}
function normalizeBaseKey(base3) {
  base3 = normalizeKey(base3);
  return base3 ? base3 + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base3) {
  if (base3) {
    return key.startsWith(base3) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/unstorage/dist/index.mjs
function defineDriver(factory2) {
  return factory2;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base3 of context.mountpoints) {
      if (key.startsWith(base3)) {
        return {
          base: base3,
          relativeKey: key.slice(base3.length),
          driver: context.mounts[base3]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base3, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base3) || includeParent && base3.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base3.length > mountpoint.length ? base3.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage2 = {
    // Item
    hasItem(key, opts2 = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts2);
    },
    getItem(key, opts2 = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts2).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts2 = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts2);
      }
      return asyncCall(driver.getItem, relativeKey, opts2).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts2 = {}) {
      if (value === void 0) {
        return storage2.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify3(value), opts2);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify3(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify3(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts2 = {}) {
      if (value === void 0) {
        return storage2.removeItem(key, opts2);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts2);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts2);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts2 = {}) {
      if (typeof opts2 === "boolean") {
        opts2 = { removeMeta: opts2 };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts2);
      if (opts2.removeMeta || opts2.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts2);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts2 = {}) {
      if (typeof opts2 === "boolean") {
        opts2 = { nativeOnly: opts2 };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts2));
      }
      if (!opts2.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts2
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts2 = {}) {
      return this.setItem(key + "$", value, opts2);
    },
    removeMeta(key, opts2 = {}) {
      return this.removeItem(key + "$", opts2);
    },
    // Keys
    async getKeys(base3, opts2 = {}) {
      var _a21;
      base3 = normalizeBaseKey(base3);
      const mounts = getMounts(base3, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a21 = mount.driver.flags) == null ? void 0 : _a21.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts2
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p4) => fullKey.startsWith(p4))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p4) => !p4.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts2.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts2.maxDepth)) && filterKeyByBase(key, base3)
      );
    },
    // Utils
    async clear(base3, opts2 = {}) {
      base3 = normalizeBaseKey(base3);
      await Promise.all(
        getMounts(base3, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall(m3.driver.clear, m3.relativeBase, opts2);
          }
          if (m3.driver.removeItem) {
            const keys4 = await m3.driver.getKeys(m3.relativeBase || "", opts2);
            return Promise.all(
              keys4.map((key) => m3.driver.removeItem(key, opts2))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base3, driver) {
      base3 = normalizeBaseKey(base3);
      if (base3 && context.mounts[base3]) {
        throw new Error(`already mounted at ${base3}`);
      }
      if (base3) {
        context.mountpoints.push(base3);
        context.mountpoints.sort((a3, b4) => b4.length - a3.length);
      }
      context.mounts[base3] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base3)).then((unwatcher) => {
          context.unwatch[base3] = unwatcher;
        }).catch(console.error);
      }
      return storage2;
    },
    async unmount(base3, _dispose = true) {
      var _a21, _b;
      base3 = normalizeBaseKey(base3);
      if (!base3 || !context.mounts[base3]) {
        return;
      }
      if (context.watching && base3 in context.unwatch) {
        (_b = (_a21 = context.unwatch)[base3]) == null ? void 0 : _b.call(_a21);
        delete context.unwatch[base3];
      }
      if (_dispose) {
        await dispose(context.mounts[base3]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base3);
      delete context.mounts[base3];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base3 = "", opts2 = {}) {
      base3 = normalizeKey(base3);
      const mounts = getMounts(base3, opts2.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    },
    // Aliases
    keys: (base3, opts2 = {}) => storage2.getKeys(base3, opts2),
    get: (key, opts2 = {}) => storage2.getItem(key, opts2),
    set: (key, value, opts2 = {}) => storage2.setItem(key, value, opts2),
    has: (key, opts2 = {}) => storage2.hasItem(key, opts2),
    del: (key, opts2 = {}) => storage2.removeItem(key, opts2),
    remove: (key, opts2 = {}) => storage2.removeItem(key, opts2)
  };
  return storage2;
}
function watch(driver, onChange, base3) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base3 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request2) {
  return new Promise((resolve, reject) => {
    request2.oncomplete = request2.onsuccess = () => resolve(request2.result);
    request2.onabort = request2.onerror = () => reject(request2.error);
  });
}
function createStore(dbName, storeName) {
  const request2 = indexedDB.open(dbName);
  request2.onupgradeneeded = () => request2.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request2);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get3(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x2 = "idb-keyval";
var z = (i4 = {}) => {
  const t = i4.base && i4.base.length > 0 ? `${i4.base}:` : "", e2 = (s3) => t + s3;
  let n5;
  return i4.dbName && i4.storeName && (n5 = createStore(i4.dbName, i4.storeName)), { name: x2, options: i4, async hasItem(s3) {
    return !(typeof await get3(e2(s3), n5) > "u");
  }, async getItem(s3) {
    return await get3(e2(s3), n5) ?? null;
  }, setItem(s3, a3) {
    return set(e2(s3), a3, n5);
  }, removeItem(s3) {
    return del(e2(s3), n5);
  }, getKeys() {
    return keys(n5);
  }, clear() {
    return clear(n5);
  } };
};
var D2 = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D2, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e2 = await this.indexedDb.getItem(t);
    if (e2 !== null) return e2;
  }
  async setItem(t, e2) {
    await this.indexedDb.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i4;
  function t() {
  }
  i4 = t, i4.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i4.prototype.setItem = function(e2, n5) {
    this[e2] = String(n5);
  }, i4.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i4.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n5) {
      e2[n5] = void 0, delete e2[n5];
    });
  }, i4.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i4.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i4) {
  var t;
  return [i4[0], safeJsonParse((t = i4[1]) != null ? t : "")];
}
var K3 = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e2 = this.localStorage.getItem(t);
    if (e2 !== null) return safeJsonParse(e2);
  }
  async setItem(t, e2) {
    this.localStorage.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N11 = "wc_storage_version";
var y = 1;
var O = async (i4, t, e2) => {
  const n5 = N11, s3 = await t.getItem(n5);
  if (s3 && s3 >= y) {
    e2(t);
    return;
  }
  const a3 = await i4.getKeys();
  if (!a3.length) {
    e2(t);
    return;
  }
  const m3 = [];
  for (; a3.length; ) {
    const r3 = a3.shift();
    if (!r3) continue;
    const o4 = r3.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f8 = await i4.getItem(r3);
      await t.setItem(r3, f8), m3.push(r3);
    }
  }
  await t.setItem(n5, y), e2(t), j2(i4, m3);
};
var j2 = async (i4, t) => {
  t.length && t.forEach(async (e2) => {
    await i4.removeItem(e2);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t = new K3();
    this.storage = t;
    try {
      const e2 = new _();
      O(t, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e2) {
    return await this.initialize(), this.storage.setItem(t, e2);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t());
      }, 20);
    });
  }
};

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino = __toESM(require_browser2());
var import_pino2 = __toESM(require_browser2());
var c2 = { level: "info" };
var n2 = "custom_context";
var l3 = 1e3 * 1024;
var O2 = class {
  constructor(e2) {
    this.nodeValue = e2, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d = class {
  constructor(e2) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e2, this.sizeInBytes = 0;
  }
  append(e2) {
    const t = new O2(e2);
    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e2} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head) return;
    const e2 = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e2.size;
  }
  toArray() {
    const e2 = [];
    let t = this.head;
    for (; t !== null; ) e2.push(t.value), t = t.next;
    return e2;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e2 = this.head;
    return { next: () => {
      if (!e2) return { done: true, value: null };
      const t = e2.value;
      return e2 = e2.next, { done: false, value: t };
    } };
  }
};
var L = class {
  constructor(e2, t = l3) {
    this.level = e2 ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e2, t) {
    t === import_pino.levels.values.error ? console.error(e2) : t === import_pino.levels.values.warn ? console.warn(e2) : t === import_pino.levels.values.debug ? console.debug(e2) : t === import_pino.levels.values.trace ? console.trace(e2) : console.log(e2);
  }
  appendToLogs(e2) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e2 }));
    const t = typeof e2 == "string" ? JSON.parse(e2).level : e2.level;
    t >= this.levelValue && this.forwardToConsole(e2, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e2) {
    const t = this.getLogArray();
    return t.push(safeJsonStringify({ extraMetadata: e2 })), new Blob(t, { type: "application/json" });
  }
};
var m = class {
  constructor(e2, t = l3) {
    this.baseChunkLogger = new L(e2, t);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
  downloadLogsBlobInBrowser(e2) {
    const t = URL.createObjectURL(this.logsToBlob(e2)), o4 = document.createElement("a");
    o4.href = t, o4.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o4), o4.click(), document.body.removeChild(o4), URL.revokeObjectURL(t);
  }
};
var B = class {
  constructor(e2, t = l3) {
    this.baseChunkLogger = new L(e2, t);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
};
var x3 = Object.defineProperty;
var S = Object.defineProperties;
var _2 = Object.getOwnPropertyDescriptors;
var p = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z2 = Object.prototype.propertyIsEnumerable;
var f = (r3, e2, t) => e2 in r3 ? x3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var i2 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) T.call(e2, t) && f(r3, t, e2[t]);
  if (p) for (var t of p(e2)) z2.call(e2, t) && f(r3, t, e2[t]);
  return r3;
};
var g = (r3, e2) => S(r3, _2(e2));
function k3(r3) {
  return g(i2({}, r3), { level: (r3 == null ? void 0 : r3.level) || c2.level });
}
function v(r3, e2 = n2) {
  return r3[e2] || "";
}
function b(r3, e2, t = n2) {
  return r3[t] = e2, r3;
}
function y2(r3, e2 = n2) {
  let t = "";
  return typeof r3.bindings > "u" ? t = v(r3, e2) : t = r3.bindings().context || "", t;
}
function w(r3, e2, t = n2) {
  const o4 = y2(r3, t);
  return o4.trim() ? `${o4}/${e2}` : e2;
}
function E2(r3, e2, t = n2) {
  const o4 = w(r3, e2, t), a3 = r3.child({ context: o4 });
  return b(a3, o4, t);
}
function C2(r3) {
  var e2, t;
  const o4 = new m((e2 = r3.opts) == null ? void 0 : e2.level, r3.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r3.opts), { level: "trace", browser: g(i2({}, (t = r3.opts) == null ? void 0 : t.browser), { write: (a3) => o4.write(a3) }) })), chunkLoggerController: o4 };
}
function I(r3) {
  var e2;
  const t = new B((e2 = r3.opts) == null ? void 0 : e2.level, r3.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r3.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function A(r3) {
  return typeof r3.loggerOverride < "u" && typeof r3.loggerOverride != "string" ? { logger: r3.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C2(r3) : I(r3);
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/types/dist/index.es.js
var import_events4 = __toESM(require_events());
var a2 = Object.defineProperty;
var u = (e2, s3, r3) => s3 in e2 ? a2(e2, s3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e2[s3] = r3;
var c3 = (e2, s3, r3) => u(e2, typeof s3 != "symbol" ? s3 + "" : s3, r3);
var h3 = class extends IEvents {
  constructor(s3) {
    super(), this.opts = s3, c3(this, "protocol", "wc"), c3(this, "version", 2);
  }
};
var p2 = Object.defineProperty;
var b2 = (e2, s3, r3) => s3 in e2 ? p2(e2, s3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e2[s3] = r3;
var v2 = (e2, s3, r3) => b2(e2, typeof s3 != "symbol" ? s3 + "" : s3, r3);
var I2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.core = s3, this.logger = r3, v2(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s3, r3) {
    this.logger = s3, this.core = r3;
  }
};
var m2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.relayer = s3, this.logger = r3;
  }
};
var d2 = class extends IEvents {
  constructor(s3) {
    super();
  }
};
var f2 = class {
  constructor(s3, r3, t, q) {
    this.core = s3, this.logger = r3, this.name = t;
  }
};
var P2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.relayer = s3, this.logger = r3;
  }
};
var S2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.core = s3, this.logger = r3;
  }
};
var M2 = class {
  constructor(s3, r3, t) {
    this.core = s3, this.logger = r3, this.store = t;
  }
};
var O3 = class {
  constructor(s3, r3) {
    this.projectId = s3, this.logger = r3;
  }
};
var R = class {
  constructor(s3, r3, t) {
    this.core = s3, this.logger = r3, this.telemetryEnabled = t;
  }
};
var T2 = Object.defineProperty;
var k4 = (e2, s3, r3) => s3 in e2 ? T2(e2, s3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e2[s3] = r3;
var i3 = (e2, s3, r3) => k4(e2, typeof s3 != "symbol" ? s3 + "" : s3, r3);
var J2 = class {
  constructor(s3) {
    this.opts = s3, i3(this, "protocol", "wc"), i3(this, "version", 2);
  }
};
var V = class {
  constructor(s3) {
    this.client = s3;
  }
};

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/core/dist/index.es.js
var import_time5 = __toESM(require_cjs());

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/utils/dist/index.es.js
var import_time4 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs2());
var import_window_metadata2 = __toESM(require_cjs3());

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress2(publicKey5) {
  const address = keccak256(`0x${publicKey5.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey2({ hash, signature: signature4 }) {
  const hashHex = isHex(hash) ? hash : toHex(hash);
  const { secp256k1: secp256k16 } = await import("./secp256k1-EZEHYHEM.js");
  const signature_ = (() => {
    if (typeof signature4 === "object" && "r" in signature4 && "s" in signature4) {
      const { r: r3, s: s3, v: v6, yParity } = signature4;
      const yParityOrV2 = Number(yParity ?? v6);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k16.Signature(hexToBigInt(r3), hexToBigInt(s3)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature4) ? signature4 : toHex(signature4);
    if (size2(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber2(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k16.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey5 = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey5}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress2({ hash, signature: signature4 }) {
  return publicKeyToAddress2(await recoverPublicKey2({ hash, signature: signature4 }));
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction2(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType2[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction2 = defineFormatter2("transaction", formatTransaction2);
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock2(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction2(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock2 = defineFormatter2("block", formatBlock2);

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount2(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex2(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber2(count);
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob2 * blobsPerTransaction2;

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/formatters/log.js
function formatLog2(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace2 = new LruMap2(128);

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses2 = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt2(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog2(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses2[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType2[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt2 = defineFormatter2("transactionReceipt", formatTransactionReceipt2);

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier2 = numberToHex2(0, {
  size: 32
});

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache2 = new LruMap2(8192);

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore2() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache2 = createIdStore2();

// node_modules/@dynamic-labs/wallet-connect/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager2(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap2(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc2() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount2(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager2 = createNonceManager2({
  source: jsonRpc2()
});

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/Hash.js
function keccak2564(value, options = {}) {
  const { as: as16 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes2 = keccak_256(from2(value));
  if (as16 === "Bytes")
    return bytes2;
  return fromBytes2(bytes2);
}

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/internal/lru.js
var LruMap4 = class extends Map {
  constructor(size9) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size9;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/Caches.js
var caches2 = {
  checksum: new LruMap4(8192)
};
var checksum3 = caches2.checksum;

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/Address.js
var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
function assert5(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex2.test(value))
    throw new InvalidAddressError4({
      address: value,
      cause: new InvalidInputError2()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum4(value) !== value)
      throw new InvalidAddressError4({
        address: value,
        cause: new InvalidChecksumError2()
      });
  }
}
function checksum4(address) {
  if (checksum3.has(address))
    return checksum3.get(address);
  assert5(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2564(fromString3(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hash[i4 >> 1] >> 4 >= 8 && characters[i4]) {
      characters[i4] = characters[i4].toUpperCase();
    }
    if ((hash[i4 >> 1] & 15) >= 8 && characters[i4 + 1]) {
      characters[i4 + 1] = characters[i4 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum3.set(address, result);
  return result;
}
var InvalidAddressError4 = class extends BaseError2 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError2 = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError2 = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/Solidity.js
var arrayRegex4 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex4 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex4 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt83 = 2n ** (8n - 1n) - 1n;
var maxInt163 = 2n ** (16n - 1n) - 1n;
var maxInt243 = 2n ** (24n - 1n) - 1n;
var maxInt323 = 2n ** (32n - 1n) - 1n;
var maxInt403 = 2n ** (40n - 1n) - 1n;
var maxInt483 = 2n ** (48n - 1n) - 1n;
var maxInt563 = 2n ** (56n - 1n) - 1n;
var maxInt643 = 2n ** (64n - 1n) - 1n;
var maxInt723 = 2n ** (72n - 1n) - 1n;
var maxInt803 = 2n ** (80n - 1n) - 1n;
var maxInt883 = 2n ** (88n - 1n) - 1n;
var maxInt963 = 2n ** (96n - 1n) - 1n;
var maxInt1043 = 2n ** (104n - 1n) - 1n;
var maxInt1123 = 2n ** (112n - 1n) - 1n;
var maxInt1203 = 2n ** (120n - 1n) - 1n;
var maxInt1283 = 2n ** (128n - 1n) - 1n;
var maxInt1363 = 2n ** (136n - 1n) - 1n;
var maxInt1443 = 2n ** (144n - 1n) - 1n;
var maxInt1523 = 2n ** (152n - 1n) - 1n;
var maxInt1603 = 2n ** (160n - 1n) - 1n;
var maxInt1683 = 2n ** (168n - 1n) - 1n;
var maxInt1763 = 2n ** (176n - 1n) - 1n;
var maxInt1843 = 2n ** (184n - 1n) - 1n;
var maxInt1923 = 2n ** (192n - 1n) - 1n;
var maxInt2003 = 2n ** (200n - 1n) - 1n;
var maxInt2083 = 2n ** (208n - 1n) - 1n;
var maxInt2163 = 2n ** (216n - 1n) - 1n;
var maxInt2243 = 2n ** (224n - 1n) - 1n;
var maxInt2323 = 2n ** (232n - 1n) - 1n;
var maxInt2403 = 2n ** (240n - 1n) - 1n;
var maxInt2483 = 2n ** (248n - 1n) - 1n;
var maxInt2563 = 2n ** (256n - 1n) - 1n;
var minInt83 = -(2n ** (8n - 1n));
var minInt163 = -(2n ** (16n - 1n));
var minInt243 = -(2n ** (24n - 1n));
var minInt323 = -(2n ** (32n - 1n));
var minInt403 = -(2n ** (40n - 1n));
var minInt483 = -(2n ** (48n - 1n));
var minInt563 = -(2n ** (56n - 1n));
var minInt643 = -(2n ** (64n - 1n));
var minInt723 = -(2n ** (72n - 1n));
var minInt803 = -(2n ** (80n - 1n));
var minInt883 = -(2n ** (88n - 1n));
var minInt963 = -(2n ** (96n - 1n));
var minInt1043 = -(2n ** (104n - 1n));
var minInt1123 = -(2n ** (112n - 1n));
var minInt1203 = -(2n ** (120n - 1n));
var minInt1283 = -(2n ** (128n - 1n));
var minInt1363 = -(2n ** (136n - 1n));
var minInt1443 = -(2n ** (144n - 1n));
var minInt1523 = -(2n ** (152n - 1n));
var minInt1603 = -(2n ** (160n - 1n));
var minInt1683 = -(2n ** (168n - 1n));
var minInt1763 = -(2n ** (176n - 1n));
var minInt1843 = -(2n ** (184n - 1n));
var minInt1923 = -(2n ** (192n - 1n));
var minInt2003 = -(2n ** (200n - 1n));
var minInt2083 = -(2n ** (208n - 1n));
var minInt2163 = -(2n ** (216n - 1n));
var minInt2243 = -(2n ** (224n - 1n));
var minInt2323 = -(2n ** (232n - 1n));
var minInt2403 = -(2n ** (240n - 1n));
var minInt2483 = -(2n ** (248n - 1n));
var minInt2563 = -(2n ** (256n - 1n));
var maxUint83 = 2n ** 8n - 1n;
var maxUint163 = 2n ** 16n - 1n;
var maxUint243 = 2n ** 24n - 1n;
var maxUint323 = 2n ** 32n - 1n;
var maxUint403 = 2n ** 40n - 1n;
var maxUint483 = 2n ** 48n - 1n;
var maxUint563 = 2n ** 56n - 1n;
var maxUint643 = 2n ** 64n - 1n;
var maxUint723 = 2n ** 72n - 1n;
var maxUint803 = 2n ** 80n - 1n;
var maxUint883 = 2n ** 88n - 1n;
var maxUint963 = 2n ** 96n - 1n;
var maxUint1043 = 2n ** 104n - 1n;
var maxUint1123 = 2n ** 112n - 1n;
var maxUint1203 = 2n ** 120n - 1n;
var maxUint1283 = 2n ** 128n - 1n;
var maxUint1363 = 2n ** 136n - 1n;
var maxUint1443 = 2n ** 144n - 1n;
var maxUint1523 = 2n ** 152n - 1n;
var maxUint1603 = 2n ** 160n - 1n;
var maxUint1683 = 2n ** 168n - 1n;
var maxUint1763 = 2n ** 176n - 1n;
var maxUint1843 = 2n ** 184n - 1n;
var maxUint1923 = 2n ** 192n - 1n;
var maxUint2003 = 2n ** 200n - 1n;
var maxUint2083 = 2n ** 208n - 1n;
var maxUint2163 = 2n ** 216n - 1n;
var maxUint2243 = 2n ** 224n - 1n;
var maxUint2323 = 2n ** 232n - 1n;
var maxUint2403 = 2n ** 240n - 1n;
var maxUint2483 = 2n ** 248n - 1n;
var maxUint2564 = 2n ** 256n - 1n;

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor2 = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError2({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError4({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset5) {
    if (offset5 < 0)
      throw new NegativeOffsetError2({ offset: offset5 });
    const position = this.position - offset5;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset5) {
    if (offset5 < 0)
      throw new NegativeOffsetError2({ offset: offset5 });
    const position = this.position + offset5;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length2, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length2 - 1);
    return this.bytes.subarray(position, position + length2);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length2, size9) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length2);
    this.position += size9 ?? length2;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError2 = class extends BaseError2 {
  constructor({ offset: offset5 }) {
    super(`Offset \`${offset5}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError4 = class extends BaseError2 {
  constructor({ length: length2, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length2}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError2 = class extends BaseError2 {
  constructor({ count, limit: limit2 }) {
    super(`Recursive read limit of \`${limit2}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@dynamic-labs/wallet-connect/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked4(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError2({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i4 = 0; i4 < types.length; i4++) {
    const type3 = types[i4];
    const value = values[i4];
    data.push(encodePacked4.encode(type3, value));
  }
  return concat2(...data);
}
(function(encodePacked5) {
  function encode16(type3, value, isArray4 = false) {
    if (type3 === "address") {
      const address = value;
      assert5(address);
      return padLeft2(address.toLowerCase(), isArray4 ? 32 : 0);
    }
    if (type3 === "string")
      return fromString4(value);
    if (type3 === "bytes")
      return value;
    if (type3 === "bool")
      return padLeft2(fromBoolean2(value), isArray4 ? 32 : 1);
    const intMatch = type3.match(integerRegex4);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size9 = Number.parseInt(bits) / 8;
      return fromNumber2(value, {
        size: isArray4 ? 32 : size9,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type3.match(bytesRegex4);
    if (bytesMatch) {
      const [_type, size9] = bytesMatch;
      if (Number.parseInt(size9) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError4({
          expectedSize: Number.parseInt(size9),
          value
        });
      return padRight2(value, isArray4 ? 32 : 0);
    }
    const arrayMatch = type3.match(arrayRegex4);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i4 = 0; i4 < value.length; i4++) {
        data.push(encode16(childType, value[i4], true));
      }
      if (data.length === 0)
        return "0x";
      return concat2(...data);
    }
    throw new InvalidTypeError2(type3);
  }
  encodePacked5.encode = encode16;
})(encodePacked4 || (encodePacked4 = {}));
var BytesSizeMismatchError4 = class extends BaseError2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError2 = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError2 = class extends BaseError2 {
  constructor(type3) {
    super(`Type \`${type3}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/bs58/src/esm/index.js
var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default3 = esm_default(ALPHABET2);

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs2 = __toESM(require_blakejs());
var xe2 = ":";
function Fe(t) {
  const [e2, n5] = t.split(xe2);
  return { namespace: e2, reference: n5 };
}
function ve2(t, e2) {
  return t.includes(":") ? [t] : e2.chains || [];
}
var $s = Object.defineProperty;
var Cs = Object.defineProperties;
var Ls = Object.getOwnPropertyDescriptors;
var Jn2 = Object.getOwnPropertySymbols;
var js = Object.prototype.hasOwnProperty;
var ks = Object.prototype.propertyIsEnumerable;
var Ze2 = (t, e2, n5) => e2 in t ? $s(t, e2, { enumerable: true, configurable: true, writable: true, value: n5 }) : t[e2] = n5;
var Qn2 = (t, e2) => {
  for (var n5 in e2 || (e2 = {})) js.call(e2, n5) && Ze2(t, n5, e2[n5]);
  if (Jn2) for (var n5 of Jn2(e2)) ks.call(e2, n5) && Ze2(t, n5, e2[n5]);
  return t;
};
var Ps = (t, e2) => Cs(t, Ls(e2));
var tr2 = (t, e2, n5) => Ze2(t, typeof e2 != "symbol" ? e2 + "" : e2, n5);
var er2 = "ReactNative";
var J3 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var rr2 = "js";
function Ye2() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Bt2() {
  return !(0, import_window_getters2.getDocument)() && !!(0, import_window_getters2.getNavigator)() && navigator.product === er2;
}
function Ms() {
  return Bt2() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Vs() {
  return Bt2() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function zt2() {
  return !Ye2() && !!(0, import_window_getters2.getNavigator)() && !!(0, import_window_getters2.getDocument)();
}
function Pt2() {
  return Bt2() ? J3.reactNative : Ye2() ? J3.node : zt2() ? J3.browser : J3.unknown;
}
function qs() {
  var t;
  try {
    return Bt2() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function or3(t, e2) {
  const n5 = new URLSearchParams(t);
  for (const r3 of Object.keys(e2).sort()) if (e2.hasOwnProperty(r3)) {
    const o4 = e2[r3];
    o4 !== void 0 && n5.set(r3, o4);
  }
  return n5.toString();
}
function Ks(t) {
  var e2, n5;
  const r3 = sr2();
  try {
    return t != null && t.url && r3.url && new URL(t.url).host !== new URL(r3.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r3.url}. This is probably unintended and can lead to issues.`), t.url = r3.url), (e2 = t == null ? void 0 : t.icons) != null && e2.length && t.icons.length > 0 && (t.icons = t.icons.filter((o4) => o4 !== "")), Ps(Qn2(Qn2({}, r3), t), { url: (t == null ? void 0 : t.url) || r3.url, name: (t == null ? void 0 : t.name) || r3.name, description: (t == null ? void 0 : t.description) || r3.description, icons: (n5 = t == null ? void 0 : t.icons) != null && n5.length && t.icons.length > 0 ? t.icons : r3.icons });
  } catch (o4) {
    return console.warn("Error populating app metadata", o4), t || r3;
  }
}
function sr2() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ir2() {
  if (Pt2() === J3.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n5, Version: r3 } = global.Platform;
    return [n5, r3].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e2 = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e2, t.name, t.version].join("-") : [e2, t.version].join("-");
}
function fr2() {
  var t;
  const e2 = Pt2();
  return e2 === J3.browser ? [e2, ((t = (0, import_window_getters2.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e2;
}
function cr2(t, e2, n5) {
  const r3 = ir2(), o4 = fr2();
  return [[t, e2].join("-"), [rr2, n5].join("-"), r3, o4].join("/");
}
function zs({ protocol: t, version: e2, relayUrl: n5, sdkVersion: r3, auth: o4, projectId: s3, useOnCloseEvent: i4, bundleId: f8, packageName: a3 }) {
  const l6 = n5.split("?"), c6 = cr2(t, e2, r3), u2 = { auth: o4, ua: c6, projectId: s3, useOnCloseEvent: i4 || void 0, packageName: a3 || void 0, bundleId: f8 || void 0 }, h5 = or3(l6[1] || "", u2);
  return l6[0] + "?" + h5;
}
function It2(t, e2) {
  return t.filter((n5) => e2.includes(n5)).length === t.length;
}
function Ys(t) {
  return Object.fromEntries(t.entries());
}
function Xs(t) {
  return new Map(Object.entries(t));
}
function ei(t = import_time4.FIVE_MINUTES, e2) {
  const n5 = (0, import_time4.toMiliseconds)(t || import_time4.FIVE_MINUTES);
  let r3, o4, s3, i4;
  return { resolve: (f8) => {
    s3 && r3 && (clearTimeout(s3), r3(f8), i4 = Promise.resolve(f8));
  }, reject: (f8) => {
    s3 && o4 && (clearTimeout(s3), o4(f8));
  }, done: () => new Promise((f8, a3) => {
    if (i4) return f8(i4);
    s3 = setTimeout(() => {
      const l6 = new Error(e2);
      i4 = Promise.reject(l6), a3(l6);
    }, n5), r3 = f8, o4 = a3;
  }) };
}
function ni(t, e2, n5) {
  return new Promise(async (r3, o4) => {
    const s3 = setTimeout(() => o4(new Error(n5)), e2);
    try {
      const i4 = await t;
      r3(i4);
    } catch (i4) {
      o4(i4);
    }
    clearTimeout(s3);
  });
}
function Xe2(t, e2) {
  if (typeof e2 == "string" && e2.startsWith(`${t}:`)) return e2;
  if (t.toLowerCase() === "topic") {
    if (typeof e2 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e2}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e2 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e2}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function ri(t) {
  return Xe2("topic", t);
}
function oi(t) {
  return Xe2("id", t);
}
function si(t) {
  const [e2, n5] = t.split(":"), r3 = { id: void 0, topic: void 0 };
  if (e2 === "topic" && typeof n5 == "string") r3.topic = n5;
  else if (e2 === "id" && Number.isInteger(Number(n5))) r3.id = Number(n5);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e2}:${n5}`);
  return r3;
}
function ii(t, e2) {
  return (0, import_time4.fromMiliseconds)((e2 || Date.now()) + (0, import_time4.toMiliseconds)(t));
}
function fi(t) {
  return Date.now() >= (0, import_time4.toMiliseconds)(t);
}
function ci(t, e2) {
  return `${t}${e2 ? `:${e2}` : ""}`;
}
function ct2(t = [], e2 = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e2])];
}
async function ai({ id: t, topic: e2, wcDeepLink: n5 }) {
  var r3;
  try {
    if (!n5) return;
    const o4 = typeof n5 == "string" ? JSON.parse(n5) : n5, s3 = o4 == null ? void 0 : o4.href;
    if (typeof s3 != "string") return;
    const i4 = dr2(s3, t, e2), f8 = Pt2();
    if (f8 === J3.browser) {
      if (!((r3 = (0, import_window_getters2.getDocument)()) != null && r3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      hr2(i4);
    } else f8 === J3.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i4);
  } catch (o4) {
    console.error(o4);
  }
}
function dr2(t, e2, n5) {
  const r3 = `requestId=${e2}&sessionTopic=${n5}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o4 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s3 = t.includes("?") ? "&startapp=" : "?startapp=";
    o4 = `${o4}${s3}${br2(r3, true)}`;
  } else o4 = `${o4}/wc?${r3}`;
  return o4;
}
function hr2(t) {
  let e2 = "_self";
  gr2() ? e2 = "_top" : (pr2() || t.startsWith("https://") || t.startsWith("http://")) && (e2 = "_blank"), window.open(t, e2, "noreferrer noopener");
}
async function ui(t, e2) {
  let n5 = "";
  try {
    if (zt2() && (n5 = localStorage.getItem(e2), n5)) return n5;
    n5 = await t.getItem(e2);
  } catch (r3) {
    console.error(r3);
  }
  return n5;
}
function li(t, e2) {
  if (!t.includes(e2)) return null;
  const n5 = t.split(/([&,?,=])/), r3 = n5.indexOf(e2);
  return n5[r3 + 2];
}
function di() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e2 = Math.random() * 16 | 0;
    return (t === "x" ? e2 : e2 & 3 | 8).toString(16);
  });
}
function hi() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function pr2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function gr2() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function br2(t, e2 = false) {
  const n5 = Buffer.from(t).toString("base64");
  return e2 ? n5.replace(/[=]/g, "") : n5;
}
function Qe2(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function pi(t) {
  return new Promise((e2) => setTimeout(e2, t));
}
var gi = class {
  constructor({ limit: e2 }) {
    tr2(this, "limit"), tr2(this, "set"), this.limit = e2, this.set = /* @__PURE__ */ new Set();
  }
  add(e2) {
    if (!this.set.has(e2)) {
      if (this.set.size >= this.limit) {
        const n5 = this.set.values().next().value;
        n5 && this.set.delete(n5);
      }
      this.set.add(e2);
    }
  }
  has(e2) {
    return this.set.has(e2);
  }
};
var Be3 = BigInt(2 ** 32 - 1);
var yr3 = BigInt(32);
function mr3(t, e2 = false) {
  return e2 ? { h: Number(t & Be3), l: Number(t >> yr3 & Be3) } : { h: Number(t >> yr3 & Be3) | 0, l: Number(t & Be3) | 0 };
}
function wr3(t, e2 = false) {
  const n5 = t.length;
  let r3 = new Uint32Array(n5), o4 = new Uint32Array(n5);
  for (let s3 = 0; s3 < n5; s3++) {
    const { h: i4, l: f8 } = mr3(t[s3], e2);
    [r3[s3], o4[s3]] = [i4, f8];
  }
  return [r3, o4];
}
var xr3 = (t, e2, n5) => t >>> n5;
var vr3 = (t, e2, n5) => t << 32 - n5 | e2 >>> n5;
var At2 = (t, e2, n5) => t >>> n5 | e2 << 32 - n5;
var St3 = (t, e2, n5) => t << 32 - n5 | e2 >>> n5;
var se2 = (t, e2, n5) => t << 64 - n5 | e2 >>> n5 - 32;
var ie2 = (t, e2, n5) => t >>> n5 - 32 | e2 << 64 - n5;
var bi2 = (t, e2) => e2;
var yi2 = (t, e2) => t;
var mi2 = (t, e2, n5) => t << n5 | e2 >>> 32 - n5;
var wi2 = (t, e2, n5) => e2 << n5 | t >>> 32 - n5;
var xi2 = (t, e2, n5) => e2 << n5 - 32 | t >>> 64 - n5;
var vi2 = (t, e2, n5) => t << n5 - 32 | e2 >>> 64 - n5;
function dt3(t, e2, n5, r3) {
  const o4 = (e2 >>> 0) + (r3 >>> 0);
  return { h: t + n5 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var tn2 = (t, e2, n5) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0);
var en3 = (t, e2, n5, r3) => e2 + n5 + r3 + (t / 2 ** 32 | 0) | 0;
var Ei2 = (t, e2, n5, r3) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0) + (r3 >>> 0);
var Bi2 = (t, e2, n5, r3, o4) => e2 + n5 + r3 + o4 + (t / 2 ** 32 | 0) | 0;
var Ii2 = (t, e2, n5, r3, o4) => (t >>> 0) + (e2 >>> 0) + (n5 >>> 0) + (r3 >>> 0) + (o4 >>> 0);
var Ai2 = (t, e2, n5, r3, o4, s3) => e2 + n5 + r3 + o4 + s3 + (t / 2 ** 32 | 0) | 0;
var Gt3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn3(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt2(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function at2(t, ...e2) {
  if (!nn3(t)) throw new Error("Uint8Array expected");
  if (e2.length > 0 && !e2.includes(t.length)) throw new Error("Uint8Array expected of length " + e2 + ", got length=" + t.length);
}
function rn3(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt2(t.outputLen), mt2(t.blockLen);
}
function Nt3(t, e2 = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e2 && t.finished) throw new Error("Hash#digest() has already been called");
}
function on4(t, e2) {
  at2(t);
  const n5 = e2.outputLen;
  if (t.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function fe3(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function ut3(...t) {
  for (let e2 = 0; e2 < t.length; e2++) t[e2].fill(0);
}
function sn3(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function gt3(t, e2) {
  return t << 32 - e2 | t >>> e2;
}
var Er3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br3(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt3 = Er3 ? (t) => t : (t) => Br3(t);
function Si2(t) {
  for (let e2 = 0; e2 < t.length; e2++) t[e2] = Br3(t[e2]);
  return t;
}
var Ot3 = Er3 ? (t) => t : Si2;
var Ir3 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni2 = Array.from({ length: 256 }, (t, e2) => e2.toString(16).padStart(2, "0"));
function ce2(t) {
  if (at2(t), Ir3) return t.toHex();
  let e2 = "";
  for (let n5 = 0; n5 < t.length; n5++) e2 += Ni2[t[n5]];
  return e2;
}
var xt3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar3(t) {
  if (t >= xt3._0 && t <= xt3._9) return t - xt3._0;
  if (t >= xt3.A && t <= xt3.F) return t - (xt3.A - 10);
  if (t >= xt3.a && t <= xt3.f) return t - (xt3.a - 10);
}
function fn2(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (Ir3) return Uint8Array.fromHex(t);
  const e2 = t.length, n5 = e2 / 2;
  if (e2 % 2) throw new Error("hex string expected, got unpadded hex of length " + e2);
  const r3 = new Uint8Array(n5);
  for (let o4 = 0, s3 = 0; o4 < n5; o4++, s3 += 2) {
    const i4 = Ar3(t.charCodeAt(s3)), f8 = Ar3(t.charCodeAt(s3 + 1));
    if (i4 === void 0 || f8 === void 0) {
      const a3 = t[s3] + t[s3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a3 + '" at index ' + s3);
    }
    r3[o4] = i4 * 16 + f8;
  }
  return r3;
}
function Oi2(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ht3(t) {
  return typeof t == "string" && (t = Oi2(t)), at2(t), t;
}
function Ht3(...t) {
  let e2 = 0;
  for (let r3 = 0; r3 < t.length; r3++) {
    const o4 = t[r3];
    at2(o4), e2 += o4.length;
  }
  const n5 = new Uint8Array(e2);
  for (let r3 = 0, o4 = 0; r3 < t.length; r3++) {
    const s3 = t[r3];
    n5.set(s3, o4), o4 += s3.length;
  }
  return n5;
}
var Ie3 = class {
};
function ae2(t) {
  const e2 = (r3) => t().update(ht3(r3)).digest(), n5 = t();
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = () => t(), e2;
}
function Ui2(t) {
  const e2 = (r3, o4) => t(o4).update(ht3(r3)).digest(), n5 = t({});
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = (r3) => t(r3), e2;
}
function Zt3(t = 32) {
  if (Gt3 && typeof Gt3.getRandomValues == "function") return Gt3.getRandomValues(new Uint8Array(t));
  if (Gt3 && typeof Gt3.randomBytes == "function") return Uint8Array.from(Gt3.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i2 = BigInt(0);
var ue2 = BigInt(1);
var Ti2 = BigInt(2);
var Ri2 = BigInt(7);
var $i2 = BigInt(256);
var Ci2 = BigInt(113);
var Sr3 = [];
var Nr3 = [];
var Or3 = [];
for (let t = 0, e2 = ue2, n5 = 1, r3 = 0; t < 24; t++) {
  [n5, r3] = [r3, (2 * n5 + 3 * r3) % 5], Sr3.push(2 * (5 * r3 + n5)), Nr3.push((t + 1) * (t + 2) / 2 % 64);
  let o4 = _i2;
  for (let s3 = 0; s3 < 7; s3++) e2 = (e2 << ue2 ^ (e2 >> Ri2) * Ci2) % $i2, e2 & Ti2 && (o4 ^= ue2 << (ue2 << BigInt(s3)) - ue2);
  Or3.push(o4);
}
var Ur3 = wr3(Or3, true);
var Li2 = Ur3[0];
var ji2 = Ur3[1];
var _r3 = (t, e2, n5) => n5 > 32 ? xi2(t, e2, n5) : mi2(t, e2, n5);
var Tr3 = (t, e2, n5) => n5 > 32 ? vi2(t, e2, n5) : wi2(t, e2, n5);
function ki2(t, e2 = 24) {
  const n5 = new Uint32Array(10);
  for (let r3 = 24 - e2; r3 < 24; r3++) {
    for (let i4 = 0; i4 < 10; i4++) n5[i4] = t[i4] ^ t[i4 + 10] ^ t[i4 + 20] ^ t[i4 + 30] ^ t[i4 + 40];
    for (let i4 = 0; i4 < 10; i4 += 2) {
      const f8 = (i4 + 8) % 10, a3 = (i4 + 2) % 10, l6 = n5[a3], c6 = n5[a3 + 1], u2 = _r3(l6, c6, 1) ^ n5[f8], h5 = Tr3(l6, c6, 1) ^ n5[f8 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) t[i4 + g3] ^= u2, t[i4 + g3 + 1] ^= h5;
    }
    let o4 = t[2], s3 = t[3];
    for (let i4 = 0; i4 < 24; i4++) {
      const f8 = Nr3[i4], a3 = _r3(o4, s3, f8), l6 = Tr3(o4, s3, f8), c6 = Sr3[i4];
      o4 = t[c6], s3 = t[c6 + 1], t[c6] = a3, t[c6 + 1] = l6;
    }
    for (let i4 = 0; i4 < 50; i4 += 10) {
      for (let f8 = 0; f8 < 10; f8++) n5[f8] = t[i4 + f8];
      for (let f8 = 0; f8 < 10; f8++) t[i4 + f8] ^= ~n5[(f8 + 2) % 10] & n5[(f8 + 4) % 10];
    }
    t[0] ^= Li2[r3], t[1] ^= ji2[r3];
  }
  ut3(n5);
}
var qn3 = class _qn extends Ie3 {
  constructor(e2, n5, r3, o4 = false, s3 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e2, this.suffix = n5, this.outputLen = r3, this.enableXOF = o4, this.rounds = s3, mt2(r3), !(0 < e2 && e2 < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe3(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot3(this.state32), ki2(this.state32, this.rounds), Ot3(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e2) {
    Nt3(this), e2 = ht3(e2), at2(e2);
    const { blockLen: n5, state: r3 } = this, o4 = e2.length;
    for (let s3 = 0; s3 < o4; ) {
      const i4 = Math.min(n5 - this.pos, o4 - s3);
      for (let f8 = 0; f8 < i4; f8++) r3[this.pos++] ^= e2[s3++];
      this.pos === n5 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e2, suffix: n5, pos: r3, blockLen: o4 } = this;
    e2[r3] ^= n5, (n5 & 128) !== 0 && r3 === o4 - 1 && this.keccak(), e2[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(e2) {
    Nt3(this, false), at2(e2), this.finish();
    const n5 = this.state, { blockLen: r3 } = this;
    for (let o4 = 0, s3 = e2.length; o4 < s3; ) {
      this.posOut >= r3 && this.keccak();
      const i4 = Math.min(r3 - this.posOut, s3 - o4);
      e2.set(n5.subarray(this.posOut, this.posOut + i4), o4), this.posOut += i4, o4 += i4;
    }
    return e2;
  }
  xofInto(e2) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e2);
  }
  xof(e2) {
    return mt2(e2), this.xofInto(new Uint8Array(e2));
  }
  digestInto(e2) {
    if (on4(e2, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e2), this.destroy(), e2;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut3(this.state);
  }
  _cloneInto(e2) {
    const { blockLen: n5, suffix: r3, outputLen: o4, rounds: s3, enableXOF: i4 } = this;
    return e2 || (e2 = new _qn(n5, r3, o4, i4, s3)), e2.state32.set(this.state32), e2.pos = this.pos, e2.posOut = this.posOut, e2.finished = this.finished, e2.rounds = s3, e2.suffix = r3, e2.outputLen = o4, e2.enableXOF = i4, e2.destroyed = this.destroyed, e2;
  }
};
var Pi2 = (t, e2, n5) => ae2(() => new qn3(e2, t, n5));
var Hi2 = Pi2(1, 136, 256 / 8);
function Di2(t, e2, n5, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e2, n5, r3);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i4 = Number(n5 >> o4 & s3), f8 = Number(n5 & s3), a3 = r3 ? 4 : 0, l6 = r3 ? 0 : 4;
  t.setUint32(e2 + a3, i4, r3), t.setUint32(e2 + l6, f8, r3);
}
function Mi2(t, e2, n5) {
  return t & e2 ^ ~t & n5;
}
function Vi2(t, e2, n5) {
  return t & e2 ^ t & n5 ^ e2 & n5;
}
var Rr3 = class extends Ie3 {
  constructor(e2, n5, r3, o4) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e2, this.outputLen = n5, this.padOffset = r3, this.isLE = o4, this.buffer = new Uint8Array(e2), this.view = sn3(this.buffer);
  }
  update(e2) {
    Nt3(this), e2 = ht3(e2), at2(e2);
    const { view: n5, buffer: r3, blockLen: o4 } = this, s3 = e2.length;
    for (let i4 = 0; i4 < s3; ) {
      const f8 = Math.min(o4 - this.pos, s3 - i4);
      if (f8 === o4) {
        const a3 = sn3(e2);
        for (; o4 <= s3 - i4; i4 += o4) this.process(a3, i4);
        continue;
      }
      r3.set(e2.subarray(i4, i4 + f8), this.pos), this.pos += f8, i4 += f8, this.pos === o4 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    Nt3(this), on4(e2, this), this.finished = true;
    const { buffer: n5, view: r3, blockLen: o4, isLE: s3 } = this;
    let { pos: i4 } = this;
    n5[i4++] = 128, ut3(this.buffer.subarray(i4)), this.padOffset > o4 - i4 && (this.process(r3, 0), i4 = 0);
    for (let u2 = i4; u2 < o4; u2++) n5[u2] = 0;
    Di2(r3, o4 - 8, BigInt(this.length * 8), s3), this.process(r3, 0);
    const f8 = sn3(e2), a3 = this.outputLen;
    if (a3 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l6 = a3 / 4, c6 = this.get();
    if (l6 > c6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u2 = 0; u2 < l6; u2++) f8.setUint32(4 * u2, c6[u2], s3);
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: n5, buffer: r3, length: o4, finished: s3, destroyed: i4, pos: f8 } = this;
    return e2.destroyed = i4, e2.finished = s3, e2.length = o4, e2.pos = f8, o4 % n5 && e2.buffer.set(r3), e2;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut3 = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W3 = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y2 = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi2 = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t3 = new Uint32Array(64);
var Ki2 = class extends Rr3 {
  constructor(e2 = 32) {
    super(64, e2, 8, false), this.A = Ut3[0] | 0, this.B = Ut3[1] | 0, this.C = Ut3[2] | 0, this.D = Ut3[3] | 0, this.E = Ut3[4] | 0, this.F = Ut3[5] | 0, this.G = Ut3[6] | 0, this.H = Ut3[7] | 0;
  }
  get() {
    const { A: e2, B: n5, C: r3, D: o4, E: s3, F: i4, G: f8, H: a3 } = this;
    return [e2, n5, r3, o4, s3, i4, f8, a3];
  }
  set(e2, n5, r3, o4, s3, i4, f8, a3) {
    this.A = e2 | 0, this.B = n5 | 0, this.C = r3 | 0, this.D = o4 | 0, this.E = s3 | 0, this.F = i4 | 0, this.G = f8 | 0, this.H = a3 | 0;
  }
  process(e2, n5) {
    for (let u2 = 0; u2 < 16; u2++, n5 += 4) _t3[u2] = e2.getUint32(n5, false);
    for (let u2 = 16; u2 < 64; u2++) {
      const h5 = _t3[u2 - 15], g3 = _t3[u2 - 2], w4 = gt3(h5, 7) ^ gt3(h5, 18) ^ h5 >>> 3, y5 = gt3(g3, 17) ^ gt3(g3, 19) ^ g3 >>> 10;
      _t3[u2] = y5 + _t3[u2 - 7] + w4 + _t3[u2 - 16] | 0;
    }
    let { A: r3, B: o4, C: s3, D: i4, E: f8, F: a3, G: l6, H: c6 } = this;
    for (let u2 = 0; u2 < 64; u2++) {
      const h5 = gt3(f8, 6) ^ gt3(f8, 11) ^ gt3(f8, 25), g3 = c6 + h5 + Mi2(f8, a3, l6) + qi2[u2] + _t3[u2] | 0, y5 = (gt3(r3, 2) ^ gt3(r3, 13) ^ gt3(r3, 22)) + Vi2(r3, o4, s3) | 0;
      c6 = l6, l6 = a3, a3 = f8, f8 = i4 + g3 | 0, i4 = s3, s3 = o4, o4 = r3, r3 = g3 + y5 | 0;
    }
    r3 = r3 + this.A | 0, o4 = o4 + this.B | 0, s3 = s3 + this.C | 0, i4 = i4 + this.D | 0, f8 = f8 + this.E | 0, a3 = a3 + this.F | 0, l6 = l6 + this.G | 0, c6 = c6 + this.H | 0, this.set(r3, o4, s3, i4, f8, a3, l6, c6);
  }
  roundClean() {
    ut3(_t3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut3(this.buffer);
  }
};
var $r3 = wr3(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var Fi2 = $r3[0];
var zi2 = $r3[1];
var Tt3 = new Uint32Array(80);
var Rt3 = new Uint32Array(80);
var cn2 = class extends Rr3 {
  constructor(e2 = 64) {
    super(128, e2, 16, false), this.Ah = Y2[0] | 0, this.Al = Y2[1] | 0, this.Bh = Y2[2] | 0, this.Bl = Y2[3] | 0, this.Ch = Y2[4] | 0, this.Cl = Y2[5] | 0, this.Dh = Y2[6] | 0, this.Dl = Y2[7] | 0, this.Eh = Y2[8] | 0, this.El = Y2[9] | 0, this.Fh = Y2[10] | 0, this.Fl = Y2[11] | 0, this.Gh = Y2[12] | 0, this.Gl = Y2[13] | 0, this.Hh = Y2[14] | 0, this.Hl = Y2[15] | 0;
  }
  get() {
    const { Ah: e2, Al: n5, Bh: r3, Bl: o4, Ch: s3, Cl: i4, Dh: f8, Dl: a3, Eh: l6, El: c6, Fh: u2, Fl: h5, Gh: g3, Gl: w4, Hh: y5, Hl: x5 } = this;
    return [e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5];
  }
  set(e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5) {
    this.Ah = e2 | 0, this.Al = n5 | 0, this.Bh = r3 | 0, this.Bl = o4 | 0, this.Ch = s3 | 0, this.Cl = i4 | 0, this.Dh = f8 | 0, this.Dl = a3 | 0, this.Eh = l6 | 0, this.El = c6 | 0, this.Fh = u2 | 0, this.Fl = h5 | 0, this.Gh = g3 | 0, this.Gl = w4 | 0, this.Hh = y5 | 0, this.Hl = x5 | 0;
  }
  process(e2, n5) {
    for (let L3 = 0; L3 < 16; L3++, n5 += 4) Tt3[L3] = e2.getUint32(n5), Rt3[L3] = e2.getUint32(n5 += 4);
    for (let L3 = 16; L3 < 80; L3++) {
      const V3 = Tt3[L3 - 15] | 0, _3 = Rt3[L3 - 15] | 0, k6 = At2(V3, _3, 1) ^ At2(V3, _3, 8) ^ xr3(V3, _3, 7), j3 = St3(V3, _3, 1) ^ St3(V3, _3, 8) ^ vr3(V3, _3, 7), $3 = Tt3[L3 - 2] | 0, d4 = Rt3[L3 - 2] | 0, m3 = At2($3, d4, 19) ^ se2($3, d4, 61) ^ xr3($3, d4, 6), p4 = St3($3, d4, 19) ^ ie2($3, d4, 61) ^ vr3($3, d4, 6), b4 = Ei2(j3, p4, Rt3[L3 - 7], Rt3[L3 - 16]), v6 = Bi2(b4, k6, m3, Tt3[L3 - 7], Tt3[L3 - 16]);
      Tt3[L3] = v6 | 0, Rt3[L3] = b4 | 0;
    }
    let { Ah: r3, Al: o4, Bh: s3, Bl: i4, Ch: f8, Cl: a3, Dh: l6, Dl: c6, Eh: u2, El: h5, Fh: g3, Fl: w4, Gh: y5, Gl: x5, Hh: R3, Hl: M4 } = this;
    for (let L3 = 0; L3 < 80; L3++) {
      const V3 = At2(u2, h5, 14) ^ At2(u2, h5, 18) ^ se2(u2, h5, 41), _3 = St3(u2, h5, 14) ^ St3(u2, h5, 18) ^ ie2(u2, h5, 41), k6 = u2 & g3 ^ ~u2 & y5, j3 = h5 & w4 ^ ~h5 & x5, $3 = Ii2(M4, _3, j3, zi2[L3], Rt3[L3]), d4 = Ai2($3, R3, V3, k6, Fi2[L3], Tt3[L3]), m3 = $3 | 0, p4 = At2(r3, o4, 28) ^ se2(r3, o4, 34) ^ se2(r3, o4, 39), b4 = St3(r3, o4, 28) ^ ie2(r3, o4, 34) ^ ie2(r3, o4, 39), v6 = r3 & s3 ^ r3 & f8 ^ s3 & f8, B3 = o4 & i4 ^ o4 & a3 ^ i4 & a3;
      R3 = y5 | 0, M4 = x5 | 0, y5 = g3 | 0, x5 = w4 | 0, g3 = u2 | 0, w4 = h5 | 0, { h: u2, l: h5 } = dt3(l6 | 0, c6 | 0, d4 | 0, m3 | 0), l6 = f8 | 0, c6 = a3 | 0, f8 = s3 | 0, a3 = i4 | 0, s3 = r3 | 0, i4 = o4 | 0;
      const E4 = tn2(m3, b4, B3);
      r3 = en3(E4, d4, p4, v6), o4 = E4 | 0;
    }
    ({ h: r3, l: o4 } = dt3(this.Ah | 0, this.Al | 0, r3 | 0, o4 | 0)), { h: s3, l: i4 } = dt3(this.Bh | 0, this.Bl | 0, s3 | 0, i4 | 0), { h: f8, l: a3 } = dt3(this.Ch | 0, this.Cl | 0, f8 | 0, a3 | 0), { h: l6, l: c6 } = dt3(this.Dh | 0, this.Dl | 0, l6 | 0, c6 | 0), { h: u2, l: h5 } = dt3(this.Eh | 0, this.El | 0, u2 | 0, h5 | 0), { h: g3, l: w4 } = dt3(this.Fh | 0, this.Fl | 0, g3 | 0, w4 | 0), { h: y5, l: x5 } = dt3(this.Gh | 0, this.Gl | 0, y5 | 0, x5 | 0), { h: R3, l: M4 } = dt3(this.Hh | 0, this.Hl | 0, R3 | 0, M4 | 0), this.set(r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5, R3, M4);
  }
  roundClean() {
    ut3(Tt3, Rt3);
  }
  destroy() {
    ut3(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi2 = class extends cn2 {
  constructor() {
    super(48), this.Ah = W3[0] | 0, this.Al = W3[1] | 0, this.Bh = W3[2] | 0, this.Bl = W3[3] | 0, this.Ch = W3[4] | 0, this.Cl = W3[5] | 0, this.Dh = W3[6] | 0, this.Dl = W3[7] | 0, this.Eh = W3[8] | 0, this.El = W3[9] | 0, this.Fh = W3[10] | 0, this.Fl = W3[11] | 0, this.Gh = W3[12] | 0, this.Gl = W3[13] | 0, this.Hh = W3[14] | 0, this.Hl = W3[15] | 0;
  }
};
var X2 = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi2 = class extends cn2 {
  constructor() {
    super(32), this.Ah = X2[0] | 0, this.Al = X2[1] | 0, this.Bh = X2[2] | 0, this.Bl = X2[3] | 0, this.Ch = X2[4] | 0, this.Cl = X2[5] | 0, this.Dh = X2[6] | 0, this.Dl = X2[7] | 0, this.Eh = X2[8] | 0, this.El = X2[9] | 0, this.Fh = X2[10] | 0, this.Fl = X2[11] | 0, this.Gh = X2[12] | 0, this.Gl = X2[13] | 0, this.Hh = X2[14] | 0, this.Hl = X2[15] | 0;
  }
};
var Ae3 = ae2(() => new Ki2());
var Wi2 = ae2(() => new cn2());
var Yi2 = ae2(() => new Gi2());
var Xi2 = ae2(() => new Zi2());
var Ji2 = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F2 = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N12 = new Uint32Array(32);
function $t3(t, e2, n5, r3, o4, s3) {
  const i4 = o4[s3], f8 = o4[s3 + 1];
  let a3 = N12[2 * t], l6 = N12[2 * t + 1], c6 = N12[2 * e2], u2 = N12[2 * e2 + 1], h5 = N12[2 * n5], g3 = N12[2 * n5 + 1], w4 = N12[2 * r3], y5 = N12[2 * r3 + 1], x5 = tn2(a3, c6, i4);
  l6 = en3(x5, l6, u2, f8), a3 = x5 | 0, { Dh: y5, Dl: w4 } = { Dh: y5 ^ l6, Dl: w4 ^ a3 }, { Dh: y5, Dl: w4 } = { Dh: bi2(y5, w4), Dl: yi2(y5) }, { h: g3, l: h5 } = dt3(g3, h5, y5, w4), { Bh: u2, Bl: c6 } = { Bh: u2 ^ g3, Bl: c6 ^ h5 }, { Bh: u2, Bl: c6 } = { Bh: At2(u2, c6, 24), Bl: St3(u2, c6, 24) }, N12[2 * t] = a3, N12[2 * t + 1] = l6, N12[2 * e2] = c6, N12[2 * e2 + 1] = u2, N12[2 * n5] = h5, N12[2 * n5 + 1] = g3, N12[2 * r3] = w4, N12[2 * r3 + 1] = y5;
}
function Ct2(t, e2, n5, r3, o4, s3) {
  const i4 = o4[s3], f8 = o4[s3 + 1];
  let a3 = N12[2 * t], l6 = N12[2 * t + 1], c6 = N12[2 * e2], u2 = N12[2 * e2 + 1], h5 = N12[2 * n5], g3 = N12[2 * n5 + 1], w4 = N12[2 * r3], y5 = N12[2 * r3 + 1], x5 = tn2(a3, c6, i4);
  l6 = en3(x5, l6, u2, f8), a3 = x5 | 0, { Dh: y5, Dl: w4 } = { Dh: y5 ^ l6, Dl: w4 ^ a3 }, { Dh: y5, Dl: w4 } = { Dh: At2(y5, w4, 16), Dl: St3(y5, w4, 16) }, { h: g3, l: h5 } = dt3(g3, h5, y5, w4), { Bh: u2, Bl: c6 } = { Bh: u2 ^ g3, Bl: c6 ^ h5 }, { Bh: u2, Bl: c6 } = { Bh: se2(u2, c6, 63), Bl: ie2(u2, c6, 63) }, N12[2 * t] = a3, N12[2 * t + 1] = l6, N12[2 * e2] = c6, N12[2 * e2 + 1] = u2, N12[2 * n5] = h5, N12[2 * n5 + 1] = g3, N12[2 * r3] = w4, N12[2 * r3 + 1] = y5;
}
function Qi2(t, e2 = {}, n5, r3, o4) {
  if (mt2(n5), t < 0 || t > n5) throw new Error("outputLen bigger than keyLen");
  const { key: s3, salt: i4, personalization: f8 } = e2;
  if (s3 !== void 0 && (s3.length < 1 || s3.length > n5)) throw new Error("key length must be undefined or 1.." + n5);
  if (i4 !== void 0 && i4.length !== r3) throw new Error("salt must be undefined or " + r3);
  if (f8 !== void 0 && f8.length !== o4) throw new Error("personalization must be undefined or " + o4);
}
var tf2 = class extends Ie3 {
  constructor(e2, n5) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt2(e2), mt2(n5), this.blockLen = e2, this.outputLen = n5, this.buffer = new Uint8Array(e2), this.buffer32 = fe3(this.buffer);
  }
  update(e2) {
    Nt3(this), e2 = ht3(e2), at2(e2);
    const { blockLen: n5, buffer: r3, buffer32: o4 } = this, s3 = e2.length, i4 = e2.byteOffset, f8 = e2.buffer;
    for (let a3 = 0; a3 < s3; ) {
      this.pos === n5 && (Ot3(o4), this.compress(o4, 0, false), Ot3(o4), this.pos = 0);
      const l6 = Math.min(n5 - this.pos, s3 - a3), c6 = i4 + a3;
      if (l6 === n5 && !(c6 % 4) && a3 + l6 < s3) {
        const u2 = new Uint32Array(f8, c6, Math.floor((s3 - a3) / 4));
        Ot3(u2);
        for (let h5 = 0; a3 + n5 < s3; h5 += o4.length, a3 += n5) this.length += n5, this.compress(u2, h5, false);
        Ot3(u2);
        continue;
      }
      r3.set(e2.subarray(a3, a3 + l6), this.pos), this.pos += l6, this.length += l6, a3 += l6;
    }
    return this;
  }
  digestInto(e2) {
    Nt3(this), on4(e2, this);
    const { pos: n5, buffer32: r3 } = this;
    this.finished = true, ut3(this.buffer.subarray(n5)), Ot3(r3), this.compress(r3, 0, true), Ot3(r3);
    const o4 = fe3(e2);
    this.get().forEach((s3, i4) => o4[i4] = wt3(s3));
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(e2) {
    const { buffer: n5, length: r3, finished: o4, destroyed: s3, outputLen: i4, pos: f8 } = this;
    return e2 || (e2 = new this.constructor({ dkLen: i4 })), e2.set(...this.get()), e2.buffer.set(n5), e2.destroyed = s3, e2.finished = o4, e2.length = r3, e2.pos = f8, e2.outputLen = i4, e2;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef2 = class extends tf2 {
  constructor(e2 = {}) {
    const n5 = e2.dkLen === void 0 ? 64 : e2.dkLen;
    super(128, n5), this.v0l = F2[0] | 0, this.v0h = F2[1] | 0, this.v1l = F2[2] | 0, this.v1h = F2[3] | 0, this.v2l = F2[4] | 0, this.v2h = F2[5] | 0, this.v3l = F2[6] | 0, this.v3h = F2[7] | 0, this.v4l = F2[8] | 0, this.v4h = F2[9] | 0, this.v5l = F2[10] | 0, this.v5h = F2[11] | 0, this.v6l = F2[12] | 0, this.v6h = F2[13] | 0, this.v7l = F2[14] | 0, this.v7h = F2[15] | 0, Qi2(n5, e2, 64, 16, 16);
    let { key: r3, personalization: o4, salt: s3 } = e2, i4 = 0;
    if (r3 !== void 0 && (r3 = ht3(r3), i4 = r3.length), this.v0l ^= this.outputLen | i4 << 8 | 65536 | 1 << 24, s3 !== void 0) {
      s3 = ht3(s3);
      const f8 = fe3(s3);
      this.v4l ^= wt3(f8[0]), this.v4h ^= wt3(f8[1]), this.v5l ^= wt3(f8[2]), this.v5h ^= wt3(f8[3]);
    }
    if (o4 !== void 0) {
      o4 = ht3(o4);
      const f8 = fe3(o4);
      this.v6l ^= wt3(f8[0]), this.v6h ^= wt3(f8[1]), this.v7l ^= wt3(f8[2]), this.v7h ^= wt3(f8[3]);
    }
    if (r3 !== void 0) {
      const f8 = new Uint8Array(this.blockLen);
      f8.set(r3), this.update(f8);
    }
  }
  get() {
    let { v0l: e2, v0h: n5, v1l: r3, v1h: o4, v2l: s3, v2h: i4, v3l: f8, v3h: a3, v4l: l6, v4h: c6, v5l: u2, v5h: h5, v6l: g3, v6h: w4, v7l: y5, v7h: x5 } = this;
    return [e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5];
  }
  set(e2, n5, r3, o4, s3, i4, f8, a3, l6, c6, u2, h5, g3, w4, y5, x5) {
    this.v0l = e2 | 0, this.v0h = n5 | 0, this.v1l = r3 | 0, this.v1h = o4 | 0, this.v2l = s3 | 0, this.v2h = i4 | 0, this.v3l = f8 | 0, this.v3h = a3 | 0, this.v4l = l6 | 0, this.v4h = c6 | 0, this.v5l = u2 | 0, this.v5h = h5 | 0, this.v6l = g3 | 0, this.v6h = w4 | 0, this.v7l = y5 | 0, this.v7h = x5 | 0;
  }
  compress(e2, n5, r3) {
    this.get().forEach((a3, l6) => N12[l6] = a3), N12.set(F2, 16);
    let { h: o4, l: s3 } = mr3(BigInt(this.length));
    N12[24] = F2[8] ^ s3, N12[25] = F2[9] ^ o4, r3 && (N12[28] = ~N12[28], N12[29] = ~N12[29]);
    let i4 = 0;
    const f8 = Ji2;
    for (let a3 = 0; a3 < 12; a3++) $t3(0, 4, 8, 12, e2, n5 + 2 * f8[i4++]), Ct2(0, 4, 8, 12, e2, n5 + 2 * f8[i4++]), $t3(1, 5, 9, 13, e2, n5 + 2 * f8[i4++]), Ct2(1, 5, 9, 13, e2, n5 + 2 * f8[i4++]), $t3(2, 6, 10, 14, e2, n5 + 2 * f8[i4++]), Ct2(2, 6, 10, 14, e2, n5 + 2 * f8[i4++]), $t3(3, 7, 11, 15, e2, n5 + 2 * f8[i4++]), Ct2(3, 7, 11, 15, e2, n5 + 2 * f8[i4++]), $t3(0, 5, 10, 15, e2, n5 + 2 * f8[i4++]), Ct2(0, 5, 10, 15, e2, n5 + 2 * f8[i4++]), $t3(1, 6, 11, 12, e2, n5 + 2 * f8[i4++]), Ct2(1, 6, 11, 12, e2, n5 + 2 * f8[i4++]), $t3(2, 7, 8, 13, e2, n5 + 2 * f8[i4++]), Ct2(2, 7, 8, 13, e2, n5 + 2 * f8[i4++]), $t3(3, 4, 9, 14, e2, n5 + 2 * f8[i4++]), Ct2(3, 4, 9, 14, e2, n5 + 2 * f8[i4++]);
    this.v0l ^= N12[0] ^ N12[16], this.v0h ^= N12[1] ^ N12[17], this.v1l ^= N12[2] ^ N12[18], this.v1h ^= N12[3] ^ N12[19], this.v2l ^= N12[4] ^ N12[20], this.v2h ^= N12[5] ^ N12[21], this.v3l ^= N12[6] ^ N12[22], this.v3h ^= N12[7] ^ N12[23], this.v4l ^= N12[8] ^ N12[24], this.v4h ^= N12[9] ^ N12[25], this.v5l ^= N12[10] ^ N12[26], this.v5h ^= N12[11] ^ N12[27], this.v6l ^= N12[12] ^ N12[28], this.v6h ^= N12[13] ^ N12[29], this.v7l ^= N12[14] ^ N12[30], this.v7h ^= N12[15] ^ N12[31], ut3(N12);
  }
  destroy() {
    this.destroyed = true, ut3(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf2 = Ui2((t) => new ef2(t));
var rf = "https://rpc.walletconnect.org/v1";
function an(t) {
  const e2 = `Ethereum Signed Message:
${t.length}`, n5 = new TextEncoder().encode(e2 + t);
  return "0x" + Buffer.from(Hi2(n5)).toString("hex");
}
async function Cr2(t, e2, n5, r3, o4, s3) {
  switch (n5.t) {
    case "eip191":
      return await Lr2(t, e2, n5.s);
    case "eip1271":
      return await jr2(t, e2, n5.s, r3, o4, s3);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n5.t}`);
  }
}
async function Lr2(t, e2, n5) {
  return (await recoverAddress2({ hash: an(e2), signature: n5 })).toLowerCase() === t.toLowerCase();
}
async function jr2(t, e2, n5, r3, o4, s3) {
  const i4 = Fe(r3);
  if (!i4.namespace || !i4.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r3}`);
  try {
    const f8 = "0x1626ba7e", a3 = "0000000000000000000000000000000000000000000000000000000000000040", l6 = n5.substring(2), c6 = (l6.length / 2).toString(16).padStart(64, "0"), u2 = (e2.startsWith("0x") ? e2 : an(e2)).substring(2), h5 = f8 + u2 + a3 + c6 + l6, g3 = await fetch(`${s3 || rf}/?chainId=${r3}&projectId=${o4}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: of(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: h5 }, "latest"] }) }), { result: w4 } = await g3.json();
    return w4 ? w4.slice(0, f8.length).toLowerCase() === f8.toLowerCase() : false;
  } catch (f8) {
    return console.error("isValidEip1271Signature: ", f8), false;
  }
}
function of() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function sf(t) {
  const e2 = atob(t), n5 = new Uint8Array(e2.length);
  for (let i4 = 0; i4 < e2.length; i4++) n5[i4] = e2.charCodeAt(i4);
  const r3 = n5[0];
  if (r3 === 0) throw new Error("No signatures found");
  const o4 = 1 + r3 * 64;
  if (n5.length < o4) throw new Error("Transaction data too short for claimed signature count");
  if (n5.length < 100) throw new Error("Transaction too short");
  const s3 = Buffer.from(t, "base64").slice(1, 65);
  return esm_default3.encode(s3);
}
function ff(t) {
  const e2 = new Uint8Array(Buffer.from(t, "base64")), n5 = Array.from("TransactionData::").map((s3) => s3.charCodeAt(0)), r3 = new Uint8Array(n5.length + e2.length);
  r3.set(n5), r3.set(e2, n5.length);
  const o4 = nf2(r3, { dkLen: 32 });
  return esm_default3.encode(o4);
}
function cf(t) {
  const e2 = new Uint8Array(Ae3(kr2(t)));
  return esm_default3.encode(e2);
}
function kr2(t) {
  if (t instanceof Uint8Array) return t;
  if (Array.isArray(t)) return new Uint8Array(t);
  if (typeof t == "object" && t != null && t.data) return new Uint8Array(Object.values(t.data));
  if (typeof t == "object" && t) return new Uint8Array(Object.values(t));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function af(t) {
  const e2 = Buffer.from(t, "base64"), n5 = decode2(e2).txn;
  if (!n5) throw new Error("Invalid signed transaction: missing 'txn' field");
  const r3 = encode4(n5), o4 = Buffer.from("TX"), s3 = Buffer.concat([o4, Buffer.from(r3)]), i4 = Xi2(s3);
  return base32.encode(i4).replace(/=+$/, "");
}
function un(t) {
  const e2 = [];
  let n5 = BigInt(t);
  for (; n5 >= BigInt(128); ) e2.push(Number(n5 & BigInt(127) | BigInt(128))), n5 >>= BigInt(7);
  return e2.push(Number(n5)), Buffer.from(e2);
}
function uf(t) {
  const e2 = Buffer.from(t.signed.bodyBytes, "base64"), n5 = Buffer.from(t.signed.authInfoBytes, "base64"), r3 = Buffer.from(t.signature.signature, "base64"), o4 = [];
  o4.push(Buffer.from([10])), o4.push(un(e2.length)), o4.push(e2), o4.push(Buffer.from([18])), o4.push(un(n5.length)), o4.push(n5), o4.push(Buffer.from([26])), o4.push(un(r3.length)), o4.push(r3);
  const s3 = Buffer.concat(o4), i4 = Ae3(s3);
  return Buffer.from(i4).toString("hex").toUpperCase();
}
var lf = Object.defineProperty;
var df = Object.defineProperties;
var hf = Object.getOwnPropertyDescriptors;
var Pr2 = Object.getOwnPropertySymbols;
var pf = Object.prototype.hasOwnProperty;
var gf = Object.prototype.propertyIsEnumerable;
var Hr2 = (t, e2, n5) => e2 in t ? lf(t, e2, { enumerable: true, configurable: true, writable: true, value: n5 }) : t[e2] = n5;
var ln = (t, e2) => {
  for (var n5 in e2 || (e2 = {})) pf.call(e2, n5) && Hr2(t, n5, e2[n5]);
  if (Pr2) for (var n5 of Pr2(e2)) gf.call(e2, n5) && Hr2(t, n5, e2[n5]);
  return t;
};
var Dr2 = (t, e2) => df(t, hf(e2));
var bf = "did:pkh:";
var Se2 = (t) => t == null ? void 0 : t.split(":");
var Mr2 = (t) => {
  const e2 = t && Se2(t);
  if (e2) return t.includes(bf) ? e2[3] : e2[1];
};
var Vr2 = (t) => {
  const e2 = t && Se2(t);
  if (e2) return e2[2] + ":" + e2[3];
};
var dn = (t) => {
  const e2 = t && Se2(t);
  if (e2) return e2.pop();
};
async function yf(t) {
  const { cacao: e2, projectId: n5 } = t, { s: r3, p: o4 } = e2, s3 = qr2(o4, o4.iss), i4 = dn(o4.iss);
  return await Cr2(i4, s3, r3, Vr2(o4.iss), n5);
}
var qr2 = (t, e2) => {
  const n5 = `${t.domain} wants you to sign in with your Ethereum account:`, r3 = dn(e2);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o4 = t.statement || void 0;
  const s3 = `URI: ${t.aud || t.uri}`, i4 = `Version: ${t.version}`, f8 = `Chain ID: ${Mr2(e2)}`, a3 = `Nonce: ${t.nonce}`, l6 = `Issued At: ${t.iat}`, c6 = t.exp ? `Expiration Time: ${t.exp}` : void 0, u2 = t.nbf ? `Not Before: ${t.nbf}` : void 0, h5 = t.requestId ? `Request ID: ${t.requestId}` : void 0, g3 = t.resources ? `Resources:${t.resources.map((y5) => `
- ${y5}`).join("")}` : void 0, w4 = Oe2(t.resources);
  if (w4) {
    const y5 = Lt2(w4);
    o4 = gn2(o4, y5);
  }
  return [n5, r3, "", o4, "", s3, i4, f8, a3, l6, c6, u2, h5, g3].filter((y5) => y5 != null).join(`
`);
};
function Gr2(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function Zr2(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function bt2(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e2 = Object.keys(t.att);
  if (!(e2 != null && e2.length)) throw new Error("No resources found in `att` property");
  e2.forEach((n5) => {
    const r3 = t.att[n5];
    if (Array.isArray(r3)) throw new Error(`Resource must be an object: ${n5}`);
    if (typeof r3 != "object") throw new Error(`Resource must be an object: ${n5}`);
    if (!Object.keys(r3).length) throw new Error(`Resource object is empty: ${n5}`);
    Object.keys(r3).forEach((o4) => {
      const s3 = r3[o4];
      if (!Array.isArray(s3)) throw new Error(`Ability limits ${o4} must be an array of objects, found: ${s3}`);
      if (!s3.length) throw new Error(`Value of ${o4} is empty array, must be an array with objects`);
      s3.forEach((i4) => {
        if (typeof i4 != "object") throw new Error(`Ability limits (${o4}) must be an array of objects, found: ${i4}`);
      });
    });
  });
}
function Wr2(t, e2, n5, r3 = {}) {
  return n5 == null ? void 0 : n5.sort((o4, s3) => o4.localeCompare(s3)), { att: { [t]: hn(e2, n5, r3) } };
}
function hn(t, e2, n5 = {}) {
  e2 = e2 == null ? void 0 : e2.sort((o4, s3) => o4.localeCompare(s3));
  const r3 = e2.map((o4) => ({ [`${t}/${o4}`]: [n5] }));
  return Object.assign({}, ...r3);
}
function Ne2(t) {
  return bt2(t), `urn:recap:${Gr2(t).replace(/=/g, "")}`;
}
function Lt2(t) {
  const e2 = Zr2(t.replace("urn:recap:", ""));
  return bt2(e2), e2;
}
function Ef(t, e2, n5) {
  const r3 = Wr2(t, e2, n5);
  return Ne2(r3);
}
function pn(t) {
  return t && t.includes("urn:recap:");
}
function Bf(t, e2) {
  const n5 = Lt2(t), r3 = Lt2(e2), o4 = Xr2(n5, r3);
  return Ne2(o4);
}
function Xr2(t, e2) {
  bt2(t), bt2(e2);
  const n5 = Object.keys(t.att).concat(Object.keys(e2.att)).sort((o4, s3) => o4.localeCompare(s3)), r3 = { att: {} };
  return n5.forEach((o4) => {
    var s3, i4;
    Object.keys(((s3 = t.att) == null ? void 0 : s3[o4]) || {}).concat(Object.keys(((i4 = e2.att) == null ? void 0 : i4[o4]) || {})).sort((f8, a3) => f8.localeCompare(a3)).forEach((f8) => {
      var a3, l6;
      r3.att[o4] = Dr2(ln({}, r3.att[o4]), { [f8]: ((a3 = t.att[o4]) == null ? void 0 : a3[f8]) || ((l6 = e2.att[o4]) == null ? void 0 : l6[f8]) });
    });
  }), r3;
}
function gn2(t = "", e2) {
  bt2(e2);
  const n5 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n5)) return t;
  const r3 = [];
  let o4 = 0;
  Object.keys(e2.att).forEach((f8) => {
    const a3 = Object.keys(e2.att[f8]).map((u2) => ({ ability: u2.split("/")[0], action: u2.split("/")[1] }));
    a3.sort((u2, h5) => u2.action.localeCompare(h5.action));
    const l6 = {};
    a3.forEach((u2) => {
      l6[u2.ability] || (l6[u2.ability] = []), l6[u2.ability].push(u2.action);
    });
    const c6 = Object.keys(l6).map((u2) => (o4++, `(${o4}) '${u2}': '${l6[u2].join("', '")}' for '${f8}'.`));
    r3.push(c6.join(", ").replace(".,", "."));
  });
  const s3 = r3.join(" "), i4 = `${n5}${s3}`;
  return `${t ? t + " " : ""}${i4}`;
}
function If(t) {
  var e2;
  const n5 = Lt2(t);
  bt2(n5);
  const r3 = (e2 = n5.att) == null ? void 0 : e2.eip155;
  return r3 ? Object.keys(r3).map((o4) => o4.split("/")[1]) : [];
}
function Af(t) {
  const e2 = Lt2(t);
  bt2(e2);
  const n5 = [];
  return Object.values(e2.att).forEach((r3) => {
    Object.values(r3).forEach((o4) => {
      var s3;
      (s3 = o4 == null ? void 0 : o4[0]) != null && s3.chains && n5.push(o4[0].chains);
    });
  }), [...new Set(n5.flat())];
}
function Oe2(t) {
  if (!t) return;
  const e2 = t == null ? void 0 : t[t.length - 1];
  return pn(e2) ? e2 : void 0;
}
function Qr3(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function bn3(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function yn3(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function nt3(t, ...e2) {
  if (!Qr3(t)) throw new Error("Uint8Array expected");
  if (e2.length > 0 && !e2.includes(t.length)) throw new Error("Uint8Array expected of length " + e2 + ", got length=" + t.length);
}
function to3(t, e2 = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e2 && t.finished) throw new Error("Hash#digest() has already been called");
}
function Sf2(t, e2) {
  nt3(t);
  const n5 = e2.outputLen;
  if (t.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function jt3(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Wt3(...t) {
  for (let e2 = 0; e2 < t.length; e2++) t[e2].fill(0);
}
function Nf2(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Of2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf2(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function mn3(t) {
  if (typeof t == "string") t = Uf2(t);
  else if (Qr3(t)) t = wn2(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function _f2(t, e2) {
  if (e2 == null || typeof e2 != "object") throw new Error("options must be defined");
  return Object.assign(t, e2);
}
function Tf2(t, e2) {
  if (t.length !== e2.length) return false;
  let n5 = 0;
  for (let r3 = 0; r3 < t.length; r3++) n5 |= t[r3] ^ e2[r3];
  return n5 === 0;
}
var Rf2 = (t, e2) => {
  function n5(r3, ...o4) {
    if (nt3(r3), !Of2) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const c6 = o4[0];
      if (!c6) throw new Error("nonce / iv required");
      t.varSizeNonce ? nt3(c6) : nt3(c6, t.nonceLength);
    }
    const s3 = t.tagLength;
    s3 && o4[1] !== void 0 && nt3(o4[1]);
    const i4 = e2(r3, ...o4), f8 = (c6, u2) => {
      if (u2 !== void 0) {
        if (c6 !== 2) throw new Error("cipher output not supported");
        nt3(u2);
      }
    };
    let a3 = false;
    return { encrypt(c6, u2) {
      if (a3) throw new Error("cannot encrypt() twice with same key + nonce");
      return a3 = true, nt3(c6), f8(i4.encrypt.length, u2), i4.encrypt(c6, u2);
    }, decrypt(c6, u2) {
      if (nt3(c6), s3 && c6.length < s3) throw new Error("invalid ciphertext length: smaller than tagLength=" + s3);
      return f8(i4.decrypt.length, u2), i4.decrypt(c6, u2);
    } };
  }
  return Object.assign(n5, t), n5;
};
function eo3(t, e2, n5 = true) {
  if (e2 === void 0) return new Uint8Array(t);
  if (e2.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e2.length);
  if (n5 && !Cf2(e2)) throw new Error("invalid output, must be aligned");
  return e2;
}
function no3(t, e2, n5, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e2, n5, r3);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i4 = Number(n5 >> o4 & s3), f8 = Number(n5 & s3), a3 = r3 ? 4 : 0, l6 = r3 ? 0 : 4;
  t.setUint32(e2 + a3, i4, r3), t.setUint32(e2 + l6, f8, r3);
}
function $f2(t, e2, n5) {
  bn3(n5);
  const r3 = new Uint8Array(16), o4 = Nf2(r3);
  return no3(o4, 0, BigInt(e2), n5), no3(o4, 8, BigInt(t), n5), r3;
}
function Cf2(t) {
  return t.byteOffset % 4 === 0;
}
function wn2(t) {
  return Uint8Array.from(t);
}
var ro3 = (t) => Uint8Array.from(t.split("").map((e2) => e2.charCodeAt(0)));
var Lf2 = ro3("expand 16-byte k");
var jf2 = ro3("expand 32-byte k");
var kf2 = jt3(Lf2);
var Pf2 = jt3(jf2);
function D3(t, e2) {
  return t << e2 | t >>> 32 - e2;
}
function xn3(t) {
  return t.byteOffset % 4 === 0;
}
var Ue3 = 64;
var Hf2 = 16;
var oo3 = 2 ** 32 - 1;
var so3 = new Uint32Array();
function Df2(t, e2, n5, r3, o4, s3, i4, f8) {
  const a3 = o4.length, l6 = new Uint8Array(Ue3), c6 = jt3(l6), u2 = xn3(o4) && xn3(s3), h5 = u2 ? jt3(o4) : so3, g3 = u2 ? jt3(s3) : so3;
  for (let w4 = 0; w4 < a3; i4++) {
    if (t(e2, n5, r3, c6, i4, f8), i4 >= oo3) throw new Error("arx: counter overflow");
    const y5 = Math.min(Ue3, a3 - w4);
    if (u2 && y5 === Ue3) {
      const x5 = w4 / 4;
      if (w4 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R3 = 0, M4; R3 < Hf2; R3++) M4 = x5 + R3, g3[M4] = h5[M4] ^ c6[R3];
      w4 += Ue3;
      continue;
    }
    for (let x5 = 0, R3; x5 < y5; x5++) R3 = w4 + x5, s3[R3] = o4[R3] ^ l6[x5];
    w4 += y5;
  }
}
function Mf2(t, e2) {
  const { allowShortKeys: n5, extendNonceFn: r3, counterLength: o4, counterRight: s3, rounds: i4 } = _f2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e2);
  if (typeof t != "function") throw new Error("core must be a function");
  return yn3(o4), yn3(i4), bn3(s3), bn3(n5), (f8, a3, l6, c6, u2 = 0) => {
    nt3(f8), nt3(a3), nt3(l6);
    const h5 = l6.length;
    if (c6 === void 0 && (c6 = new Uint8Array(h5)), nt3(c6), yn3(u2), u2 < 0 || u2 >= oo3) throw new Error("arx: counter overflow");
    if (c6.length < h5) throw new Error(`arx: output (${c6.length}) is shorter than data (${h5})`);
    const g3 = [];
    let w4 = f8.length, y5, x5;
    if (w4 === 32) g3.push(y5 = wn2(f8)), x5 = Pf2;
    else if (w4 === 16 && n5) y5 = new Uint8Array(32), y5.set(f8), y5.set(f8, 16), x5 = kf2, g3.push(y5);
    else throw new Error(`arx: invalid 32-byte key, got length=${w4}`);
    xn3(a3) || g3.push(a3 = wn2(a3));
    const R3 = jt3(y5);
    if (r3) {
      if (a3.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r3(x5, R3, jt3(a3.subarray(0, 16)), R3), a3 = a3.subarray(16);
    }
    const M4 = 16 - o4;
    if (M4 !== a3.length) throw new Error(`arx: nonce must be ${M4} or 16 bytes`);
    if (M4 !== 12) {
      const V3 = new Uint8Array(12);
      V3.set(a3, s3 ? 0 : 12 - a3.length), a3 = V3, g3.push(a3);
    }
    const L3 = jt3(a3);
    return Df2(t, x5, R3, L3, l6, c6, u2, i4), Wt3(...g3), c6;
  };
}
var G3 = (t, e2) => t[e2++] & 255 | (t[e2++] & 255) << 8;
var Vf2 = class {
  constructor(e2) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e2 = mn3(e2), nt3(e2, 32);
    const n5 = G3(e2, 0), r3 = G3(e2, 2), o4 = G3(e2, 4), s3 = G3(e2, 6), i4 = G3(e2, 8), f8 = G3(e2, 10), a3 = G3(e2, 12), l6 = G3(e2, 14);
    this.r[0] = n5 & 8191, this.r[1] = (n5 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s3 << 9) & 8191, this.r[4] = (s3 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, this.r[6] = (i4 >>> 14 | f8 << 2) & 8191, this.r[7] = (f8 >>> 11 | a3 << 5) & 8065, this.r[8] = (a3 >>> 8 | l6 << 8) & 8191, this.r[9] = l6 >>> 5 & 127;
    for (let c6 = 0; c6 < 8; c6++) this.pad[c6] = G3(e2, 16 + 2 * c6);
  }
  process(e2, n5, r3 = false) {
    const o4 = r3 ? 0 : 2048, { h: s3, r: i4 } = this, f8 = i4[0], a3 = i4[1], l6 = i4[2], c6 = i4[3], u2 = i4[4], h5 = i4[5], g3 = i4[6], w4 = i4[7], y5 = i4[8], x5 = i4[9], R3 = G3(e2, n5 + 0), M4 = G3(e2, n5 + 2), L3 = G3(e2, n5 + 4), V3 = G3(e2, n5 + 6), _3 = G3(e2, n5 + 8), k6 = G3(e2, n5 + 10), j3 = G3(e2, n5 + 12), $3 = G3(e2, n5 + 14);
    let d4 = s3[0] + (R3 & 8191), m3 = s3[1] + ((R3 >>> 13 | M4 << 3) & 8191), p4 = s3[2] + ((M4 >>> 10 | L3 << 6) & 8191), b4 = s3[3] + ((L3 >>> 7 | V3 << 9) & 8191), v6 = s3[4] + ((V3 >>> 4 | _3 << 12) & 8191), B3 = s3[5] + (_3 >>> 1 & 8191), E4 = s3[6] + ((_3 >>> 14 | k6 << 2) & 8191), I4 = s3[7] + ((k6 >>> 11 | j3 << 5) & 8191), S4 = s3[8] + ((j3 >>> 8 | $3 << 8) & 8191), O5 = s3[9] + ($3 >>> 5 | o4), A4 = 0, T3 = A4 + d4 * f8 + m3 * (5 * x5) + p4 * (5 * y5) + b4 * (5 * w4) + v6 * (5 * g3);
    A4 = T3 >>> 13, T3 &= 8191, T3 += B3 * (5 * h5) + E4 * (5 * u2) + I4 * (5 * c6) + S4 * (5 * l6) + O5 * (5 * a3), A4 += T3 >>> 13, T3 &= 8191;
    let U3 = A4 + d4 * a3 + m3 * f8 + p4 * (5 * x5) + b4 * (5 * y5) + v6 * (5 * w4);
    A4 = U3 >>> 13, U3 &= 8191, U3 += B3 * (5 * g3) + E4 * (5 * h5) + I4 * (5 * u2) + S4 * (5 * c6) + O5 * (5 * l6), A4 += U3 >>> 13, U3 &= 8191;
    let C4 = A4 + d4 * l6 + m3 * a3 + p4 * f8 + b4 * (5 * x5) + v6 * (5 * y5);
    A4 = C4 >>> 13, C4 &= 8191, C4 += B3 * (5 * w4) + E4 * (5 * g3) + I4 * (5 * h5) + S4 * (5 * u2) + O5 * (5 * c6), A4 += C4 >>> 13, C4 &= 8191;
    let H2 = A4 + d4 * c6 + m3 * l6 + p4 * a3 + b4 * f8 + v6 * (5 * x5);
    A4 = H2 >>> 13, H2 &= 8191, H2 += B3 * (5 * y5) + E4 * (5 * w4) + I4 * (5 * g3) + S4 * (5 * h5) + O5 * (5 * u2), A4 += H2 >>> 13, H2 &= 8191;
    let q = A4 + d4 * u2 + m3 * c6 + p4 * l6 + b4 * a3 + v6 * f8;
    A4 = q >>> 13, q &= 8191, q += B3 * (5 * x5) + E4 * (5 * y5) + I4 * (5 * w4) + S4 * (5 * g3) + O5 * (5 * h5), A4 += q >>> 13, q &= 8191;
    let P4 = A4 + d4 * h5 + m3 * u2 + p4 * c6 + b4 * l6 + v6 * a3;
    A4 = P4 >>> 13, P4 &= 8191, P4 += B3 * f8 + E4 * (5 * x5) + I4 * (5 * y5) + S4 * (5 * w4) + O5 * (5 * g3), A4 += P4 >>> 13, P4 &= 8191;
    let K4 = A4 + d4 * g3 + m3 * h5 + p4 * u2 + b4 * c6 + v6 * l6;
    A4 = K4 >>> 13, K4 &= 8191, K4 += B3 * a3 + E4 * f8 + I4 * (5 * x5) + S4 * (5 * y5) + O5 * (5 * w4), A4 += K4 >>> 13, K4 &= 8191;
    let et = A4 + d4 * w4 + m3 * g3 + p4 * h5 + b4 * u2 + v6 * c6;
    A4 = et >>> 13, et &= 8191, et += B3 * l6 + E4 * a3 + I4 * f8 + S4 * (5 * x5) + O5 * (5 * y5), A4 += et >>> 13, et &= 8191;
    let Z2 = A4 + d4 * y5 + m3 * w4 + p4 * g3 + b4 * h5 + v6 * u2;
    A4 = Z2 >>> 13, Z2 &= 8191, Z2 += B3 * c6 + E4 * l6 + I4 * a3 + S4 * f8 + O5 * (5 * x5), A4 += Z2 >>> 13, Z2 &= 8191;
    let z4 = A4 + d4 * x5 + m3 * y5 + p4 * w4 + b4 * g3 + v6 * h5;
    A4 = z4 >>> 13, z4 &= 8191, z4 += B3 * u2 + E4 * c6 + I4 * l6 + S4 * a3 + O5 * f8, A4 += z4 >>> 13, z4 &= 8191, A4 = (A4 << 2) + A4 | 0, A4 = A4 + T3 | 0, T3 = A4 & 8191, A4 = A4 >>> 13, U3 += A4, s3[0] = T3, s3[1] = U3, s3[2] = C4, s3[3] = H2, s3[4] = q, s3[5] = P4, s3[6] = K4, s3[7] = et, s3[8] = Z2, s3[9] = z4;
  }
  finalize() {
    const { h: e2, pad: n5 } = this, r3 = new Uint16Array(10);
    let o4 = e2[1] >>> 13;
    e2[1] &= 8191;
    for (let f8 = 2; f8 < 10; f8++) e2[f8] += o4, o4 = e2[f8] >>> 13, e2[f8] &= 8191;
    e2[0] += o4 * 5, o4 = e2[0] >>> 13, e2[0] &= 8191, e2[1] += o4, o4 = e2[1] >>> 13, e2[1] &= 8191, e2[2] += o4, r3[0] = e2[0] + 5, o4 = r3[0] >>> 13, r3[0] &= 8191;
    for (let f8 = 1; f8 < 10; f8++) r3[f8] = e2[f8] + o4, o4 = r3[f8] >>> 13, r3[f8] &= 8191;
    r3[9] -= 8192;
    let s3 = (o4 ^ 1) - 1;
    for (let f8 = 0; f8 < 10; f8++) r3[f8] &= s3;
    s3 = ~s3;
    for (let f8 = 0; f8 < 10; f8++) e2[f8] = e2[f8] & s3 | r3[f8];
    e2[0] = (e2[0] | e2[1] << 13) & 65535, e2[1] = (e2[1] >>> 3 | e2[2] << 10) & 65535, e2[2] = (e2[2] >>> 6 | e2[3] << 7) & 65535, e2[3] = (e2[3] >>> 9 | e2[4] << 4) & 65535, e2[4] = (e2[4] >>> 12 | e2[5] << 1 | e2[6] << 14) & 65535, e2[5] = (e2[6] >>> 2 | e2[7] << 11) & 65535, e2[6] = (e2[7] >>> 5 | e2[8] << 8) & 65535, e2[7] = (e2[8] >>> 8 | e2[9] << 5) & 65535;
    let i4 = e2[0] + n5[0];
    e2[0] = i4 & 65535;
    for (let f8 = 1; f8 < 8; f8++) i4 = (e2[f8] + n5[f8] | 0) + (i4 >>> 16) | 0, e2[f8] = i4 & 65535;
    Wt3(r3);
  }
  update(e2) {
    to3(this), e2 = mn3(e2), nt3(e2);
    const { buffer: n5, blockLen: r3 } = this, o4 = e2.length;
    for (let s3 = 0; s3 < o4; ) {
      const i4 = Math.min(r3 - this.pos, o4 - s3);
      if (i4 === r3) {
        for (; r3 <= o4 - s3; s3 += r3) this.process(e2, s3);
        continue;
      }
      n5.set(e2.subarray(s3, s3 + i4), this.pos), this.pos += i4, s3 += i4, this.pos === r3 && (this.process(n5, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt3(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e2) {
    to3(this), Sf2(e2, this), this.finished = true;
    const { buffer: n5, h: r3 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n5[o4++] = 1; o4 < 16; o4++) n5[o4] = 0;
      this.process(n5, 0, true);
    }
    this.finalize();
    let s3 = 0;
    for (let i4 = 0; i4 < 8; i4++) e2[s3++] = r3[i4] >>> 0, e2[s3++] = r3[i4] >>> 8;
    return e2;
  }
  digest() {
    const { buffer: e2, outputLen: n5 } = this;
    this.digestInto(e2);
    const r3 = e2.slice(0, n5);
    return this.destroy(), r3;
  }
};
function qf2(t) {
  const e2 = (r3, o4) => t(o4).update(mn3(r3)).digest(), n5 = t(new Uint8Array(32));
  return e2.outputLen = n5.outputLen, e2.blockLen = n5.blockLen, e2.create = (r3) => t(r3), e2;
}
var Kf2 = qf2((t) => new Vf2(t));
function Ff2(t, e2, n5, r3, o4, s3 = 20) {
  let i4 = t[0], f8 = t[1], a3 = t[2], l6 = t[3], c6 = e2[0], u2 = e2[1], h5 = e2[2], g3 = e2[3], w4 = e2[4], y5 = e2[5], x5 = e2[6], R3 = e2[7], M4 = o4, L3 = n5[0], V3 = n5[1], _3 = n5[2], k6 = i4, j3 = f8, $3 = a3, d4 = l6, m3 = c6, p4 = u2, b4 = h5, v6 = g3, B3 = w4, E4 = y5, I4 = x5, S4 = R3, O5 = M4, A4 = L3, T3 = V3, U3 = _3;
  for (let H2 = 0; H2 < s3; H2 += 2) k6 = k6 + m3 | 0, O5 = D3(O5 ^ k6, 16), B3 = B3 + O5 | 0, m3 = D3(m3 ^ B3, 12), k6 = k6 + m3 | 0, O5 = D3(O5 ^ k6, 8), B3 = B3 + O5 | 0, m3 = D3(m3 ^ B3, 7), j3 = j3 + p4 | 0, A4 = D3(A4 ^ j3, 16), E4 = E4 + A4 | 0, p4 = D3(p4 ^ E4, 12), j3 = j3 + p4 | 0, A4 = D3(A4 ^ j3, 8), E4 = E4 + A4 | 0, p4 = D3(p4 ^ E4, 7), $3 = $3 + b4 | 0, T3 = D3(T3 ^ $3, 16), I4 = I4 + T3 | 0, b4 = D3(b4 ^ I4, 12), $3 = $3 + b4 | 0, T3 = D3(T3 ^ $3, 8), I4 = I4 + T3 | 0, b4 = D3(b4 ^ I4, 7), d4 = d4 + v6 | 0, U3 = D3(U3 ^ d4, 16), S4 = S4 + U3 | 0, v6 = D3(v6 ^ S4, 12), d4 = d4 + v6 | 0, U3 = D3(U3 ^ d4, 8), S4 = S4 + U3 | 0, v6 = D3(v6 ^ S4, 7), k6 = k6 + p4 | 0, U3 = D3(U3 ^ k6, 16), I4 = I4 + U3 | 0, p4 = D3(p4 ^ I4, 12), k6 = k6 + p4 | 0, U3 = D3(U3 ^ k6, 8), I4 = I4 + U3 | 0, p4 = D3(p4 ^ I4, 7), j3 = j3 + b4 | 0, O5 = D3(O5 ^ j3, 16), S4 = S4 + O5 | 0, b4 = D3(b4 ^ S4, 12), j3 = j3 + b4 | 0, O5 = D3(O5 ^ j3, 8), S4 = S4 + O5 | 0, b4 = D3(b4 ^ S4, 7), $3 = $3 + v6 | 0, A4 = D3(A4 ^ $3, 16), B3 = B3 + A4 | 0, v6 = D3(v6 ^ B3, 12), $3 = $3 + v6 | 0, A4 = D3(A4 ^ $3, 8), B3 = B3 + A4 | 0, v6 = D3(v6 ^ B3, 7), d4 = d4 + m3 | 0, T3 = D3(T3 ^ d4, 16), E4 = E4 + T3 | 0, m3 = D3(m3 ^ E4, 12), d4 = d4 + m3 | 0, T3 = D3(T3 ^ d4, 8), E4 = E4 + T3 | 0, m3 = D3(m3 ^ E4, 7);
  let C4 = 0;
  r3[C4++] = i4 + k6 | 0, r3[C4++] = f8 + j3 | 0, r3[C4++] = a3 + $3 | 0, r3[C4++] = l6 + d4 | 0, r3[C4++] = c6 + m3 | 0, r3[C4++] = u2 + p4 | 0, r3[C4++] = h5 + b4 | 0, r3[C4++] = g3 + v6 | 0, r3[C4++] = w4 + B3 | 0, r3[C4++] = y5 + E4 | 0, r3[C4++] = x5 + I4 | 0, r3[C4++] = R3 + S4 | 0, r3[C4++] = M4 + O5 | 0, r3[C4++] = L3 + A4 | 0, r3[C4++] = V3 + T3 | 0, r3[C4++] = _3 + U3 | 0;
}
var zf2 = Mf2(Ff2, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf2 = new Uint8Array(16);
var io3 = (t, e2) => {
  t.update(e2);
  const n5 = e2.length % 16;
  n5 && t.update(Gf2.subarray(n5));
};
var Zf2 = new Uint8Array(32);
function fo3(t, e2, n5, r3, o4) {
  const s3 = t(e2, n5, Zf2), i4 = Kf2.create(s3);
  o4 && io3(i4, o4), io3(i4, r3);
  const f8 = $f2(r3.length, o4 ? o4.length : 0, true);
  i4.update(f8);
  const a3 = i4.digest();
  return Wt3(s3, f8), a3;
}
var Wf2 = (t) => (e2, n5, r3) => ({ encrypt(s3, i4) {
  const f8 = s3.length;
  i4 = eo3(f8 + 16, i4, false), i4.set(s3);
  const a3 = i4.subarray(0, -16);
  t(e2, n5, a3, a3, 1);
  const l6 = fo3(t, e2, n5, a3, r3);
  return i4.set(l6, f8), Wt3(l6), i4;
}, decrypt(s3, i4) {
  i4 = eo3(s3.length - 16, i4, false);
  const f8 = s3.subarray(0, -16), a3 = s3.subarray(-16), l6 = fo3(t, e2, n5, f8, r3);
  if (!Tf2(a3, l6)) throw new Error("invalid tag");
  return i4.set(s3.subarray(0, -16)), t(e2, n5, i4, i4, 1), Wt3(l6), i4;
} });
var co3 = Rf2({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf2(zf2));
var ao3 = class extends Ie3 {
  constructor(e2, n5) {
    super(), this.finished = false, this.destroyed = false, rn3(e2);
    const r3 = ht3(n5);
    if (this.iHash = e2.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s3 = new Uint8Array(o4);
    s3.set(r3.length > o4 ? e2.create().update(r3).digest() : r3);
    for (let i4 = 0; i4 < s3.length; i4++) s3[i4] ^= 54;
    this.iHash.update(s3), this.oHash = e2.create();
    for (let i4 = 0; i4 < s3.length; i4++) s3[i4] ^= 106;
    this.oHash.update(s3), ut3(s3);
  }
  update(e2) {
    return Nt3(this), this.iHash.update(e2), this;
  }
  digestInto(e2) {
    Nt3(this), at2(e2, this.outputLen), this.finished = true, this.iHash.digestInto(e2), this.oHash.update(e2), this.oHash.digestInto(e2), this.destroy();
  }
  digest() {
    const e2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e2), e2;
  }
  _cloneInto(e2) {
    e2 || (e2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n5, iHash: r3, finished: o4, destroyed: s3, blockLen: i4, outputLen: f8 } = this;
    return e2 = e2, e2.finished = o4, e2.destroyed = s3, e2.blockLen = i4, e2.outputLen = f8, e2.oHash = n5._cloneInto(e2.oHash), e2.iHash = r3._cloneInto(e2.iHash), e2;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e3 = (t, e2, n5) => new ao3(t, e2).update(n5).digest();
_e3.create = (t, e2) => new ao3(t, e2);
function Yf(t, e2, n5) {
  return rn3(t), n5 === void 0 && (n5 = new Uint8Array(t.outputLen)), _e3(t, ht3(n5), ht3(e2));
}
var vn3 = Uint8Array.from([0]);
var uo3 = Uint8Array.of();
function Xf(t, e2, n5, r3 = 32) {
  rn3(t), mt2(r3);
  const o4 = t.outputLen;
  if (r3 > 255 * o4) throw new Error("Length should be <= 255*HashLen");
  const s3 = Math.ceil(r3 / o4);
  n5 === void 0 && (n5 = uo3);
  const i4 = new Uint8Array(s3 * o4), f8 = _e3.create(t, e2), a3 = f8._cloneInto(), l6 = new Uint8Array(f8.outputLen);
  for (let c6 = 0; c6 < s3; c6++) vn3[0] = c6 + 1, a3.update(c6 === 0 ? uo3 : l6).update(n5).update(vn3).digestInto(l6), i4.set(l6, o4 * c6), f8._cloneInto(a3);
  return f8.destroy(), a3.destroy(), ut3(l6, vn3), i4.slice(0, r3);
}
var Jf = (t, e2, n5, r3, o4) => Xf(t, Yf(t, e2, n5), r3, o4);
var Te2 = Ae3;
var En3 = BigInt(0);
var Bn3 = BigInt(1);
function Re3(t, e2) {
  if (typeof e2 != "boolean") throw new Error(t + " boolean expected, got " + e2);
}
function $e3(t) {
  const e2 = t.toString(16);
  return e2.length & 1 ? "0" + e2 : e2;
}
function lo3(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? En3 : BigInt("0x" + t);
}
function Ce3(t) {
  return lo3(ce2(t));
}
function Le3(t) {
  return at2(t), lo3(ce2(Uint8Array.from(t).reverse()));
}
function In3(t, e2) {
  return fn2(t.toString(16).padStart(e2 * 2, "0"));
}
function An3(t, e2) {
  return In3(t, e2).reverse();
}
function rt3(t, e2, n5) {
  let r3;
  if (typeof e2 == "string") try {
    r3 = fn2(e2);
  } catch (s3) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s3);
  }
  else if (nn3(e2)) r3 = Uint8Array.from(e2);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o4 = r3.length;
  if (typeof n5 == "number" && o4 !== n5) throw new Error(t + " of length " + n5 + " expected, got " + o4);
  return r3;
}
var Sn3 = (t) => typeof t == "bigint" && En3 <= t;
function Qf2(t, e2, n5) {
  return Sn3(t) && Sn3(e2) && Sn3(n5) && e2 <= t && t < n5;
}
function Nn3(t, e2, n5, r3) {
  if (!Qf2(e2, n5, r3)) throw new Error("expected valid " + t + ": " + n5 + " <= n < " + r3 + ", got " + e2);
}
function tc2(t) {
  let e2;
  for (e2 = 0; t > En3; t >>= Bn3, e2 += 1) ;
  return e2;
}
var je3 = (t) => (Bn3 << BigInt(t)) - Bn3;
function ec2(t, e2, n5) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e2 != "number" || e2 < 2) throw new Error("qByteLen must be a number");
  if (typeof n5 != "function") throw new Error("hmacFn must be a function");
  const r3 = (g3) => new Uint8Array(g3), o4 = (g3) => Uint8Array.of(g3);
  let s3 = r3(t), i4 = r3(t), f8 = 0;
  const a3 = () => {
    s3.fill(1), i4.fill(0), f8 = 0;
  }, l6 = (...g3) => n5(i4, s3, ...g3), c6 = (g3 = r3(0)) => {
    i4 = l6(o4(0), g3), s3 = l6(), g3.length !== 0 && (i4 = l6(o4(1), g3), s3 = l6());
  }, u2 = () => {
    if (f8++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g3 = 0;
    const w4 = [];
    for (; g3 < e2; ) {
      s3 = l6();
      const y5 = s3.slice();
      w4.push(y5), g3 += s3.length;
    }
    return Ht3(...w4);
  };
  return (g3, w4) => {
    a3(), c6(g3);
    let y5;
    for (; !(y5 = w4(u2())); ) c6();
    return a3(), y5;
  };
}
function ke3(t, e2, n5 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r3(o4, s3, i4) {
    const f8 = t[o4];
    if (i4 && f8 === void 0) return;
    const a3 = typeof f8;
    if (a3 !== s3 || f8 === null) throw new Error(`param "${o4}" is invalid: expected ${s3}, got ${a3}`);
  }
  Object.entries(e2).forEach(([o4, s3]) => r3(o4, s3, false)), Object.entries(n5).forEach(([o4, s3]) => r3(o4, s3, true));
}
function ho3(t) {
  const e2 = /* @__PURE__ */ new WeakMap();
  return (n5, ...r3) => {
    const o4 = e2.get(n5);
    if (o4 !== void 0) return o4;
    const s3 = t(n5, ...r3);
    return e2.set(n5, s3), s3;
  };
}
var ot2 = BigInt(0);
var Q3 = BigInt(1);
var Dt3 = BigInt(2);
var nc2 = BigInt(3);
var po3 = BigInt(4);
var go3 = BigInt(5);
var bo3 = BigInt(8);
function lt3(t, e2) {
  const n5 = t % e2;
  return n5 >= ot2 ? n5 : e2 + n5;
}
function pt2(t, e2, n5) {
  let r3 = t;
  for (; e2-- > ot2; ) r3 *= r3, r3 %= n5;
  return r3;
}
function yo3(t, e2) {
  if (t === ot2) throw new Error("invert: expected non-zero number");
  if (e2 <= ot2) throw new Error("invert: expected positive modulus, got " + e2);
  let n5 = lt3(t, e2), r3 = e2, o4 = ot2, s3 = Q3;
  for (; n5 !== ot2; ) {
    const f8 = r3 / n5, a3 = r3 % n5, l6 = o4 - s3 * f8;
    r3 = n5, n5 = a3, o4 = s3, s3 = l6;
  }
  if (r3 !== Q3) throw new Error("invert: does not exist");
  return lt3(o4, e2);
}
function mo3(t, e2) {
  const n5 = (t.ORDER + Q3) / po3, r3 = t.pow(e2, n5);
  if (!t.eql(t.sqr(r3), e2)) throw new Error("Cannot find square root");
  return r3;
}
function rc2(t, e2) {
  const n5 = (t.ORDER - go3) / bo3, r3 = t.mul(e2, Dt3), o4 = t.pow(r3, n5), s3 = t.mul(e2, o4), i4 = t.mul(t.mul(s3, Dt3), o4), f8 = t.mul(s3, t.sub(i4, t.ONE));
  if (!t.eql(t.sqr(f8), e2)) throw new Error("Cannot find square root");
  return f8;
}
function oc2(t) {
  if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e2 = t - Q3, n5 = 0;
  for (; e2 % Dt3 === ot2; ) e2 /= Dt3, n5++;
  let r3 = Dt3;
  const o4 = Yt3(t);
  for (; xo3(o4, r3) === 1; ) if (r3++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n5 === 1) return mo3;
  let s3 = o4.pow(r3, e2);
  const i4 = (e2 + Q3) / Dt3;
  return function(a3, l6) {
    if (a3.is0(l6)) return l6;
    if (xo3(a3, l6) !== 1) throw new Error("Cannot find square root");
    let c6 = n5, u2 = a3.mul(a3.ONE, s3), h5 = a3.pow(l6, e2), g3 = a3.pow(l6, i4);
    for (; !a3.eql(h5, a3.ONE); ) {
      if (a3.is0(h5)) return a3.ZERO;
      let w4 = 1, y5 = a3.sqr(h5);
      for (; !a3.eql(y5, a3.ONE); ) if (w4++, y5 = a3.sqr(y5), w4 === c6) throw new Error("Cannot find square root");
      const x5 = Q3 << BigInt(c6 - w4 - 1), R3 = a3.pow(u2, x5);
      c6 = w4, u2 = a3.sqr(R3), h5 = a3.mul(h5, u2), g3 = a3.mul(g3, R3);
    }
    return g3;
  };
}
function sc2(t) {
  return t % po3 === nc2 ? mo3 : t % bo3 === go3 ? rc2 : oc2(t);
}
var ic2 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc2(t) {
  const e2 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n5 = ic2.reduce((r3, o4) => (r3[o4] = "function", r3), e2);
  return ke3(t, n5), t;
}
function cc2(t, e2, n5) {
  if (n5 < ot2) throw new Error("invalid exponent, negatives unsupported");
  if (n5 === ot2) return t.ONE;
  if (n5 === Q3) return e2;
  let r3 = t.ONE, o4 = e2;
  for (; n5 > ot2; ) n5 & Q3 && (r3 = t.mul(r3, o4)), o4 = t.sqr(o4), n5 >>= Q3;
  return r3;
}
function wo3(t, e2, n5 = false) {
  const r3 = new Array(e2.length).fill(n5 ? t.ZERO : void 0), o4 = e2.reduce((i4, f8, a3) => t.is0(f8) ? i4 : (r3[a3] = i4, t.mul(i4, f8)), t.ONE), s3 = t.inv(o4);
  return e2.reduceRight((i4, f8, a3) => t.is0(f8) ? i4 : (r3[a3] = t.mul(i4, r3[a3]), t.mul(i4, f8)), s3), r3;
}
function xo3(t, e2) {
  const n5 = (t.ORDER - Q3) / Dt3, r3 = t.pow(e2, n5), o4 = t.eql(r3, t.ONE), s3 = t.eql(r3, t.ZERO), i4 = t.eql(r3, t.neg(t.ONE));
  if (!o4 && !s3 && !i4) throw new Error("invalid Legendre symbol result");
  return o4 ? 1 : s3 ? 0 : -1;
}
function ac2(t, e2) {
  e2 !== void 0 && mt2(e2);
  const n5 = e2 !== void 0 ? e2 : t.toString(2).length, r3 = Math.ceil(n5 / 8);
  return { nBitLength: n5, nByteLength: r3 };
}
function Yt3(t, e2, n5 = false, r3 = {}) {
  if (t <= ot2) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o4, s3;
  if (typeof e2 == "object" && e2 != null) {
    if (r3.sqrt || n5) throw new Error("cannot specify opts in two arguments");
    const c6 = e2;
    c6.BITS && (o4 = c6.BITS), c6.sqrt && (s3 = c6.sqrt), typeof c6.isLE == "boolean" && (n5 = c6.isLE);
  } else typeof e2 == "number" && (o4 = e2), r3.sqrt && (s3 = r3.sqrt);
  const { nBitLength: i4, nByteLength: f8 } = ac2(t, o4);
  if (f8 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a3;
  const l6 = Object.freeze({ ORDER: t, isLE: n5, BITS: i4, BYTES: f8, MASK: je3(i4), ZERO: ot2, ONE: Q3, create: (c6) => lt3(c6, t), isValid: (c6) => {
    if (typeof c6 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c6);
    return ot2 <= c6 && c6 < t;
  }, is0: (c6) => c6 === ot2, isValidNot0: (c6) => !l6.is0(c6) && l6.isValid(c6), isOdd: (c6) => (c6 & Q3) === Q3, neg: (c6) => lt3(-c6, t), eql: (c6, u2) => c6 === u2, sqr: (c6) => lt3(c6 * c6, t), add: (c6, u2) => lt3(c6 + u2, t), sub: (c6, u2) => lt3(c6 - u2, t), mul: (c6, u2) => lt3(c6 * u2, t), pow: (c6, u2) => cc2(l6, c6, u2), div: (c6, u2) => lt3(c6 * yo3(u2, t), t), sqrN: (c6) => c6 * c6, addN: (c6, u2) => c6 + u2, subN: (c6, u2) => c6 - u2, mulN: (c6, u2) => c6 * u2, inv: (c6) => yo3(c6, t), sqrt: s3 || ((c6) => (a3 || (a3 = sc2(t)), a3(l6, c6))), toBytes: (c6) => n5 ? An3(c6, f8) : In3(c6, f8), fromBytes: (c6) => {
    if (c6.length !== f8) throw new Error("Field.fromBytes: expected " + f8 + " bytes, got " + c6.length);
    return n5 ? Le3(c6) : Ce3(c6);
  }, invertBatch: (c6) => wo3(l6, c6), cmov: (c6, u2, h5) => h5 ? u2 : c6 });
  return Object.freeze(l6);
}
function vo3(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e2 = t.toString(2).length;
  return Math.ceil(e2 / 8);
}
function Eo3(t) {
  const e2 = vo3(t);
  return e2 + Math.ceil(e2 / 2);
}
function uc2(t, e2, n5 = false) {
  const r3 = t.length, o4 = vo3(e2), s3 = Eo3(e2);
  if (r3 < 16 || r3 < s3 || r3 > 1024) throw new Error("expected " + s3 + "-1024 bytes of input, got " + r3);
  const i4 = n5 ? Le3(t) : Ce3(t), f8 = lt3(i4, e2 - Q3) + Q3;
  return n5 ? An3(f8, o4) : In3(f8, o4);
}
var Xt3 = BigInt(0);
var Mt3 = BigInt(1);
function le3(t, e2) {
  const n5 = e2.negate();
  return t ? n5 : e2;
}
function lc2(t, e2, n5) {
  const r3 = e2 === "pz" ? (i4) => i4.pz : (i4) => i4.ez, o4 = wo3(t.Fp, n5.map(r3));
  return n5.map((i4, f8) => i4.toAffine(o4[f8])).map(t.fromAffine);
}
function Bo3(t, e2) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e2) throw new Error("invalid window size, expected [1.." + e2 + "], got W=" + t);
}
function On3(t, e2) {
  Bo3(t, e2);
  const n5 = Math.ceil(e2 / t) + 1, r3 = 2 ** (t - 1), o4 = 2 ** t, s3 = je3(t), i4 = BigInt(t);
  return { windows: n5, windowSize: r3, mask: s3, maxNumber: o4, shiftBy: i4 };
}
function Io3(t, e2, n5) {
  const { windowSize: r3, mask: o4, maxNumber: s3, shiftBy: i4 } = n5;
  let f8 = Number(t & o4), a3 = t >> i4;
  f8 > r3 && (f8 -= s3, a3 += Mt3);
  const l6 = e2 * r3, c6 = l6 + Math.abs(f8) - 1, u2 = f8 === 0, h5 = f8 < 0, g3 = e2 % 2 !== 0;
  return { nextN: a3, offset: c6, isZero: u2, isNeg: h5, isNegF: g3, offsetF: l6 };
}
function dc2(t, e2) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n5, r3) => {
    if (!(n5 instanceof e2)) throw new Error("invalid point at index " + r3);
  });
}
function hc2(t, e2) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n5, r3) => {
    if (!e2.isValid(n5)) throw new Error("invalid scalar at index " + r3);
  });
}
var Un3 = /* @__PURE__ */ new WeakMap();
var Ao3 = /* @__PURE__ */ new WeakMap();
function _n3(t) {
  return Ao3.get(t) || 1;
}
function So3(t) {
  if (t !== Xt3) throw new Error("invalid wNAF");
}
function pc2(t, e2) {
  return { constTimeNegate: le3, hasPrecomputes(n5) {
    return _n3(n5) !== 1;
  }, unsafeLadder(n5, r3, o4 = t.ZERO) {
    let s3 = n5;
    for (; r3 > Xt3; ) r3 & Mt3 && (o4 = o4.add(s3)), s3 = s3.double(), r3 >>= Mt3;
    return o4;
  }, precomputeWindow(n5, r3) {
    const { windows: o4, windowSize: s3 } = On3(r3, e2), i4 = [];
    let f8 = n5, a3 = f8;
    for (let l6 = 0; l6 < o4; l6++) {
      a3 = f8, i4.push(a3);
      for (let c6 = 1; c6 < s3; c6++) a3 = a3.add(f8), i4.push(a3);
      f8 = a3.double();
    }
    return i4;
  }, wNAF(n5, r3, o4) {
    let s3 = t.ZERO, i4 = t.BASE;
    const f8 = On3(n5, e2);
    for (let a3 = 0; a3 < f8.windows; a3++) {
      const { nextN: l6, offset: c6, isZero: u2, isNeg: h5, isNegF: g3, offsetF: w4 } = Io3(o4, a3, f8);
      o4 = l6, u2 ? i4 = i4.add(le3(g3, r3[w4])) : s3 = s3.add(le3(h5, r3[c6]));
    }
    return So3(o4), { p: s3, f: i4 };
  }, wNAFUnsafe(n5, r3, o4, s3 = t.ZERO) {
    const i4 = On3(n5, e2);
    for (let f8 = 0; f8 < i4.windows && o4 !== Xt3; f8++) {
      const { nextN: a3, offset: l6, isZero: c6, isNeg: u2 } = Io3(o4, f8, i4);
      if (o4 = a3, !c6) {
        const h5 = r3[l6];
        s3 = s3.add(u2 ? h5.negate() : h5);
      }
    }
    return So3(o4), s3;
  }, getPrecomputes(n5, r3, o4) {
    let s3 = Un3.get(r3);
    return s3 || (s3 = this.precomputeWindow(r3, n5), n5 !== 1 && (typeof o4 == "function" && (s3 = o4(s3)), Un3.set(r3, s3))), s3;
  }, wNAFCached(n5, r3, o4) {
    const s3 = _n3(n5);
    return this.wNAF(s3, this.getPrecomputes(s3, n5, o4), r3);
  }, wNAFCachedUnsafe(n5, r3, o4, s3) {
    const i4 = _n3(n5);
    return i4 === 1 ? this.unsafeLadder(n5, r3, s3) : this.wNAFUnsafe(i4, this.getPrecomputes(i4, n5, o4), r3, s3);
  }, setWindowSize(n5, r3) {
    Bo3(r3, e2), Ao3.set(n5, r3), Un3.delete(n5);
  } };
}
function gc2(t, e2, n5, r3) {
  let o4 = e2, s3 = t.ZERO, i4 = t.ZERO;
  for (; n5 > Xt3 || r3 > Xt3; ) n5 & Mt3 && (s3 = s3.add(o4)), r3 & Mt3 && (i4 = i4.add(o4)), o4 = o4.double(), n5 >>= Mt3, r3 >>= Mt3;
  return { p1: s3, p2: i4 };
}
function bc2(t, e2, n5, r3) {
  dc2(n5, t), hc2(r3, e2);
  const o4 = n5.length, s3 = r3.length;
  if (o4 !== s3) throw new Error("arrays of points and scalars must have equal length");
  const i4 = t.ZERO, f8 = tc2(BigInt(o4));
  let a3 = 1;
  f8 > 12 ? a3 = f8 - 3 : f8 > 4 ? a3 = f8 - 2 : f8 > 0 && (a3 = 2);
  const l6 = je3(a3), c6 = new Array(Number(l6) + 1).fill(i4), u2 = Math.floor((e2.BITS - 1) / a3) * a3;
  let h5 = i4;
  for (let g3 = u2; g3 >= 0; g3 -= a3) {
    c6.fill(i4);
    for (let y5 = 0; y5 < s3; y5++) {
      const x5 = r3[y5], R3 = Number(x5 >> BigInt(g3) & l6);
      c6[R3] = c6[R3].add(n5[y5]);
    }
    let w4 = i4;
    for (let y5 = c6.length - 1, x5 = i4; y5 > 0; y5--) x5 = x5.add(c6[y5]), w4 = w4.add(x5);
    if (h5 = h5.add(w4), g3 !== 0) for (let y5 = 0; y5 < a3; y5++) h5 = h5.double();
  }
  return h5;
}
function No3(t, e2) {
  if (e2) {
    if (e2.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc2(e2), e2;
  } else return Yt3(t);
}
function yc2(t, e2, n5 = {}) {
  if (!e2 || typeof e2 != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f8 of ["p", "n", "h"]) {
    const a3 = e2[f8];
    if (!(typeof a3 == "bigint" && a3 > Xt3)) throw new Error(`CURVE.${f8} must be positive bigint`);
  }
  const r3 = No3(e2.p, n5.Fp), o4 = No3(e2.n, n5.Fn), i4 = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f8 of i4) if (!r3.isValid(e2[f8])) throw new Error(`CURVE.${f8} must be valid field element of CURVE.Fp`);
  return { Fp: r3, Fn: o4 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de3 = BigInt(0);
var Jt3 = BigInt(1);
var Pe3 = BigInt(2);
function mc2(t) {
  return ke3(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function wc2(t) {
  const e2 = mc2(t), { P: n5, type: r3, adjustScalarBytes: o4, powPminus2: s3, randomBytes: i4 } = e2, f8 = r3 === "x25519";
  if (!f8 && r3 !== "x448") throw new Error("invalid type");
  const a3 = i4 || Zt3, l6 = f8 ? 255 : 448, c6 = f8 ? 32 : 56, u2 = BigInt(f8 ? 9 : 5), h5 = BigInt(f8 ? 121665 : 39081), g3 = f8 ? Pe3 ** BigInt(254) : Pe3 ** BigInt(447), w4 = f8 ? BigInt(8) * Pe3 ** BigInt(251) - Jt3 : BigInt(4) * Pe3 ** BigInt(445) - Jt3, y5 = g3 + w4 + Jt3, x5 = (d4) => lt3(d4, n5), R3 = M4(u2);
  function M4(d4) {
    return An3(x5(d4), c6);
  }
  function L3(d4) {
    const m3 = rt3("u coordinate", d4, c6);
    return f8 && (m3[31] &= 127), x5(Le3(m3));
  }
  function V3(d4) {
    return Le3(o4(rt3("scalar", d4, c6)));
  }
  function _3(d4, m3) {
    const p4 = $3(L3(m3), V3(d4));
    if (p4 === de3) throw new Error("invalid private or public key received");
    return M4(p4);
  }
  function k6(d4) {
    return _3(d4, R3);
  }
  function j3(d4, m3, p4) {
    const b4 = x5(d4 * (m3 - p4));
    return m3 = x5(m3 - b4), p4 = x5(p4 + b4), { x_2: m3, x_3: p4 };
  }
  function $3(d4, m3) {
    Nn3("u", d4, de3, n5), Nn3("scalar", m3, g3, y5);
    const p4 = m3, b4 = d4;
    let v6 = Jt3, B3 = de3, E4 = d4, I4 = Jt3, S4 = de3;
    for (let A4 = BigInt(l6 - 1); A4 >= de3; A4--) {
      const T3 = p4 >> A4 & Jt3;
      S4 ^= T3, { x_2: v6, x_3: E4 } = j3(S4, v6, E4), { x_2: B3, x_3: I4 } = j3(S4, B3, I4), S4 = T3;
      const U3 = v6 + B3, C4 = x5(U3 * U3), H2 = v6 - B3, q = x5(H2 * H2), P4 = C4 - q, K4 = E4 + I4, et = E4 - I4, Z2 = x5(et * U3), z4 = x5(K4 * H2), Ft3 = Z2 + z4, yt3 = Z2 - z4;
      E4 = x5(Ft3 * Ft3), I4 = x5(b4 * x5(yt3 * yt3)), v6 = x5(C4 * q), B3 = x5(P4 * (C4 + x5(h5 * P4)));
    }
    ({ x_2: v6, x_3: E4 } = j3(S4, v6, E4)), { x_2: B3, x_3: I4 } = j3(S4, B3, I4);
    const O5 = s3(B3);
    return x5(v6 * O5);
  }
  return { scalarMult: _3, scalarMultBase: k6, getSharedSecret: (d4, m3) => _3(d4, m3), getPublicKey: (d4) => k6(d4), utils: { randomPrivateKey: () => a3(c6) }, GuBytes: R3.slice() };
}
BigInt(0);
var xc2 = BigInt(1);
var Oo3 = BigInt(2);
var vc2 = BigInt(3);
var Ec2 = BigInt(5);
var Bc2 = BigInt(8);
var Uo3 = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc2, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic2(t) {
  const e2 = BigInt(10), n5 = BigInt(20), r3 = BigInt(40), o4 = BigInt(80), s3 = Uo3.p, f8 = t * t % s3 * t % s3, a3 = pt2(f8, Oo3, s3) * f8 % s3, l6 = pt2(a3, xc2, s3) * t % s3, c6 = pt2(l6, Ec2, s3) * l6 % s3, u2 = pt2(c6, e2, s3) * c6 % s3, h5 = pt2(u2, n5, s3) * u2 % s3, g3 = pt2(h5, r3, s3) * h5 % s3, w4 = pt2(g3, o4, s3) * g3 % s3, y5 = pt2(w4, o4, s3) * g3 % s3, x5 = pt2(y5, e2, s3) * c6 % s3;
  return { pow_p_5_8: pt2(x5, Oo3, s3) * t % s3, b2: f8 };
}
function Ac2(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Tn3 = (() => {
  const t = Uo3.p;
  return wc2({ P: t, type: "x25519", powPminus2: (e2) => {
    const { pow_p_5_8: n5, b2: r3 } = Ic2(e2);
    return lt3(pt2(n5, vc2, t) * r3, t);
  }, adjustScalarBytes: Ac2 });
})();
function _o3(t) {
  t.lowS !== void 0 && Re3("lowS", t.lowS), t.prehash !== void 0 && Re3("prehash", t.prehash);
}
var Sc2 = class extends Error {
  constructor(e2 = "") {
    super(e2);
  }
};
var vt3 = { Err: Sc2, _tlv: { encode: (t, e2) => {
  const { Err: n5 } = vt3;
  if (t < 0 || t > 256) throw new n5("tlv.encode: wrong tag");
  if (e2.length & 1) throw new n5("tlv.encode: unpadded data");
  const r3 = e2.length / 2, o4 = $e3(r3);
  if (o4.length / 2 & 128) throw new n5("tlv.encode: long form length too big");
  const s3 = r3 > 127 ? $e3(o4.length / 2 | 128) : "";
  return $e3(t) + s3 + o4 + e2;
}, decode(t, e2) {
  const { Err: n5 } = vt3;
  let r3 = 0;
  if (t < 0 || t > 256) throw new n5("tlv.encode: wrong tag");
  if (e2.length < 2 || e2[r3++] !== t) throw new n5("tlv.decode: wrong tlv");
  const o4 = e2[r3++], s3 = !!(o4 & 128);
  let i4 = 0;
  if (!s3) i4 = o4;
  else {
    const a3 = o4 & 127;
    if (!a3) throw new n5("tlv.decode(long): indefinite length not supported");
    if (a3 > 4) throw new n5("tlv.decode(long): byte length is too big");
    const l6 = e2.subarray(r3, r3 + a3);
    if (l6.length !== a3) throw new n5("tlv.decode: length bytes not complete");
    if (l6[0] === 0) throw new n5("tlv.decode(long): zero leftmost byte");
    for (const c6 of l6) i4 = i4 << 8 | c6;
    if (r3 += a3, i4 < 128) throw new n5("tlv.decode(long): not minimal encoding");
  }
  const f8 = e2.subarray(r3, r3 + i4);
  if (f8.length !== i4) throw new n5("tlv.decode: wrong value length");
  return { v: f8, l: e2.subarray(r3 + i4) };
} }, _int: { encode(t) {
  const { Err: e2 } = vt3;
  if (t < he3) throw new e2("integer: negative integers are not allowed");
  let n5 = $e3(t);
  if (Number.parseInt(n5[0], 16) & 8 && (n5 = "00" + n5), n5.length & 1) throw new e2("unexpected DER parsing assertion: unpadded hex");
  return n5;
}, decode(t) {
  const { Err: e2 } = vt3;
  if (t[0] & 128) throw new e2("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e2("invalid signature integer: unnecessary leading zero");
  return Ce3(t);
} }, toSig(t) {
  const { Err: e2, _int: n5, _tlv: r3 } = vt3, o4 = rt3("signature", t), { v: s3, l: i4 } = r3.decode(48, o4);
  if (i4.length) throw new e2("invalid signature: left bytes after parsing");
  const { v: f8, l: a3 } = r3.decode(2, s3), { v: l6, l: c6 } = r3.decode(2, a3);
  if (c6.length) throw new e2("invalid signature: left bytes after parsing");
  return { r: n5.decode(f8), s: n5.decode(l6) };
}, hexFromSig(t) {
  const { _tlv: e2, _int: n5 } = vt3, r3 = e2.encode(2, n5.encode(t.r)), o4 = e2.encode(2, n5.encode(t.s)), s3 = r3 + o4;
  return e2.encode(48, s3);
} };
var he3 = BigInt(0);
var pe3 = BigInt(1);
var Nc2 = BigInt(2);
var He3 = BigInt(3);
var Oc2 = BigInt(4);
function Uc2(t, e2, n5) {
  function r3(o4) {
    const s3 = t.sqr(o4), i4 = t.mul(s3, o4);
    return t.add(t.add(i4, t.mul(o4, e2)), n5);
  }
  return r3;
}
function To3(t, e2, n5) {
  const { BYTES: r3 } = t;
  function o4(s3) {
    let i4;
    if (typeof s3 == "bigint") i4 = s3;
    else {
      let f8 = rt3("private key", s3);
      if (e2) {
        if (!e2.includes(f8.length * 2)) throw new Error("invalid private key");
        const a3 = new Uint8Array(r3);
        a3.set(f8, a3.length - f8.length), f8 = a3;
      }
      try {
        i4 = t.fromBytes(f8);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r3}, got ${typeof s3}`);
      }
    }
    if (n5 && (i4 = t.create(i4)), !t.isValidNot0(i4)) throw new Error("invalid private key: out of range [1..N-1]");
    return i4;
  }
  return o4;
}
function _c2(t, e2 = {}) {
  const { Fp: n5, Fn: r3 } = yc2("weierstrass", t, e2), { h: o4, n: s3 } = t;
  ke3(e2, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i4 } = e2;
  if (i4 && (!n5.is0(t.a) || typeof i4.beta != "bigint" || typeof i4.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f8() {
    if (!n5.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a3($3, d4, m3) {
    const { x: p4, y: b4 } = d4.toAffine(), v6 = n5.toBytes(p4);
    if (Re3("isCompressed", m3), m3) {
      f8();
      const B3 = !n5.isOdd(b4);
      return Ht3(Ro3(B3), v6);
    } else return Ht3(Uint8Array.of(4), v6, n5.toBytes(b4));
  }
  function l6($3) {
    at2($3);
    const d4 = n5.BYTES, m3 = d4 + 1, p4 = 2 * d4 + 1, b4 = $3.length, v6 = $3[0], B3 = $3.subarray(1);
    if (b4 === m3 && (v6 === 2 || v6 === 3)) {
      const E4 = n5.fromBytes(B3);
      if (!n5.isValid(E4)) throw new Error("bad point: is not on curve, wrong x");
      const I4 = h5(E4);
      let S4;
      try {
        S4 = n5.sqrt(I4);
      } catch (T3) {
        const U3 = T3 instanceof Error ? ": " + T3.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U3);
      }
      f8();
      const O5 = n5.isOdd(S4);
      return (v6 & 1) === 1 !== O5 && (S4 = n5.neg(S4)), { x: E4, y: S4 };
    } else if (b4 === p4 && v6 === 4) {
      const E4 = n5.fromBytes(B3.subarray(d4 * 0, d4 * 1)), I4 = n5.fromBytes(B3.subarray(d4 * 1, d4 * 2));
      if (!g3(E4, I4)) throw new Error("bad point: is not on curve");
      return { x: E4, y: I4 };
    } else throw new Error(`bad point: got length ${b4}, expected compressed=${m3} or uncompressed=${p4}`);
  }
  const c6 = e2.toBytes || a3, u2 = e2.fromBytes || l6, h5 = Uc2(n5, t.a, t.b);
  function g3($3, d4) {
    const m3 = n5.sqr(d4), p4 = h5($3);
    return n5.eql(m3, p4);
  }
  if (!g3(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
  const w4 = n5.mul(n5.pow(t.a, He3), Oc2), y5 = n5.mul(n5.sqr(t.b), BigInt(27));
  if (n5.is0(n5.add(w4, y5))) throw new Error("bad curve params: a or b");
  function x5($3, d4, m3 = false) {
    if (!n5.isValid(d4) || m3 && n5.is0(d4)) throw new Error(`bad point coordinate ${$3}`);
    return d4;
  }
  function R3($3) {
    if (!($3 instanceof _3)) throw new Error("ProjectivePoint expected");
  }
  const M4 = ho3(($3, d4) => {
    const { px: m3, py: p4, pz: b4 } = $3;
    if (n5.eql(b4, n5.ONE)) return { x: m3, y: p4 };
    const v6 = $3.is0();
    d4 == null && (d4 = v6 ? n5.ONE : n5.inv(b4));
    const B3 = n5.mul(m3, d4), E4 = n5.mul(p4, d4), I4 = n5.mul(b4, d4);
    if (v6) return { x: n5.ZERO, y: n5.ZERO };
    if (!n5.eql(I4, n5.ONE)) throw new Error("invZ was invalid");
    return { x: B3, y: E4 };
  }), L3 = ho3(($3) => {
    if ($3.is0()) {
      if (e2.allowInfinityPoint && !n5.is0($3.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d4, y: m3 } = $3.toAffine();
    if (!n5.isValid(d4) || !n5.isValid(m3)) throw new Error("bad point: x or y not field elements");
    if (!g3(d4, m3)) throw new Error("bad point: equation left != right");
    if (!$3.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V3($3, d4, m3, p4, b4) {
    return m3 = new _3(n5.mul(m3.px, $3), m3.py, m3.pz), d4 = le3(p4, d4), m3 = le3(b4, m3), d4.add(m3);
  }
  class _3 {
    constructor(d4, m3, p4) {
      this.px = x5("x", d4), this.py = x5("y", m3, true), this.pz = x5("z", p4), Object.freeze(this);
    }
    static fromAffine(d4) {
      const { x: m3, y: p4 } = d4 || {};
      if (!d4 || !n5.isValid(m3) || !n5.isValid(p4)) throw new Error("invalid affine point");
      if (d4 instanceof _3) throw new Error("projective point not allowed");
      return n5.is0(m3) && n5.is0(p4) ? _3.ZERO : new _3(m3, p4, n5.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d4) {
      return lc2(_3, "pz", d4);
    }
    static fromBytes(d4) {
      return at2(d4), _3.fromHex(d4);
    }
    static fromHex(d4) {
      const m3 = _3.fromAffine(u2(rt3("pointHex", d4)));
      return m3.assertValidity(), m3;
    }
    static fromPrivateKey(d4) {
      const m3 = To3(r3, e2.allowedPrivateKeyLengths, e2.wrapPrivateKey);
      return _3.BASE.multiply(m3(d4));
    }
    static msm(d4, m3) {
      return bc2(_3, r3, d4, m3);
    }
    precompute(d4 = 8, m3 = true) {
      return j3.setWindowSize(this, d4), m3 || this.multiply(He3), this;
    }
    _setWindowSize(d4) {
      this.precompute(d4);
    }
    assertValidity() {
      L3(this);
    }
    hasEvenY() {
      const { y: d4 } = this.toAffine();
      if (!n5.isOdd) throw new Error("Field doesn't support isOdd");
      return !n5.isOdd(d4);
    }
    equals(d4) {
      R3(d4);
      const { px: m3, py: p4, pz: b4 } = this, { px: v6, py: B3, pz: E4 } = d4, I4 = n5.eql(n5.mul(m3, E4), n5.mul(v6, b4)), S4 = n5.eql(n5.mul(p4, E4), n5.mul(B3, b4));
      return I4 && S4;
    }
    negate() {
      return new _3(this.px, n5.neg(this.py), this.pz);
    }
    double() {
      const { a: d4, b: m3 } = t, p4 = n5.mul(m3, He3), { px: b4, py: v6, pz: B3 } = this;
      let E4 = n5.ZERO, I4 = n5.ZERO, S4 = n5.ZERO, O5 = n5.mul(b4, b4), A4 = n5.mul(v6, v6), T3 = n5.mul(B3, B3), U3 = n5.mul(b4, v6);
      return U3 = n5.add(U3, U3), S4 = n5.mul(b4, B3), S4 = n5.add(S4, S4), E4 = n5.mul(d4, S4), I4 = n5.mul(p4, T3), I4 = n5.add(E4, I4), E4 = n5.sub(A4, I4), I4 = n5.add(A4, I4), I4 = n5.mul(E4, I4), E4 = n5.mul(U3, E4), S4 = n5.mul(p4, S4), T3 = n5.mul(d4, T3), U3 = n5.sub(O5, T3), U3 = n5.mul(d4, U3), U3 = n5.add(U3, S4), S4 = n5.add(O5, O5), O5 = n5.add(S4, O5), O5 = n5.add(O5, T3), O5 = n5.mul(O5, U3), I4 = n5.add(I4, O5), T3 = n5.mul(v6, B3), T3 = n5.add(T3, T3), O5 = n5.mul(T3, U3), E4 = n5.sub(E4, O5), S4 = n5.mul(T3, A4), S4 = n5.add(S4, S4), S4 = n5.add(S4, S4), new _3(E4, I4, S4);
    }
    add(d4) {
      R3(d4);
      const { px: m3, py: p4, pz: b4 } = this, { px: v6, py: B3, pz: E4 } = d4;
      let I4 = n5.ZERO, S4 = n5.ZERO, O5 = n5.ZERO;
      const A4 = t.a, T3 = n5.mul(t.b, He3);
      let U3 = n5.mul(m3, v6), C4 = n5.mul(p4, B3), H2 = n5.mul(b4, E4), q = n5.add(m3, p4), P4 = n5.add(v6, B3);
      q = n5.mul(q, P4), P4 = n5.add(U3, C4), q = n5.sub(q, P4), P4 = n5.add(m3, b4);
      let K4 = n5.add(v6, E4);
      return P4 = n5.mul(P4, K4), K4 = n5.add(U3, H2), P4 = n5.sub(P4, K4), K4 = n5.add(p4, b4), I4 = n5.add(B3, E4), K4 = n5.mul(K4, I4), I4 = n5.add(C4, H2), K4 = n5.sub(K4, I4), O5 = n5.mul(A4, P4), I4 = n5.mul(T3, H2), O5 = n5.add(I4, O5), I4 = n5.sub(C4, O5), O5 = n5.add(C4, O5), S4 = n5.mul(I4, O5), C4 = n5.add(U3, U3), C4 = n5.add(C4, U3), H2 = n5.mul(A4, H2), P4 = n5.mul(T3, P4), C4 = n5.add(C4, H2), H2 = n5.sub(U3, H2), H2 = n5.mul(A4, H2), P4 = n5.add(P4, H2), U3 = n5.mul(C4, P4), S4 = n5.add(S4, U3), U3 = n5.mul(K4, P4), I4 = n5.mul(q, I4), I4 = n5.sub(I4, U3), U3 = n5.mul(q, C4), O5 = n5.mul(K4, O5), O5 = n5.add(O5, U3), new _3(I4, S4, O5);
    }
    subtract(d4) {
      return this.add(d4.negate());
    }
    is0() {
      return this.equals(_3.ZERO);
    }
    multiply(d4) {
      const { endo: m3 } = e2;
      if (!r3.isValidNot0(d4)) throw new Error("invalid scalar: out of range");
      let p4, b4;
      const v6 = (B3) => j3.wNAFCached(this, B3, _3.normalizeZ);
      if (m3) {
        const { k1neg: B3, k1: E4, k2neg: I4, k2: S4 } = m3.splitScalar(d4), { p: O5, f: A4 } = v6(E4), { p: T3, f: U3 } = v6(S4);
        b4 = A4.add(U3), p4 = V3(m3.beta, O5, T3, B3, I4);
      } else {
        const { p: B3, f: E4 } = v6(d4);
        p4 = B3, b4 = E4;
      }
      return _3.normalizeZ([p4, b4])[0];
    }
    multiplyUnsafe(d4) {
      const { endo: m3 } = e2, p4 = this;
      if (!r3.isValid(d4)) throw new Error("invalid scalar: out of range");
      if (d4 === he3 || p4.is0()) return _3.ZERO;
      if (d4 === pe3) return p4;
      if (j3.hasPrecomputes(this)) return this.multiply(d4);
      if (m3) {
        const { k1neg: b4, k1: v6, k2neg: B3, k2: E4 } = m3.splitScalar(d4), { p1: I4, p2: S4 } = gc2(_3, p4, v6, E4);
        return V3(m3.beta, I4, S4, b4, B3);
      } else return j3.wNAFCachedUnsafe(p4, d4);
    }
    multiplyAndAddUnsafe(d4, m3, p4) {
      const b4 = this.multiplyUnsafe(m3).add(d4.multiplyUnsafe(p4));
      return b4.is0() ? void 0 : b4;
    }
    toAffine(d4) {
      return M4(this, d4);
    }
    isTorsionFree() {
      const { isTorsionFree: d4 } = e2;
      return o4 === pe3 ? true : d4 ? d4(_3, this) : j3.wNAFCachedUnsafe(this, s3).is0();
    }
    clearCofactor() {
      const { clearCofactor: d4 } = e2;
      return o4 === pe3 ? this : d4 ? d4(_3, this) : this.multiplyUnsafe(o4);
    }
    toBytes(d4 = true) {
      return Re3("isCompressed", d4), this.assertValidity(), c6(_3, this, d4);
    }
    toRawBytes(d4 = true) {
      return this.toBytes(d4);
    }
    toHex(d4 = true) {
      return ce2(this.toBytes(d4));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _3.BASE = new _3(t.Gx, t.Gy, n5.ONE), _3.ZERO = new _3(n5.ZERO, n5.ONE, n5.ZERO), _3.Fp = n5, _3.Fn = r3;
  const k6 = r3.BITS, j3 = pc2(_3, e2.endo ? Math.ceil(k6 / 2) : k6);
  return _3;
}
function Ro3(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Tc2(t, e2, n5 = {}) {
  ke3(e2, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r3 = e2.randomBytes || Zt3, o4 = e2.hmac || ((p4, ...b4) => _e3(e2.hash, p4, Ht3(...b4))), { Fp: s3, Fn: i4 } = t, { ORDER: f8, BITS: a3 } = i4;
  function l6(p4) {
    const b4 = f8 >> pe3;
    return p4 > b4;
  }
  function c6(p4) {
    return l6(p4) ? i4.neg(p4) : p4;
  }
  function u2(p4, b4) {
    if (!i4.isValidNot0(b4)) throw new Error(`invalid signature ${p4}: out of range 1..CURVE.n`);
  }
  class h5 {
    constructor(b4, v6, B3) {
      u2("r", b4), u2("s", v6), this.r = b4, this.s = v6, B3 != null && (this.recovery = B3), Object.freeze(this);
    }
    static fromCompact(b4) {
      const v6 = i4.BYTES, B3 = rt3("compactSignature", b4, v6 * 2);
      return new h5(i4.fromBytes(B3.subarray(0, v6)), i4.fromBytes(B3.subarray(v6, v6 * 2)));
    }
    static fromDER(b4) {
      const { r: v6, s: B3 } = vt3.toSig(rt3("DER", b4));
      return new h5(v6, B3);
    }
    assertValidity() {
    }
    addRecoveryBit(b4) {
      return new h5(this.r, this.s, b4);
    }
    recoverPublicKey(b4) {
      const v6 = s3.ORDER, { r: B3, s: E4, recovery: I4 } = this;
      if (I4 == null || ![0, 1, 2, 3].includes(I4)) throw new Error("recovery id invalid");
      if (f8 * Nc2 < v6 && I4 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O5 = I4 === 2 || I4 === 3 ? B3 + f8 : B3;
      if (!s3.isValid(O5)) throw new Error("recovery id 2 or 3 invalid");
      const A4 = s3.toBytes(O5), T3 = t.fromHex(Ht3(Ro3((I4 & 1) === 0), A4)), U3 = i4.inv(O5), C4 = L3(rt3("msgHash", b4)), H2 = i4.create(-C4 * U3), q = i4.create(E4 * U3), P4 = t.BASE.multiplyUnsafe(H2).add(T3.multiplyUnsafe(q));
      if (P4.is0()) throw new Error("point at infinify");
      return P4.assertValidity(), P4;
    }
    hasHighS() {
      return l6(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h5(this.r, i4.neg(this.s), this.recovery) : this;
    }
    toBytes(b4) {
      if (b4 === "compact") return Ht3(i4.toBytes(this.r), i4.toBytes(this.s));
      if (b4 === "der") return fn2(vt3.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce2(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce2(this.toBytes("compact"));
    }
  }
  const g3 = To3(i4, n5.allowedPrivateKeyLengths, n5.wrapPrivateKey), w4 = { isValidPrivateKey(p4) {
    try {
      return g3(p4), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g3, randomPrivateKey: () => {
    const p4 = f8;
    return uc2(r3(Eo3(p4)), p4);
  }, precompute(p4 = 8, b4 = t.BASE) {
    return b4.precompute(p4, false);
  } };
  function y5(p4, b4 = true) {
    return t.fromPrivateKey(p4).toBytes(b4);
  }
  function x5(p4) {
    if (typeof p4 == "bigint") return false;
    if (p4 instanceof t) return true;
    const v6 = rt3("key", p4).length, B3 = s3.BYTES, E4 = B3 + 1, I4 = 2 * B3 + 1;
    if (!(n5.allowedPrivateKeyLengths || i4.BYTES === E4)) return v6 === E4 || v6 === I4;
  }
  function R3(p4, b4, v6 = true) {
    if (x5(p4) === true) throw new Error("first arg must be private key");
    if (x5(b4) === false) throw new Error("second arg must be public key");
    return t.fromHex(b4).multiply(g3(p4)).toBytes(v6);
  }
  const M4 = e2.bits2int || function(p4) {
    if (p4.length > 8192) throw new Error("input is too large");
    const b4 = Ce3(p4), v6 = p4.length * 8 - a3;
    return v6 > 0 ? b4 >> BigInt(v6) : b4;
  }, L3 = e2.bits2int_modN || function(p4) {
    return i4.create(M4(p4));
  }, V3 = je3(a3);
  function _3(p4) {
    return Nn3("num < 2^" + a3, p4, he3, V3), i4.toBytes(p4);
  }
  function k6(p4, b4, v6 = j3) {
    if (["recovered", "canonical"].some((q) => q in v6)) throw new Error("sign() legacy options not supported");
    const { hash: B3 } = e2;
    let { lowS: E4, prehash: I4, extraEntropy: S4 } = v6;
    E4 == null && (E4 = true), p4 = rt3("msgHash", p4), _o3(v6), I4 && (p4 = rt3("prehashed msgHash", B3(p4)));
    const O5 = L3(p4), A4 = g3(b4), T3 = [_3(A4), _3(O5)];
    if (S4 != null && S4 !== false) {
      const q = S4 === true ? r3(s3.BYTES) : S4;
      T3.push(rt3("extraEntropy", q));
    }
    const U3 = Ht3(...T3), C4 = O5;
    function H2(q) {
      const P4 = M4(q);
      if (!i4.isValidNot0(P4)) return;
      const K4 = i4.inv(P4), et = t.BASE.multiply(P4).toAffine(), Z2 = i4.create(et.x);
      if (Z2 === he3) return;
      const z4 = i4.create(K4 * i4.create(C4 + Z2 * A4));
      if (z4 === he3) return;
      let Ft3 = (et.x === Z2 ? 0 : 2) | Number(et.y & pe3), yt3 = z4;
      return E4 && l6(z4) && (yt3 = c6(z4), Ft3 ^= 1), new h5(Z2, yt3, Ft3);
    }
    return { seed: U3, k2sig: H2 };
  }
  const j3 = { lowS: e2.lowS, prehash: false }, $3 = { lowS: e2.lowS, prehash: false };
  function d4(p4, b4, v6 = j3) {
    const { seed: B3, k2sig: E4 } = k6(p4, b4, v6);
    return ec2(e2.hash.outputLen, i4.BYTES, o4)(B3, E4);
  }
  t.BASE.precompute(8);
  function m3(p4, b4, v6, B3 = $3) {
    const E4 = p4;
    b4 = rt3("msgHash", b4), v6 = rt3("publicKey", v6), _o3(B3);
    const { lowS: I4, prehash: S4, format: O5 } = B3;
    if ("strict" in B3) throw new Error("options.strict was renamed to lowS");
    if (O5 !== void 0 && !["compact", "der", "js"].includes(O5)) throw new Error('format must be "compact", "der" or "js"');
    const A4 = typeof E4 == "string" || nn3(E4), T3 = !A4 && !O5 && typeof E4 == "object" && E4 !== null && typeof E4.r == "bigint" && typeof E4.s == "bigint";
    if (!A4 && !T3) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U3, C4;
    try {
      if (T3) if (O5 === void 0 || O5 === "js") U3 = new h5(E4.r, E4.s);
      else throw new Error("invalid format");
      if (A4) {
        try {
          O5 !== "compact" && (U3 = h5.fromDER(E4));
        } catch (yt3) {
          if (!(yt3 instanceof vt3.Err)) throw yt3;
        }
        !U3 && O5 !== "der" && (U3 = h5.fromCompact(E4));
      }
      C4 = t.fromHex(v6);
    } catch {
      return false;
    }
    if (!U3 || I4 && U3.hasHighS()) return false;
    S4 && (b4 = e2.hash(b4));
    const { r: H2, s: q } = U3, P4 = L3(b4), K4 = i4.inv(q), et = i4.create(P4 * K4), Z2 = i4.create(H2 * K4), z4 = t.BASE.multiplyUnsafe(et).add(C4.multiplyUnsafe(Z2));
    return z4.is0() ? false : i4.create(z4.x) === H2;
  }
  return Object.freeze({ getPublicKey: y5, getSharedSecret: R3, sign: d4, verify: m3, utils: w4, Point: t, Signature: h5 });
}
function Rc2(t) {
  const e2 = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n5 = t.Fp, r3 = Yt3(e2.n, t.nBitLength), o4 = { Fp: n5, Fn: r3, allowedPrivateKeyLengths: t.allowedPrivateKeyLengths, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, wrapPrivateKey: t.wrapPrivateKey, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e2, curveOpts: o4 };
}
function $c2(t) {
  const { CURVE: e2, curveOpts: n5 } = Rc2(t), r3 = { hash: t.hash, hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e2, curveOpts: n5, ecdsaOpts: r3 };
}
function Cc2(t, e2) {
  return Object.assign({}, e2, { ProjectivePoint: e2.Point, CURVE: t });
}
function Lc2(t) {
  const { CURVE: e2, curveOpts: n5, ecdsaOpts: r3 } = $c2(t), o4 = _c2(e2, n5), s3 = Tc2(o4, r3, n5);
  return Cc2(t, s3);
}
function Rn3(t, e2) {
  const n5 = (r3) => Lc2({ ...t, hash: r3 });
  return { ...n5(e2), create: n5 };
}
var $o3 = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co3 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo3 = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc2 = Yt3($o3.p);
var kc2 = Yt3(Co3.p);
var Pc2 = Yt3(Lo3.p);
var Hc2 = Rn3({ ...$o3, Fp: jc2, lowS: false }, Ae3);
Rn3({ ...Co3, Fp: kc2, lowS: false }, Yi2), Rn3({ ...Lo3, Fp: Pc2, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi2);
var Dc = Hc2;
var $n2 = "base10";
var tt = "base16";
var Qt2 = "base64pad";
var De2 = "base64url";
var te2 = "utf8";
var Cn2 = 0;
var ee = 1;
var ge2 = 2;
var Mc = 0;
var jo2 = 1;
var be2 = 12;
var Ln2 = 32;
function Vc() {
  const t = Tn3.utils.randomPrivateKey(), e2 = Tn3.getPublicKey(t);
  return { privateKey: toString3(t, tt), publicKey: toString3(e2, tt) };
}
function qc() {
  const t = Zt3(Ln2);
  return toString3(t, tt);
}
function Kc(t, e2) {
  const n5 = Tn3.getSharedSecret(fromString6(t, tt), fromString6(e2, tt)), r3 = Jf(Te2, n5, void 0, void 0, Ln2);
  return toString3(r3, tt);
}
function Fc(t) {
  const e2 = Te2(fromString6(t, tt));
  return toString3(e2, tt);
}
function zc(t) {
  const e2 = Te2(fromString6(t, te2));
  return toString3(e2, tt);
}
function jn2(t) {
  return fromString6(`${t}`, $n2);
}
function Vt2(t) {
  return Number(toString3(t, $n2));
}
function ko2(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Po2(t) {
  const e2 = t.replace(/-/g, "+").replace(/_/g, "/"), n5 = (4 - e2.length % 4) % 4;
  return e2 + "=".repeat(n5);
}
function Gc(t) {
  const e2 = jn2(typeof t.type < "u" ? t.type : Cn2);
  if (Vt2(e2) === ee && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n5 = typeof t.senderPublicKey < "u" ? fromString6(t.senderPublicKey, tt) : void 0, r3 = typeof t.iv < "u" ? fromString6(t.iv, tt) : Zt3(be2), o4 = fromString6(t.symKey, tt), s3 = co3(o4, r3).encrypt(fromString6(t.message, te2)), i4 = kn2({ type: e2, sealed: s3, iv: r3, senderPublicKey: n5 });
  return t.encoding === De2 ? ko2(i4) : i4;
}
function Zc(t) {
  const e2 = fromString6(t.symKey, tt), { sealed: n5, iv: r3 } = Me2({ encoded: t.encoded, encoding: t.encoding }), o4 = co3(e2, r3).decrypt(n5);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString3(o4, te2);
}
function Wc(t, e2) {
  const n5 = jn2(ge2), r3 = Zt3(be2), o4 = fromString6(t, te2), s3 = kn2({ type: n5, sealed: o4, iv: r3 });
  return e2 === De2 ? ko2(s3) : s3;
}
function Yc(t, e2) {
  const { sealed: n5 } = Me2({ encoded: t, encoding: e2 });
  return toString3(n5, te2);
}
function kn2(t) {
  if (Vt2(t.type) === ge2) return toString3(concat4([t.type, t.sealed]), Qt2);
  if (Vt2(t.type) === ee) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString3(concat4([t.type, t.senderPublicKey, t.iv, t.sealed]), Qt2);
  }
  return toString3(concat4([t.type, t.iv, t.sealed]), Qt2);
}
function Me2(t) {
  const e2 = (t.encoding || Qt2) === De2 ? Po2(t.encoded) : t.encoded, n5 = fromString6(e2, Qt2), r3 = n5.slice(Mc, jo2), o4 = jo2;
  if (Vt2(r3) === ee) {
    const a3 = o4 + Ln2, l6 = a3 + be2, c6 = n5.slice(o4, a3), u2 = n5.slice(a3, l6), h5 = n5.slice(l6);
    return { type: r3, sealed: h5, iv: u2, senderPublicKey: c6 };
  }
  if (Vt2(r3) === ge2) {
    const a3 = n5.slice(o4), l6 = Zt3(be2);
    return { type: r3, sealed: a3, iv: l6 };
  }
  const s3 = o4 + be2, i4 = n5.slice(o4, s3), f8 = n5.slice(s3);
  return { type: r3, sealed: f8, iv: i4 };
}
function Xc(t, e2) {
  const n5 = Me2({ encoded: t, encoding: e2 == null ? void 0 : e2.encoding });
  return Ho2({ type: Vt2(n5.type), senderPublicKey: typeof n5.senderPublicKey < "u" ? toString3(n5.senderPublicKey, tt) : void 0, receiverPublicKey: e2 == null ? void 0 : e2.receiverPublicKey });
}
function Ho2(t) {
  const e2 = (t == null ? void 0 : t.type) || Cn2;
  if (e2 === ee) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e2, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Jc(t) {
  return t.type === ee && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Qc(t) {
  return t.type === ge2;
}
function Do2(t) {
  const e2 = Buffer.from(t.x, "base64"), n5 = Buffer.from(t.y, "base64");
  return concat4([new Uint8Array([4]), e2, n5]);
}
function ta(t, e2) {
  const [n5, r3, o4] = t.split("."), s3 = Buffer.from(Po2(o4), "base64");
  if (s3.length !== 64) throw new Error("Invalid signature length");
  const i4 = s3.slice(0, 32), f8 = s3.slice(32, 64), a3 = `${n5}.${r3}`, l6 = Te2(a3), c6 = Do2(e2);
  if (!Dc.verify(concat4([i4, f8]), l6, c6)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var Mo2 = "irn";
function ea(t) {
  return (t == null ? void 0 : t.relay) || { protocol: Mo2 };
}
function na(t) {
  const e2 = C[t];
  if (typeof e2 > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e2;
}
function Vo2(t, e2 = "-") {
  const n5 = {}, r3 = "relay" + e2;
  return Object.keys(t).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s3 = o4.replace(r3, ""), i4 = t[o4];
      n5[s3] = i4;
    }
  }), n5;
}
function ra(t) {
  if (!t.includes("wc:")) {
    const l6 = Qe2(t);
    l6 != null && l6.includes("wc:") && (t = l6);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e2 = t.indexOf(":"), n5 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r3 = t.substring(0, e2), o4 = t.substring(e2 + 1, n5).split("@"), s3 = typeof n5 < "u" ? t.substring(n5) : "", i4 = new URLSearchParams(s3), f8 = {};
  i4.forEach((l6, c6) => {
    f8[c6] = l6;
  });
  const a3 = typeof f8.methods == "string" ? f8.methods.split(",") : void 0;
  return { protocol: r3, topic: qo2(o4[0]), version: parseInt(o4[1], 10), symKey: f8.symKey, relay: Vo2(f8), methods: a3, expiryTimestamp: f8.expiryTimestamp ? parseInt(f8.expiryTimestamp, 10) : void 0 };
}
function qo2(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function Ko2(t, e2 = "-") {
  const n5 = "relay", r3 = {};
  return Object.keys(t).forEach((o4) => {
    const s3 = o4, i4 = n5 + e2 + s3;
    t[s3] && (r3[i4] = t[s3]);
  }), r3;
}
function oa(t) {
  const e2 = new URLSearchParams(), n5 = Ko2(t.relay);
  Object.keys(n5).sort().forEach((o4) => {
    e2.set(o4, n5[o4]);
  }), e2.set("symKey", t.symKey), t.expiryTimestamp && e2.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e2.set("methods", t.methods.join(","));
  const r3 = e2.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r3}`;
}
function sa(t, e2, n5) {
  return `${t}?wc_ev=${n5}&topic=${e2}`;
}
var ia = Object.defineProperty;
var fa = Object.defineProperties;
var ca = Object.getOwnPropertyDescriptors;
var Fo2 = Object.getOwnPropertySymbols;
var aa = Object.prototype.hasOwnProperty;
var ua = Object.prototype.propertyIsEnumerable;
var zo2 = (t, e2, n5) => e2 in t ? ia(t, e2, { enumerable: true, configurable: true, writable: true, value: n5 }) : t[e2] = n5;
var la = (t, e2) => {
  for (var n5 in e2 || (e2 = {})) aa.call(e2, n5) && zo2(t, n5, e2[n5]);
  if (Fo2) for (var n5 of Fo2(e2)) ua.call(e2, n5) && zo2(t, n5, e2[n5]);
  return t;
};
var da = (t, e2) => fa(t, ca(e2));
function qt2(t) {
  const e2 = [];
  return t.forEach((n5) => {
    const [r3, o4] = n5.split(":");
    e2.push(`${r3}:${o4}`);
  }), e2;
}
function Go2(t) {
  const e2 = [];
  return Object.values(t).forEach((n5) => {
    e2.push(...qt2(n5.accounts));
  }), e2;
}
function Zo2(t, e2) {
  const n5 = [];
  return Object.values(t).forEach((r3) => {
    qt2(r3.accounts).includes(e2) && n5.push(...r3.methods);
  }), n5;
}
function Wo2(t, e2) {
  const n5 = [];
  return Object.values(t).forEach((r3) => {
    qt2(r3.accounts).includes(e2) && n5.push(...r3.events);
  }), n5;
}
function Pn2(t) {
  return t.includes(":");
}
function Yo2(t) {
  return Pn2(t) ? t.split(":")[0] : t;
}
function ye2(t) {
  var e2, n5, r3;
  const o4 = {};
  if (!Ve2(t)) return o4;
  for (const [s3, i4] of Object.entries(t)) {
    const f8 = Pn2(s3) ? [s3] : i4.chains, a3 = i4.methods || [], l6 = i4.events || [], c6 = Yo2(s3);
    o4[c6] = da(la({}, o4[c6]), { chains: ct2(f8, (e2 = o4[c6]) == null ? void 0 : e2.chains), methods: ct2(a3, (n5 = o4[c6]) == null ? void 0 : n5.methods), events: ct2(l6, (r3 = o4[c6]) == null ? void 0 : r3.events) });
  }
  return o4;
}
function Xo(t) {
  const e2 = {};
  return t == null ? void 0 : t.forEach((n5) => {
    var r3;
    const [o4, s3] = n5.split(":");
    e2[o4] || (e2[o4] = { accounts: [], chains: [], events: [], methods: [] }), e2[o4].accounts.push(n5), (r3 = e2[o4].chains) == null || r3.push(`${o4}:${s3}`);
  }), e2;
}
function ga(t, e2) {
  e2 = e2.map((r3) => r3.replace("did:pkh:", ""));
  const n5 = Xo(e2);
  for (const [r3, o4] of Object.entries(n5)) o4.methods ? o4.methods = ct2(o4.methods, t) : o4.methods = t, o4.events = ["chainChanged", "accountsChanged"];
  return n5;
}
function ba(t, e2) {
  var n5, r3, o4, s3, i4, f8;
  const a3 = ye2(t), l6 = ye2(e2), c6 = {}, u2 = Object.keys(a3).concat(Object.keys(l6));
  for (const h5 of u2) c6[h5] = { chains: ct2((n5 = a3[h5]) == null ? void 0 : n5.chains, (r3 = l6[h5]) == null ? void 0 : r3.chains), methods: ct2((o4 = a3[h5]) == null ? void 0 : o4.methods, (s3 = l6[h5]) == null ? void 0 : s3.methods), events: ct2((i4 = a3[h5]) == null ? void 0 : i4.events, (f8 = l6[h5]) == null ? void 0 : f8.events) };
  return c6;
}
var Jo3 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Qo2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function Et2(t, e2) {
  const { message: n5, code: r3 } = Qo2[t];
  return { message: e2 ? `${n5} ${e2}` : n5, code: r3 };
}
function Kt2(t, e2) {
  const { message: n5, code: r3 } = Jo3[t];
  return { message: e2 ? `${n5} ${e2}` : n5, code: r3 };
}
function me2(t, e2) {
  return Array.isArray(t) ? typeof e2 < "u" && t.length ? t.every(e2) : true : false;
}
function Ve2(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function kt2(t) {
  return typeof t > "u";
}
function it2(t, e2) {
  return e2 && kt2(t) ? true : typeof t == "string" && !!t.trim().length;
}
function qe2(t, e2) {
  return e2 && kt2(t) ? true : typeof t == "number" && !isNaN(t);
}
function ya(t, e2) {
  const { requiredNamespaces: n5 } = e2, r3 = Object.keys(t.namespaces), o4 = Object.keys(n5);
  let s3 = true;
  return It2(o4, r3) ? (r3.forEach((i4) => {
    const { accounts: f8, methods: a3, events: l6 } = t.namespaces[i4], c6 = qt2(f8), u2 = n5[i4];
    (!It2(ve2(i4, u2), c6) || !It2(u2.methods, a3) || !It2(u2.events, l6)) && (s3 = false);
  }), s3) : false;
}
function we2(t) {
  return it2(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function ts(t) {
  if (it2(t, false) && t.includes(":")) {
    const e2 = t.split(":");
    if (e2.length === 3) {
      const n5 = e2[0] + ":" + e2[1];
      return !!e2[2] && we2(n5);
    }
  }
  return false;
}
function ma(t) {
  function e2(n5) {
    try {
      return typeof new URL(n5) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (it2(t, false)) {
      if (e2(t)) return true;
      const n5 = Qe2(t);
      return e2(n5);
    }
  } catch {
  }
  return false;
}
function wa(t) {
  var e2;
  return (e2 = t == null ? void 0 : t.proposer) == null ? void 0 : e2.publicKey;
}
function xa(t) {
  return t == null ? void 0 : t.topic;
}
function va(t, e2) {
  let n5 = null;
  return it2(t == null ? void 0 : t.publicKey, false) || (n5 = Et2("MISSING_OR_INVALID", `${e2} controller public key should be a string`)), n5;
}
function Hn2(t) {
  let e2 = true;
  return me2(t) ? t.length && (e2 = t.every((n5) => it2(n5, false))) : e2 = false, e2;
}
function es(t, e2, n5) {
  let r3 = null;
  return me2(e2) && e2.length ? e2.forEach((o4) => {
    r3 || we2(o4) || (r3 = Kt2("UNSUPPORTED_CHAINS", `${n5}, chain ${o4} should be a string and conform to "namespace:chainId" format`));
  }) : we2(t) || (r3 = Kt2("UNSUPPORTED_CHAINS", `${n5}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r3;
}
function ns(t, e2, n5) {
  let r3 = null;
  return Object.entries(t).forEach(([o4, s3]) => {
    if (r3) return;
    const i4 = es(o4, ve2(o4, s3), `${e2} ${n5}`);
    i4 && (r3 = i4);
  }), r3;
}
function rs(t, e2) {
  let n5 = null;
  return me2(t) ? t.forEach((r3) => {
    n5 || ts(r3) || (n5 = Kt2("UNSUPPORTED_ACCOUNTS", `${e2}, account ${r3} should be a string and conform to "namespace:chainId:address" format`));
  }) : n5 = Kt2("UNSUPPORTED_ACCOUNTS", `${e2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n5;
}
function os(t, e2) {
  let n5 = null;
  return Object.values(t).forEach((r3) => {
    if (n5) return;
    const o4 = rs(r3 == null ? void 0 : r3.accounts, `${e2} namespace`);
    o4 && (n5 = o4);
  }), n5;
}
function ss(t, e2) {
  let n5 = null;
  return Hn2(t == null ? void 0 : t.methods) ? Hn2(t == null ? void 0 : t.events) || (n5 = Kt2("UNSUPPORTED_EVENTS", `${e2}, events should be an array of strings or empty array for no events`)) : n5 = Kt2("UNSUPPORTED_METHODS", `${e2}, methods should be an array of strings or empty array for no methods`), n5;
}
function Dn(t, e2) {
  let n5 = null;
  return Object.values(t).forEach((r3) => {
    if (n5) return;
    const o4 = ss(r3, `${e2}, namespace`);
    o4 && (n5 = o4);
  }), n5;
}
function Ea(t, e2, n5) {
  let r3 = null;
  if (t && Ve2(t)) {
    const o4 = Dn(t, e2);
    o4 && (r3 = o4);
    const s3 = ns(t, e2, n5);
    s3 && (r3 = s3);
  } else r3 = Et2("MISSING_OR_INVALID", `${e2}, ${n5} should be an object with data`);
  return r3;
}
function is(t, e2) {
  let n5 = null;
  if (t && Ve2(t)) {
    const r3 = Dn(t, e2);
    r3 && (n5 = r3);
    const o4 = os(t, e2);
    o4 && (n5 = o4);
  } else n5 = Et2("MISSING_OR_INVALID", `${e2}, namespaces should be an object with data`);
  return n5;
}
function fs(t) {
  return it2(t.protocol, true);
}
function Ba(t, e2) {
  let n5 = false;
  return e2 && !t ? n5 = true : t && me2(t) && t.length && t.forEach((r3) => {
    n5 = fs(r3);
  }), n5;
}
function Ia(t) {
  return typeof t == "number";
}
function Aa(t) {
  return typeof t < "u" && typeof t !== null;
}
function Sa(t) {
  return !(!t || typeof t != "object" || !t.code || !qe2(t.code, false) || !t.message || !it2(t.message, false));
}
function Na(t) {
  return !(kt2(t) || !it2(t.method, false));
}
function Oa(t) {
  return !(kt2(t) || kt2(t.result) && kt2(t.error) || !qe2(t.id, false) || !it2(t.jsonrpc, false));
}
function Ua(t) {
  return !(kt2(t) || !it2(t.name, false));
}
function _a(t, e2) {
  return !(!we2(e2) || !Go2(t).includes(e2));
}
function Ta(t, e2, n5) {
  return it2(n5, false) ? Zo2(t, e2).includes(n5) : false;
}
function Ra(t, e2, n5) {
  return it2(n5, false) ? Wo2(t, e2).includes(n5) : false;
}
function cs(t, e2, n5) {
  let r3 = null;
  const o4 = $a(t), s3 = Ca(e2), i4 = Object.keys(o4), f8 = Object.keys(s3), a3 = as(Object.keys(t)), l6 = as(Object.keys(e2)), c6 = a3.filter((u2) => !l6.includes(u2));
  return c6.length && (r3 = Et2("NON_CONFORMING_NAMESPACES", `${n5} namespaces keys don't satisfy requiredNamespaces.
      Required: ${c6.toString()}
      Received: ${Object.keys(e2).toString()}`)), It2(i4, f8) || (r3 = Et2("NON_CONFORMING_NAMESPACES", `${n5} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${f8.toString()}`)), Object.keys(e2).forEach((u2) => {
    if (!u2.includes(":") || r3) return;
    const h5 = qt2(e2[u2].accounts);
    h5.includes(u2) || (r3 = Et2("NON_CONFORMING_NAMESPACES", `${n5} namespaces accounts don't satisfy namespace accounts for ${u2}
        Required: ${u2}
        Approved: ${h5.toString()}`));
  }), i4.forEach((u2) => {
    r3 || (It2(o4[u2].methods, s3[u2].methods) ? It2(o4[u2].events, s3[u2].events) || (r3 = Et2("NON_CONFORMING_NAMESPACES", `${n5} namespaces events don't satisfy namespace events for ${u2}`)) : r3 = Et2("NON_CONFORMING_NAMESPACES", `${n5} namespaces methods don't satisfy namespace methods for ${u2}`));
  }), r3;
}
function $a(t) {
  const e2 = {};
  return Object.keys(t).forEach((n5) => {
    var r3;
    n5.includes(":") ? e2[n5] = t[n5] : (r3 = t[n5].chains) == null || r3.forEach((o4) => {
      e2[o4] = { methods: t[n5].methods, events: t[n5].events };
    });
  }), e2;
}
function as(t) {
  return [...new Set(t.map((e2) => e2.includes(":") ? e2.split(":")[0] : e2))];
}
function Ca(t) {
  const e2 = {};
  return Object.keys(t).forEach((n5) => {
    if (n5.includes(":")) e2[n5] = t[n5];
    else {
      const r3 = qt2(t[n5].accounts);
      r3 == null ? void 0 : r3.forEach((o4) => {
        e2[o4] = { accounts: t[n5].accounts.filter((s3) => s3.includes(`${o4}:`)), methods: t[n5].methods, events: t[n5].events };
      });
    }
  }), e2;
}
function La(t, e2) {
  return qe2(t, false) && t <= e2.max && t >= e2.min;
}
function ja() {
  const t = Pt2();
  return new Promise((e2) => {
    switch (t) {
      case J3.browser:
        e2(us());
        break;
      case J3.reactNative:
        e2(ls());
        break;
      case J3.node:
        e2(ds());
        break;
      default:
        e2(true);
    }
  });
}
function us() {
  return zt2() && (navigator == null ? void 0 : navigator.onLine);
}
async function ls() {
  if (Bt2() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return true;
}
function ds() {
  return true;
}
function ka(t) {
  switch (Pt2()) {
    case J3.browser:
      hs(t);
      break;
    case J3.reactNative:
      ps(t);
      break;
    case J3.node:
      break;
  }
}
function hs(t) {
  !Bt2() && zt2() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function ps(t) {
  Bt2() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((e2) => t(e2 == null ? void 0 : e2.isConnected)));
}
function Pa() {
  var t;
  return zt2() && (0, import_window_getters2.getDocument)() ? ((t = (0, import_window_getters2.getDocument)()) == null ? void 0 : t.visibilityState) === "visible" : true;
}
var Mn2 = {};
var Ha = class {
  static get(e2) {
    return Mn2[e2];
  }
  static set(e2, n5) {
    Mn2[e2] = n5;
  }
  static delete(e2) {
    delete Mn2[e2];
  }
};
function gs(t) {
  const e2 = esm_default3.decode(t);
  if (e2.length < 33) throw new Error("Too short to contain a public key");
  return e2.slice(1, 33);
}
function bs({ publicKey: t, signature: e2, payload: n5 }) {
  var r3;
  const o4 = Vn2(n5.method), s3 = 128 | parseInt(((r3 = n5.version) == null ? void 0 : r3.toString()) || "4"), i4 = Ma(n5.address), f8 = n5.era === "00" ? new Uint8Array([0]) : Vn2(n5.era);
  if (f8.length !== 1 && f8.length !== 2) throw new Error("Invalid era length");
  const a3 = parseInt(n5.nonce, 16), l6 = new Uint8Array([a3 & 255, a3 >> 8 & 255]), c6 = BigInt(`0x${Da(n5.tip)}`), u2 = qa(c6), h5 = new Uint8Array([0, ...t, i4, ...e2, ...f8, ...l6, ...u2, ...o4]), g3 = Va(h5.length + 1);
  return new Uint8Array([...g3, s3, ...h5]);
}
function ys(t) {
  const e2 = Vn2(t), n5 = (0, import_blakejs2.blake2b)(e2, void 0, 32);
  return "0x" + Buffer.from(n5).toString("hex");
}
function Vn2(t) {
  return new Uint8Array(t.replace(/^0x/, "").match(/.{1,2}/g).map((e2) => parseInt(e2, 16)));
}
function Da(t) {
  return t.startsWith("0x") ? t.slice(2) : t;
}
function Ma(t) {
  const e2 = esm_default3.decode(t)[0];
  return e2 === 42 ? 0 : e2 === 60 ? 2 : 1;
}
function Va(t) {
  if (t < 64) return new Uint8Array([t << 2]);
  if (t < 16384) {
    const e2 = t << 2 | 1;
    return new Uint8Array([e2 & 255, e2 >> 8 & 255]);
  } else if (t < 1 << 30) {
    const e2 = t << 2 | 2;
    return new Uint8Array([e2 & 255, e2 >> 8 & 255, e2 >> 16 & 255, e2 >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function qa(t) {
  if (t < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t << BigInt(2))]);
  if (t < BigInt(1) << BigInt(14)) {
    const e2 = t << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e2 & BigInt(255)), Number(e2 >> BigInt(8) & BigInt(255))]);
  } else if (t < BigInt(1) << BigInt(30)) {
    const e2 = t << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e2 & BigInt(255)), Number(e2 >> BigInt(8) & BigInt(255)), Number(e2 >> BigInt(16) & BigInt(255)), Number(e2 >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function Ka(t) {
  const e2 = Uint8Array.from(Buffer.from(t.signature, "hex")), n5 = gs(t.transaction.address), r3 = bs({ publicKey: n5, signature: e2, payload: t.transaction }), o4 = Buffer.from(r3).toString("hex");
  return ys(o4);
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n4,
  IEvents: () => e,
  IJsonRpcConnection: () => o2,
  IJsonRpcProvider: () => r2,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code2) {
  return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function isValidErrorCode(code2) {
  return typeof code2 === "number";
}
function getError(type3) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type3)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type3];
}
function getErrorByCode(code2) {
  const match14 = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code2);
  if (!match14) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match14;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type3) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type3} RPC url at ${url}`) : e2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs4());
__reExport(env_exports, __toESM(require_cjs4()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x5) => x5.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o2 = class extends e {
  constructor(c6) {
    super();
  }
};
var n4 = class extends e {
  constructor() {
    super();
  }
};
var r2 = class extends n4 {
  constructor(c6) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var o3 = class extends r2 {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async request(t, e2) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e2);
  }
  async requestStrict(t, e2) {
    return new Promise(async (i4, s3) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n5) {
        s3(n5);
      }
      this.events.on(`${t.id}`, (n5) => {
        isJsonRpcError(n5) ? s3(n5.error) : i4(n5.result);
      });
      try {
        await this.connection.send(t, e2);
      } catch (n5) {
        s3(n5);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var v3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
var w2 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d3 = (r3) => r3.split("?")[0];
var h4 = 10;
var b3 = v3();
var f3 = class {
  constructor(e2) {
    if (this.url = e2, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    this.url = e2;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async open(e2 = this.url) {
    await this.register(e2);
  }
  async close() {
    return new Promise((e2, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n5) => {
        this.onClose(n5), e2();
      }, this.socket.close();
    });
  }
  async send(e2) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e2));
    } catch (t) {
      this.onError(e2.id, t);
    }
  }
  register(e2 = this.url) {
    if (!isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n5, s3) => {
        this.events.once("register_error", (o4) => {
          this.resetMaxListeners(), s3(o4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s3(new Error("WebSocket connection is missing or invalid"));
          n5(this.socket);
        });
      });
    }
    return this.url = e2, this.registering = true, new Promise((t, n5) => {
      const s3 = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e2) }, o4 = new b3(e2, [], s3);
      w2() ? o4.onerror = (i4) => {
        const a3 = i4;
        n5(this.emitError(a3.error));
      } : o4.on("error", (i4) => {
        n5(this.emitError(i4));
      }), o4.onopen = () => {
        this.onOpen(o4), t(o4);
      };
    });
  }
  onOpen(e2) {
    e2.onmessage = (t) => this.onPayload(t), e2.onclose = (t) => this.onClose(t), this.socket = e2, this.registering = false, this.events.emit("open");
  }
  onClose(e2) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e2);
  }
  onPayload(e2) {
    if (typeof e2.data > "u") return;
    const t = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", t);
  }
  onError(e2, t) {
    const n5 = this.parseError(t), s3 = n5.message || n5.toString(), o4 = formatJsonRpcError(e2, s3);
    this.events.emit("payload", o4);
  }
  parseError(e2, t = this.url) {
    return parseConnectionError(e2, d3(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h4 && this.events.setMaxListeners(h4);
  }
  emitError(e2) {
    const t = this.parseError(new Error((e2 == null ? void 0 : e2.message) || `WebSocket connection failed for host: ${d3(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters3 = __toESM(require_cjs2());
var ze2 = "wc";
var Le4 = 2;
var he4 = "core";
var B2 = `${ze2}@2:${he4}:`;
var Et3 = { name: he4, logger: "error" };
var It3 = { database: ":memory:" };
var Tt4 = "crypto";
var ke4 = "client_ed25519_seed";
var Ct3 = import_time5.ONE_DAY;
var Pt3 = "keychain";
var St4 = "0.3";
var Ot4 = "messages";
var Rt4 = "0.3";
var je4 = import_time5.SIX_HOURS;
var At3 = "publisher";
var xt4 = "irn";
var Nt4 = "error";
var Ue4 = "wss://relay.walletconnect.org";
var $t4 = "relayer";
var C3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt3 = "_subscription";
var L2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt3 = 0.1;
var _e4 = "2.21.5";
var Q4 = { link_mode: "link_mode", relay: "relay" };
var le4 = { inbound: "inbound", outbound: "outbound" };
var kt3 = "0.3";
var jt4 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut4 = "subscription";
var Ft2 = "0.3";
var Js = import_time5.FIVE_SECONDS * 1e3;
var Mt4 = "pairing";
var Kt3 = "0.3";
var se3 = { wc_pairingDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 } } };
var re = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F3 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt3 = "history";
var Vt3 = "0.3";
var qt3 = "expirer";
var M3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt4 = "0.3";
var Wt4 = "verify-api";
var Qs = "https://verify.walletconnect.com";
var Ht4 = "https://verify.walletconnect.org";
var ue3 = Ht4;
var Yt4 = `${ue3}/v3`;
var Jt4 = [Qs, Ht4];
var Xt4 = "echo";
var Zt4 = "https://echo.walletconnect.com";
var G4 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y3 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var tr3 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var ir3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var sr3 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var rr3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt3 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii2 = "https://pulse.walletconnect.org/batch";
function nr2(r3, e2) {
  if (r3.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i4 = 0; i4 < t.length; i4++) t[i4] = 255;
  for (var s3 = 0; s3 < r3.length; s3++) {
    var n5 = r3.charAt(s3), o4 = n5.charCodeAt(0);
    if (t[o4] !== 255) throw new TypeError(n5 + " is ambiguous");
    t[o4] = s3;
  }
  var a3 = r3.length, c6 = r3.charAt(0), h5 = Math.log(a3) / Math.log(256), l6 = Math.log(256) / Math.log(a3);
  function d4(u2) {
    if (u2 instanceof Uint8Array || (ArrayBuffer.isView(u2) ? u2 = new Uint8Array(u2.buffer, u2.byteOffset, u2.byteLength) : Array.isArray(u2) && (u2 = Uint8Array.from(u2))), !(u2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u2.length === 0) return "";
    for (var b4 = 0, x5 = 0, I4 = 0, D4 = u2.length; I4 !== D4 && u2[I4] === 0; ) I4++, b4++;
    for (var j3 = (D4 - I4) * l6 + 1 >>> 0, T3 = new Uint8Array(j3); I4 !== D4; ) {
      for (var q = u2[I4], J4 = 0, K4 = j3 - 1; (q !== 0 || J4 < x5) && K4 !== -1; K4--, J4++) q += 256 * T3[K4] >>> 0, T3[K4] = q % a3 >>> 0, q = q / a3 >>> 0;
      if (q !== 0) throw new Error("Non-zero carry");
      x5 = J4, I4++;
    }
    for (var H2 = j3 - x5; H2 !== j3 && T3[H2] === 0; ) H2++;
    for (var me4 = c6.repeat(b4); H2 < j3; ++H2) me4 += r3.charAt(T3[H2]);
    return me4;
  }
  function g3(u2) {
    if (typeof u2 != "string") throw new TypeError("Expected String");
    if (u2.length === 0) return new Uint8Array();
    var b4 = 0;
    if (u2[b4] !== " ") {
      for (var x5 = 0, I4 = 0; u2[b4] === c6; ) x5++, b4++;
      for (var D4 = (u2.length - b4) * h5 + 1 >>> 0, j3 = new Uint8Array(D4); u2[b4]; ) {
        var T3 = t[u2.charCodeAt(b4)];
        if (T3 === 255) return;
        for (var q = 0, J4 = D4 - 1; (T3 !== 0 || q < I4) && J4 !== -1; J4--, q++) T3 += a3 * j3[J4] >>> 0, j3[J4] = T3 % 256 >>> 0, T3 = T3 / 256 >>> 0;
        if (T3 !== 0) throw new Error("Non-zero carry");
        I4 = q, b4++;
      }
      if (u2[b4] !== " ") {
        for (var K4 = D4 - I4; K4 !== D4 && j3[K4] === 0; ) K4++;
        for (var H2 = new Uint8Array(x5 + (D4 - K4)), me4 = x5; K4 !== D4; ) H2[me4++] = j3[K4++];
        return H2;
      }
    }
  }
  function _3(u2) {
    var b4 = g3(u2);
    if (b4) return b4;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: d4, decodeUnsafe: g3, decode: _3 };
}
var or4 = nr2;
var ar2 = or4;
var si2 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array") return r3;
  if (r3 instanceof ArrayBuffer) return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3)) return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var cr3 = (r3) => new TextEncoder().encode(r3);
var hr3 = (r3) => new TextDecoder().decode(r3);
var lr2 = class {
  constructor(e2, t, i4) {
    this.name = e2, this.prefix = t, this.baseEncode = i4;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ur2 = class {
  constructor(e2, t, i4) {
    if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i4;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return ri2(this, e2);
  }
};
var dr3 = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return ri2(this, e2);
  }
  decode(e2) {
    const t = e2[0], i4 = this.decoders[t];
    if (i4) return i4.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r3, e2) => new dr3({ ...r3.decoders || { [r3.prefix]: r3 }, ...e2.decoders || { [e2.prefix]: e2 } });
var gr3 = class {
  constructor(e2, t, i4, s3) {
    this.name = e2, this.prefix = t, this.baseEncode = i4, this.baseDecode = s3, this.encoder = new lr2(e2, t, i4), this.decoder = new ur2(e2, t, s3);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var Ee2 = ({ name: r3, prefix: e2, encode: t, decode: i4 }) => new gr3(r3, e2, t, i4);
var de4 = ({ prefix: r3, name: e2, alphabet: t }) => {
  const { encode: i4, decode: s3 } = ar2(t, e2);
  return Ee2({ prefix: r3, name: e2, encode: i4, decode: (n5) => si2(s3(n5)) });
};
var pr3 = (r3, e2, t, i4) => {
  const s3 = {};
  for (let l6 = 0; l6 < e2.length; ++l6) s3[e2[l6]] = l6;
  let n5 = r3.length;
  for (; r3[n5 - 1] === "="; ) --n5;
  const o4 = new Uint8Array(n5 * t / 8 | 0);
  let a3 = 0, c6 = 0, h5 = 0;
  for (let l6 = 0; l6 < n5; ++l6) {
    const d4 = s3[r3[l6]];
    if (d4 === void 0) throw new SyntaxError(`Non-${i4} character`);
    c6 = c6 << t | d4, a3 += t, a3 >= 8 && (a3 -= 8, o4[h5++] = 255 & c6 >> a3);
  }
  if (a3 >= t || 255 & c6 << 8 - a3) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var yr4 = (r3, e2, t) => {
  const i4 = e2[e2.length - 1] === "=", s3 = (1 << t) - 1;
  let n5 = "", o4 = 0, a3 = 0;
  for (let c6 = 0; c6 < r3.length; ++c6) for (a3 = a3 << 8 | r3[c6], o4 += 8; o4 > t; ) o4 -= t, n5 += e2[s3 & a3 >> o4];
  if (o4 && (n5 += e2[s3 & a3 << t - o4]), i4) for (; n5.length * t & 7; ) n5 += "=";
  return n5;
};
var P3 = ({ name: r3, prefix: e2, bitsPerChar: t, alphabet: i4 }) => Ee2({ prefix: e2, name: r3, encode(s3) {
  return yr4(s3, i4, t);
}, decode(s3) {
  return pr3(s3, i4, t, r3);
} });
var br3 = Ee2({ prefix: "\0", name: "identity", encode: (r3) => hr3(r3), decode: (r3) => cr3(r3) });
var mr4 = Object.freeze({ __proto__: null, identity: br3 });
var fr3 = P3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Dr3 = Object.freeze({ __proto__: null, base2: fr3 });
var vr4 = P3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wr4 = Object.freeze({ __proto__: null, base8: vr4 });
var _r4 = de4({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Er4 = Object.freeze({ __proto__: null, base10: _r4 });
var Ir4 = P3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Tr4 = P3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Cr3 = Object.freeze({ __proto__: null, base16: Ir4, base16upper: Tr4 });
var Pr3 = P3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Sr4 = P3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Or4 = P3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Rr4 = P3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ar4 = P3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var xr4 = P3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Nr4 = P3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var $r4 = P3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var zr2 = P3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Lr3 = Object.freeze({ __proto__: null, base32: Pr3, base32upper: Sr4, base32pad: Or4, base32padupper: Rr4, base32hex: Ar4, base32hexupper: xr4, base32hexpad: Nr4, base32hexpadupper: $r4, base32z: zr2 });
var kr3 = de4({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jr3 = de4({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ur4 = Object.freeze({ __proto__: null, base36: kr3, base36upper: jr3 });
var Fr2 = de4({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mr3 = de4({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Kr2 = Object.freeze({ __proto__: null, base58btc: Fr2, base58flickr: Mr3 });
var Br4 = P3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Vr3 = P3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var qr3 = P3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gr3 = P3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Wr3 = Object.freeze({ __proto__: null, base64: Br4, base64pad: Vr3, base64url: qr3, base64urlpad: Gr3 });
var ni2 = Array.from("");
var Hr3 = ni2.reduce((r3, e2, t) => (r3[t] = e2, r3), []);
var Yr2 = ni2.reduce((r3, e2, t) => (r3[e2.codePointAt(0)] = t, r3), []);
function Jr2(r3) {
  return r3.reduce((e2, t) => (e2 += Hr3[t], e2), "");
}
function Xr3(r3) {
  const e2 = [];
  for (const t of r3) {
    const i4 = Yr2[t.codePointAt(0)];
    if (i4 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e2.push(i4);
  }
  return new Uint8Array(e2);
}
var Zr3 = Ee2({ prefix: "", name: "base256emoji", encode: Jr2, decode: Xr3 });
var Qr4 = Object.freeze({ __proto__: null, base256emoji: Zr3 });
var en4 = ai2;
var oi2 = 128;
var tn3 = 127;
var sn4 = ~tn3;
var rn4 = Math.pow(2, 31);
function ai2(r3, e2, t) {
  e2 = e2 || [], t = t || 0;
  for (var i4 = t; r3 >= rn4; ) e2[t++] = r3 & 255 | oi2, r3 /= 128;
  for (; r3 & sn4; ) e2[t++] = r3 & 255 | oi2, r3 >>>= 7;
  return e2[t] = r3 | 0, ai2.bytes = t - i4 + 1, e2;
}
var nn4 = Me3;
var on5 = 128;
var ci2 = 127;
function Me3(r3, i4) {
  var t = 0, i4 = i4 || 0, s3 = 0, n5 = i4, o4, a3 = r3.length;
  do {
    if (n5 >= a3) throw Me3.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[n5++], t += s3 < 28 ? (o4 & ci2) << s3 : (o4 & ci2) * Math.pow(2, s3), s3 += 7;
  } while (o4 >= on5);
  return Me3.bytes = n5 - i4, t;
}
var an2 = Math.pow(2, 7);
var cn3 = Math.pow(2, 14);
var hn2 = Math.pow(2, 21);
var ln2 = Math.pow(2, 28);
var un2 = Math.pow(2, 35);
var dn2 = Math.pow(2, 42);
var gn3 = Math.pow(2, 49);
var pn2 = Math.pow(2, 56);
var yn4 = Math.pow(2, 63);
var bn4 = function(r3) {
  return r3 < an2 ? 1 : r3 < cn3 ? 2 : r3 < hn2 ? 3 : r3 < ln2 ? 4 : r3 < un2 ? 5 : r3 < dn2 ? 6 : r3 < gn3 ? 7 : r3 < pn2 ? 8 : r3 < yn4 ? 9 : 10;
};
var mn4 = { encode: en4, decode: nn4, encodingLength: bn4 };
var hi2 = mn4;
var li2 = (r3, e2, t = 0) => (hi2.encode(r3, e2, t), e2);
var ui2 = (r3) => hi2.encodingLength(r3);
var Ke4 = (r3, e2) => {
  const t = e2.byteLength, i4 = ui2(r3), s3 = i4 + ui2(t), n5 = new Uint8Array(s3 + t);
  return li2(r3, n5, 0), li2(t, n5, i4), n5.set(e2, s3), new fn3(r3, t, e2, n5);
};
var fn3 = class {
  constructor(e2, t, i4, s3) {
    this.code = e2, this.size = t, this.digest = i4, this.bytes = s3;
  }
};
var di2 = ({ name: r3, code: e2, encode: t }) => new Dn2(r3, e2, t);
var Dn2 = class {
  constructor(e2, t, i4) {
    this.name = e2, this.code = t, this.encode = i4;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t = this.encode(e2);
      return t instanceof Uint8Array ? Ke4(this.code, t) : t.then((i4) => Ke4(this.code, i4));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r3) => async (e2) => new Uint8Array(await crypto.subtle.digest(r3, e2));
var vn4 = di2({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var wn3 = di2({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var _n4 = Object.freeze({ __proto__: null, sha256: vn4, sha512: wn3 });
var pi2 = 0;
var En4 = "identity";
var yi3 = si2;
var In4 = (r3) => Ke4(pi2, yi3(r3));
var Tn4 = { code: pi2, name: En4, encode: yi3, digest: In4 };
var Cn3 = Object.freeze({ __proto__: null, identity: Tn4 });
new TextEncoder(), new TextDecoder();
var bi3 = { ...mr4, ...Dr3, ...wr4, ...Er4, ...Cr3, ...Lr3, ...Ur4, ...Kr2, ...Wr3, ...Qr4 };
({ ..._n4, ...Cn3 });
function mi3(r3) {
  return globalThis.Buffer != null ? new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength) : r3;
}
function Pn3(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? mi3(globalThis.Buffer.allocUnsafe(r3)) : new Uint8Array(r3);
}
function fi2(r3, e2, t, i4) {
  return { name: r3, prefix: e2, encoder: { name: r3, prefix: e2, encode: t }, decoder: { decode: i4 } };
}
var Di3 = fi2("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var Be4 = fi2("ascii", "a", (r3) => {
  let e2 = "a";
  for (let t = 0; t < r3.length; t++) e2 += String.fromCharCode(r3[t]);
  return e2;
}, (r3) => {
  r3 = r3.substring(1);
  const e2 = Pn3(r3.length);
  for (let t = 0; t < r3.length; t++) e2[t] = r3.charCodeAt(t);
  return e2;
});
var Sn4 = { utf8: Di3, "utf-8": Di3, hex: bi3.base16, latin1: Be4, ascii: Be4, binary: Be4, ...bi3 };
function On4(r3, e2 = "utf8") {
  const t = Sn4[e2];
  if (!t) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? mi3(globalThis.Buffer.from(r3, "utf-8")) : t.decoder.decode(`${t.prefix}${r3}`);
}
var Rn4 = Object.defineProperty;
var An4 = (r3, e2, t) => e2 in r3 ? Rn4(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var W4 = (r3, e2, t) => An4(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var vi3 = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, W4(this, "keychain", /* @__PURE__ */ new Map()), W4(this, "name", Pt3), W4(this, "version", St4), W4(this, "initialized", false), W4(this, "storagePrefix", B2), W4(this, "init", async () => {
      if (!this.initialized) {
        const i4 = await this.getKeyChain();
        typeof i4 < "u" && (this.keychain = i4), this.initialized = true;
      }
    }), W4(this, "has", (i4) => (this.isInitialized(), this.keychain.has(i4))), W4(this, "set", async (i4, s3) => {
      this.isInitialized(), this.keychain.set(i4, s3), await this.persist();
    }), W4(this, "get", (i4) => {
      this.isInitialized();
      const s3 = this.keychain.get(i4);
      if (typeof s3 > "u") {
        const { message: n5 } = Et2("NO_MATCHING_KEY", `${this.name}: ${i4}`);
        throw new Error(n5);
      }
      return s3;
    }), W4(this, "del", async (i4) => {
      this.isInitialized(), this.keychain.delete(i4), await this.persist();
    }), this.core = e2, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, Ys(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? Xs(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var xn4 = Object.defineProperty;
var Nn4 = (r3, e2, t) => e2 in r3 ? xn4(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var S3 = (r3, e2, t) => Nn4(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var wi3 = class {
  constructor(e2, t, i4) {
    this.core = e2, this.logger = t, S3(this, "name", Tt4), S3(this, "keychain"), S3(this, "randomSessionIdentifier", qc()), S3(this, "initialized", false), S3(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S3(this, "hasKeys", (s3) => (this.isInitialized(), this.keychain.has(s3))), S3(this, "getClientId", async () => {
      this.isInitialized();
      const s3 = await this.getClientSeed(), n5 = Po(s3);
      return Qe(n5.publicKey);
    }), S3(this, "generateKeyPair", () => {
      this.isInitialized();
      const s3 = Vc();
      return this.setPrivateKey(s3.publicKey, s3.privateKey);
    }), S3(this, "signJWT", async (s3) => {
      this.isInitialized();
      const n5 = await this.getClientSeed(), o4 = Po(n5), a3 = this.randomSessionIdentifier, c6 = Ct3;
      return await Qo(a3, s3, c6, o4);
    }), S3(this, "generateSharedKey", (s3, n5, o4) => {
      this.isInitialized();
      const a3 = this.getPrivateKey(s3), c6 = Kc(a3, n5);
      return this.setSymKey(c6, o4);
    }), S3(this, "setSymKey", async (s3, n5) => {
      this.isInitialized();
      const o4 = n5 || Fc(s3);
      return await this.keychain.set(o4, s3), o4;
    }), S3(this, "deleteKeyPair", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S3(this, "deleteSymKey", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S3(this, "encode", async (s3, n5, o4) => {
      this.isInitialized();
      const a3 = Ho2(o4), c6 = safeJsonStringify(n5);
      if (Qc(a3)) return Wc(c6, o4 == null ? void 0 : o4.encoding);
      if (Jc(a3)) {
        const g3 = a3.senderPublicKey, _3 = a3.receiverPublicKey;
        s3 = await this.generateSharedKey(g3, _3);
      }
      const h5 = this.getSymKey(s3), { type: l6, senderPublicKey: d4 } = a3;
      return Gc({ type: l6, symKey: h5, message: c6, senderPublicKey: d4, encoding: o4 == null ? void 0 : o4.encoding });
    }), S3(this, "decode", async (s3, n5, o4) => {
      this.isInitialized();
      const a3 = Xc(n5, o4);
      if (Qc(a3)) {
        const c6 = Yc(n5, o4 == null ? void 0 : o4.encoding);
        return safeJsonParse(c6);
      }
      if (Jc(a3)) {
        const c6 = a3.receiverPublicKey, h5 = a3.senderPublicKey;
        s3 = await this.generateSharedKey(c6, h5);
      }
      try {
        const c6 = this.getSymKey(s3), h5 = Zc({ symKey: c6, encoded: n5, encoding: o4 == null ? void 0 : o4.encoding });
        return safeJsonParse(h5);
      } catch (c6) {
        this.logger.error(`Failed to decode message from topic: '${s3}', clientId: '${await this.getClientId()}'`), this.logger.error(c6);
      }
    }), S3(this, "getPayloadType", (s3, n5 = Qt2) => {
      const o4 = Me2({ encoded: s3, encoding: n5 });
      return Vt2(o4.type);
    }), S3(this, "getPayloadSenderPublicKey", (s3, n5 = Qt2) => {
      const o4 = Me2({ encoded: s3, encoding: n5 });
      return o4.senderPublicKey ? toString3(o4.senderPublicKey, tt) : void 0;
    }), this.core = e2, this.logger = E2(t, this.name), this.keychain = i4 || new vi3(this.core, this.logger);
  }
  get context() {
    return y2(this.logger);
  }
  async setPrivateKey(e2, t) {
    return await this.keychain.set(e2, t), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(ke4);
    } catch {
      e2 = qc(), await this.keychain.set(ke4, e2);
    }
    return On4(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var $n3 = Object.defineProperty;
var zn4 = Object.defineProperties;
var Ln3 = Object.getOwnPropertyDescriptors;
var _i3 = Object.getOwnPropertySymbols;
var kn3 = Object.prototype.hasOwnProperty;
var jn3 = Object.prototype.propertyIsEnumerable;
var Ve3 = (r3, e2, t) => e2 in r3 ? $n3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Un4 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) kn3.call(e2, t) && Ve3(r3, t, e2[t]);
  if (_i3) for (var t of _i3(e2)) jn3.call(e2, t) && Ve3(r3, t, e2[t]);
  return r3;
};
var Fn4 = (r3, e2) => zn4(r3, Ln3(e2));
var k5 = (r3, e2, t) => Ve3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ei3 = class extends y3 {
  constructor(e2, t) {
    super(e2, t), this.logger = e2, this.core = t, k5(this, "messages", /* @__PURE__ */ new Map()), k5(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k5(this, "name", Ot4), k5(this, "version", Rt4), k5(this, "initialized", false), k5(this, "storagePrefix", B2), k5(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i4 = await this.getRelayerMessages();
          typeof i4 < "u" && (this.messages = i4);
          const s3 = await this.getRelayerMessagesWithoutClientAck();
          typeof s3 < "u" && (this.messagesWithoutClientAck = s3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i4) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i4);
        } finally {
          this.initialized = true;
        }
      }
    }), k5(this, "set", async (i4, s3, n5) => {
      this.isInitialized();
      const o4 = zc(s3);
      let a3 = this.messages.get(i4);
      if (typeof a3 > "u" && (a3 = {}), typeof a3[o4] < "u") return o4;
      if (a3[o4] = s3, this.messages.set(i4, a3), n5 === le4.inbound) {
        const c6 = this.messagesWithoutClientAck.get(i4) || {};
        this.messagesWithoutClientAck.set(i4, Fn4(Un4({}, c6), { [o4]: s3 }));
      }
      return await this.persist(), o4;
    }), k5(this, "get", (i4) => {
      this.isInitialized();
      let s3 = this.messages.get(i4);
      return typeof s3 > "u" && (s3 = {}), s3;
    }), k5(this, "getWithoutAck", (i4) => {
      this.isInitialized();
      const s3 = {};
      for (const n5 of i4) {
        const o4 = this.messagesWithoutClientAck.get(n5) || {};
        s3[n5] = Object.values(o4);
      }
      return s3;
    }), k5(this, "has", (i4, s3) => {
      this.isInitialized();
      const n5 = this.get(i4), o4 = zc(s3);
      return typeof n5[o4] < "u";
    }), k5(this, "ack", async (i4, s3) => {
      this.isInitialized();
      const n5 = this.messagesWithoutClientAck.get(i4);
      if (typeof n5 > "u") return;
      const o4 = zc(s3);
      delete n5[o4], Object.keys(n5).length === 0 ? this.messagesWithoutClientAck.delete(i4) : this.messagesWithoutClientAck.set(i4, n5), await this.persist();
    }), k5(this, "del", async (i4) => {
      this.isInitialized(), this.messages.delete(i4), this.messagesWithoutClientAck.delete(i4), await this.persist();
    }), this.logger = E2(e2, this.name), this.core = t;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, Ys(e2));
  }
  async setRelayerMessagesWithoutClientAck(e2) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ys(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? Xs(e2) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e2 = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e2 < "u" ? Xs(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Mn3 = Object.defineProperty;
var Kn4 = Object.defineProperties;
var Bn4 = Object.getOwnPropertyDescriptors;
var Ii3 = Object.getOwnPropertySymbols;
var Vn3 = Object.prototype.hasOwnProperty;
var qn4 = Object.prototype.propertyIsEnumerable;
var qe3 = (r3, e2, t) => e2 in r3 ? Mn3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Ie4 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) Vn3.call(e2, t) && qe3(r3, t, e2[t]);
  if (Ii3) for (var t of Ii3(e2)) qn4.call(e2, t) && qe3(r3, t, e2[t]);
  return r3;
};
var Ge2 = (r3, e2) => Kn4(r3, Bn4(e2));
var V2 = (r3, e2, t) => qe3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Gn2 = class extends m2 {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, V2(this, "events", new import_events7.EventEmitter()), V2(this, "name", At3), V2(this, "queue", /* @__PURE__ */ new Map()), V2(this, "publishTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_MINUTE)), V2(this, "initialPublishTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND * 15)), V2(this, "needsTransportRestart", false), V2(this, "publish", async (i4, s3, n5) => {
      var o4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i4, message: s3, opts: n5 } });
      const a3 = (n5 == null ? void 0 : n5.ttl) || je4, c6 = ea(n5), h5 = (n5 == null ? void 0 : n5.prompt) || false, l6 = (n5 == null ? void 0 : n5.tag) || 0, d4 = (n5 == null ? void 0 : n5.id) || getBigIntRpcId().toString(), g3 = { topic: i4, message: s3, opts: { ttl: a3, relay: c6, prompt: h5, tag: l6, id: d4, attestation: n5 == null ? void 0 : n5.attestation, tvf: n5 == null ? void 0 : n5.tvf } }, _3 = `Failed to publish payload, please try again. id:${d4} tag:${l6}`;
      try {
        const u2 = new Promise(async (b4) => {
          const x5 = ({ id: D4 }) => {
            g3.opts.id === D4 && (this.removeRequestFromQueue(D4), this.relayer.events.removeListener(C3.publish, x5), b4(g3));
          };
          this.relayer.events.on(C3.publish, x5);
          const I4 = ni(new Promise((D4, j3) => {
            this.rpcPublish({ topic: i4, message: s3, ttl: a3, prompt: h5, tag: l6, id: d4, attestation: n5 == null ? void 0 : n5.attestation, tvf: n5 == null ? void 0 : n5.tvf }).then(D4).catch((T3) => {
              this.logger.warn(T3, T3 == null ? void 0 : T3.message), j3(T3);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d4} tag:${l6}`);
          try {
            await I4, this.events.removeListener(C3.publish, x5);
          } catch (D4) {
            this.queue.set(d4, Ge2(Ie4({}, g3), { attempt: 1 })), this.logger.warn(D4, D4 == null ? void 0 : D4.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d4, topic: i4, message: s3, opts: n5 } }), await ni(u2, this.publishTimeout, _3);
      } catch (u2) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u2), (o4 = n5 == null ? void 0 : n5.internal) != null && o4.throwOnFailedPublish) throw u2;
      } finally {
        this.queue.delete(d4);
      }
    }), V2(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), V2(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), V2(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), V2(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), this.relayer = e2, this.logger = E2(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y2(this.logger);
  }
  async rpcPublish(e2) {
    var t, i4, s3, n5;
    const { topic: o4, message: a3, ttl: c6 = je4, prompt: h5, tag: l6, id: d4, attestation: g3, tvf: _3 } = e2, u2 = { method: na(ea().protocol).publish, params: Ie4({ topic: o4, message: a3, ttl: c6, prompt: h5, tag: l6, attestation: g3 }, _3), id: d4 };
    kt2((t = u2.params) == null ? void 0 : t.prompt) && ((i4 = u2.params) == null || delete i4.prompt), kt2((s3 = u2.params) == null ? void 0 : s3.tag) && ((n5 = u2.params) == null || delete n5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u2 });
    const b4 = await this.relayer.request(u2);
    return this.relayer.events.emit(C3.publish, e2), this.logger.debug("Successfully Published Payload"), b4;
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2, t) => {
      const i4 = e2.attempt + 1;
      this.queue.set(t, Ge2(Ie4({}, e2), { attempt: i4 }));
      const { topic: s3, message: n5, opts: o4, attestation: a3 } = e2;
      this.logger.warn({}, `Publisher: queue->publishing: ${e2.opts.id}, tag: ${e2.opts.tag}, attempt: ${i4}`), await this.rpcPublish(Ge2(Ie4({}, e2), { topic: s3, message: n5, ttl: o4.ttl, prompt: o4.prompt, tag: o4.tag, id: o4.id, attestation: a3, tvf: o4.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e2.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C3.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var Wn2 = Object.defineProperty;
var Hn3 = (r3, e2, t) => e2 in r3 ? Wn2(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var ne3 = (r3, e2, t) => Hn3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Yn2 = class {
  constructor() {
    ne3(this, "map", /* @__PURE__ */ new Map()), ne3(this, "set", (e2, t) => {
      const i4 = this.get(e2);
      this.exists(e2, t) || this.map.set(e2, [...i4, t]);
    }), ne3(this, "get", (e2) => this.map.get(e2) || []), ne3(this, "exists", (e2, t) => this.get(e2).includes(t)), ne3(this, "delete", (e2, t) => {
      if (typeof t > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2)) return;
      const i4 = this.get(e2);
      if (!this.exists(e2, t)) return;
      const s3 = i4.filter((n5) => n5 !== t);
      if (!s3.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, s3);
    }), ne3(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Jn3 = Object.defineProperty;
var Xn2 = Object.defineProperties;
var Zn2 = Object.getOwnPropertyDescriptors;
var Ti3 = Object.getOwnPropertySymbols;
var Qn3 = Object.prototype.hasOwnProperty;
var eo4 = Object.prototype.propertyIsEnumerable;
var We2 = (r3, e2, t) => e2 in r3 ? Jn3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var ge3 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) Qn3.call(e2, t) && We2(r3, t, e2[t]);
  if (Ti3) for (var t of Ti3(e2)) eo4.call(e2, t) && We2(r3, t, e2[t]);
  return r3;
};
var He4 = (r3, e2) => Xn2(r3, Zn2(e2));
var f4 = (r3, e2, t) => We2(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ci3 = class extends P2 {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, f4(this, "subscriptions", /* @__PURE__ */ new Map()), f4(this, "topicMap", new Yn2()), f4(this, "events", new import_events7.EventEmitter()), f4(this, "name", Ut4), f4(this, "version", Ft2), f4(this, "pending", /* @__PURE__ */ new Map()), f4(this, "cached", []), f4(this, "initialized", false), f4(this, "storagePrefix", B2), f4(this, "subscribeTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_MINUTE)), f4(this, "initialSubscribeTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND * 15)), f4(this, "clientId"), f4(this, "batchSubscribeTopicsLimit", 500), f4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f4(this, "subscribe", async (i4, s3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s3 } });
      try {
        const n5 = ea(s3), o4 = { topic: i4, relay: n5, transportType: s3 == null ? void 0 : s3.transportType };
        this.pending.set(i4, o4);
        const a3 = await this.rpcSubscribe(i4, n5, s3);
        return typeof a3 == "string" && (this.onSubscribe(a3, o4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s3 } })), a3;
      } catch (n5) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n5), n5;
      }
    }), f4(this, "unsubscribe", async (i4, s3) => {
      this.isInitialized(), typeof (s3 == null ? void 0 : s3.id) < "u" ? await this.unsubscribeById(i4, s3.id, s3) : await this.unsubscribeByTopic(i4, s3);
    }), f4(this, "isSubscribed", (i4) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i4));
    })), f4(this, "isKnownTopic", (i4) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i4) || this.pending.has(i4) || this.cached.some((n5) => n5.topic === i4));
    })), f4(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), f4(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), f4(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), f4(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), f4(this, "start", async () => {
      await this.onConnect();
    }), f4(this, "stop", async () => {
      await this.onDisconnect();
    }), f4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i4 = [];
      this.pending.forEach((s3) => {
        i4.push(s3);
      }), await this.batchSubscribe(i4);
    }), f4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i4) => {
        const s3 = $.created;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i4 }), await this.persist();
      }), this.events.on($.deleted, async (i4) => {
        const s3 = $.deleted;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i4 }), await this.persist();
      });
    }), this.relayer = e2, this.logger = E2(t, this.name), this.clientId = "";
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e2, t) {
    let i4 = false;
    try {
      i4 = this.getSubscription(e2).topic === t;
    } catch {
    }
    return i4;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t) {
    const i4 = this.topicMap.get(e2);
    await Promise.all(i4.map(async (s3) => await this.unsubscribeById(e2, s3, t)));
  }
  async unsubscribeById(e2, t, i4) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i4 } });
    try {
      const s3 = ea(i4);
      await this.restartToComplete({ topic: e2, id: t, relay: s3 }), await this.rpcUnsubscribe(e2, t, s3);
      const n5 = Kt2("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t, n5), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i4 } });
    } catch (s3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s3), s3;
    }
  }
  async rpcSubscribe(e2, t, i4) {
    var s3;
    (!i4 || (i4 == null ? void 0 : i4.transportType) === Q4.relay) && await this.restartToComplete({ topic: e2, id: e2, relay: t });
    const n5 = { method: na(t.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n5 });
    const o4 = (s3 = i4 == null ? void 0 : i4.internal) == null ? void 0 : s3.throwOnFailedPublish;
    try {
      const a3 = await this.getSubscriptionId(e2);
      if ((i4 == null ? void 0 : i4.transportType) === Q4.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n5).catch((l6) => this.logger.warn(l6));
      }, (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND)), a3;
      const c6 = new Promise(async (l6) => {
        const d4 = (g3) => {
          g3.topic === e2 && (this.events.removeListener($.created, d4), l6(g3.id));
        };
        this.events.on($.created, d4);
        try {
          const g3 = await ni(new Promise((_3, u2) => {
            this.relayer.request(n5).catch((b4) => {
              this.logger.warn(b4, b4 == null ? void 0 : b4.message), u2(b4);
            }).then(_3);
          }), this.initialSubscribeTimeout, `Subscribing to ${e2} failed, please try again`);
          this.events.removeListener($.created, d4), l6(g3);
        } catch {
        }
      }), h5 = await ni(c6, this.subscribeTimeout, `Subscribing to ${e2} failed, please try again`);
      if (!h5 && o4) throw new Error(`Subscribing to ${e2} failed, please try again`);
      return h5 ? a3 : null;
    } catch (a3) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C3.connection_stalled), o4) throw a3;
    }
    return null;
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, i4 = { method: na(t.protocol).batchSubscribe, params: { topics: e2.map((s3) => s3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    try {
      await await ni(new Promise((s3) => {
        this.relayer.request(i4).catch((n5) => this.logger.warn(n5)).then(s3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, i4 = { method: na(t.protocol).batchFetchMessages, params: { topics: e2.map((n5) => n5.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    let s3;
    try {
      s3 = await await ni(new Promise((n5, o4) => {
        this.relayer.request(i4).catch((a3) => {
          this.logger.warn(a3), o4(a3);
        }).then(n5);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
    return s3;
  }
  rpcUnsubscribe(e2, t, i4) {
    const s3 = { method: na(i4.protocol).unsubscribe, params: { topic: e2, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s3 }), this.relayer.request(s3);
  }
  onSubscribe(e2, t) {
    this.setSubscription(e2, He4(ge3({}, t), { id: e2 })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t) => {
      this.setSubscription(t.id, ge3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e2, t, i4) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, i4), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t);
  }
  addSubscription(e2, t) {
    this.subscriptions.set(e2, ge3({}, t)), this.topicMap.set(t.topic, e2), this.events.emit($.created, t);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t = this.subscriptions.get(e2);
    if (!t) {
      const { message: i4 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i4);
    }
    return t;
  }
  deleteSubscription(e2, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
    const i4 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(i4.topic, e2), this.events.emit($.deleted, He4(ge3({}, i4), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e2 = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i4 = 0; i4 < t; i4++) {
        const s3 = e2.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s3);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.subscriptions.size) {
        const { message: t } = Et2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    e2.length && (await this.rpcBatchSubscribe(e2), this.onBatchSubscribe(await Promise.all(e2.map(async (t) => He4(ge3({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e2) {
    if (!e2.length) return;
    this.logger.trace(`Fetching batch messages for ${e2.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e2);
    t && t.messages && (await pi((0, import_time5.toMiliseconds)(import_time5.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete(e2) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e2), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e2) {
    return zc(e2 + await this.getClientId());
  }
};
var to4 = Object.defineProperty;
var Pi3 = Object.getOwnPropertySymbols;
var io4 = Object.prototype.hasOwnProperty;
var so4 = Object.prototype.propertyIsEnumerable;
var Ye3 = (r3, e2, t) => e2 in r3 ? to4(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Si3 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) io4.call(e2, t) && Ye3(r3, t, e2[t]);
  if (Pi3) for (var t of Pi3(e2)) so4.call(e2, t) && Ye3(r3, t, e2[t]);
  return r3;
};
var y4 = (r3, e2, t) => Ye3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Oi3 = class extends d2 {
  constructor(e2) {
    super(e2), y4(this, "protocol", "wc"), y4(this, "version", 2), y4(this, "core"), y4(this, "logger"), y4(this, "events", new import_events7.EventEmitter()), y4(this, "provider"), y4(this, "messages"), y4(this, "subscriber"), y4(this, "publisher"), y4(this, "name", $t4), y4(this, "transportExplicitlyClosed", false), y4(this, "initialized", false), y4(this, "connectionAttemptInProgress", false), y4(this, "relayUrl"), y4(this, "projectId"), y4(this, "packageName"), y4(this, "bundleId"), y4(this, "hasExperiencedNetworkDisruption", false), y4(this, "pingTimeout"), y4(this, "heartBeatTimeout", (0, import_time5.toMiliseconds)(import_time5.THIRTY_SECONDS + import_time5.FIVE_SECONDS)), y4(this, "reconnectTimeout"), y4(this, "connectPromise"), y4(this, "reconnectInProgress", false), y4(this, "requestsInFlight", []), y4(this, "connectTimeout", (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND * 15)), y4(this, "request", async (t) => {
      var i4, s3;
      this.logger.debug("Publishing Request Payload");
      const n5 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n5, method: t.method, topic: (i4 = t.params) == null ? void 0 : i4.topic }, "relayer.request - publishing...");
        const o4 = `${n5}:${((s3 = t.params) == null ? void 0 : s3.tag) || ""}`;
        this.requestsInFlight.push(o4);
        const a3 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c6) => c6 !== o4), a3;
      } catch (o4) {
        throw this.logger.debug(`Failed to Publish Request: ${n5}`), o4;
      }
    }), y4(this, "resetPingTimeout", () => {
      Ye2() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i4, s3, n5;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n5 = (s3 = (i4 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i4.socket) == null ? void 0 : s3.terminate) == null || n5.call(s3);
        } catch (o4) {
          this.logger.warn(o4, o4 == null ? void 0 : o4.message);
        }
      }, this.heartBeatTimeout));
    }), y4(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y4(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C3.connect);
    }), y4(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y4(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C3.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y4(this, "registerProviderListeners", () => {
      this.provider.on(L2.payload, this.onPayloadHandler), this.provider.on(L2.connect, this.onConnectHandler), this.provider.on(L2.disconnect, this.onDisconnectHandler), this.provider.on(L2.error, this.onProviderErrorHandler);
    }), this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? E2(e2.logger, this.name) : (0, import_pino2.default)(k3({ level: e2.logger || Nt4 })), this.messages = new Ei3(this.logger, e2.core), this.subscriber = new Ci3(this, this.logger), this.publisher = new Gn2(this, this.logger), this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ue4, this.projectId = e2.projectId, Ms() ? this.packageName = qs() : Vs() && (this.bundleId = qs()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e2) => this.logger.warn(e2, e2 == null ? void 0 : e2.message));
  }
  get context() {
    return y2(this.logger);
  }
  get connected() {
    var e2, t, i4;
    return ((i4 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : i4.readyState) === 1 || false;
  }
  get connecting() {
    var e2, t, i4;
    return ((i4 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : i4.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e2, t, i4) {
    this.isInitialized(), await this.publisher.publish(e2, t, i4), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now(), transportType: Q4.relay }, le4.outbound);
  }
  async subscribe(e2, t) {
    var i4, s3, n5;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o4 = typeof ((i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish) > "u" ? true : (s3 = t == null ? void 0 : t.internal) == null ? void 0 : s3.throwOnFailedPublish;
    let a3 = ((n5 = this.subscriber.topicMap.get(e2)) == null ? void 0 : n5[0]) || "", c6;
    const h5 = (l6) => {
      l6.topic === e2 && (this.subscriber.off($.created, h5), c6());
    };
    return await Promise.all([new Promise((l6) => {
      c6 = l6, this.subscriber.on($.created, h5);
    }), new Promise(async (l6, d4) => {
      a3 = await this.subscriber.subscribe(e2, Si3({ internal: { throwOnFailedPublish: o4 } }, t)).catch((g3) => {
        o4 && d4(g3);
      }) || a3, l6();
    })]), a3;
  }
  async unsubscribe(e2, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ni(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e2) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i4) => {
      await this.connect(e2).then(t).catch(i4).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e2) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e2 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await ja()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e2) {
    if ((e2 == null ? void 0 : e2.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e2.sort((i4, s3) => i4.publishedAt - s3.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i4 of t) try {
      await this.onMessageEvent(i4);
    } catch (s3) {
      this.logger.warn(s3, "Error while processing batch message event: " + (s3 == null ? void 0 : s3.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e2, t) {
    const { topic: i4 } = e2;
    if (!t.sessionExists) {
      const s3 = ii(import_time5.FIVE_MINUTES), n5 = { topic: i4, expiry: s3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i4, n5);
    }
    this.events.emit(C3.message, e2), await this.recordMessageEvent(e2, le4.inbound);
  }
  async connect(e2) {
    await this.confirmOnlineStateOrThrow(), e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i4, s3) => {
          const n5 = () => {
            s3(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(L2.disconnect, n5), await ni(new Promise((o4, a3) => {
            this.provider.connect().then(o4).catch(a3);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o4) => {
            s3(o4);
          }).finally(() => {
            this.provider.off(L2.disconnect, n5), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o4, a3) => {
            const c6 = () => {
              s3(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L2.disconnect, c6), await this.subscriber.start().then(o4).catch(a3).finally(() => {
              this.provider.off(L2.disconnect, c6);
            });
          }), this.hasExperiencedNetworkDisruption = false, i4();
        });
      } catch (i4) {
        await this.subscriber.stop();
        const s3 = i4;
        this.logger.warn({}, s3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i4) => setTimeout(i4, (0, import_time5.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e2, t, i4, s3, n5;
    if (Ye2()) try {
      (t = (e2 = this.provider) == null ? void 0 : e2.connection) != null && t.socket && ((n5 = (s3 = (i4 = this.provider) == null ? void 0 : i4.connection) == null ? void 0 : s3.socket) == null || n5.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o4) {
      this.logger.warn(o4, o4 == null ? void 0 : o4.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o3(new f3(zs({ sdkVersion: _e4, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2, t) {
    const { topic: i4, message: s3 } = e2;
    await this.messages.set(i4, s3, t);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t, message: i4 } = e2;
    if (!i4 || i4.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i4}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s3 = this.messages.has(t, i4);
    return s3 && this.logger.warn(`Ignoring duplicate message: ${i4}`), s3;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(zt3)) return;
      const t = e2.params, { topic: i4, message: s3, publishedAt: n5, attestation: o4 } = t.data, a3 = { topic: i4, message: s3, publishedAt: n5, transportType: Q4.relay, attestation: o4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Si3({ type: "event", event: t.id }, a3)), this.events.emit(t.id, a3), await this.acknowledgePayload(e2), await this.onMessageEvent(a3);
    } else isJsonRpcResponse(e2) && this.events.emit(C3.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (await this.recordMessageEvent(e2, le4.inbound), this.events.emit(C3.message, e2));
  }
  async acknowledgePayload(e2) {
    const t = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L2.payload, this.onPayloadHandler), this.provider.off(L2.connect, this.onConnectHandler), this.provider.off(L2.disconnect, this.onDisconnectHandler), this.provider.off(L2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e2 = await ja();
    ka(async (t) => {
      e2 !== t && (e2 = t, t ? await this.transportOpen().catch((i4) => this.logger.error(i4, i4 == null ? void 0 : i4.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Pa()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C3.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e2) => this.logger.error(e2, e2 == null ? void 0 : e2.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time5.toMiliseconds)(Lt3)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function ro4(r3, e2) {
  return r3 === e2 || Number.isNaN(r3) && Number.isNaN(e2);
}
function Ri3(r3) {
  return Object.getOwnPropertySymbols(r3).filter((e2) => Object.prototype.propertyIsEnumerable.call(r3, e2));
}
function Ai3(r3) {
  return r3 == null ? r3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r3);
}
var no4 = "[object RegExp]";
var oo4 = "[object String]";
var ao4 = "[object Number]";
var co4 = "[object Boolean]";
var xi3 = "[object Arguments]";
var ho4 = "[object Symbol]";
var lo4 = "[object Date]";
var uo4 = "[object Map]";
var go4 = "[object Set]";
var po4 = "[object Array]";
var yo4 = "[object Function]";
var bo4 = "[object ArrayBuffer]";
var Je2 = "[object Object]";
var mo4 = "[object Error]";
var fo4 = "[object DataView]";
var Do3 = "[object Uint8Array]";
var vo4 = "[object Uint8ClampedArray]";
var wo4 = "[object Uint16Array]";
var _o4 = "[object Uint32Array]";
var Eo4 = "[object BigUint64Array]";
var Io4 = "[object Int8Array]";
var To4 = "[object Int16Array]";
var Co4 = "[object Int32Array]";
var Po3 = "[object BigInt64Array]";
var So4 = "[object Float32Array]";
var Oo4 = "[object Float64Array]";
function Ro4() {
}
function Ni3(r3) {
  if (!r3 || typeof r3 != "object") return false;
  const e2 = Object.getPrototypeOf(r3);
  return e2 === null || e2 === Object.prototype || Object.getPrototypeOf(e2) === null ? Object.prototype.toString.call(r3) === "[object Object]" : false;
}
function Ao4(r3, e2, t) {
  return pe4(r3, e2, void 0, void 0, void 0, void 0, t);
}
function pe4(r3, e2, t, i4, s3, n5, o4) {
  const a3 = o4(r3, e2, t, i4, s3, n5);
  if (a3 !== void 0) return a3;
  if (typeof r3 == typeof e2) switch (typeof r3) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r3 === e2;
    case "number":
      return r3 === e2 || Object.is(r3, e2);
    case "function":
      return r3 === e2;
    case "object":
      return ye3(r3, e2, n5, o4);
  }
  return ye3(r3, e2, n5, o4);
}
function ye3(r3, e2, t, i4) {
  if (Object.is(r3, e2)) return true;
  let s3 = Ai3(r3), n5 = Ai3(e2);
  if (s3 === xi3 && (s3 = Je2), n5 === xi3 && (n5 = Je2), s3 !== n5) return false;
  switch (s3) {
    case oo4:
      return r3.toString() === e2.toString();
    case ao4: {
      const c6 = r3.valueOf(), h5 = e2.valueOf();
      return ro4(c6, h5);
    }
    case co4:
    case lo4:
    case ho4:
      return Object.is(r3.valueOf(), e2.valueOf());
    case no4:
      return r3.source === e2.source && r3.flags === e2.flags;
    case yo4:
      return r3 === e2;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o4 = t.get(r3), a3 = t.get(e2);
  if (o4 != null && a3 != null) return o4 === e2;
  t.set(r3, e2), t.set(e2, r3);
  try {
    switch (s3) {
      case uo4: {
        if (r3.size !== e2.size) return false;
        for (const [c6, h5] of r3.entries()) if (!e2.has(c6) || !pe4(h5, e2.get(c6), c6, r3, e2, t, i4)) return false;
        return true;
      }
      case go4: {
        if (r3.size !== e2.size) return false;
        const c6 = Array.from(r3.values()), h5 = Array.from(e2.values());
        for (let l6 = 0; l6 < c6.length; l6++) {
          const d4 = c6[l6], g3 = h5.findIndex((_3) => pe4(d4, _3, void 0, r3, e2, t, i4));
          if (g3 === -1) return false;
          h5.splice(g3, 1);
        }
        return true;
      }
      case po4:
      case Do3:
      case vo4:
      case wo4:
      case _o4:
      case Eo4:
      case Io4:
      case To4:
      case Co4:
      case Po3:
      case So4:
      case Oo4: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r3) !== Buffer.isBuffer(e2) || r3.length !== e2.length) return false;
        for (let c6 = 0; c6 < r3.length; c6++) if (!pe4(r3[c6], e2[c6], c6, r3, e2, t, i4)) return false;
        return true;
      }
      case bo4:
        return r3.byteLength !== e2.byteLength ? false : ye3(new Uint8Array(r3), new Uint8Array(e2), t, i4);
      case fo4:
        return r3.byteLength !== e2.byteLength || r3.byteOffset !== e2.byteOffset ? false : ye3(new Uint8Array(r3), new Uint8Array(e2), t, i4);
      case mo4:
        return r3.name === e2.name && r3.message === e2.message;
      case Je2: {
        if (!(ye3(r3.constructor, e2.constructor, t, i4) || Ni3(r3) && Ni3(e2))) return false;
        const h5 = [...Object.keys(r3), ...Ri3(r3)], l6 = [...Object.keys(e2), ...Ri3(e2)];
        if (h5.length !== l6.length) return false;
        for (let d4 = 0; d4 < h5.length; d4++) {
          const g3 = h5[d4], _3 = r3[g3];
          if (!Object.hasOwn(e2, g3)) return false;
          const u2 = e2[g3];
          if (!pe4(_3, u2, g3, r3, e2, t, i4)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r3), t.delete(e2);
  }
}
function xo4(r3, e2) {
  return Ao4(r3, e2, Ro4);
}
var No4 = Object.defineProperty;
var $i3 = Object.getOwnPropertySymbols;
var $o4 = Object.prototype.hasOwnProperty;
var zo3 = Object.prototype.propertyIsEnumerable;
var Xe3 = (r3, e2, t) => e2 in r3 ? No4(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var zi3 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) $o4.call(e2, t) && Xe3(r3, t, e2[t]);
  if ($i3) for (var t of $i3(e2)) zo3.call(e2, t) && Xe3(r3, t, e2[t]);
  return r3;
};
var z3 = (r3, e2, t) => Xe3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Li3 = class extends f2 {
  constructor(e2, t, i4, s3 = B2, n5 = void 0) {
    super(e2, t, i4, s3), this.core = e2, this.logger = t, this.name = i4, z3(this, "map", /* @__PURE__ */ new Map()), z3(this, "version", kt3), z3(this, "cached", []), z3(this, "initialized", false), z3(this, "getKey"), z3(this, "storagePrefix", B2), z3(this, "recentlyDeleted", []), z3(this, "recentlyDeletedLimit", 200), z3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o4) => {
        this.getKey && o4 !== null && !kt2(o4) ? this.map.set(this.getKey(o4), o4) : wa(o4) ? this.map.set(o4.id, o4) : xa(o4) && this.map.set(o4.topic, o4);
      }), this.cached = [], this.initialized = true);
    }), z3(this, "set", async (o4, a3) => {
      this.isInitialized(), this.map.has(o4) ? await this.update(o4, a3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o4, value: a3 }), this.map.set(o4, a3), await this.persist());
    }), z3(this, "get", (o4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o4 }), this.getData(o4))), z3(this, "getAll", (o4) => (this.isInitialized(), o4 ? this.values.filter((a3) => Object.keys(o4).every((c6) => xo4(a3[c6], o4[c6]))) : this.values)), z3(this, "update", async (o4, a3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o4, update: a3 });
      const c6 = zi3(zi3({}, this.getData(o4)), a3);
      this.map.set(o4, c6), await this.persist();
    }), z3(this, "delete", async (o4, a3) => {
      this.isInitialized(), this.map.has(o4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o4, reason: a3 }), this.map.delete(o4), this.addToRecentlyDeleted(o4), await this.persist());
    }), this.logger = E2(t, this.name), this.storagePrefix = s3, this.getKey = n5;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e2) {
    this.recentlyDeleted.push(e2), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t = this.map.get(e2);
    if (!t) {
      if (this.recentlyDeleted.includes(e2)) {
        const { message: s3 } = Et2("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e2}`);
        throw this.logger.error(s3), new Error(s3);
      }
      const { message: i4 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i4), new Error(i4);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.map.size) {
        const { message: t } = Et2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Lo4 = Object.defineProperty;
var ko3 = (r3, e2, t) => e2 in r3 ? Lo4(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var p3 = (r3, e2, t) => ko3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var ki3 = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, p3(this, "name", Mt4), p3(this, "version", Kt3), p3(this, "events", new import_events7.default()), p3(this, "pairings"), p3(this, "initialized", false), p3(this, "storagePrefix", B2), p3(this, "ignoredPayloadTypes", [ee]), p3(this, "registeredMethods", []), p3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p3(this, "register", ({ methods: i4 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i4])];
    }), p3(this, "create", async (i4) => {
      this.isInitialized();
      const s3 = qc(), n5 = await this.core.crypto.setSymKey(s3), o4 = ii(import_time5.FIVE_MINUTES), a3 = { protocol: xt4 }, c6 = { topic: n5, expiry: o4, relay: a3, active: false, methods: i4 == null ? void 0 : i4.methods }, h5 = oa({ protocol: this.core.protocol, version: this.core.version, topic: n5, symKey: s3, relay: a3, expiryTimestamp: o4, methods: i4 == null ? void 0 : i4.methods });
      return this.events.emit(re.create, c6), this.core.expirer.set(n5, o4), await this.pairings.set(n5, c6), await this.core.relayer.subscribe(n5, { transportType: i4 == null ? void 0 : i4.transportType }), { topic: n5, uri: h5 };
    }), p3(this, "pair", async (i4) => {
      this.isInitialized();
      const s3 = this.core.eventClient.createEvent({ properties: { topic: i4 == null ? void 0 : i4.uri, trace: [G4.pairing_started] } });
      this.isValidPair(i4, s3);
      const { topic: n5, symKey: o4, relay: a3, expiryTimestamp: c6, methods: h5 } = ra(i4.uri);
      s3.props.properties.topic = n5, s3.addTrace(G4.pairing_uri_validation_success), s3.addTrace(G4.pairing_uri_not_expired);
      let l6;
      if (this.pairings.keys.includes(n5)) {
        if (l6 = this.pairings.get(n5), s3.addTrace(G4.existing_pairing), l6.active) throw s3.setError(Y3.active_pairing_already_exists), new Error(`Pairing already exists: ${n5}. Please try again with a new connection URI.`);
        s3.addTrace(G4.pairing_not_expired);
      }
      const d4 = c6 || ii(import_time5.FIVE_MINUTES), g3 = { topic: n5, relay: a3, expiry: d4, active: false, methods: h5 };
      this.core.expirer.set(n5, d4), await this.pairings.set(n5, g3), s3.addTrace(G4.store_new_pairing), i4.activatePairing && await this.activate({ topic: n5 }), this.events.emit(re.create, g3), s3.addTrace(G4.emit_inactive_pairing), this.core.crypto.keychain.has(n5) || await this.core.crypto.setSymKey(o4, n5), s3.addTrace(G4.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s3.setError(Y3.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n5, { relay: a3 });
      } catch (_3) {
        throw s3.setError(Y3.subscribe_pairing_topic_failure), _3;
      }
      return s3.addTrace(G4.subscribe_pairing_topic_success), g3;
    }), p3(this, "activate", async ({ topic: i4 }) => {
      this.isInitialized();
      const s3 = ii(import_time5.FIVE_MINUTES);
      this.core.expirer.set(i4, s3), await this.pairings.update(i4, { active: true, expiry: s3 });
    }), p3(this, "ping", async (i4) => {
      this.isInitialized(), await this.isValidPing(i4), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s3 } = i4;
      if (this.pairings.keys.includes(s3)) {
        const n5 = await this.sendRequest(s3, "wc_pairingPing", {}), { done: o4, resolve: a3, reject: c6 } = ei();
        this.events.once(ci("pairing_ping", n5), ({ error: h5 }) => {
          h5 ? c6(h5) : a3();
        }), await o4();
      }
    }), p3(this, "updateExpiry", async ({ topic: i4, expiry: s3 }) => {
      this.isInitialized(), await this.pairings.update(i4, { expiry: s3 });
    }), p3(this, "updateMetadata", async ({ topic: i4, metadata: s3 }) => {
      this.isInitialized(), await this.pairings.update(i4, { peerMetadata: s3 });
    }), p3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p3(this, "disconnect", async (i4) => {
      this.isInitialized(), await this.isValidDisconnect(i4);
      const { topic: s3 } = i4;
      this.pairings.keys.includes(s3) && (await this.sendRequest(s3, "wc_pairingDelete", Kt2("USER_DISCONNECTED")), await this.deletePairing(s3));
    }), p3(this, "formatUriFromPairing", (i4) => {
      this.isInitialized();
      const { topic: s3, relay: n5, expiry: o4, methods: a3 } = i4, c6 = this.core.crypto.keychain.get(s3);
      return oa({ protocol: this.core.protocol, version: this.core.version, topic: s3, symKey: c6, relay: n5, expiryTimestamp: o4, methods: a3 });
    }), p3(this, "sendRequest", async (i4, s3, n5) => {
      const o4 = formatJsonRpcRequest(s3, n5), a3 = await this.core.crypto.encode(i4, o4), c6 = se3[s3].req;
      return this.core.history.set(i4, o4), this.core.relayer.publish(i4, a3, c6), o4.id;
    }), p3(this, "sendResult", async (i4, s3, n5) => {
      const o4 = formatJsonRpcResult(i4, n5), a3 = await this.core.crypto.encode(s3, o4), c6 = (await this.core.history.get(s3, i4)).request.method, h5 = se3[c6].res;
      await this.core.relayer.publish(s3, a3, h5), await this.core.history.resolve(o4);
    }), p3(this, "sendError", async (i4, s3, n5) => {
      const o4 = formatJsonRpcError(i4, n5), a3 = await this.core.crypto.encode(s3, o4), c6 = (await this.core.history.get(s3, i4)).request.method, h5 = se3[c6] ? se3[c6].res : se3.unregistered_method.res;
      await this.core.relayer.publish(s3, a3, h5), await this.core.history.resolve(o4);
    }), p3(this, "deletePairing", async (i4, s3) => {
      await this.core.relayer.unsubscribe(i4), await Promise.all([this.pairings.delete(i4, Kt2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i4), s3 ? Promise.resolve() : this.core.expirer.del(i4)]);
    }), p3(this, "cleanup", async () => {
      const i4 = this.pairings.getAll().filter((s3) => fi(s3.expiry));
      await Promise.all(i4.map((s3) => this.deletePairing(s3.topic)));
    }), p3(this, "onRelayEventRequest", async (i4) => {
      const { topic: s3, payload: n5 } = i4;
      switch (n5.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s3, n5);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s3, n5);
        default:
          return await this.onUnknownRpcMethodRequest(s3, n5);
      }
    }), p3(this, "onRelayEventResponse", async (i4) => {
      const { topic: s3, payload: n5 } = i4, o4 = (await this.core.history.get(s3, n5.id)).request.method;
      switch (o4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s3, n5);
        default:
          return this.onUnknownRpcMethodResponse(o4);
      }
    }), p3(this, "onPairingPingRequest", async (i4, s3) => {
      const { id: n5 } = s3;
      try {
        this.isValidPing({ topic: i4 }), await this.sendResult(n5, i4, true), this.events.emit(re.ping, { id: n5, topic: i4 });
      } catch (o4) {
        await this.sendError(n5, i4, o4), this.logger.error(o4);
      }
    }), p3(this, "onPairingPingResponse", (i4, s3) => {
      const { id: n5 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(ci("pairing_ping", n5), {}) : isJsonRpcError(s3) && this.events.emit(ci("pairing_ping", n5), { error: s3.error });
      }, 500);
    }), p3(this, "onPairingDeleteRequest", async (i4, s3) => {
      const { id: n5 } = s3;
      try {
        this.isValidDisconnect({ topic: i4 }), await this.deletePairing(i4), this.events.emit(re.delete, { id: n5, topic: i4 });
      } catch (o4) {
        await this.sendError(n5, i4, o4), this.logger.error(o4);
      }
    }), p3(this, "onUnknownRpcMethodRequest", async (i4, s3) => {
      const { id: n5, method: o4 } = s3;
      try {
        if (this.registeredMethods.includes(o4)) return;
        const a3 = Kt2("WC_METHOD_UNSUPPORTED", o4);
        await this.sendError(n5, i4, a3), this.logger.error(a3);
      } catch (a3) {
        await this.sendError(n5, i4, a3), this.logger.error(a3);
      }
    }), p3(this, "onUnknownRpcMethodResponse", (i4) => {
      this.registeredMethods.includes(i4) || this.logger.error(Kt2("WC_METHOD_UNSUPPORTED", i4));
    }), p3(this, "isValidPair", (i4, s3) => {
      var n5;
      if (!Aa(i4)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `pair() params: ${i4}`);
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a3);
      }
      if (!ma(i4.uri)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `pair() uri: ${i4.uri}`);
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a3);
      }
      const o4 = ra(i4 == null ? void 0 : i4.uri);
      if (!((n5 = o4 == null ? void 0 : o4.relay) != null && n5.protocol)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a3);
      }
      if (!(o4 != null && o4.symKey)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a3);
      }
      if (o4 != null && o4.expiryTimestamp && (0, import_time5.toMiliseconds)(o4 == null ? void 0 : o4.expiryTimestamp) < Date.now()) {
        s3.setError(Y3.pairing_expired);
        const { message: a3 } = Et2("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a3);
      }
    }), p3(this, "isValidPing", async (i4) => {
      if (!Aa(i4)) {
        const { message: n5 } = Et2("MISSING_OR_INVALID", `ping() params: ${i4}`);
        throw new Error(n5);
      }
      const { topic: s3 } = i4;
      await this.isValidPairingTopic(s3);
    }), p3(this, "isValidDisconnect", async (i4) => {
      if (!Aa(i4)) {
        const { message: n5 } = Et2("MISSING_OR_INVALID", `disconnect() params: ${i4}`);
        throw new Error(n5);
      }
      const { topic: s3 } = i4;
      await this.isValidPairingTopic(s3);
    }), p3(this, "isValidPairingTopic", async (i4) => {
      if (!it2(i4, false)) {
        const { message: s3 } = Et2("MISSING_OR_INVALID", `pairing topic should be a string: ${i4}`);
        throw new Error(s3);
      }
      if (!this.pairings.keys.includes(i4)) {
        const { message: s3 } = Et2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i4}`);
        throw new Error(s3);
      }
      if (fi(this.pairings.get(i4).expiry)) {
        await this.deletePairing(i4);
        const { message: s3 } = Et2("EXPIRED", `pairing topic: ${i4}`);
        throw new Error(s3);
      }
    }), this.core = e2, this.logger = E2(t, this.name), this.pairings = new Li3(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y2(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C3.message, async (e2) => {
      const { topic: t, message: i4, transportType: s3 } = e2;
      if (this.pairings.keys.includes(t) && s3 !== Q4.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i4))) try {
        const n5 = await this.core.crypto.decode(t, i4);
        isJsonRpcRequest(n5) ? (this.core.history.set(t, n5), await this.onRelayEventRequest({ topic: t, payload: n5 })) : isJsonRpcResponse(n5) && (await this.core.history.resolve(n5), await this.onRelayEventResponse({ topic: t, payload: n5 }), this.core.history.delete(t, n5.id)), await this.core.relayer.messages.ack(t, i4);
      } catch (n5) {
        this.logger.error(n5);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M3.expired, async (e2) => {
      const { topic: t } = si(e2.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(re.expire, { topic: t }));
    });
  }
};
var jo3 = Object.defineProperty;
var Uo4 = (r3, e2, t) => e2 in r3 ? jo3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var O4 = (r3, e2, t) => Uo4(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var ji3 = class extends I2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, O4(this, "records", /* @__PURE__ */ new Map()), O4(this, "events", new import_events7.EventEmitter()), O4(this, "name", Bt3), O4(this, "version", Vt3), O4(this, "cached", []), O4(this, "initialized", false), O4(this, "storagePrefix", B2), O4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.records.set(i4.id, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), O4(this, "set", (i4, s3, n5) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i4, request: s3, chainId: n5 }), this.records.has(s3.id)) return;
      const o4 = { id: s3.id, topic: i4, request: { method: s3.method, params: s3.params || null }, chainId: n5, expiry: ii(import_time5.THIRTY_DAYS) };
      this.records.set(o4.id, o4), this.persist(), this.events.emit(F3.created, o4);
    }), O4(this, "resolve", async (i4) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i4 }), !this.records.has(i4.id)) return;
      const s3 = await this.getRecord(i4.id);
      typeof s3.response > "u" && (s3.response = isJsonRpcError(i4) ? { error: i4.error } : { result: i4.result }, this.records.set(s3.id, s3), this.persist(), this.events.emit(F3.updated, s3));
    }), O4(this, "get", async (i4, s3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i4, id: s3 }), await this.getRecord(s3))), O4(this, "delete", (i4, s3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s3 }), this.values.forEach((n5) => {
        if (n5.topic === i4) {
          if (typeof s3 < "u" && n5.id !== s3) return;
          this.records.delete(n5.id), this.events.emit(F3.deleted, n5);
        }
      }), this.persist();
    }), O4(this, "exists", async (i4, s3) => (this.isInitialized(), this.records.has(s3) ? (await this.getRecord(s3)).topic === i4 : false)), O4(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), O4(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), O4(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), O4(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i4 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e2.push(i4);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t = this.records.get(e2);
    if (!t) {
      const { message: i4 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i4);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F3.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.records.size) {
        const { message: t } = Et2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(F3.created, (e2) => {
      const t = F3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(F3.updated, (e2) => {
      const t = F3.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(F3.deleted, (e2) => {
      const t = F3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e2 = false;
      this.records.forEach((t) => {
        (0, import_time5.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F3.deleted, t, false), e2 = true);
      }), e2 && this.persist();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Fo3 = Object.defineProperty;
var Mo3 = (r3, e2, t) => e2 in r3 ? Fo3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var A2 = (r3, e2, t) => Mo3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ui3 = class extends S2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events7.EventEmitter()), A2(this, "name", qt3), A2(this, "version", Gt4), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B2), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.expirations.set(i4.target, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i4) => {
      try {
        const s3 = this.formatTarget(i4);
        return typeof this.getExpiration(s3) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i4, s3) => {
      this.isInitialized();
      const n5 = this.formatTarget(i4), o4 = { target: n5, expiry: s3 };
      this.expirations.set(n5, o4), this.checkExpiry(n5, o4), this.events.emit(M3.created, { target: n5, expiration: o4 });
    }), A2(this, "get", (i4) => {
      this.isInitialized();
      const s3 = this.formatTarget(i4);
      return this.getExpiration(s3);
    }), A2(this, "del", (i4) => {
      if (this.isInitialized(), this.has(i4)) {
        const s3 = this.formatTarget(i4), n5 = this.getExpiration(s3);
        this.expirations.delete(s3), this.events.emit(M3.deleted, { target: s3, expiration: n5 });
      }
    }), A2(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), A2(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), A2(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), A2(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string") return ri(e2);
    if (typeof e2 == "number") return oi(e2);
    const { message: t } = Et2("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M3.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.expirations.size) {
        const { message: t } = Et2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t = this.expirations.get(e2);
    if (!t) {
      const { message: i4 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.warn(i4), new Error(i4);
    }
    return t;
  }
  checkExpiry(e2, t) {
    const { expiry: i4 } = t;
    (0, import_time5.toMiliseconds)(i4) - Date.now() <= 0 && this.expire(e2, t);
  }
  expire(e2, t) {
    this.expirations.delete(e2), this.events.emit(M3.expired, { target: e2, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M3.created, (e2) => {
      const t = M3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(M3.expired, (e2) => {
      const t = M3.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(M3.deleted, (e2) => {
      const t = M3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Ko3 = Object.defineProperty;
var Bo4 = (r3, e2, t) => e2 in r3 ? Ko3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var w3 = (r3, e2, t) => Bo4(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Fi3 = class extends M2 {
  constructor(e2, t, i4) {
    super(e2, t, i4), this.core = e2, this.logger = t, this.store = i4, w3(this, "name", Wt4), w3(this, "abortController"), w3(this, "isDevEnv"), w3(this, "verifyUrlV3", Yt4), w3(this, "storagePrefix", B2), w3(this, "version", Le4), w3(this, "publicKey"), w3(this, "fetchPromise"), w3(this, "init", async () => {
      var s3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time5.toMiliseconds)((s3 = this.publicKey) == null ? void 0 : s3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w3(this, "register", async (s3) => {
      if (!zt2() || this.isDevEnv) return;
      const n5 = window.location.origin, { id: o4, decryptedId: a3 } = s3, c6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n5}&id=${o4}&decryptedId=${a3}`;
      try {
        const h5 = (0, import_window_getters3.getDocument)(), l6 = this.startAbortTimer(import_time5.ONE_SECOND * 5), d4 = await new Promise((g3, _3) => {
          const u2 = () => {
            window.removeEventListener("message", x5), h5.body.removeChild(b4), _3("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u2);
          const b4 = h5.createElement("iframe");
          b4.src = c6, b4.style.display = "none", b4.addEventListener("error", u2, { signal: this.abortController.signal });
          const x5 = (I4) => {
            if (I4.data && typeof I4.data == "string") try {
              const D4 = JSON.parse(I4.data);
              if (D4.type === "verify_attestation") {
                if (sn(D4.attestation).payload.id !== o4) return;
                clearInterval(l6), h5.body.removeChild(b4), this.abortController.signal.removeEventListener("abort", u2), window.removeEventListener("message", x5), g3(D4.attestation === null ? "" : D4.attestation);
              }
            } catch (D4) {
              this.logger.warn(D4);
            }
          };
          h5.body.appendChild(b4), window.addEventListener("message", x5, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d4), d4;
      } catch (h5) {
        this.logger.warn(h5);
      }
      return "";
    }), w3(this, "resolve", async (s3) => {
      if (this.isDevEnv) return "";
      const { attestationId: n5, hash: o4, encryptedId: a3 } = s3;
      if (n5 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n5) {
        if (sn(n5).payload.id !== a3) return;
        const h5 = await this.isValidJwtAttestation(n5);
        if (h5) {
          if (!h5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h5;
        }
      }
      if (!o4) return;
      const c6 = this.getVerifyUrl(s3 == null ? void 0 : s3.verifyUrl);
      return this.fetchAttestation(o4, c6);
    }), w3(this, "fetchAttestation", async (s3, n5) => {
      this.logger.debug(`resolving attestation: ${s3} from url: ${n5}`);
      const o4 = this.startAbortTimer(import_time5.ONE_SECOND * 5), a3 = await fetch(`${n5}/attestation/${s3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o4), a3.status === 200 ? await a3.json() : void 0;
    }), w3(this, "getVerifyUrl", (s3) => {
      let n5 = s3 || ue3;
      return Jt4.includes(n5) || (this.logger.info(`verify url: ${n5}, not included in trusted list, assigning default: ${ue3}`), n5 = ue3), n5;
    }), w3(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s3 = this.startAbortTimer(import_time5.FIVE_SECONDS), n5 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s3), await n5.json();
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), w3(this, "persistPublicKey", async (s3) => {
      this.logger.debug("persisting public key to local storage", s3), await this.store.setItem(this.storeKey, s3), this.publicKey = s3;
    }), w3(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w3(this, "isValidJwtAttestation", async (s3) => {
      const n5 = await this.getPublicKey();
      try {
        if (n5) return this.validateAttestation(s3, n5);
      } catch (a3) {
        this.logger.error(a3), this.logger.warn("error validating attestation");
      }
      const o4 = await this.fetchAndPersistPublicKey();
      try {
        if (o4) return this.validateAttestation(s3, o4);
      } catch (a3) {
        this.logger.error(a3), this.logger.warn("error validating attestation");
      }
    }), w3(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w3(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n5) => {
        const o4 = await this.fetchPublicKey();
        o4 && (await this.persistPublicKey(o4), n5(o4));
      });
      const s3 = await this.fetchPromise;
      return this.fetchPromise = void 0, s3;
    }), w3(this, "validateAttestation", (s3, n5) => {
      const o4 = ta(s3, n5.publicKey), a3 = { hasExpired: (0, import_time5.toMiliseconds)(o4.exp) < Date.now(), payload: o4 };
      if (a3.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a3.payload.origin, isScam: a3.payload.isScam, isVerified: a3.payload.isVerified };
    }), this.logger = E2(t, this.name), this.abortController = new AbortController(), this.isDevEnv = hi(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y2(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time5.toMiliseconds)(e2));
  }
};
var Vo3 = Object.defineProperty;
var qo3 = (r3, e2, t) => e2 in r3 ? Vo3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Mi3 = (r3, e2, t) => qo3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ki3 = class extends O3 {
  constructor(e2, t) {
    super(e2, t), this.projectId = e2, this.logger = t, Mi3(this, "context", Xt4), Mi3(this, "registerDeviceToken", async (i4) => {
      const { clientId: s3, token: n5, notificationType: o4, enableEncrypted: a3 = false } = i4, c6 = `${Zt4}/${this.projectId}/clients`;
      await fetch(c6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s3, type: o4, token: n5, always_raw: a3 }) });
    }), this.logger = E2(t, this.context);
  }
};
var Go3 = Object.defineProperty;
var Bi3 = Object.getOwnPropertySymbols;
var Wo3 = Object.prototype.hasOwnProperty;
var Ho3 = Object.prototype.propertyIsEnumerable;
var Ze3 = (r3, e2, t) => e2 in r3 ? Go3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var be3 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) Wo3.call(e2, t) && Ze3(r3, t, e2[t]);
  if (Bi3) for (var t of Bi3(e2)) Ho3.call(e2, t) && Ze3(r3, t, e2[t]);
  return r3;
};
var E3 = (r3, e2, t) => Ze3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Vi3 = class extends R {
  constructor(e2, t, i4 = true) {
    super(e2, t, i4), this.core = e2, this.logger = t, E3(this, "context", ei2), E3(this, "storagePrefix", B2), E3(this, "storageVersion", Qt3), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!hi()) try {
        const s3 = { eventId: di(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cr2(this.core.relayer.protocol, this.core.relayer.version, _e4) } } };
        await this.sendEvent([s3]);
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E3(this, "createEvent", (s3) => {
      const { event: n5 = "ERROR", type: o4 = "", properties: { topic: a3, trace: c6 } } = s3, h5 = di(), l6 = this.core.projectId || "", d4 = Date.now(), g3 = be3({ eventId: h5, timestamp: d4, props: { event: n5, type: o4, properties: { topic: a3, trace: c6 } }, bundleId: l6, domain: this.getAppDomain() }, this.setMethods(h5));
      return this.telemetryEnabled && (this.events.set(h5, g3), this.shouldPersist = true), g3;
    }), E3(this, "getEvent", (s3) => {
      const { eventId: n5, topic: o4 } = s3;
      if (n5) return this.events.get(n5);
      const a3 = Array.from(this.events.values()).find((c6) => c6.props.properties.topic === o4);
      if (a3) return be3(be3({}, a3), this.setMethods(a3.eventId));
    }), E3(this, "deleteEvent", (s3) => {
      const { eventId: n5 } = s3;
      this.events.delete(n5), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s3) => {
          (0, import_time5.fromMiliseconds)(Date.now()) - (0, import_time5.fromMiliseconds)(s3.timestamp) > ti && (this.events.delete(s3.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (s3) => ({ addTrace: (n5) => this.addTrace(s3, n5), setError: (n5) => this.setError(s3, n5) })), E3(this, "addTrace", (s3, n5) => {
      const o4 = this.events.get(s3);
      o4 && (o4.props.properties.trace.push(n5), this.events.set(s3, o4), this.shouldPersist = true);
    }), E3(this, "setError", (s3, n5) => {
      const o4 = this.events.get(s3);
      o4 && (o4.props.type = n5, o4.timestamp = Date.now(), this.events.set(s3, o4), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const s3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s3.length) return;
        s3.forEach((n5) => {
          this.events.set(n5.eventId, be3(be3({}, n5), this.setMethods(n5.eventId)));
        });
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s3 = [];
      for (const [n5, o4] of this.events) o4.props.type && s3.push(o4);
      if (s3.length !== 0) try {
        if ((await this.sendEvent(s3)).ok) for (const n5 of s3) this.events.delete(n5.eventId), this.shouldPersist = true;
      } catch (n5) {
        this.logger.warn(n5);
      }
    }), E3(this, "sendEvent", async (s3) => {
      const n5 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e4}${n5}`, { method: "POST", body: JSON.stringify(s3) });
    }), E3(this, "getAppDomain", () => sr2().url), this.logger = E2(t, this.context), this.telemetryEnabled = i4, i4 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Yo3 = Object.defineProperty;
var qi3 = Object.getOwnPropertySymbols;
var Jo4 = Object.prototype.hasOwnProperty;
var Xo2 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r3, e2, t) => e2 in r3 ? Yo3(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Gi3 = (r3, e2) => {
  for (var t in e2 || (e2 = {})) Jo4.call(e2, t) && Qe3(r3, t, e2[t]);
  if (qi3) for (var t of qi3(e2)) Xo2.call(e2, t) && Qe3(r3, t, e2[t]);
  return r3;
};
var v4 = (r3, e2, t) => Qe3(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Te3 = class _Te extends h3 {
  constructor(e2) {
    var t;
    super(e2), v4(this, "protocol", ze2), v4(this, "version", Le4), v4(this, "name", he4), v4(this, "relayUrl"), v4(this, "projectId"), v4(this, "customStoragePrefix"), v4(this, "events", new import_events7.EventEmitter()), v4(this, "logger"), v4(this, "heartbeat"), v4(this, "relayer"), v4(this, "crypto"), v4(this, "storage"), v4(this, "history"), v4(this, "expirer"), v4(this, "pairing"), v4(this, "verify"), v4(this, "echoClient"), v4(this, "linkModeSupportedApps"), v4(this, "eventClient"), v4(this, "initialized", false), v4(this, "logChunkController"), v4(this, "on", (a3, c6) => this.events.on(a3, c6)), v4(this, "once", (a3, c6) => this.events.once(a3, c6)), v4(this, "off", (a3, c6) => this.events.off(a3, c6)), v4(this, "removeListener", (a3, c6) => this.events.removeListener(a3, c6)), v4(this, "dispatchEnvelope", ({ topic: a3, message: c6, sessionExists: h5 }) => {
      if (!a3 || !c6) return;
      const l6 = { topic: a3, message: c6, publishedAt: Date.now(), transportType: Q4.link_mode };
      this.relayer.onLinkMessageEvent(l6, { sessionExists: h5 });
    });
    const i4 = this.getGlobalCore(e2 == null ? void 0 : e2.customStoragePrefix);
    if (i4) try {
      return this.customStoragePrefix = i4.customStoragePrefix, this.logger = i4.logger, this.heartbeat = i4.heartbeat, this.crypto = i4.crypto, this.history = i4.history, this.expirer = i4.expirer, this.storage = i4.storage, this.relayer = i4.relayer, this.pairing = i4.pairing, this.verify = i4.verify, this.echoClient = i4.echoClient, this.linkModeSupportedApps = i4.linkModeSupportedApps, this.eventClient = i4.eventClient, this.initialized = i4.initialized, this.logChunkController = i4.logChunkController, i4;
    } catch (a3) {
      console.warn("Failed to copy global core", a3);
    }
    this.projectId = e2 == null ? void 0 : e2.projectId, this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ue4, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const s3 = k3({ level: typeof (e2 == null ? void 0 : e2.logger) == "string" && e2.logger ? e2.logger : Et3.logger, name: he4 }), { logger: n5, chunkLoggerController: o4 } = A({ opts: s3, maxSizeInBytes: e2 == null ? void 0 : e2.maxLogBlobSizeInBytes, loggerOverride: e2 == null ? void 0 : e2.logger });
    this.logChunkController = o4, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a3, c6;
      (a3 = this.logChunkController) != null && a3.downloadLogsBlobInBrowser && ((c6 = this.logChunkController) == null || c6.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E2(n5, this.name), this.heartbeat = new i(), this.crypto = new wi3(this, this.logger, e2 == null ? void 0 : e2.keychain), this.history = new ji3(this, this.logger), this.expirer = new Ui3(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new h(Gi3(Gi3({}, It3), e2 == null ? void 0 : e2.storageOptions)), this.relayer = new Oi3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ki3(this, this.logger), this.verify = new Fi3(this, this.logger, this.storage), this.echoClient = new Ki3(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Vi3(this, this.logger, e2 == null ? void 0 : e2.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e2) {
    const t = new _Te(e2);
    await t.initialize();
    const i4 = await t.crypto.getClientId();
    return await t.storage.setItem(jt4, i4), t;
  }
  get context() {
    return y2(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e2;
    return (e2 = this.logChunkController) == null ? void 0 : e2.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e2) {
    this.linkModeSupportedApps.includes(e2) || (this.linkModeSupportedApps.push(e2), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
  getGlobalCore(e2 = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e2}`, i4 = `${t}_count`;
      return globalThis[i4] = (globalThis[i4] || 0) + 1, globalThis[i4] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i4]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e2) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i4 = `_walletConnectCore_${((t = e2.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i4] = e2;
    } catch (i4) {
      console.warn("Failed to set global WalletConnect core", i4);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Zo3 = Te3;

// node_modules/@dynamic-labs/wallet-connect/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time6 = __toESM(require_cjs());
var Ce5 = "wc";
var ke5 = 2;
var De3 = "client";
var me3 = `${Ce5}@${ke5}:${De3}:`;
var we3 = { name: De3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Le5 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ht4 = "proposal";
var Me4 = "Proposal expired";
var dt4 = "session";
var X3 = import_time6.SEVEN_DAYS;
var ut4 = "engine";
var N13 = { wc_sessionPropose: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time6.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time6.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e5 = { min: import_time6.FIVE_MINUTES, max: import_time6.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var gt4 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var yt2 = "request";
var mt3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var wt4 = "wc";
var _t4 = "auth";
var Et4 = "authKeys";
var ft2 = "pairingTopics";
var St5 = "requests";
var ae3 = `${wt4}@${1.5}:${_t4}:`;
var ce3 = `${ae3}:PUB_KEY`;
var Os = Object.defineProperty;
var bs2 = Object.defineProperties;
var As = Object.getOwnPropertyDescriptors;
var Rt5 = Object.getOwnPropertySymbols;
var xs3 = Object.prototype.hasOwnProperty;
var Vs2 = Object.prototype.propertyIsEnumerable;
var $e4 = (S4, o4, t) => o4 in S4 ? Os(S4, o4, { enumerable: true, configurable: true, writable: true, value: t }) : S4[o4] = t;
var I3 = (S4, o4) => {
  for (var t in o4 || (o4 = {})) xs3.call(o4, t) && $e4(S4, t, o4[t]);
  if (Rt5) for (var t of Rt5(o4)) Vs2.call(o4, t) && $e4(S4, t, o4[t]);
  return S4;
};
var x4 = (S4, o4) => bs2(S4, As(o4));
var c5 = (S4, o4, t) => $e4(S4, typeof o4 != "symbol" ? o4 + "" : o4, t);
var Cs2 = class extends V {
  constructor(o4) {
    super(o4), c5(this, "name", ut4), c5(this, "events", new import_events8.default()), c5(this, "initialized", false), c5(this, "requestQueue", { state: $2.idle, queue: [] }), c5(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c5(this, "emittedSessionRequests", new gi({ limit: 500 })), c5(this, "requestQueueDelay", import_time6.ONE_SECOND), c5(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedLimit", 200), c5(this, "relayMessageCache", []), c5(this, "pendingSessions", /* @__PURE__ */ new Map()), c5(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N13) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay)));
    }), c5(this, "connect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const e2 = x4(I3({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(e2), e2.optionalNamespaces = ba(e2.requiredNamespaces, e2.optionalNamespaces), e2.requiredNamespaces = {};
      const { pairingTopic: s3, requiredNamespaces: i4, optionalNamespaces: r3, sessionProperties: n5, scopedProperties: a3, relays: l6 } = e2;
      let p4 = s3, h5, u2 = false;
      try {
        if (p4) {
          const T3 = this.client.core.pairing.pairings.get(p4);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u2 = T3.active;
        }
      } catch (T3) {
        throw this.client.logger.error(`connect() -> pairing.get(${p4}) failed`), T3;
      }
      if (!p4 || !u2) {
        const { topic: T3, uri: K4 } = await this.client.core.pairing.create();
        p4 = T3, h5 = K4;
      }
      if (!p4) {
        const { message: T3 } = Et2("NO_MATCHING_KEY", `connect() pairing topic: ${p4}`);
        throw new Error(T3);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), w4 = N13.wc_sessionPropose.req.ttl || import_time6.FIVE_MINUTES, m3 = ii(w4), y5 = x4(I3(I3({ requiredNamespaces: i4, optionalNamespaces: r3, relays: l6 ?? [{ protocol: xt4 }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: m3, pairingTopic: p4 }, n5 && { sessionProperties: n5 }), a3 && { scopedProperties: a3 }), { id: payloadId() }), E4 = ci("session_connect", y5.id), { reject: _3, resolve: V3, done: C4 } = ei(w4, Me4), v6 = ({ id: T3 }) => {
        T3 === y5.id && (this.client.events.off("proposal_expire", v6), this.pendingSessions.delete(y5.id), this.events.emit(E4, { error: { message: Me4, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", v6), this.events.once(E4, ({ error: T3, session: K4 }) => {
        this.client.events.off("proposal_expire", v6), T3 ? _3(T3) : K4 && V3(K4);
      }), await this.sendRequest({ topic: p4, method: "wc_sessionPropose", params: y5, throwOnFailedPublish: true, clientRpcId: y5.id }), await this.setProposal(y5.id, y5), { uri: h5, approval: C4 };
    }), c5(this, "pair", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t);
      } catch (e2) {
        throw this.client.logger.error("pair() failed"), e2;
      }
    }), c5(this, "approve", async (t) => {
      var e2, s3, i4;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (e2 = t == null ? void 0 : t.id) == null ? void 0 : e2.toString(), trace: [tr3.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q) {
        throw r3.setError(ir3.no_internet_connection), q;
      }
      try {
        await this.isValidProposalId(t == null ? void 0 : t.id);
      } catch (q) {
        throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), r3.setError(ir3.proposal_not_found), q;
      }
      try {
        await this.isValidApprove(t);
      } catch (q) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(ir3.session_approve_namespace_validation_failure), q;
      }
      const { id: n5, relayProtocol: a3, namespaces: l6, sessionProperties: p4, scopedProperties: h5, sessionConfig: u2 } = t, d4 = this.client.proposal.get(n5);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: w4, proposer: m3, requiredNamespaces: y5, optionalNamespaces: E4 } = d4;
      let _3 = (s3 = this.client.core.eventClient) == null ? void 0 : s3.getEvent({ topic: w4 });
      _3 || (_3 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: tr3.session_approve_started, properties: { topic: w4, trace: [tr3.session_approve_started, tr3.session_namespaces_validation_success] } }));
      const V3 = await this.client.core.crypto.generateKeyPair(), C4 = m3.publicKey, v6 = await this.client.core.crypto.generateSharedKey(V3, C4), T3 = I3(I3(I3({ relay: { protocol: a3 ?? "irn" }, namespaces: l6, controller: { publicKey: V3, metadata: this.client.metadata }, expiry: ii(X3) }, p4 && { sessionProperties: p4 }), h5 && { scopedProperties: h5 }), u2 && { sessionConfig: u2 }), K4 = Q4.relay;
      _3.addTrace(tr3.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(v6, { transportType: K4 });
      } catch (q) {
        throw _3.setError(ir3.subscribe_session_topic_failure), q;
      }
      _3.addTrace(tr3.subscribe_session_topic_success);
      const fe5 = x4(I3({}, T3), { topic: v6, requiredNamespaces: y5, optionalNamespaces: E4, pairingTopic: w4, acknowledged: false, self: T3.controller, peer: { publicKey: m3.publicKey, metadata: m3.metadata }, controller: V3, transportType: Q4.relay });
      await this.client.session.set(v6, fe5), _3.addTrace(tr3.store_session);
      try {
        _3.addTrace(tr3.publishing_session_settle), await this.sendRequest({ topic: v6, method: "wc_sessionSettle", params: T3, throwOnFailedPublish: true }).catch((q) => {
          throw _3 == null ? void 0 : _3.setError(ir3.session_settle_publish_failure), q;
        }), _3.addTrace(tr3.session_settle_publish_success), _3.addTrace(tr3.publishing_session_approve), await this.sendResult({ id: n5, topic: w4, result: { relay: { protocol: a3 ?? "irn" }, responderPublicKey: V3 }, throwOnFailedPublish: true }).catch((q) => {
          throw _3 == null ? void 0 : _3.setError(ir3.session_approve_publish_failure), q;
        }), _3.addTrace(tr3.session_approve_publish_success);
      } catch (q) {
        throw this.client.logger.error(q), this.client.session.delete(v6, Kt2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(v6), q;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _3.eventId }), await this.client.core.pairing.updateMetadata({ topic: w4, metadata: m3.metadata }), await this.deleteProposal(n5), await this.client.core.pairing.activate({ topic: w4 }), await this.setExpiry(v6, ii(X3)), { topic: v6, acknowledged: () => Promise.resolve(this.client.session.get(v6)) };
    }), c5(this, "reject", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: e2, reason: s3 } = t;
      let i4;
      try {
        i4 = this.client.proposal.get(e2).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${e2}) failed`), r3;
      }
      i4 && await this.sendError({ id: e2, topic: i4, error: s3, rpcOpts: N13.wc_sessionPropose.reject }), await this.deleteProposal(e2);
    }), c5(this, "update", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t);
      } catch (h5) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h5;
      }
      const { topic: e2, namespaces: s3 } = t, { done: i4, resolve: r3, reject: n5 } = ei(), a3 = payloadId(), l6 = getBigIntRpcId().toString(), p4 = this.client.session.get(e2).namespaces;
      return this.events.once(ci("session_update", a3), ({ error: h5 }) => {
        h5 ? n5(h5) : r3();
      }), await this.client.session.update(e2, { namespaces: s3 }), await this.sendRequest({ topic: e2, method: "wc_sessionUpdate", params: { namespaces: s3 }, throwOnFailedPublish: true, clientRpcId: a3, relayRpcId: l6 }).catch((h5) => {
        this.client.logger.error(h5), this.client.session.update(e2, { namespaces: p4 }), n5(h5);
      }), { acknowledged: i4 };
    }), c5(this, "extend", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t);
      } catch (a3) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a3;
      }
      const { topic: e2 } = t, s3 = payloadId(), { done: i4, resolve: r3, reject: n5 } = ei();
      return this.events.once(ci("session_extend", s3), ({ error: a3 }) => {
        a3 ? n5(a3) : r3();
      }), await this.setExpiry(e2, ii(X3)), this.sendRequest({ topic: e2, method: "wc_sessionExtend", params: {}, clientRpcId: s3, throwOnFailedPublish: true }).catch((a3) => {
        n5(a3);
      }), { acknowledged: i4 };
    }), c5(this, "request", async (t) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t);
      } catch (y5) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), y5;
      }
      const { chainId: e2, request: s3, topic: i4, expiry: r3 = N13.wc_sessionRequest.req.ttl } = t, n5 = this.client.session.get(i4);
      (n5 == null ? void 0 : n5.transportType) === Q4.relay && await this.confirmOnlineStateOrThrow();
      const a3 = payloadId(), l6 = getBigIntRpcId().toString(), { done: p4, resolve: h5, reject: u2 } = ei(r3, "Request expired. Please try again.");
      this.events.once(ci("session_request", a3), ({ error: y5, result: E4 }) => {
        y5 ? u2(y5) : h5(E4);
      });
      const d4 = "wc_sessionRequest", w4 = this.getAppLinkIfEnabled(n5.peer.metadata, n5.transportType);
      if (w4) return await this.sendRequest({ clientRpcId: a3, relayRpcId: l6, topic: i4, method: d4, params: { request: x4(I3({}, s3), { expiryTimestamp: ii(r3) }), chainId: e2 }, expiry: r3, throwOnFailedPublish: true, appLink: w4 }).catch((y5) => u2(y5)), this.client.events.emit("session_request_sent", { topic: i4, request: s3, chainId: e2, id: a3 }), await p4();
      const m3 = { request: x4(I3({}, s3), { expiryTimestamp: ii(r3) }), chainId: e2 };
      return await Promise.all([new Promise(async (y5) => {
        await this.sendRequest({ clientRpcId: a3, relayRpcId: l6, topic: i4, method: d4, params: m3, expiry: r3, throwOnFailedPublish: true, tvf: this.getTVFParams(a3, m3) }).catch((E4) => u2(E4)), this.client.events.emit("session_request_sent", { topic: i4, request: s3, chainId: e2, id: a3 }), y5();
      }), new Promise(async (y5) => {
        var E4;
        if (!((E4 = n5.sessionConfig) != null && E4.disableDeepLink)) {
          const _3 = await ui(this.client.core.storage, Le5);
          await ai({ id: a3, topic: i4, wcDeepLink: _3 });
        }
        y5();
      }), p4()]).then((y5) => y5[2]);
    }), c5(this, "respond", async (t) => {
      this.isInitialized(), await this.isValidRespond(t);
      const { topic: e2, response: s3 } = t, { id: i4 } = s3, r3 = this.client.session.get(e2);
      r3.transportType === Q4.relay && await this.confirmOnlineStateOrThrow();
      const n5 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s3) ? await this.sendResult({ id: i4, topic: e2, result: s3.result, throwOnFailedPublish: true, appLink: n5 }) : isJsonRpcError(s3) && await this.sendError({ id: i4, topic: e2, error: s3.error, appLink: n5 }), this.cleanupAfterResponse(t);
    }), c5(this, "ping", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t);
      } catch (s3) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s3;
      }
      const { topic: e2 } = t;
      if (this.client.session.keys.includes(e2)) {
        const s3 = payloadId(), i4 = getBigIntRpcId().toString(), { done: r3, resolve: n5, reject: a3 } = ei();
        this.events.once(ci("session_ping", s3), ({ error: l6 }) => {
          l6 ? a3(l6) : n5();
        }), await Promise.all([this.sendRequest({ topic: e2, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s3, relayRpcId: i4 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(e2) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e2 }));
    }), c5(this, "emit", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
      const { topic: e2, event: s3, chainId: i4 } = t, r3 = getBigIntRpcId().toString(), n5 = payloadId();
      await this.sendRequest({ topic: e2, method: "wc_sessionEvent", params: { event: s3, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: r3, clientRpcId: n5 });
    }), c5(this, "disconnect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
      const { topic: e2 } = t;
      if (this.client.session.keys.includes(e2)) await this.sendRequest({ topic: e2, method: "wc_sessionDelete", params: Kt2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e2, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e2)) await this.client.core.pairing.disconnect({ topic: e2 });
      else {
        const { message: s3 } = Et2("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e2}`);
        throw new Error(s3);
      }
    }), c5(this, "find", (t) => (this.isInitialized(), this.client.session.getAll().filter((e2) => ya(e2, t)))), c5(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c5(this, "authenticate", async (t, e2) => {
      var s3;
      this.isInitialized(), this.isValidAuthenticate(t);
      const i4 = e2 && this.client.core.linkModeSupportedApps.includes(e2) && ((s3 = this.client.metadata.redirect) == null ? void 0 : s3.linkMode), r3 = i4 ? Q4.link_mode : Q4.relay;
      r3 === Q4.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n5, statement: a3 = "", uri: l6, domain: p4, nonce: h5, type: u2, exp: d4, nbf: w4, methods: m3 = [], expiry: y5 } = t, E4 = [...t.resources || []], { topic: _3, uri: V3 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _3, uri: V3 } });
      const C4 = await this.client.core.crypto.generateKeyPair(), v6 = Fc(C4);
      if (await Promise.all([this.client.auth.authKeys.set(ce3, { responseTopic: v6, publicKey: C4 }), this.client.auth.pairingTopics.set(v6, { topic: v6, pairingTopic: _3 })]), await this.client.core.relayer.subscribe(v6, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${_3}`), m3.length > 0) {
        const { namespace: O5 } = Fe(n5[0]);
        let k6 = Ef(O5, "request", m3);
        Oe2(E4) && (k6 = Bf(k6, E4.pop())), E4.push(k6);
      }
      const T3 = y5 && y5 > N13.wc_sessionAuthenticate.req.ttl ? y5 : N13.wc_sessionAuthenticate.req.ttl, K4 = { authPayload: { type: u2 ?? "caip122", chains: n5, statement: a3, aud: l6, domain: p4, version: "1", nonce: h5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d4, nbf: w4, resources: E4 }, requester: { publicKey: C4, metadata: this.client.metadata }, expiryTimestamp: ii(T3) }, fe5 = { eip155: { chains: n5, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m3])], events: ["chainChanged", "accountsChanged"] } }, q = { requiredNamespaces: {}, optionalNamespaces: fe5, relays: [{ protocol: "irn" }], pairingTopic: _3, proposer: { publicKey: C4, metadata: this.client.metadata }, expiryTimestamp: ii(N13.wc_sessionPropose.req.ttl), id: payloadId() }, { done: It4, resolve: Ue5, reject: Se4 } = ei(T3, "Request expired"), te3 = payloadId(), le5 = ci("session_connect", q.id), Re4 = ci("session_request", te3), pe5 = async ({ error: O5, session: k6 }) => {
        this.events.off(Re4, ve3), O5 ? Se4(O5) : k6 && Ue5({ session: k6 });
      }, ve3 = async (O5) => {
        var k6, Ge3, je5;
        if (await this.deletePendingAuthRequest(te3, { message: "fulfilled", code: 0 }), O5.error) {
          const ie4 = Kt2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O5.error.code === ie4.code ? void 0 : (this.events.off(le5, pe5), Se4(O5.error.message));
        }
        await this.deleteProposal(q.id), this.events.off(le5, pe5);
        const { cacaos: Fe3, responder: Q6 } = O5.result, Te4 = [], Qe4 = [];
        for (const ie4 of Fe3) {
          await yf({ cacao: ie4, projectId: this.client.core.projectId }) || (this.client.logger.error(ie4, "Signature verification failed"), Se4(Kt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe4 } = ie4, Pe5 = Oe2(qe4.resources), He5 = [Vr2(qe4.iss)], Tt5 = dn(qe4.iss);
          if (Pe5) {
            const Ne3 = If(Pe5), qt4 = Af(Pe5);
            Te4.push(...Ne3), He5.push(...qt4);
          }
          for (const Ne3 of He5) Qe4.push(`${Ne3}:${Tt5}`);
        }
        const se4 = await this.client.core.crypto.generateSharedKey(C4, Q6.publicKey);
        let he5;
        Te4.length > 0 && (he5 = { topic: se4, acknowledged: true, self: { publicKey: C4, metadata: this.client.metadata }, peer: Q6, controller: Q6.publicKey, expiry: ii(X3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _3, namespaces: ga([...new Set(Te4)], [...new Set(Qe4)]), transportType: r3 }, await this.client.core.relayer.subscribe(se4, { transportType: r3 }), await this.client.session.set(se4, he5), _3 && await this.client.core.pairing.updateMetadata({ topic: _3, metadata: Q6.metadata }), he5 = this.client.session.get(se4)), (k6 = this.client.metadata.redirect) != null && k6.linkMode && (Ge3 = Q6.metadata.redirect) != null && Ge3.linkMode && (je5 = Q6.metadata.redirect) != null && je5.universal && e2 && (this.client.core.addLinkModeSupportedApp(Q6.metadata.redirect.universal), this.client.session.update(se4, { transportType: Q4.link_mode })), Ue5({ auths: Fe3, session: he5 });
      };
      this.events.once(le5, pe5), this.events.once(Re4, ve3);
      let Ie5;
      try {
        if (i4) {
          const O5 = formatJsonRpcRequest("wc_sessionAuthenticate", K4, te3);
          this.client.core.history.set(_3, O5);
          const k6 = await this.client.core.crypto.encode("", O5, { type: ge2, encoding: De2 });
          Ie5 = sa(e2, _3, k6);
        } else await Promise.all([this.sendRequest({ topic: _3, method: "wc_sessionAuthenticate", params: K4, expiry: t.expiry, throwOnFailedPublish: true, clientRpcId: te3 }), this.sendRequest({ topic: _3, method: "wc_sessionPropose", params: q, expiry: N13.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q.id })]);
      } catch (O5) {
        throw this.events.off(le5, pe5), this.events.off(Re4, ve3), O5;
      }
      return await this.setProposal(q.id, q), await this.setAuthRequest(te3, { request: x4(I3({}, K4), { verifyContext: {} }), pairingTopic: _3, transportType: r3 }), { uri: Ie5 ?? V3, response: It4 };
    }), c5(this, "approveSessionAuthenticate", async (t) => {
      const { id: e2, auths: s3 } = t, i4 = this.client.core.eventClient.createEvent({ properties: { topic: e2.toString(), trace: [sr3.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y5) {
        throw i4.setError(rr3.no_internet_connection), y5;
      }
      const r3 = this.getPendingAuthRequest(e2);
      if (!r3) throw i4.setError(rr3.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e2}`);
      const n5 = r3.transportType || Q4.relay;
      n5 === Q4.relay && await this.confirmOnlineStateOrThrow();
      const a3 = r3.requester.publicKey, l6 = await this.client.core.crypto.generateKeyPair(), p4 = Fc(a3), h5 = { type: ee, receiverPublicKey: a3, senderPublicKey: l6 }, u2 = [], d4 = [];
      for (const y5 of s3) {
        if (!await yf({ cacao: y5, projectId: this.client.core.projectId })) {
          i4.setError(rr3.invalid_cacao);
          const v6 = Kt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: e2, topic: p4, error: v6, encodeOpts: h5 }), new Error(v6.message);
        }
        i4.addTrace(sr3.cacaos_verified);
        const { p: E4 } = y5, _3 = Oe2(E4.resources), V3 = [Vr2(E4.iss)], C4 = dn(E4.iss);
        if (_3) {
          const v6 = If(_3), T3 = Af(_3);
          u2.push(...v6), V3.push(...T3);
        }
        for (const v6 of V3) d4.push(`${v6}:${C4}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(l6, a3);
      i4.addTrace(sr3.create_authenticated_session_topic);
      let m3;
      if ((u2 == null ? void 0 : u2.length) > 0) {
        m3 = { topic: w4, acknowledged: true, self: { publicKey: l6, metadata: this.client.metadata }, peer: { publicKey: a3, metadata: r3.requester.metadata }, controller: a3, expiry: ii(X3), authentication: s3, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: ga([...new Set(u2)], [...new Set(d4)]), transportType: n5 }, i4.addTrace(sr3.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: n5 });
        } catch (y5) {
          throw i4.setError(rr3.subscribe_authenticated_session_topic_failure), y5;
        }
        i4.addTrace(sr3.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m3), i4.addTrace(sr3.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i4.addTrace(sr3.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p4, id: e2, result: { cacaos: s3, responder: { publicKey: l6, metadata: this.client.metadata } }, encodeOpts: h5, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n5) });
      } catch (y5) {
        throw i4.setError(rr3.authenticated_session_approve_publish_failure), y5;
      }
      return await this.client.auth.requests.delete(e2, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: m3 };
    }), c5(this, "rejectSessionAuthenticate", async (t) => {
      this.isInitialized();
      const { id: e2, reason: s3 } = t, i4 = this.getPendingAuthRequest(e2);
      if (!i4) throw new Error(`Could not find pending auth request with id ${e2}`);
      i4.transportType === Q4.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i4.requester.publicKey, n5 = await this.client.core.crypto.generateKeyPair(), a3 = Fc(r3), l6 = { type: ee, receiverPublicKey: r3, senderPublicKey: n5 };
      await this.sendError({ id: e2, topic: a3, error: s3, encodeOpts: l6, rpcOpts: N13.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(e2, { message: "rejected", code: 0 }), await this.deleteProposal(e2);
    }), c5(this, "formatAuthMessage", (t) => {
      this.isInitialized();
      const { request: e2, iss: s3 } = t;
      return qr2(e2, s3);
    }), c5(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t = this.relayMessageCache.shift();
          t && await this.onRelayMessage(t);
        } catch (t) {
          this.client.logger.error(t);
        }
      }, 50);
    }), c5(this, "cleanupDuplicatePairings", async (t) => {
      if (t.pairingTopic) try {
        const e2 = this.client.core.pairing.pairings.get(t.pairingTopic), s3 = this.client.core.pairing.pairings.getAll().filter((i4) => {
          var r3, n5;
          return ((r3 = i4.peerMetadata) == null ? void 0 : r3.url) && ((n5 = i4.peerMetadata) == null ? void 0 : n5.url) === t.peer.metadata.url && i4.topic && i4.topic !== e2.topic;
        });
        if (s3.length === 0) return;
        this.client.logger.info(`Cleaning up ${s3.length} duplicate pairing(s)`), await Promise.all(s3.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (e2) {
        this.client.logger.error(e2);
      }
    }), c5(this, "deleteSession", async (t) => {
      var e2;
      const { topic: s3, expirerHasDeleted: i4 = false, emitEvent: r3 = true, id: n5 = 0 } = t, { self: a3 } = this.client.session.get(s3);
      await this.client.core.relayer.unsubscribe(s3), await this.client.session.delete(s3, Kt2("USER_DISCONNECTED")), this.addToRecentlyDeleted(s3, "session"), this.client.core.crypto.keychain.has(a3.publicKey) && await this.client.core.crypto.deleteKeyPair(a3.publicKey), this.client.core.crypto.keychain.has(s3) && await this.client.core.crypto.deleteSymKey(s3), i4 || this.client.core.expirer.del(s3), this.client.core.storage.removeItem(Le5).catch((l6) => this.client.logger.warn(l6)), this.getPendingSessionRequests().forEach((l6) => {
        l6.topic === s3 && this.deletePendingSessionRequest(l6.id, Kt2("USER_DISCONNECTED"));
      }), s3 === ((e2 = this.sessionRequestQueue.queue[0]) == null ? void 0 : e2.topic) && (this.sessionRequestQueue.state = $2.idle), r3 && this.client.events.emit("session_delete", { id: n5, topic: s3 });
    }), c5(this, "deleteProposal", async (t, e2) => {
      if (e2) try {
        const s3 = this.client.proposal.get(t), i4 = this.client.core.eventClient.getEvent({ topic: s3.pairingTopic });
        i4 == null ? void 0 : i4.setError(ir3.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t, Kt2("USER_DISCONNECTED")), e2 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
    }), c5(this, "deletePendingSessionRequest", async (t, e2, s3 = false) => {
      await Promise.all([this.client.pendingRequest.delete(t, e2), s3 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== t), s3 && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: t }));
    }), c5(this, "deletePendingAuthRequest", async (t, e2, s3 = false) => {
      await Promise.all([this.client.auth.requests.delete(t, e2), s3 ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }), c5(this, "setExpiry", async (t, e2) => {
      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, e2), await this.client.session.update(t, { expiry: e2 }));
    }), c5(this, "setProposal", async (t, e2) => {
      this.client.core.expirer.set(t, ii(N13.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, e2);
    }), c5(this, "setAuthRequest", async (t, e2) => {
      const { request: s3, pairingTopic: i4, transportType: r3 = Q4.relay } = e2;
      this.client.core.expirer.set(t, s3.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: s3.authPayload, requester: s3.requester, expiryTimestamp: s3.expiryTimestamp, id: t, pairingTopic: i4, verifyContext: s3.verifyContext, transportType: r3 });
    }), c5(this, "setPendingSessionRequest", async (t) => {
      const { id: e2, topic: s3, params: i4, verifyContext: r3 } = t, n5 = i4.request.expiryTimestamp || ii(N13.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(e2, n5), await this.client.pendingRequest.set(e2, { id: e2, topic: s3, params: i4, verifyContext: r3 });
    }), c5(this, "sendRequest", async (t) => {
      const { topic: e2, method: s3, params: i4, expiry: r3, relayRpcId: n5, clientRpcId: a3, throwOnFailedPublish: l6, appLink: p4, tvf: h5 } = t, u2 = formatJsonRpcRequest(s3, i4, a3);
      let d4;
      const w4 = !!p4;
      try {
        const E4 = w4 ? De2 : Qt2;
        d4 = await this.client.core.crypto.encode(e2, u2, { encoding: E4 });
      } catch (E4) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e2} failed`), E4;
      }
      let m3;
      if (mt3.includes(s3)) {
        const E4 = zc(JSON.stringify(u2)), _3 = zc(d4);
        m3 = await this.client.core.verify.register({ id: _3, decryptedId: E4 });
      }
      const y5 = N13[s3].req;
      if (y5.attestation = m3, r3 && (y5.ttl = r3), n5 && (y5.id = n5), this.client.core.history.set(e2, u2), w4) {
        const E4 = sa(p4, e2, d4);
        await global.Linking.openURL(E4, this.client.name);
      } else {
        const E4 = N13[s3].req;
        r3 && (E4.ttl = r3), n5 && (E4.id = n5), E4.tvf = x4(I3({}, h5), { correlationId: u2.id }), l6 ? (E4.internal = x4(I3({}, E4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e2, d4, E4)) : this.client.core.relayer.publish(e2, d4, E4).catch((_3) => this.client.logger.error(_3));
      }
      return u2.id;
    }), c5(this, "sendResult", async (t) => {
      const { id: e2, topic: s3, result: i4, throwOnFailedPublish: r3, encodeOpts: n5, appLink: a3 } = t, l6 = formatJsonRpcResult(e2, i4);
      let p4;
      const h5 = a3 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w4 = h5 ? De2 : Qt2;
        p4 = await this.client.core.crypto.encode(s3, l6, x4(I3({}, n5 || {}), { encoding: w4 }));
      } catch (w4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s3} failed`), w4;
      }
      let u2, d4;
      try {
        u2 = await this.client.core.history.get(s3, e2);
        const w4 = u2.request;
        try {
          d4 = this.getTVFParams(e2, w4.params, i4);
        } catch (m3) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m3 == null ? void 0 : m3.message}`);
        }
      } catch (w4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s3}, ${e2}) failed`), w4;
      }
      if (h5) {
        const w4 = sa(a3, s3, p4);
        await global.Linking.openURL(w4, this.client.name);
      } else {
        const w4 = u2.request.method, m3 = N13[w4].res;
        m3.tvf = x4(I3({}, d4), { correlationId: e2 }), r3 ? (m3.internal = x4(I3({}, m3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s3, p4, m3)) : this.client.core.relayer.publish(s3, p4, m3).catch((y5) => this.client.logger.error(y5));
      }
      await this.client.core.history.resolve(l6);
    }), c5(this, "sendError", async (t) => {
      const { id: e2, topic: s3, error: i4, encodeOpts: r3, rpcOpts: n5, appLink: a3 } = t, l6 = formatJsonRpcError(e2, i4);
      let p4;
      const h5 = a3 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d4 = h5 ? De2 : Qt2;
        p4 = await this.client.core.crypto.encode(s3, l6, x4(I3({}, r3 || {}), { encoding: d4 }));
      } catch (d4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s3} failed`), d4;
      }
      let u2;
      try {
        u2 = await this.client.core.history.get(s3, e2);
      } catch (d4) {
        throw this.client.logger.error(`sendError() -> history.get(${s3}, ${e2}) failed`), d4;
      }
      if (h5) {
        const d4 = sa(a3, s3, p4);
        await global.Linking.openURL(d4, this.client.name);
      } else {
        const d4 = u2.request.method, w4 = n5 || N13[d4].res;
        this.client.core.relayer.publish(s3, p4, w4);
      }
      await this.client.core.history.resolve(l6);
    }), c5(this, "cleanup", async () => {
      const t = [], e2 = [];
      this.client.session.getAll().forEach((s3) => {
        let i4 = false;
        fi(s3.expiry) && (i4 = true), this.client.core.crypto.keychain.has(s3.topic) || (i4 = true), i4 && t.push(s3.topic);
      }), this.client.proposal.getAll().forEach((s3) => {
        fi(s3.expiryTimestamp) && e2.push(s3.id);
      }), await Promise.all([...t.map((s3) => this.deleteSession({ topic: s3 })), ...e2.map((s3) => this.deleteProposal(s3))]);
    }), c5(this, "onProviderMessageEvent", async (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
    }), c5(this, "onRelayEventRequest", async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }), c5(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const t = this.requestQueue.queue.shift();
        if (t) try {
          await this.processRequest(t);
        } catch (e2) {
          this.client.logger.warn(e2);
        }
      }
      this.requestQueue.state = $2.idle;
    }), c5(this, "processRequest", async (t) => {
      const { topic: e2, payload: s3, attestation: i4, transportType: r3, encryptedId: n5 } = t, a3 = s3.method;
      if (!this.shouldIgnorePairingRequest({ topic: e2, requestMethod: a3 })) switch (a3) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: e2, payload: s3, attestation: i4, encryptedId: n5 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(e2, s3);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(e2, s3);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(e2, s3);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(e2, s3);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(e2, s3);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: e2, payload: s3, attestation: i4, encryptedId: n5, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(e2, s3);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: e2, payload: s3, attestation: i4, encryptedId: n5, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a3}`);
      }
    }), c5(this, "onRelayEventResponse", async (t) => {
      const { topic: e2, payload: s3, transportType: i4 } = t, r3 = (await this.client.core.history.get(e2, s3.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e2, s3, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e2, s3);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e2, s3);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e2, s3);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e2, s3);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e2, s3);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(e2, s3);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }), c5(this, "onRelayEventUnknownPayload", (t) => {
      const { topic: e2 } = t, { message: s3 } = Et2("MISSING_OR_INVALID", `Decoded payload on topic ${e2} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s3);
    }), c5(this, "shouldIgnorePairingRequest", (t) => {
      const { topic: e2, requestMethod: s3 } = t, i4 = this.expectedPairingMethodMap.get(e2);
      return !i4 || i4.includes(s3) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c5(this, "onSessionProposeRequest", async (t) => {
      const { topic: e2, payload: s3, attestation: i4, encryptedId: r3 } = t, { params: n5, id: a3 } = s3;
      try {
        const l6 = this.client.core.eventClient.getEvent({ topic: e2 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l6 == null ? void 0 : l6.setError(Y3.proposal_listener_not_found)), this.isValidConnect(I3({}, s3.params));
        const p4 = n5.expiryTimestamp || ii(N13.wc_sessionPropose.req.ttl), h5 = I3({ id: a3, pairingTopic: e2, expiryTimestamp: p4, attestation: i4, encryptedId: r3 }, n5);
        await this.setProposal(a3, h5);
        const u2 = await this.getVerifyContext({ attestationId: i4, hash: zc(JSON.stringify(s3)), encryptedId: r3, metadata: h5.proposer.metadata });
        l6 == null ? void 0 : l6.addTrace(G4.emit_session_proposal), this.client.events.emit("session_proposal", { id: a3, params: h5, verifyContext: u2 });
      } catch (l6) {
        await this.sendError({ id: a3, topic: e2, error: l6, rpcOpts: N13.wc_sessionPropose.autoReject }), this.client.logger.error(l6);
      }
    }), c5(this, "onSessionProposeResponse", async (t, e2, s3) => {
      const { id: i4 } = e2;
      if (isJsonRpcResult(e2)) {
        const { result: r3 } = e2;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n5 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n5 });
        const a3 = n5.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a3 });
        const l6 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l6 });
        const p4 = await this.client.core.crypto.generateSharedKey(a3, l6);
        this.pendingSessions.set(i4, { sessionTopic: p4, pairingTopic: t, proposalId: i4, publicKey: a3 });
        const h5 = await this.client.core.relayer.subscribe(p4, { transportType: s3 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h5 }), await this.client.core.pairing.activate({ topic: t });
      } else if (isJsonRpcError(e2)) {
        await this.deleteProposal(i4);
        const r3 = ci("session_connect", i4);
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(r3, { error: e2.error });
      }
    }), c5(this, "onSessionSettleRequest", async (t, e2) => {
      const { id: s3, params: i4 } = e2;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: r3, controller: n5, expiry: a3, namespaces: l6, sessionProperties: p4, scopedProperties: h5, sessionConfig: u2 } = e2.params, d4 = [...this.pendingSessions.values()].find((y5) => y5.sessionTopic === t);
        if (!d4) return this.client.logger.error(`Pending session not found for topic ${t}`);
        const w4 = this.client.proposal.get(d4.proposalId), m3 = x4(I3(I3(I3({ topic: t, relay: r3, expiry: a3, namespaces: l6, acknowledged: true, pairingTopic: d4.pairingTopic, requiredNamespaces: w4.requiredNamespaces, optionalNamespaces: w4.optionalNamespaces, controller: n5.publicKey, self: { publicKey: d4.publicKey, metadata: this.client.metadata }, peer: { publicKey: n5.publicKey, metadata: n5.metadata } }, p4 && { sessionProperties: p4 }), h5 && { scopedProperties: h5 }), u2 && { sessionConfig: u2 }), { transportType: Q4.relay });
        await this.client.session.set(m3.topic, m3), await this.setExpiry(m3.topic, m3.expiry), await this.client.core.pairing.updateMetadata({ topic: d4.pairingTopic, metadata: m3.peer.metadata }), this.client.events.emit("session_connect", { session: m3 }), this.events.emit(ci("session_connect", d4.proposalId), { session: m3 }), this.pendingSessions.delete(d4.proposalId), this.deleteProposal(d4.proposalId, false), this.cleanupDuplicatePairings(m3), await this.sendResult({ id: e2.id, topic: t, result: true });
      } catch (r3) {
        await this.sendError({ id: s3, topic: t, error: r3 }), this.client.logger.error(r3);
      }
    }), c5(this, "onSessionSettleResponse", async (t, e2) => {
      const { id: s3 } = e2;
      isJsonRpcResult(e2) ? (await this.client.session.update(t, { acknowledged: true }), this.events.emit(ci("session_approve", s3), {})) : isJsonRpcError(e2) && (await this.client.session.delete(t, Kt2("USER_DISCONNECTED")), this.events.emit(ci("session_approve", s3), { error: e2.error }));
    }), c5(this, "onSessionUpdateRequest", async (t, e2) => {
      const { params: s3, id: i4 } = e2;
      try {
        const r3 = `${t}_session_update`, n5 = Ha.get(r3);
        if (n5 && this.isRequestOutOfSync(n5, i4)) {
          this.client.logger.warn(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: t, error: Kt2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I3({ topic: t }, s3));
        try {
          Ha.set(r3, i4), await this.client.session.update(t, { namespaces: s3.namespaces }), await this.sendResult({ id: i4, topic: t, result: true });
        } catch (a3) {
          throw Ha.delete(r3), a3;
        }
        this.client.events.emit("session_update", { id: i4, topic: t, params: s3 });
      } catch (r3) {
        await this.sendError({ id: i4, topic: t, error: r3 }), this.client.logger.error(r3);
      }
    }), c5(this, "isRequestOutOfSync", (t, e2) => e2.toString().slice(0, -3) < t.toString().slice(0, -3)), c5(this, "onSessionUpdateResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_update", s3);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e2) ? this.events.emit(ci("session_update", s3), {}) : isJsonRpcError(e2) && this.events.emit(ci("session_update", s3), { error: e2.error });
    }), c5(this, "onSessionExtendRequest", async (t, e2) => {
      const { id: s3 } = e2;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, ii(X3)), await this.sendResult({ id: s3, topic: t, result: true }), this.client.events.emit("session_extend", { id: s3, topic: t });
      } catch (i4) {
        await this.sendError({ id: s3, topic: t, error: i4 }), this.client.logger.error(i4);
      }
    }), c5(this, "onSessionExtendResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_extend", s3);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e2) ? this.events.emit(ci("session_extend", s3), {}) : isJsonRpcError(e2) && this.events.emit(ci("session_extend", s3), { error: e2.error });
    }), c5(this, "onSessionPingRequest", async (t, e2) => {
      const { id: s3 } = e2;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: s3, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s3, topic: t });
      } catch (i4) {
        await this.sendError({ id: s3, topic: t, error: i4 }), this.client.logger.error(i4);
      }
    }), c5(this, "onSessionPingResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_ping", s3);
      setTimeout(() => {
        if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners 2176`);
        isJsonRpcResult(e2) ? this.events.emit(ci("session_ping", s3), {}) : isJsonRpcError(e2) && this.events.emit(ci("session_ping", s3), { error: e2.error });
      }, 500);
    }), c5(this, "onSessionDeleteRequest", async (t, e2) => {
      const { id: s3 } = e2;
      try {
        this.isValidDisconnect({ topic: t, reason: e2.params }), Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(C3.publish, async () => {
            i4(await this.deleteSession({ topic: t, id: s3 }));
          });
        }), this.sendResult({ id: s3, topic: t, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: Kt2("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }), c5(this, "onSessionRequest", async (t) => {
      var e2, s3, i4;
      const { topic: r3, payload: n5, attestation: a3, encryptedId: l6, transportType: p4 } = t, { id: h5, params: u2 } = n5;
      try {
        await this.isValidRequest(I3({ topic: r3 }, u2));
        const d4 = this.client.session.get(r3), w4 = await this.getVerifyContext({ attestationId: a3, hash: zc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u2, h5))), encryptedId: l6, metadata: d4.peer.metadata, transportType: p4 }), m3 = { id: h5, topic: r3, params: u2, verifyContext: w4 };
        await this.setPendingSessionRequest(m3), p4 === Q4.link_mode && (e2 = d4.peer.metadata.redirect) != null && e2.universal && this.client.core.addLinkModeSupportedApp((s3 = d4.peer.metadata.redirect) == null ? void 0 : s3.universal), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(m3) : (this.addSessionRequestToSessionRequestQueue(m3), this.processSessionRequestQueue());
      } catch (d4) {
        await this.sendError({ id: h5, topic: r3, error: d4 }), this.client.logger.error(d4);
      }
    }), c5(this, "onSessionRequestResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_request", s3);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e2) ? this.events.emit(ci("session_request", s3), { result: e2.result }) : isJsonRpcError(e2) && this.events.emit(ci("session_request", s3), { error: e2.error });
    }), c5(this, "onSessionEventRequest", async (t, e2) => {
      const { id: s3, params: i4 } = e2;
      try {
        const r3 = `${t}_session_event_${i4.event.name}`, n5 = Ha.get(r3);
        if (n5 && this.isRequestOutOfSync(n5, s3)) {
          this.client.logger.info(`Discarding out of sync request - ${s3}`);
          return;
        }
        this.isValidEmit(I3({ topic: t }, i4)), this.client.events.emit("session_event", { id: s3, topic: t, params: i4 }), Ha.set(r3, s3);
      } catch (r3) {
        await this.sendError({ id: s3, topic: t, error: r3 }), this.client.logger.error(r3);
      }
    }), c5(this, "onSessionAuthenticateResponse", (t, e2) => {
      const { id: s3 } = e2;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: e2 }), isJsonRpcResult(e2) ? this.events.emit(ci("session_request", s3), { result: e2.result }) : isJsonRpcError(e2) && this.events.emit(ci("session_request", s3), { error: e2.error });
    }), c5(this, "onSessionAuthenticateRequest", async (t) => {
      var e2;
      const { topic: s3, payload: i4, attestation: r3, encryptedId: n5, transportType: a3 } = t;
      try {
        const { requester: l6, authPayload: p4, expiryTimestamp: h5 } = i4.params, u2 = await this.getVerifyContext({ attestationId: r3, hash: zc(JSON.stringify(i4)), encryptedId: n5, metadata: l6.metadata, transportType: a3 }), d4 = { requester: l6, pairingTopic: s3, id: i4.id, authPayload: p4, verifyContext: u2, expiryTimestamp: h5 };
        await this.setAuthRequest(i4.id, { request: d4, pairingTopic: s3, transportType: a3 }), a3 === Q4.link_mode && (e2 = l6.metadata.redirect) != null && e2.universal && this.client.core.addLinkModeSupportedApp(l6.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s3, params: i4.params, id: i4.id, verifyContext: u2 });
      } catch (l6) {
        this.client.logger.error(l6);
        const p4 = i4.params.requester.publicKey, h5 = await this.client.core.crypto.generateKeyPair(), u2 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a3), d4 = { type: ee, receiverPublicKey: p4, senderPublicKey: h5 };
        await this.sendError({ id: i4.id, topic: s3, error: l6, encodeOpts: d4, rpcOpts: N13.wc_sessionAuthenticate.autoReject, appLink: u2 });
      }
    }), c5(this, "addSessionRequestToSessionRequestQueue", (t) => {
      this.sessionRequestQueue.queue.push(t);
    }), c5(this, "cleanupAfterResponse", (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay));
    }), c5(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: e2 }) => {
      const s3 = this.client.core.history.pending;
      s3.length > 0 && s3.filter((i4) => i4.topic === t && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const r3 = i4.request.id, n5 = ci("session_request", r3);
        if (this.events.listenerCount(n5) === 0) throw new Error(`emitting ${n5} without any listeners`);
        this.events.emit(ci("session_request", i4.request.id), { error: e2 });
      });
    }), c5(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t);
      } catch (e2) {
        this.client.logger.error(e2);
      }
    }), c5(this, "emitSessionRequest", (t) => {
      if (this.emittedSessionRequests.has(t.id)) {
        this.client.logger.warn({ id: t.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
        return;
      }
      this.sessionRequestQueue.state = $2.active, this.emittedSessionRequests.add(t.id), this.client.events.emit("session_request", t);
    }), c5(this, "onPairingCreated", (t) => {
      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;
      const e2 = this.client.proposal.getAll().find((s3) => s3.pairingTopic === t.topic);
      e2 && this.onSessionProposeRequest({ topic: t.topic, payload: formatJsonRpcRequest("wc_sessionPropose", x4(I3({}, e2), { requiredNamespaces: e2.requiredNamespaces, optionalNamespaces: e2.optionalNamespaces, relays: e2.relays, proposer: e2.proposer, sessionProperties: e2.sessionProperties, scopedProperties: e2.scopedProperties }), e2.id), attestation: e2.attestation, encryptedId: e2.encryptedId });
    }), c5(this, "isValidConnect", async (t) => {
      if (!Aa(t)) {
        const { message: l6 } = Et2("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(l6);
      }
      const { pairingTopic: e2, requiredNamespaces: s3, optionalNamespaces: i4, sessionProperties: r3, scopedProperties: n5, relays: a3 } = t;
      if (kt2(e2) || await this.isValidPairingTopic(e2), !Ba(a3, true)) {
        const { message: l6 } = Et2("MISSING_OR_INVALID", `connect() relays: ${a3}`);
        throw new Error(l6);
      }
      if (!kt2(s3) && Ve2(s3) !== 0) {
        const l6 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l6) : this.client.logger.warn(l6), this.validateNamespaces(s3, "requiredNamespaces");
      }
      if (!kt2(i4) && Ve2(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), kt2(r3) || this.validateSessionProps(r3, "sessionProperties"), !kt2(n5)) {
        this.validateSessionProps(n5, "scopedProperties");
        const l6 = Object.keys(s3 || {}).concat(Object.keys(i4 || {}));
        if (!Object.keys(n5).every((p4) => l6.includes(p4.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n5)}, required/optional namespaces: ${JSON.stringify(l6)}`);
      }
    }), c5(this, "validateNamespaces", (t, e2) => {
      const s3 = Ea(t, "connect()", e2);
      if (s3) throw new Error(s3.message);
    }), c5(this, "isValidApprove", async (t) => {
      if (!Aa(t)) throw new Error(Et2("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: e2, namespaces: s3, relayProtocol: i4, sessionProperties: r3, scopedProperties: n5 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidProposalId(e2);
      const a3 = this.client.proposal.get(e2), l6 = is(s3, "approve()");
      if (l6) throw new Error(l6.message);
      const p4 = cs(a3.requiredNamespaces, s3, "approve()");
      if (p4) throw new Error(p4.message);
      if (!it2(i4, true)) {
        const { message: h5 } = Et2("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h5);
      }
      if (kt2(r3) || this.validateSessionProps(r3, "sessionProperties"), !kt2(n5)) {
        this.validateSessionProps(n5, "scopedProperties");
        const h5 = new Set(Object.keys(s3));
        if (!Object.keys(n5).every((u2) => h5.has(u2.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n5)}, approved namespaces: ${Array.from(h5).join(", ")}`);
      }
    }), c5(this, "isValidReject", async (t) => {
      if (!Aa(t)) {
        const { message: i4 } = Et2("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(i4);
      }
      const { id: e2, reason: s3 } = t;
      if (this.checkRecentlyDeleted(e2), await this.isValidProposalId(e2), !Sa(s3)) {
        const { message: i4 } = Et2("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s3)}`);
        throw new Error(i4);
      }
    }), c5(this, "isValidSessionSettleRequest", (t) => {
      if (!Aa(t)) {
        const { message: l6 } = Et2("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(l6);
      }
      const { relay: e2, controller: s3, namespaces: i4, expiry: r3 } = t;
      if (!fs(e2)) {
        const { message: l6 } = Et2("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l6);
      }
      const n5 = va(s3, "onSessionSettleRequest()");
      if (n5) throw new Error(n5.message);
      const a3 = is(i4, "onSessionSettleRequest()");
      if (a3) throw new Error(a3.message);
      if (fi(r3)) {
        const { message: l6 } = Et2("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l6);
      }
    }), c5(this, "isValidUpdate", async (t) => {
      if (!Aa(t)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(a3);
      }
      const { topic: e2, namespaces: s3 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
      const i4 = this.client.session.get(e2), r3 = is(s3, "update()");
      if (r3) throw new Error(r3.message);
      const n5 = cs(i4.requiredNamespaces, s3, "update()");
      if (n5) throw new Error(n5.message);
    }), c5(this, "isValidExtend", async (t) => {
      if (!Aa(t)) {
        const { message: s3 } = Et2("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(s3);
      }
      const { topic: e2 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
    }), c5(this, "isValidRequest", async (t) => {
      if (!Aa(t)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(a3);
      }
      const { topic: e2, request: s3, chainId: i4, expiry: r3 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
      const { namespaces: n5 } = this.client.session.get(e2);
      if (!_a(n5, i4)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a3);
      }
      if (!Na(s3)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `request() ${JSON.stringify(s3)}`);
        throw new Error(a3);
      }
      if (!Ta(n5, i4, s3.method)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `request() method: ${s3.method}`);
        throw new Error(a3);
      }
      if (r3 && !La(r3, _e5)) {
        const { message: a3 } = Et2("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${_e5.min} and ${_e5.max}`);
        throw new Error(a3);
      }
    }), c5(this, "isValidRespond", async (t) => {
      var e2;
      if (!Aa(t)) {
        const { message: r3 } = Et2("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(r3);
      }
      const { topic: s3, response: i4 } = t;
      try {
        await this.isValidSessionTopic(s3);
      } catch (r3) {
        throw (e2 = t == null ? void 0 : t.response) != null && e2.id && this.cleanupAfterResponse(t), r3;
      }
      if (!Oa(i4)) {
        const { message: r3 } = Et2("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(r3);
      }
    }), c5(this, "isValidPing", async (t) => {
      if (!Aa(t)) {
        const { message: s3 } = Et2("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(s3);
      }
      const { topic: e2 } = t;
      await this.isValidSessionOrPairingTopic(e2);
    }), c5(this, "isValidEmit", async (t) => {
      if (!Aa(t)) {
        const { message: n5 } = Et2("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(n5);
      }
      const { topic: e2, event: s3, chainId: i4 } = t;
      await this.isValidSessionTopic(e2);
      const { namespaces: r3 } = this.client.session.get(e2);
      if (!_a(r3, i4)) {
        const { message: n5 } = Et2("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(n5);
      }
      if (!Ua(s3)) {
        const { message: n5 } = Et2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(n5);
      }
      if (!Ra(r3, i4, s3.name)) {
        const { message: n5 } = Et2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(n5);
      }
    }), c5(this, "isValidDisconnect", async (t) => {
      if (!Aa(t)) {
        const { message: s3 } = Et2("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(s3);
      }
      const { topic: e2 } = t;
      await this.isValidSessionOrPairingTopic(e2);
    }), c5(this, "isValidAuthenticate", (t) => {
      const { chains: e2, uri: s3, domain: i4, nonce: r3 } = t;
      if (!Array.isArray(e2) || e2.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!it2(s3, false)) throw new Error("uri is required parameter");
      if (!it2(i4, false)) throw new Error("domain is required parameter");
      if (!it2(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(e2.map((a3) => Fe(a3).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n5 } = Fe(e2[0]);
      if (n5 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c5(this, "getVerifyContext", async (t) => {
      const { attestationId: e2, hash: s3, encryptedId: i4, metadata: r3, transportType: n5 } = t, a3 = { verified: { verifyUrl: r3.verifyUrl || ue3, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n5 === Q4.link_mode) {
          const p4 = this.getAppLinkIfEnabled(r3, n5);
          return a3.verified.validation = p4 && new URL(p4).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a3;
        }
        const l6 = await this.client.core.verify.resolve({ attestationId: e2, hash: s3, encryptedId: i4, verifyUrl: r3.verifyUrl });
        l6 && (a3.verified.origin = l6.origin, a3.verified.isScam = l6.isScam, a3.verified.validation = l6.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (l6) {
        this.client.logger.warn(l6);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a3)}`), a3;
    }), c5(this, "validateSessionProps", (t, e2) => {
      Object.values(t).forEach((s3, i4) => {
        if (s3 == null) {
          const { message: r3 } = Et2("MISSING_OR_INVALID", `${e2} must contain an existing value for each key. Received: ${s3} for key ${Object.keys(t)[i4]}`);
          throw new Error(r3);
        }
      });
    }), c5(this, "getPendingAuthRequest", (t) => {
      const e2 = this.client.auth.requests.get(t);
      return typeof e2 == "object" ? e2 : void 0;
    }), c5(this, "addToRecentlyDeleted", (t, e2) => {
      if (this.recentlyDeletedMap.set(t, e2), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s3 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s3++ >= i4) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }), c5(this, "checkRecentlyDeleted", (t) => {
      const e2 = this.recentlyDeletedMap.get(t);
      if (e2) {
        const { message: s3 } = Et2("MISSING_OR_INVALID", `Record was recently deleted - ${e2}: ${t}`);
        throw new Error(s3);
      }
    }), c5(this, "isLinkModeEnabled", (t, e2) => {
      var s3, i4, r3, n5, a3, l6, p4, h5, u2;
      return !t || e2 !== Q4.link_mode ? false : ((i4 = (s3 = this.client.metadata) == null ? void 0 : s3.redirect) == null ? void 0 : i4.linkMode) === true && ((n5 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n5.universal) !== void 0 && ((l6 = (a3 = this.client.metadata) == null ? void 0 : a3.redirect) == null ? void 0 : l6.universal) !== "" && ((p4 = t == null ? void 0 : t.redirect) == null ? void 0 : p4.universal) !== void 0 && ((h5 = t == null ? void 0 : t.redirect) == null ? void 0 : h5.universal) !== "" && ((u2 = t == null ? void 0 : t.redirect) == null ? void 0 : u2.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c5(this, "getAppLinkIfEnabled", (t, e2) => {
      var s3;
      return this.isLinkModeEnabled(t, e2) ? (s3 = t == null ? void 0 : t.redirect) == null ? void 0 : s3.universal : void 0;
    }), c5(this, "handleLinkModeMessage", ({ url: t }) => {
      if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
      const e2 = li(t, "topic") || "", s3 = decodeURIComponent(li(t, "wc_ev") || ""), i4 = this.client.session.keys.includes(e2);
      i4 && this.client.session.update(e2, { transportType: Q4.link_mode }), this.client.core.dispatchEnvelope({ topic: e2, message: s3, sessionExists: i4 });
    }), c5(this, "registerLinkModeListeners", async () => {
      var t;
      if (hi() || Bt2() && (t = this.client.metadata.redirect) != null && t.linkMode) {
        const e2 = global == null ? void 0 : global.Linking;
        if (typeof e2 < "u") {
          e2.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s3 = await e2.getInitialURL();
          s3 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s3 });
          }, 50);
        }
      }
    }), c5(this, "getTVFParams", (t, e2, s3) => {
      var i4, r3, n5;
      if (!((i4 = e2.request) != null && i4.method)) return {};
      const a3 = { correlationId: t, rpcMethods: [e2.request.method], chainId: e2.chainId };
      try {
        const l6 = this.extractTxHashesFromResult(e2.request, s3);
        a3.txHashes = l6, a3.contractAddresses = this.isValidContractData(e2.request.params) ? [(n5 = (r3 = e2.request.params) == null ? void 0 : r3[0]) == null ? void 0 : n5.to] : [];
      } catch (l6) {
        this.client.logger.warn("Error getting TVF params", l6);
      }
      return a3;
    }), c5(this, "isValidContractData", (t) => {
      var e2;
      if (!t) return false;
      try {
        const s3 = (t == null ? void 0 : t.data) || ((e2 = t == null ? void 0 : t[0]) == null ? void 0 : e2.data);
        if (!s3.startsWith("0x")) return false;
        const i4 = s3.slice(2);
        return /^[0-9a-fA-F]*$/.test(i4) ? i4.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c5(this, "extractTxHashesFromResult", (t, e2) => {
      var s3;
      try {
        if (!e2) return [];
        const i4 = t.method, r3 = gt4[i4];
        if (i4 === "sui_signTransaction") return [ff(e2.transactionBytes)];
        if (i4 === "near_signTransaction") return [cf(e2)];
        if (i4 === "near_signTransactions") return e2.map((a3) => cf(a3));
        if (i4 === "xrpl_signTransactionFor" || i4 === "xrpl_signTransaction") return [(s3 = e2.tx_json) == null ? void 0 : s3.hash];
        if (i4 === "polkadot_signTransaction") return [Ka({ transaction: t.params.transactionPayload, signature: e2.signature })];
        if (i4 === "algo_signTxn") return me2(e2) ? e2.map((a3) => af(a3)) : [af(e2)];
        if (i4 === "cosmos_signDirect") return [uf(e2)];
        if (typeof e2 == "string") return [e2];
        const n5 = e2[r3.key];
        if (me2(n5)) return i4 === "solana_signAllTransactions" ? n5.map((a3) => sf(a3)) : n5;
        if (typeof n5 == "string") return [n5];
      } catch (i4) {
        this.client.logger.warn("Error extracting tx hashes from result", i4);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const o4 = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(o4);
      for (const [e2, s3] of Object.entries(t)) for (const i4 of s3) try {
        await this.onProviderMessageEvent({ topic: e2, message: i4, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${e2}, message: ${i4}`);
      }
    } catch (o4) {
      this.client.logger.warn("processPendingMessageEvents failed", o4);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = Et2("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C3.message, (o4) => {
      this.onProviderMessageEvent(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: t, message: e2, attestation: s3, transportType: i4 } = o4, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ce3) ? this.client.auth.authKeys.get(ce3) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const n5 = await this.client.core.crypto.decode(t, e2, { receiverPublicKey: r3, encoding: i4 === Q4.link_mode ? De2 : Qt2 });
      isJsonRpcRequest(n5) ? (this.client.core.history.set(t, n5), await this.onRelayEventRequest({ topic: t, payload: n5, attestation: s3, transportType: i4, encryptedId: zc(e2) })) : isJsonRpcResponse(n5) ? (await this.client.core.history.resolve(n5), await this.onRelayEventResponse({ topic: t, payload: n5, transportType: i4 }), this.client.core.history.delete(t, n5.id)) : await this.onRelayEventUnknownPayload({ topic: t, payload: n5, transportType: i4 }), await this.client.core.relayer.messages.ack(t, e2);
    } catch (n5) {
      this.client.logger.error(n5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M3.expired, async (o4) => {
      const { topic: t, id: e2 } = si(o4.target);
      if (e2 && this.client.pendingRequest.keys.includes(e2)) return await this.deletePendingSessionRequest(e2, Et2("EXPIRED"), true);
      if (e2 && this.client.auth.requests.keys.includes(e2)) return await this.deletePendingAuthRequest(e2, Et2("EXPIRED"), true);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t })) : e2 && (await this.deleteProposal(e2, true), this.client.events.emit("proposal_expire", { id: e2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(re.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!it2(o4, false)) {
      const { message: t } = Et2("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: t } = Et2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(t);
    }
    if (fi(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: t } = Et2("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(o4) {
    if (!it2(o4, false)) {
      const { message: t } = Et2("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(t);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: t } = Et2("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(t);
    }
    if (fi(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: t } = Et2("EXPIRED", `session topic: ${o4}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: t } = Et2("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4)) await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4)) this.isValidPairingTopic(o4);
    else if (it2(o4, false)) {
      const { message: t } = Et2("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(t);
    } else {
      const { message: t } = Et2("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(o4) {
    if (!Ia(o4)) {
      const { message: t } = Et2("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: t } = Et2("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(t);
    }
    if (fi(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: t } = Et2("EXPIRED", `proposal id: ${o4}`);
      throw new Error(t);
    }
  }
};
var ks2 = class extends Li3 {
  constructor(o4, t) {
    super(o4, t, ht4, me3), this.core = o4, this.logger = t;
  }
};
var vt4 = class extends Li3 {
  constructor(o4, t) {
    super(o4, t, dt4, me3), this.core = o4, this.logger = t;
  }
};
var Ds = class extends Li3 {
  constructor(o4, t) {
    super(o4, t, yt2, me3, (e2) => e2.id), this.core = o4, this.logger = t;
  }
};
var Ls2 = class extends Li3 {
  constructor(o4, t) {
    super(o4, t, Et4, ae3, () => ce3), this.core = o4, this.logger = t;
  }
};
var Ms2 = class extends Li3 {
  constructor(o4, t) {
    super(o4, t, ft2, ae3), this.core = o4, this.logger = t;
  }
};
var $s2 = class extends Li3 {
  constructor(o4, t) {
    super(o4, t, St5, ae3, (e2) => e2.id), this.core = o4, this.logger = t;
  }
};
var Ks2 = Object.defineProperty;
var Us = (S4, o4, t) => o4 in S4 ? Ks2(S4, o4, { enumerable: true, configurable: true, writable: true, value: t }) : S4[o4] = t;
var Ke5 = (S4, o4, t) => Us(S4, typeof o4 != "symbol" ? o4 + "" : o4, t);
var Gs2 = class {
  constructor(o4, t) {
    this.core = o4, this.logger = t, Ke5(this, "authKeys"), Ke5(this, "pairingTopics"), Ke5(this, "requests"), this.authKeys = new Ls2(this.core, this.logger), this.pairingTopics = new Ms2(this.core, this.logger), this.requests = new $s2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var js2 = Object.defineProperty;
var Fs = (S4, o4, t) => o4 in S4 ? js2(S4, o4, { enumerable: true, configurable: true, writable: true, value: t }) : S4[o4] = t;
var f5 = (S4, o4, t) => Fs(S4, typeof o4 != "symbol" ? o4 + "" : o4, t);
var Ee3 = class _Ee extends J2 {
  constructor(o4) {
    super(o4), f5(this, "protocol", Ce5), f5(this, "version", ke5), f5(this, "name", we3.name), f5(this, "metadata"), f5(this, "core"), f5(this, "logger"), f5(this, "events", new import_events8.EventEmitter()), f5(this, "engine"), f5(this, "session"), f5(this, "proposal"), f5(this, "pendingRequest"), f5(this, "auth"), f5(this, "signConfig"), f5(this, "on", (e2, s3) => this.events.on(e2, s3)), f5(this, "once", (e2, s3) => this.events.once(e2, s3)), f5(this, "off", (e2, s3) => this.events.off(e2, s3)), f5(this, "removeListener", (e2, s3) => this.events.removeListener(e2, s3)), f5(this, "removeAllListeners", (e2) => this.events.removeAllListeners(e2)), f5(this, "connect", async (e2) => {
      try {
        return await this.engine.connect(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "pair", async (e2) => {
      try {
        return await this.engine.pair(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "approve", async (e2) => {
      try {
        return await this.engine.approve(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "reject", async (e2) => {
      try {
        return await this.engine.reject(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "update", async (e2) => {
      try {
        return await this.engine.update(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "extend", async (e2) => {
      try {
        return await this.engine.extend(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "request", async (e2) => {
      try {
        return await this.engine.request(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "respond", async (e2) => {
      try {
        return await this.engine.respond(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "ping", async (e2) => {
      try {
        return await this.engine.ping(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "emit", async (e2) => {
      try {
        return await this.engine.emit(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "disconnect", async (e2) => {
      try {
        return await this.engine.disconnect(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "find", (e2) => {
      try {
        return this.engine.find(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }), f5(this, "authenticate", async (e2, s3) => {
      try {
        return await this.engine.authenticate(e2, s3);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }), f5(this, "formatAuthMessage", (e2) => {
      try {
        return this.engine.formatAuthMessage(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "approveSessionAuthenticate", async (e2) => {
      try {
        return await this.engine.approveSessionAuthenticate(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "rejectSessionAuthenticate", async (e2) => {
      try {
        return await this.engine.rejectSessionAuthenticate(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), this.name = (o4 == null ? void 0 : o4.name) || we3.name, this.metadata = Ks(o4 == null ? void 0 : o4.metadata), this.signConfig = o4 == null ? void 0 : o4.signConfig;
    const t = typeof (o4 == null ? void 0 : o4.logger) < "u" && typeof (o4 == null ? void 0 : o4.logger) != "string" ? o4.logger : (0, import_pino2.default)(k3({ level: (o4 == null ? void 0 : o4.logger) || we3.logger }));
    this.core = (o4 == null ? void 0 : o4.core) || new Zo3(o4), this.logger = E2(t, this.name), this.session = new vt4(this.core, this.logger), this.proposal = new ks2(this.core, this.logger), this.pendingRequest = new Ds(this.core, this.logger), this.engine = new Cs2(this), this.auth = new Gs2(this.core, this.logger);
  }
  static async init(o4) {
    const t = new _Ee(o4);
    return await t.initialize(), t;
  }
  get context() {
    return y2(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};

// node_modules/@dynamic-labs/wallet-connect/src/getSignClientSingleton/getSignClientSingleton.js
var signClientSingleton = void 0;
var getSignClientSingleton = (_a21) => __awaiter4(void 0, [_a21], void 0, function* ({ projectId, appIcon, appName }) {
  if (!signClientSingleton) {
    signClientSingleton = yield Ee3.init({
      customStoragePrefix: `dynamicauth_${projectId}_walletconnect`,
      metadata: {
        description: "",
        icons: [appIcon],
        name: appName,
        url: ""
      },
      projectId
    });
  }
  return signClientSingleton;
});

// node_modules/@dynamic-labs/wallet-connect/src/index.js
assertPackageVersion("@dynamic-labs/wallet-connect", version4);

// node_modules/@dynamic-labs/solana/src/walletConnect/SolanaWalletConnectConnector/createSolanaSignerForWalletConnect/createSolanaSignerForWalletConnect.js
var createSolanaSignerForWalletConnect = ({ walletConnector }) => {
  const connect = () => __awaiter2(void 0, void 0, void 0, function* () {
    const address = walletConnector.getActiveAddress();
    if (!address) {
      return void 0;
    }
    return { address, publicKey: new PublicKey3(address) };
  });
  const disconnect = () => __awaiter2(void 0, void 0, void 0, function* () {
    yield walletConnector.endSession();
  });
  const on6 = (event, listener) => {
    if (event === "connect") {
      logger2.debug("on - Not implemented for event: connect");
      return signer;
    }
    if (event === "activeWalletDidChange") {
      walletConnector.listenToActiveAccountChange(listener);
      return signer;
    }
    walletConnector.signClient.on("session_event", (sessionEvent) => {
      if (!walletConnector.session || sessionEvent.topic !== walletConnector.session.topic) {
        return;
      }
      if (sessionEvent.params.event.name === "accountsChanged" && event === "accountChanged") {
        const accountsParam = sessionEvent.params.event.data;
        const accounts = filterDuplicates(accountsParam.map((account) => {
          if (account.startsWith("solana:")) {
            return account.split(":")[2];
          }
          return account;
        }));
        listener(accounts[0]);
        return;
      }
      if (sessionEvent.params.event.name === "disconnected" && event === "disconnect") {
        listener("");
        return;
      }
    });
    return signer;
  };
  const signMessage3 = (messageArrayBuffer) => __awaiter2(void 0, void 0, void 0, function* () {
    const signature4 = yield walletConnector.signEncodedMessage(messageArrayBuffer);
    return { signature: signature4 };
  });
  const signAllTransactions = (transactions) => __awaiter2(void 0, void 0, void 0, function* () {
    return walletConnector.signAllTransactions(transactions);
  });
  const signAndSendTransaction = (transaction, options) => __awaiter2(void 0, void 0, void 0, function* () {
    const signature4 = yield walletConnector.signAndSendTransaction(transaction, options);
    return { signature: signature4 };
  });
  const signTransaction3 = (transaction) => __awaiter2(void 0, void 0, void 0, function* () {
    return walletConnector.signTransaction(transaction);
  });
  const signer = {
    addListener: () => {
      throw new Error("addListener - Not implemented");
    },
    connect,
    disconnect,
    emit: () => {
      throw new Error("emit - Not implemented");
    },
    eventNames: () => {
      logger2.error("eventNames - Not implemented");
      return [];
    },
    isBackpack: false,
    isBraveWallet: false,
    get isConnected() {
      return Boolean(walletConnector.getActiveAddress());
    },
    isExodus: false,
    isGlow: false,
    isMagicEden: false,
    isPhantom: false,
    isSolflare: false,
    listenerCount: () => {
      logger2.error("listenerCount - Not implemented");
      return 0;
    },
    listeners: () => {
      logger2.error("listeners - Not implemented");
      return [];
    },
    off: () => {
      throw new Error("off - Not implemented");
    },
    on: on6,
    once: () => {
      throw new Error("once - Not implemented");
    },
    providers: [],
    get publicKey() {
      const address = walletConnector.getActiveAddress();
      return address ? new PublicKey3(address) : void 0;
    },
    removeAllListeners: () => {
      throw new Error("removeAllListeners - Not implemented");
    },
    removeListener: () => {
      throw new Error("removeListener - Not implemented");
    },
    signAllTransactions,
    signAndSendTransaction,
    signMessage: signMessage3,
    signTransaction: signTransaction3
  };
  return signer;
};

// node_modules/@dynamic-labs/solana/src/walletConnect/SolanaWalletConnectConnector/SolanaWalletConnectConnector.js
var WC_SOLANA_CURRENT_CHAIN_KEY = "dynamic-wc2-solana-current-chain";
var SolanaWalletConnectConnector = class _SolanaWalletConnectConnector extends SolanaWalletConnector {
  constructor(opts2) {
    super(opts2);
    this.activeAccountEmitter = new eventemitter3_default();
    this.isInitialized = false;
    this.canConnectViaQrCode = true;
    this.isWalletConnect = true;
    this.canHandleMultipleConnections = false;
    this.mergeWalletBookChains = false;
    this.name = opts2.walletName;
    const storedChainId = StorageService.getItem(WC_SOLANA_CURRENT_CHAIN_KEY);
    if (storedChainId) {
      this.setNetworkId(storedChainId);
    }
    if (opts2.overrideKey) {
      this.overrideKey = opts2.overrideKey;
    }
    if (!opts2.projectId) {
      throw new DynamicError("WalletConnect project ID is required");
    }
  }
  get deepLinkPreference() {
    var _a21;
    return (_a21 = this.constructorProps.deepLinkPreference) !== null && _a21 !== void 0 ? _a21 : "native";
  }
  /**
   * Accesses the sign client singleton instance, and throws if it is not
   * immediately available.
   */
  get signClient() {
    if (!_SolanaWalletConnectConnector.signClientReference) {
      throw new DynamicError("Failed to access sign client for Wallet Connect Solana: Sign client not initialized");
    }
    return _SolanaWalletConnectConnector.signClientReference;
  }
  getAvailableMethods() {
    var _a21, _b;
    if (!this.session) {
      return [];
    }
    return (_b = (_a21 = this.session.namespaces.solana) === null || _a21 === void 0 ? void 0 : _a21.methods) !== null && _b !== void 0 ? _b : [];
  }
  getSupportedNetworks() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b;
      if (!this.session) {
        return this.solNetworks.map((network) => network.chainId.toString());
      }
      const sessionChains = (_b = (_a21 = this.session.namespaces.solana) === null || _a21 === void 0 ? void 0 : _a21.chains) !== null && _b !== void 0 ? _b : [];
      return this.solNetworks.filter((network) => sessionChains.includes(`solana:${network.genesisHash}`)).map((network) => network.chainId.toString());
    });
  }
  getActiveAddress() {
    var _a21, _b;
    if (!this.session) {
      logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] getActiveAddress - no session, returning undefined");
      return void 0;
    }
    logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] getActiveAddress - session", this.session);
    return (_b = (_a21 = this.session.namespaces.solana) === null || _a21 === void 0 ? void 0 : _a21.accounts) === null || _b === void 0 ? void 0 : _b[0].split(":")[2];
  }
  listenToActiveAccountChange(listener) {
    this.activeAccountEmitter.on("activeAccountDidChange", listener);
    return () => {
      this.activeAccountEmitter.off("activeAccountDidChange", listener);
    };
  }
  isSendBalanceUnsupported() {
    if (!this.session) {
      return false;
    }
    const supportedMethods = this.getAvailableMethods();
    return !supportedMethods.includes("solana_signAndSendTransaction") && !supportedMethods.includes("solana_signTransaction");
  }
  createUiTransaction(from13) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from13);
      if (this.isSendBalanceUnsupported()) {
        throw new DynamicError("Wallet does not support signing transactions. Please connect to a wallet that supports signing transactions.");
      }
      const transaction = new SolanaUiTransaction({
        connection: this.getWalletClient(),
        from: from13,
        onSubmit: (transaction2) => __awaiter2(this, void 0, void 0, function* () {
          var _a21;
          if (!transaction2)
            return;
          const blockhash = yield this.getWalletClient().getLatestBlockhash();
          if ("version" in transaction2) {
            transaction2.message.recentBlockhash = blockhash.blockhash;
          } else {
            transaction2.recentBlockhash = blockhash.blockhash;
            transaction2.feePayer = (_a21 = transaction2.feePayer) !== null && _a21 !== void 0 ? _a21 : new PublicKey3(from13);
          }
          return yield this.signAndSendTransaction(transaction2);
        })
      });
      return transaction;
    });
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      return createSolanaSignerForWalletConnect({ walletConnector: this });
    });
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      throw new Error("Connect method not implemented.");
    });
  }
  static globalInit(args) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b;
      _SolanaWalletConnectConnector.signClientPromise = getSignClientSingleton({
        appIcon: (_a21 = args.appLogoUrl) !== null && _a21 !== void 0 ? _a21 : "",
        appName: (_b = args.appName) !== null && _b !== void 0 ? _b : "",
        projectId: args.projectId
      });
      _SolanaWalletConnectConnector.signClientReference = yield _SolanaWalletConnectConnector.signClientPromise;
      _SolanaWalletConnectConnector.signClientReference.on("session_event", (event) => {
        _SolanaWalletConnectConnector.sessionEventListeners.forEach((listener) => {
          listener(event);
        });
      });
    });
  }
  static testOnly__reset() {
    _SolanaWalletConnectConnector.signClientPromise = void 0;
    _SolanaWalletConnectConnector.signClientReference = void 0;
    _SolanaWalletConnectConnector.sessionEventListeners = [];
  }
  init() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b, _c3, _d;
      if (this.isInitialized) {
        return;
      }
      logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] init called");
      this.isInitialized = true;
      const isWalletConnectEnabled = (_d = (_c3 = (_b = (_a21 = this.constructorProps.settings) === null || _a21 === void 0 ? void 0 : _a21.sdk) === null || _b === void 0 ? void 0 : _b.walletConnect) === null || _c3 === void 0 ? void 0 : _c3.v2Enabled) !== null && _d !== void 0 ? _d : false;
      if (!isWalletConnectEnabled) {
        logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] skipping init - WalletConnect is not enabled in project settings");
        return;
      }
      if (_SolanaWalletConnectConnector.signClientPromise) {
        yield _SolanaWalletConnectConnector.signClientPromise;
        this.setupWCEventListeners();
        return;
      }
      yield _SolanaWalletConnectConnector.globalInit(this.constructorProps);
      this.setupWCEventListeners();
    });
  }
  handleSessionEvent({ params: { event }, topic }) {
    var _a21, _b;
    if (!this.session || topic !== this.session.topic) {
      return;
    }
    if (event.name === "chainChanged") {
      const chainParam = event.data;
      let chainId = chainParam;
      if (typeof chainParam === "string" && chainParam.startsWith("solana:")) {
        const chainHash = chainParam.split(":")[1];
        chainId = (_b = (_a21 = this.solNetworks.find((network) => network.genesisHash === chainHash)) === null || _a21 === void 0 ? void 0 : _a21.networkId.toString()) !== null && _b !== void 0 ? _b : chainParam;
      }
      logger2.debug("[SolanaWalletConnect] onChainChange", { chainId });
      if (chainId === this.getNetworkId()) {
        logger2.debug(`[SolanaWalletConnect] onChainChange - ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
        return;
      }
      this.switchNetwork({ networkChainId: parseInt(String(chainId)) });
      return;
    }
    if (event.name === "accountsChanged") {
      const accountsParam = event.data;
      const accounts = filterDuplicates(accountsParam.map((account) => {
        if (account.startsWith("solana:")) {
          return account.split(":")[2];
        }
        return account;
      }));
      logger2.debug("[SolanaWalletConnect] onAccountChanged", { accounts });
      this.emit("accountChange", { accounts });
      return;
    }
    if (event.name === "disconnected") {
      logger2.debug("[SolanaWalletConnect] onDisconnect");
      this.emit("disconnect");
      this.endSession();
      return;
    }
  }
  setupWCEventListeners() {
    _SolanaWalletConnectConnector.sessionEventListeners.push((event) => this.handleSessionEvent(event));
  }
  endSession() {
    return __awaiter2(this, void 0, void 0, function* () {
      logger2.debug("[SolanaWalletConnect] endSession");
      this.connectionUri = void 0;
      if (!this.session) {
        return;
      }
      yield this.signClient.disconnect({
        reason: Jo2.USER_DISCONNECTED,
        topic: this.session.topic
      });
      this.session = void 0;
    });
  }
  displayUri(connectionOpts) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!this.connectionUri) {
        return;
      }
      logger2.debug("[SolanaWalletConnect] handleDisplayURI", this.connectionUri);
      yield performPlatformSpecificConnectionMethod(this.connectionUri, this.metadata.deepLinks, {
        onDesktopUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDesktopUri,
        onDisplayUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDisplayUri
      }, this.deepLinkPreference);
    });
  }
  getAddress(opts2) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      logger2.debug("[SolanaWalletConnect] getAddress", opts2);
      if (this.session) {
        return this.getActiveAddress();
      }
      if (this.connectionUri) {
        logger2.debug("[SolanaWalletConnect] getAddress - connecting to WalletConnect with existing connection URI");
        yield this.displayUri(opts2);
        return;
      }
      logger2.logVerboseTroubleshootingMessage("[WalletConnectConnector] getAddress", {
        inAppBrowserUrl: (_a21 = this.metadata) === null || _a21 === void 0 ? void 0 : _a21.inAppBrowserUrl,
        isMobile: isMobile(),
        mobileExperience: this.mobileExperience
      });
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      logger2.debug("[SolanaWalletConnect] getAddress - connecting to WalletConnect");
      const chains = this.solNetworks.map((network) => `solana:${network.genesisHash}`);
      const signClient = yield _SolanaWalletConnectConnector.signClientPromise;
      if (!signClient) {
        throw new DynamicError("Failed to access sign client for Wallet Connect Solana: Sign client not initialized");
      }
      try {
        const { approval, uri } = yield signClient.connect({
          optionalNamespaces: {
            solana: {
              chains,
              events: ["chainChanged", "accountsChanged", "disconnected"],
              methods: [
                "solana_signMessage",
                "solana_signTransaction",
                "solana_requestAccounts",
                "solana_getAccounts",
                "solana_signAllTransactions",
                "solana_signAndSendTransaction"
              ]
            }
          }
        });
        logger2.debug("[SolanaWalletConnect] getAddress - connection URI", uri);
        this.connectionUri = uri;
        yield this.displayUri(opts2);
        this.session = yield approval();
        const activeAddress = this.getActiveAddress();
        this.activeAccountEmitter.emit("activeAccountDidChange", activeAddress);
        return activeAddress;
      } finally {
        this.connectionUri = void 0;
      }
    });
  }
  signClientRequest(_a21) {
    return __awaiter2(this, arguments, void 0, function* ({ method, params }) {
      var _b, _c3;
      if (!this.session) {
        throw new DynamicError("Session not initialized. Please connect to a wallet first.");
      }
      const chainHash = (_c3 = (_b = this.getSelectedNetwork()) === null || _b === void 0 ? void 0 : _b.genesisHash) !== null && _c3 !== void 0 ? _c3 : this.solNetworks[0].genesisHash;
      const chainId = `solana:${chainHash}`;
      try {
        const requestPromise = this.signClient.request({
          chainId,
          request: {
            method,
            params
          },
          topic: this.session.topic
        });
        this.deepLinkIfApplicable({ method });
        return yield requestPromise;
      } catch (error) {
        if (error.message === "An error has occured. Please, try again.") {
          yield this.endSession();
          throw new DynamicError("Wallet connection lost. Please, try again.");
        }
        throw error;
      }
    });
  }
  deepLinkIfApplicable(params) {
    const methodsThatRequireDeepLink = [
      "solana_signMessage",
      "solana_signTransaction",
      "solana_signAllTransactions",
      "solana_signAndSendTransaction"
    ];
    const deepLink = this.getDeepLink();
    if (isMobile() && deepLink && methodsThatRequireDeepLink.includes(params.method)) {
      PlatformService.openURL(deepLink);
    }
  }
  signMessage(messageToSign, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] signMessage", messageToSign, options);
      const encodedMessage = new TextEncoder().encode(messageToSign);
      const decodedSignature = yield this.signEncodedMessage(encodedMessage, options);
      return bufferToBase64(decodedSignature);
    });
  }
  signEncodedMessage(encodedMessage, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] signEncodedMessage", encodedMessage, options);
      if (options === null || options === void 0 ? void 0 : options.address) {
        yield this.validateActiveWallet(options.address);
      }
      const activeAddress = this.getActiveAddress();
      if (!activeAddress) {
        throw new DynamicError("No active address found");
      }
      const { signature: signature4 } = yield this.signClientRequest({
        method: "solana_signMessage",
        params: {
          message: import_bs585.default.encode(encodedMessage),
          pubkey: new PublicKey3(activeAddress).toBase58()
        }
      });
      return import_bs585.default.decode(signature4);
    });
  }
  serializeTransaction(transaction) {
    const serialized = transaction.serialize({
      requireAllSignatures: false,
      verifySignatures: false
    });
    return Buffer.from(new Uint8Array(serialized)).toString("base64");
  }
  signTransaction(transaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      const activeAddress = this.getActiveAddress();
      if (!activeAddress) {
        throw new DynamicError("Active account address is required");
      }
      logger2.debug("[SolanaWalletConnect] Signing transaction", {
        activeAddress,
        isVersioned: "version" in transaction,
        transaction
      });
      const serializedTransaction = this.serializeTransaction(transaction);
      logger2.debug("[SolanaWalletConnect] Sending to wallet for signing", {
        serializedLength: serializedTransaction.length
      });
      const { signature: signature4 } = yield this.signClientRequest({
        method: "solana_signTransaction",
        params: { transaction: serializedTransaction }
      });
      logger2.debug("[SolanaWalletConnect] Received transaction signature from wallet", { signature: signature4 });
      const signatureBytes = import_bs585.default.decode(signature4);
      transaction.addSignature(new PublicKey3(activeAddress), signatureBytes);
      return transaction;
    });
  }
  signAllTransactions(transactions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const serializedTransactions = transactions.map(this.serializeTransaction);
      const { transactions: signedTransactions } = yield this.signClientRequest({
        method: "solana_signAllTransactions",
        params: { transactions: serializedTransactions }
      });
      return signedTransactions.map((signedTransaction, index) => {
        const originalTransaction = transactions[index];
        const decodedTransaction = new Uint8Array(Buffer.from(signedTransaction, "base64"));
        if (isVersionedTransaction(originalTransaction)) {
          return VersionedTransaction3.deserialize(decodedTransaction);
        }
        return Transaction3.from(decodedTransaction);
      });
    });
  }
  signAndSendTransaction(transaction, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const supportedMethods = this.getAvailableMethods();
      if (supportedMethods.includes("solana_signAndSendTransaction")) {
        const serializedTransaction = this.serializeTransaction(transaction);
        const { signature: signature4 } = yield this.signClientRequest({
          method: "solana_signAndSendTransaction",
          params: { sendOptions: options, transaction: serializedTransaction }
        });
        return signature4;
      }
      if (supportedMethods.includes("solana_signTransaction")) {
        logger2.debug("[SolanaWalletConnect] Using fallback: signTransaction + sendRawTransaction");
        const signedTransaction = yield this.signTransaction(transaction);
        const isSigned = isTxAlreadySigned(signedTransaction);
        logger2.debug("[SolanaWalletConnect] Transaction signed, checking signatures", {
          hasSignatures: "signatures" in signedTransaction && signedTransaction.signatures.length > 0,
          isSigned,
          signaturesLength: "signatures" in signedTransaction ? signedTransaction.signatures.length : "N/A"
        });
        if (!isSigned) {
          throw new DynamicError("Transaction returned from wallet was not properly signed. The wallet may have rejected the signing request.");
        }
        const serialized = signedTransaction.serialize();
        logger2.debug("[SolanaWalletConnect] Transaction serialized", {
          serializedLength: serialized.length
        });
        const signature4 = yield this.getWalletClient().sendRawTransaction(serialized, options);
        logger2.debug("[SolanaWalletConnect] Transaction sent successfully", {
          signature: signature4
        });
        return signature4;
      }
      throw new DynamicError("Wallet does not support signing and sending transactions. Please connect to a wallet that supports at least solana_signTransaction.");
    });
  }
  getDeepLink() {
    const deepLink = getDeepLink({
      deepLinks: this.metadata.deepLinks,
      mode: "regular",
      preference: this.deepLinkPreference
    });
    logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] getDeepLink - deepLink", deepLink);
    if (!deepLink) {
      return;
    }
    if (this.session) {
      return `${deepLink}?sessionTopic=${this.session.topic}`;
    }
    return deepLink;
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      const account = this.getActiveAddress();
      if (!account) {
        logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] getConnectedAccounts - no activeAccounts, returning empty array");
        return [];
      }
      logger2.logVerboseTroubleshootingMessage("[SolanaWalletConnect] getConnectedAccounts - activeAccounts", [account]);
      return [account];
    });
  }
  getConnectionUri() {
    return this.connectionUri;
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger2.debug("[SolanaWalletConnect] validateActiveWallet - validating wallet", expectedAddress);
      const [activeAddress] = yield this.getConnectedAccounts();
      const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (isWalletActive) {
        logger2.debug("[SolanaWalletConnect] validateActiveWallet - wallet is active");
        return;
      }
      return this.handleWalletNotActive({
        activeAddress,
        expectedAddress
      });
    });
  }
};
SolanaWalletConnectConnector.sessionEventListeners = [];

// node_modules/@dynamic-labs/solana/src/injected/InjectedWalletBase/InjectedWalletBase.js
var InjectedWalletBase = class extends SolanaWalletConnector {
  constructor() {
    super(...arguments);
    this.walletConnectWalletBookEntry = void 0;
  }
  getMobileOrInstalledWallet() {
    const canUseWalletConnect = this.walletConnectWalletBookEntry && this.constructorProps.projectId;
    logger2.logVerboseTroubleshootingMessage("[SOL InjectedWalletBase] getMobileOrInstalledWallet", {
      canUseWalletConnect,
      isInstalledOnBrowser: this.isInstalledOnBrowser(),
      projectId: this.constructorProps.projectId,
      walletConnectWalletBookEntry: this.walletConnectWalletBookEntry
    });
    if (this.isInstalledOnBrowser() || !canUseWalletConnect) {
      return this;
    }
    const wcConnector = new SolanaWalletConnectConnector(Object.assign(Object.assign({}, this.constructorProps), { metadata: getWalletMetadataFromWalletBook(Object.assign(Object.assign({}, this.metadata), { walletBook: this.walletBook, walletBookWallet: this.walletConnectWalletBookEntry, walletKey: this.key })), overrideKey: this.key, walletName: this.name }));
    wcConnector.init();
    return wcConnector;
  }
  get solProviderHelper() {
    if (!this._solProviderHelper) {
      this._solProviderHelper = new SolProviderHelper(this);
    }
    return this._solProviderHelper;
  }
  findProvider() {
    var _a21;
    return (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.getInstalledProvider();
  }
  setupEventListeners() {
    var _a21;
    (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21._setupEventListeners();
  }
  teardownEventListeners() {
    var _a21;
    (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21._teardownEventListeners();
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      yield (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.connect();
    });
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      return (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.connect();
    });
  }
  createUiTransaction(from13) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from13);
      const transaction = new SolanaUiTransaction({
        connection: this.getWalletClient(),
        from: from13,
        onSubmit: (transaction2) => __awaiter2(this, void 0, void 0, function* () {
          var _a21;
          if (!transaction2)
            return;
          const signer = yield this.getSigner();
          if (!signer)
            throw new Error("Signer not found");
          const blockhash = yield this.getWalletClient().getLatestBlockhash();
          if ("version" in transaction2) {
            transaction2.message.recentBlockhash = blockhash.blockhash;
          } else {
            const userAddress = yield this.getAddress();
            if (!userAddress)
              throw new Error("User address not found");
            transaction2.recentBlockhash = blockhash.blockhash;
            transaction2.feePayer = (_a21 = transaction2.feePayer) !== null && _a21 !== void 0 ? _a21 : new PublicKey3(userAddress);
          }
          return (yield signer.signAndSendTransaction(transaction2)).signature;
        })
      });
      return transaction;
    });
  }
  isInstalledOnBrowser() {
    var _a21;
    return Boolean((_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.isInstalledHelper());
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      return (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.getAddress();
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b;
      const walletAddress = yield (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.getAddress();
      if (walletAddress && this.isLedgerAddress(walletAddress)) {
        throw new SignMessageNotSupportedError(this.name);
      }
      return (_b = this.solProviderHelper) === null || _b === void 0 ? void 0 : _b.signMessage(messageToSign);
    });
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b;
      return (_b = (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.getConnectedAccounts()) !== null && _b !== void 0 ? _b : [];
    });
  }
};

// node_modules/@dynamic-labs/solana/src/injected/BackpackSol/BackpackSol.js
var BackpackSol = class extends InjectedWalletBase {
  constructor(props) {
    super(props);
    this.name = "Backpack";
    this.overrideKey = "backpacksol";
    this.walletConnectWalletBookEntry = findWalletBookWallet(props.walletBook, this.key);
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      return (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.connect();
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const publicAddress = yield this.getAddress();
      if (!publicAddress) {
        return void 0;
      }
      const provider = yield this.getSigner();
      if (!provider) {
        return void 0;
      }
      const signedMessage = yield provider.signMessage(Buffer.from(messageToSign, "utf8"));
      if (!signedMessage) {
        return void 0;
      }
      if (typeof signedMessage === "object" && "signature" in signedMessage) {
        return bufferToBase64(signedMessage.signature);
      }
      return bufferToBase64(signedMessage);
    });
  }
};
Object.defineProperty(BackpackSol, "key", {
  value: "backpacksol",
  writable: false
});

// node_modules/@dynamic-labs/embedded-wallet-solana/package.js
var version5 = "4.57.1";

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/package.js
var version6 = "4.57.1";

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/_virtual/_tslib.js
function __awaiter6(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet4(receiver, state, kind, f8) {
  if (kind === "a" && !f8) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f8 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f8 : kind === "a" ? f8.call(receiver) : f8 ? f8.value : state.get(receiver);
}
function __classPrivateFieldSet4(receiver, state, value, kind, f8) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f8) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f8 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f8.call(receiver, value) : f8 ? f8.value = value : state.set(receiver, value), value;
}

// node_modules/@turnkey/api-key-stamper/dist/index.mjs
var stampHeaderName = "X-Stamp";
var isCryptoEnabledBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
var isNode2 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var detectRuntime = () => {
  if (isCryptoEnabledBrowser) {
    return "browser";
  }
  if (isNode2) {
    return "node";
  }
  return "purejs";
};
var signWithApiKey = async (input, runtimeOverride) => {
  const runtime = runtimeOverride ?? detectRuntime();
  switch (runtime) {
    case "browser":
      return (await import("./webcrypto-S2YDHMAT.js")).signWithApiKey(input);
    case "node":
      return (await import("./nodecrypto-R3DU34XD.js")).signWithApiKey(input);
    case "purejs":
      return (await import("./purejs-GUSF7FYP.js")).signWithApiKey(input);
    default:
      throw new Error(`Unsupported runtime: ${runtime}`);
  }
};
var ApiKeyStamper = class {
  constructor(config) {
    this.apiPublicKey = config.apiPublicKey;
    this.apiPrivateKey = config.apiPrivateKey;
    this.runtimeOverride = config.runtimeOverride;
  }
  async stamp(payload) {
    const signature4 = await signWithApiKey({
      publicKey: this.apiPublicKey,
      privateKey: this.apiPrivateKey,
      content: payload
    }, this.runtimeOverride);
    const stamp = {
      publicKey: this.apiPublicKey,
      scheme: "SIGNATURE_SCHEME_TK_API_P256",
      signature: signature4
    };
    return {
      stampHeaderName,
      stampHeaderValue: stringToBase64urlString(JSON.stringify(stamp))
    };
  }
};

// node_modules/@turnkey/http/dist/universal.mjs
var import_cross_fetch = __toESM(require_browser_ponyfill(), 1);
var fetch2 = import_cross_fetch.fetch;

// node_modules/@turnkey/http/dist/webauthn-json/convert.mjs
var copyValue = "copy";
var convertValue = "convert";
function derived(schema, derive) {
  return {
    required: true,
    schema,
    derive
  };
}
function required(schema) {
  return {
    required: true,
    schema
  };
}
function optional2(schema) {
  return {
    required: false,
    schema
  };
}

// node_modules/@turnkey/http/dist/webauthn-json/schema.mjs
var simplifiedClientExtensionResultsSchema = {
  appid: optional2(copyValue),
  appidExclude: optional2(copyValue),
  credProps: optional2(copyValue)
};
var publicKeyCredentialWithAttestation = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional2(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    attestationObject: required(convertValue),
    transports: derived(copyValue, (response) => {
      var _a21;
      return ((_a21 = response.getTransports) == null ? void 0 : _a21.call(response)) || [];
    })
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
};
var publicKeyCredentialWithAssertion = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional2(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    authenticatorData: required(convertValue),
    signature: required(convertValue),
    userHandle: required(convertValue)
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
};

// node_modules/@turnkey/http/dist/webauthn.mjs
var defaultTimeout = 5 * 60 * 1e3;

// node_modules/@turnkey/http/dist/base.mjs
function isHttpClient(client) {
  return (client == null ? void 0 : client.name) === "TurnkeyClient";
}
var TurnkeyRequestError = class extends Error {
  constructor(input) {
    let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;
    if (input.details != null) {
      turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;
    }
    super(turnkeyErrorMessage);
    this.name = "TurnkeyRequestError";
    this.details = input.details ?? null;
    this.code = input.code;
  }
};

// node_modules/@turnkey/http/dist/version.mjs
var VERSION = "@turnkey/http@3.10.0";

// node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs
var TurnkeyClient = class {
  constructor(config, stamper) {
    this.name = "TurnkeyClient";
    this.getActivity = async (input) => {
      return this.request("/public/v1/query/get_activity", input);
    };
    this.stampGetActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getApiKey = async (input) => {
      return this.request("/public/v1/query/get_api_key", input);
    };
    this.stampGetApiKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getApiKeys = async (input) => {
      return this.request("/public/v1/query/get_api_keys", input);
    };
    this.stampGetApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAttestationDocument = async (input) => {
      return this.request("/public/v1/query/get_attestation", input);
    };
    this.stampGetAttestationDocument = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_attestation";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAuthenticator = async (input) => {
      return this.request("/public/v1/query/get_authenticator", input);
    };
    this.stampGetAuthenticator = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticator";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAuthenticators = async (input) => {
      return this.request("/public/v1/query/get_authenticators", input);
    };
    this.stampGetAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOauthProviders = async (input) => {
      return this.request("/public/v1/query/get_oauth_providers", input);
    };
    this.stampGetOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOrganization = async (input) => {
      return this.request("/public/v1/query/get_organization", input);
    };
    this.stampGetOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOrganizationConfigs = async (input) => {
      return this.request("/public/v1/query/get_organization_configs", input);
    };
    this.stampGetOrganizationConfigs = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization_configs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicy = async (input) => {
      return this.request("/public/v1/query/get_policy", input);
    };
    this.stampGetPolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicyEvaluations = async (input) => {
      return this.request("/public/v1/query/get_policy_evaluations", input);
    };
    this.stampGetPolicyEvaluations = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_policy_evaluations";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPrivateKey = async (input) => {
      return this.request("/public/v1/query/get_private_key", input);
    };
    this.stampGetPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSmartContractInterface = async (input) => {
      return this.request("/public/v1/query/get_smart_contract_interface", input);
    };
    this.stampGetSmartContractInterface = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_smart_contract_interface";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getUser = async (input) => {
      return this.request("/public/v1/query/get_user", input);
    };
    this.stampGetUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWallet = async (input) => {
      return this.request("/public/v1/query/get_wallet", input);
    };
    this.stampGetWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWalletAccount = async (input) => {
      return this.request("/public/v1/query/get_wallet_account", input);
    };
    this.stampGetWalletAccount = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet_account";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getActivities = async (input) => {
      return this.request("/public/v1/query/list_activities", input);
    };
    this.stampGetActivities = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_activities";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicies = async (input) => {
      return this.request("/public/v1/query/list_policies", input);
    };
    this.stampGetPolicies = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_policies";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.listPrivateKeyTags = async (input) => {
      return this.request("/public/v1/query/list_private_key_tags", input);
    };
    this.stampListPrivateKeyTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_key_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPrivateKeys = async (input) => {
      return this.request("/public/v1/query/list_private_keys", input);
    };
    this.stampGetPrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSmartContractInterfaces = async (input) => {
      return this.request("/public/v1/query/list_smart_contract_interfaces", input);
    };
    this.stampGetSmartContractInterfaces = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_smart_contract_interfaces";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSubOrgIds = async (input) => {
      return this.request("/public/v1/query/list_suborgs", input);
    };
    this.stampGetSubOrgIds = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_suborgs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.listUserTags = async (input) => {
      return this.request("/public/v1/query/list_user_tags", input);
    };
    this.stampListUserTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_user_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getUsers = async (input) => {
      return this.request("/public/v1/query/list_users", input);
    };
    this.stampGetUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getVerifiedSubOrgIds = async (input) => {
      return this.request("/public/v1/query/list_verified_suborgs", input);
    };
    this.stampGetVerifiedSubOrgIds = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_verified_suborgs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWalletAccounts = async (input) => {
      return this.request("/public/v1/query/list_wallet_accounts", input);
    };
    this.stampGetWalletAccounts = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallet_accounts";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWallets = async (input) => {
      return this.request("/public/v1/query/list_wallets", input);
    };
    this.stampGetWallets = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallets";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWhoami = async (input) => {
      return this.request("/public/v1/query/whoami", input);
    };
    this.stampGetWhoami = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/whoami";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.approveActivity = async (input) => {
      return this.request("/public/v1/submit/approve_activity", input);
    };
    this.stampApproveActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/approve_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createApiKeys = async (input) => {
      return this.request("/public/v1/submit/create_api_keys", input);
    };
    this.stampCreateApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createApiOnlyUsers = async (input) => {
      return this.request("/public/v1/submit/create_api_only_users", input);
    };
    this.stampCreateApiOnlyUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_only_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createAuthenticators = async (input) => {
      return this.request("/public/v1/submit/create_authenticators", input);
    };
    this.stampCreateAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createInvitations = async (input) => {
      return this.request("/public/v1/submit/create_invitations", input);
    };
    this.stampCreateInvitations = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_invitations";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createOauthProviders = async (input) => {
      return this.request("/public/v1/submit/create_oauth_providers", input);
    };
    this.stampCreateOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPolicies = async (input) => {
      return this.request("/public/v1/submit/create_policies", input);
    };
    this.stampCreatePolicies = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policies";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPolicy = async (input) => {
      return this.request("/public/v1/submit/create_policy", input);
    };
    this.stampCreatePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPrivateKeyTag = async (input) => {
      return this.request("/public/v1/submit/create_private_key_tag", input);
    };
    this.stampCreatePrivateKeyTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_key_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPrivateKeys = async (input) => {
      return this.request("/public/v1/submit/create_private_keys", input);
    };
    this.stampCreatePrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createReadOnlySession = async (input) => {
      return this.request("/public/v1/submit/create_read_only_session", input);
    };
    this.stampCreateReadOnlySession = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_only_session";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createReadWriteSession = async (input) => {
      return this.request("/public/v1/submit/create_read_write_session", input);
    };
    this.stampCreateReadWriteSession = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_write_session";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createSmartContractInterface = async (input) => {
      return this.request("/public/v1/submit/create_smart_contract_interface", input);
    };
    this.stampCreateSmartContractInterface = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_smart_contract_interface";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createSubOrganization = async (input) => {
      return this.request("/public/v1/submit/create_sub_organization", input);
    };
    this.stampCreateSubOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_sub_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createUserTag = async (input) => {
      return this.request("/public/v1/submit/create_user_tag", input);
    };
    this.stampCreateUserTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_user_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createUsers = async (input) => {
      return this.request("/public/v1/submit/create_users", input);
    };
    this.stampCreateUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createWallet = async (input) => {
      return this.request("/public/v1/submit/create_wallet", input);
    };
    this.stampCreateWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createWalletAccounts = async (input) => {
      return this.request("/public/v1/submit/create_wallet_accounts", input);
    };
    this.stampCreateWalletAccounts = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet_accounts";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteApiKeys = async (input) => {
      return this.request("/public/v1/submit/delete_api_keys", input);
    };
    this.stampDeleteApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteAuthenticators = async (input) => {
      return this.request("/public/v1/submit/delete_authenticators", input);
    };
    this.stampDeleteAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteInvitation = async (input) => {
      return this.request("/public/v1/submit/delete_invitation", input);
    };
    this.stampDeleteInvitation = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_invitation";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteOauthProviders = async (input) => {
      return this.request("/public/v1/submit/delete_oauth_providers", input);
    };
    this.stampDeleteOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePolicy = async (input) => {
      return this.request("/public/v1/submit/delete_policy", input);
    };
    this.stampDeletePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePrivateKeyTags = async (input) => {
      return this.request("/public/v1/submit/delete_private_key_tags", input);
    };
    this.stampDeletePrivateKeyTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_key_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePrivateKeys = async (input) => {
      return this.request("/public/v1/submit/delete_private_keys", input);
    };
    this.stampDeletePrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteSmartContractInterface = async (input) => {
      return this.request("/public/v1/submit/delete_smart_contract_interface", input);
    };
    this.stampDeleteSmartContractInterface = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_smart_contract_interface";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteSubOrganization = async (input) => {
      return this.request("/public/v1/submit/delete_sub_organization", input);
    };
    this.stampDeleteSubOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_sub_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteUserTags = async (input) => {
      return this.request("/public/v1/submit/delete_user_tags", input);
    };
    this.stampDeleteUserTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_user_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteUsers = async (input) => {
      return this.request("/public/v1/submit/delete_users", input);
    };
    this.stampDeleteUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteWallets = async (input) => {
      return this.request("/public/v1/submit/delete_wallets", input);
    };
    this.stampDeleteWallets = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_wallets";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.emailAuth = async (input) => {
      return this.request("/public/v1/submit/email_auth", input);
    };
    this.stampEmailAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/email_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportPrivateKey = async (input) => {
      return this.request("/public/v1/submit/export_private_key", input);
    };
    this.stampExportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportWallet = async (input) => {
      return this.request("/public/v1/submit/export_wallet", input);
    };
    this.stampExportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportWalletAccount = async (input) => {
      return this.request("/public/v1/submit/export_wallet_account", input);
    };
    this.stampExportWalletAccount = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet_account";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.importPrivateKey = async (input) => {
      return this.request("/public/v1/submit/import_private_key", input);
    };
    this.stampImportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/import_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.importWallet = async (input) => {
      return this.request("/public/v1/submit/import_wallet", input);
    };
    this.stampImportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/import_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initFiatOnRamp = async (input) => {
      return this.request("/public/v1/submit/init_fiat_on_ramp", input);
    };
    this.stampInitFiatOnRamp = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_fiat_on_ramp";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initImportPrivateKey = async (input) => {
      return this.request("/public/v1/submit/init_import_private_key", input);
    };
    this.stampInitImportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initImportWallet = async (input) => {
      return this.request("/public/v1/submit/init_import_wallet", input);
    };
    this.stampInitImportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initOtp = async (input) => {
      return this.request("/public/v1/submit/init_otp", input);
    };
    this.stampInitOtp = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initOtpAuth = async (input) => {
      return this.request("/public/v1/submit/init_otp_auth", input);
    };
    this.stampInitOtpAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initUserEmailRecovery = async (input) => {
      return this.request("/public/v1/submit/init_user_email_recovery", input);
    };
    this.stampInitUserEmailRecovery = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_user_email_recovery";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.oauth = async (input) => {
      return this.request("/public/v1/submit/oauth", input);
    };
    this.stampOauth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.oauthLogin = async (input) => {
      return this.request("/public/v1/submit/oauth_login", input);
    };
    this.stampOauthLogin = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth_login";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.otpAuth = async (input) => {
      return this.request("/public/v1/submit/otp_auth", input);
    };
    this.stampOtpAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.otpLogin = async (input) => {
      return this.request("/public/v1/submit/otp_login", input);
    };
    this.stampOtpLogin = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_login";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.recoverUser = async (input) => {
      return this.request("/public/v1/submit/recover_user", input);
    };
    this.stampRecoverUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/recover_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.rejectActivity = async (input) => {
      return this.request("/public/v1/submit/reject_activity", input);
    };
    this.stampRejectActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/reject_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.removeOrganizationFeature = async (input) => {
      return this.request("/public/v1/submit/remove_organization_feature", input);
    };
    this.stampRemoveOrganizationFeature = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/remove_organization_feature";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.setOrganizationFeature = async (input) => {
      return this.request("/public/v1/submit/set_organization_feature", input);
    };
    this.stampSetOrganizationFeature = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/set_organization_feature";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signRawPayload = async (input) => {
      return this.request("/public/v1/submit/sign_raw_payload", input);
    };
    this.stampSignRawPayload = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payload";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signRawPayloads = async (input) => {
      return this.request("/public/v1/submit/sign_raw_payloads", input);
    };
    this.stampSignRawPayloads = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payloads";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signTransaction = async (input) => {
      return this.request("/public/v1/submit/sign_transaction", input);
    };
    this.stampSignTransaction = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_transaction";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.stampLogin = async (input) => {
      return this.request("/public/v1/submit/stamp_login", input);
    };
    this.stampStampLogin = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/stamp_login";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updatePolicy = async (input) => {
      return this.request("/public/v1/submit/update_policy", input);
    };
    this.stampUpdatePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updatePrivateKeyTag = async (input) => {
      return this.request("/public/v1/submit/update_private_key_tag", input);
    };
    this.stampUpdatePrivateKeyTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_private_key_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateRootQuorum = async (input) => {
      return this.request("/public/v1/submit/update_root_quorum", input);
    };
    this.stampUpdateRootQuorum = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_root_quorum";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUser = async (input) => {
      return this.request("/public/v1/submit/update_user", input);
    };
    this.stampUpdateUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserEmail = async (input) => {
      return this.request("/public/v1/submit/update_user_email", input);
    };
    this.stampUpdateUserEmail = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_email";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserName = async (input) => {
      return this.request("/public/v1/submit/update_user_name", input);
    };
    this.stampUpdateUserName = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_name";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserPhoneNumber = async (input) => {
      return this.request("/public/v1/submit/update_user_phone_number", input);
    };
    this.stampUpdateUserPhoneNumber = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_phone_number";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserTag = async (input) => {
      return this.request("/public/v1/submit/update_user_tag", input);
    };
    this.stampUpdateUserTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateWallet = async (input) => {
      return this.request("/public/v1/submit/update_wallet", input);
    };
    this.stampUpdateWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.verifyOtp = async (input) => {
      return this.request("/public/v1/submit/verify_otp", input);
    };
    this.stampVerifyOtp = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/verify_otp";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.testRateLimits = async (input) => {
      return this.request("/tkhq/api/v1/test_rate_limits", input);
    };
    this.stampTestRateLimits = async (input) => {
      const fullUrl = this.config.baseUrl + "/tkhq/api/v1/test_rate_limits";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    if (!config.baseUrl) {
      throw new Error(`Missing base URL. Please verify env vars.`);
    }
    this.config = config;
    this.stamper = stamper;
  }
  async request(url, body) {
    const fullUrl = this.config.baseUrl + url;
    const stringifiedBody = JSON.stringify(body);
    const stamp = await this.stamper.stamp(stringifiedBody);
    const response = await fetch2(fullUrl, {
      method: "POST",
      headers: {
        [stamp.stampHeaderName]: stamp.stampHeaderValue,
        "X-Client-Version": VERSION
      },
      body: stringifiedBody,
      redirect: "follow"
    });
    if (!response.ok) {
      let res;
      try {
        res = await response.json();
      } catch (_3) {
        throw new Error(`${response.status} ${response.statusText}`);
      }
      throw new TurnkeyRequestError(res);
    }
    const data = await response.json();
    return data;
  }
};

// node_modules/@turnkey/http/dist/shared.mjs
var TurnkeyActivityError = class extends Error {
  constructor(input) {
    const { message, cause, activityId, activityStatus, activityType } = input;
    super(message);
    this.name = "TurnkeyActivityError";
    this.activityId = activityId ?? void 0;
    this.activityStatus = activityStatus ?? void 0;
    this.activityType = activityType ?? void 0;
    this.cause = cause ?? void 0;
  }
};
var TurnkeyActivityConsensusNeededError = class extends Error {
  constructor(input) {
    const { message, cause, activityId, activityStatus, activityType } = input;
    super(message);
    this.name = "TurnkeyActivityConsensusNeededError";
    this.activityId = activityId ?? void 0;
    this.activityStatus = activityStatus ?? void 0;
    this.activityType = activityType ?? void 0;
    this.cause = cause ?? void 0;
  }
};
function assertActivityCompleted(activity) {
  const { id: activityId, status: activityStatus } = activity;
  if (activityStatus === "ACTIVITY_STATUS_CONSENSUS_NEEDED") {
    throw new TurnkeyActivityConsensusNeededError({
      message: "Activity requires consensus",
      activityId,
      activityStatus
    });
  }
  if (activityStatus !== "ACTIVITY_STATUS_COMPLETED") {
    throw new TurnkeyActivityError({
      message: `Expected COMPLETED status, got ${activityStatus}`,
      activityId,
      activityStatus
    });
  }
  return true;
}
function assertNonNull(input) {
  if (input == null) {
    throw new Error(`Got unexpected ${JSON.stringify(input)}`);
  }
  return input;
}

// node_modules/@turnkey/iframe-stamper/dist/index.mjs
var stampHeaderName2 = "X-Stamp";
var IframeEventType;
(function(IframeEventType2) {
  IframeEventType2["PublicKeyReady"] = "PUBLIC_KEY_READY";
  IframeEventType2["InjectCredentialBundle"] = "INJECT_CREDENTIAL_BUNDLE";
  IframeEventType2["InjectKeyExportBundle"] = "INJECT_KEY_EXPORT_BUNDLE";
  IframeEventType2["InjectWalletExportBundle"] = "INJECT_WALLET_EXPORT_BUNDLE";
  IframeEventType2["InjectImportBundle"] = "INJECT_IMPORT_BUNDLE";
  IframeEventType2["ExtractWalletEncryptedBundle"] = "EXTRACT_WALLET_ENCRYPTED_BUNDLE";
  IframeEventType2["ExtractKeyEncryptedBundle"] = "EXTRACT_KEY_ENCRYPTED_BUNDLE";
  IframeEventType2["ApplySettings"] = "APPLY_SETTINGS";
  IframeEventType2["BundleInjected"] = "BUNDLE_INJECTED";
  IframeEventType2["EncryptedBundleExtracted"] = "ENCRYPTED_BUNDLE_EXTRACTED";
  IframeEventType2["SettingsApplied"] = "SETTINGS_APPLIED";
  IframeEventType2["StampRequest"] = "STAMP_REQUEST";
  IframeEventType2["Stamp"] = "STAMP";
  IframeEventType2["TurnkeyInitMessageChannel"] = "TURNKEY_INIT_MESSAGE_CHANNEL";
  IframeEventType2["GetEmbeddedPublicKey"] = "GET_EMBEDDED_PUBLIC_KEY";
  IframeEventType2["ClearEmbeddedKey"] = "RESET_EMBEDDED_KEY";
  IframeEventType2["InitEmbeddedKey"] = "INIT_EMBEDDED_KEY";
  IframeEventType2["Error"] = "ERROR";
})(IframeEventType || (IframeEventType = {}));
var KeyFormat;
(function(KeyFormat2) {
  KeyFormat2["Hexadecimal"] = "HEXADECIMAL";
  KeyFormat2["Solana"] = "SOLANA";
})(KeyFormat || (KeyFormat = {}));
function generateUUID() {
  return crypto.randomUUID();
}
var IframeStamper = class {
  /**
   * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.
   * Call `.init()` to insert the iframe element in the DOM.
   */
  constructor(config) {
    if (typeof window === "undefined") {
      throw new Error("Cannot initialize iframe in non-browser environment");
    }
    if (typeof MessageChannel === "undefined") {
      throw new Error("Cannot initialize iframe without MessageChannel support");
    }
    if (!config.iframeContainer) {
      throw new Error("Iframe container cannot be found");
    }
    this.container = config.iframeContainer;
    if (this.container.querySelector(`#${config.iframeElementId}`)) {
      throw new Error(`Iframe element with ID ${config.iframeElementId} already exists`);
    }
    let iframe = window.document.createElement("iframe");
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
    iframe.id = config.iframeElementId;
    iframe.src = config.iframeUrl;
    this.iframe = iframe;
    const iframeUrl = new URL(config.iframeUrl);
    this.iframeOrigin = iframeUrl.origin;
    this.iframePublicKey = null;
    this.messageChannel = new MessageChannel();
    this.pendingRequests = /* @__PURE__ */ new Map();
  }
  onMessageHandler(event) {
    const { type: type3, value, requestId } = event.data || {};
    if (!requestId) {
      if (type3 === IframeEventType.PublicKeyReady) {
        this.iframePublicKey = value;
        return;
      }
      return;
    }
    const pendingRequest = this.pendingRequests.get(requestId);
    if (!pendingRequest) {
      console.warn(`Received response for unknown request: ${requestId}`);
      return;
    }
    this.pendingRequests.delete(requestId);
    if (type3 === IframeEventType.Error) {
      pendingRequest.reject(new Error(value));
      return;
    }
    switch (type3) {
      case IframeEventType.Stamp:
        pendingRequest.resolve({
          stampHeaderName: stampHeaderName2,
          stampHeaderValue: value
        });
        break;
      default:
        pendingRequest.resolve(value);
    }
  }
  /**
   * Inserts the iframe on the page and returns a promise resolving to the iframe's public key
   * @param dangerouslyOverrideIframeKeyTtl Optional TTL override for the iframe's embedded key (default 48 hours). Only use this if you are intentional about the security implications.
   */
  async init(dangerouslyOverrideIframeKeyTtl) {
    return new Promise((resolve, reject) => {
      this.container.appendChild(this.iframe);
      this.iframe.addEventListener("load", () => {
        var _a21;
        if (!((_a21 = this.iframe.contentWindow) == null ? void 0 : _a21.postMessage)) {
          reject(new Error("contentWindow or contentWindow.postMessage does not exist"));
          return;
        }
        this.iframe.contentWindow.postMessage({
          type: IframeEventType.TurnkeyInitMessageChannel,
          dangerouslyOverrideIframeKeyTtl
        }, this.iframeOrigin, [this.messageChannel.port2]);
      });
      this.messageChannel.port1.onmessage = (event) => {
        var _a21;
        if (((_a21 = event.data) == null ? void 0 : _a21.type) === IframeEventType.PublicKeyReady) {
          this.iframePublicKey = event.data.value;
          resolve(event.data.value);
        }
        this.onMessageHandler(event);
      };
    });
  }
  /**
   * Removes the iframe from the DOM
   */
  clear() {
    var _a21, _b, _c3, _d;
    (_b = (_a21 = this.messageChannel) == null ? void 0 : _a21.port1) == null ? void 0 : _b.close();
    (_d = (_c3 = this.messageChannel) == null ? void 0 : _c3.port2) == null ? void 0 : _d.close();
    this.iframe.remove();
    this.pendingRequests.clear();
  }
  /**
   * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
   */
  publicKey() {
    return this.iframePublicKey;
  }
  /**
   * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
   * This differs from the above in that it reaches out to the live iframe to see if an embedded key exists.
   */
  async getEmbeddedPublicKey() {
    const publicKey5 = await this.createRequest(IframeEventType.GetEmbeddedPublicKey);
    this.iframePublicKey = publicKey5;
    return publicKey5;
  }
  /**
   * Clears the embedded key within an iframe.
   */
  async clearEmbeddedKey() {
    await this.createRequest(IframeEventType.ClearEmbeddedKey);
    this.iframePublicKey = "";
    return null;
  }
  /**
   * Creates a new embedded key within an iframe. If an embedded key already exists, this will return it.
   * This is primarily to be used in conjunction with `clearEmbeddedKey()`: after an embedded key is cleared,
   * this can be used to create a new one.
   * @return {string | null} the newly created embedded public key.
   */
  async initEmbeddedKey() {
    const publicKey5 = await this.createRequest(IframeEventType.InitEmbeddedKey);
    this.iframePublicKey = publicKey5;
    return publicKey5;
  }
  /**
   * Generic function to abstract away request creation
   * @param type
   * @param payload
   * @returns expected shape <T>
   */
  createRequest(type3, payload = {}) {
    return new Promise((resolve, reject) => {
      const requestId = generateUUID();
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        requestId
      });
      this.messageChannel.port1.postMessage({
        type: type3,
        requestId,
        ...payload
      });
    });
  }
  /**
   * Function to inject a new credential into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during recovery and auth flows.
   */
  async injectCredentialBundle(bundle) {
    return this.createRequest(IframeEventType.InjectCredentialBundle, {
      value: bundle
    });
  }
  /**
   * Function to inject an export bundle into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
   * This is used during the private key export flow.
   */
  async injectKeyExportBundle(bundle, organizationId, keyFormat) {
    return this.createRequest(IframeEventType.InjectKeyExportBundle, {
      value: bundle,
      keyFormat,
      organizationId
    });
  }
  /**
   * Function to inject an export bundle into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during the wallet export flow.
   */
  async injectWalletExportBundle(bundle, organizationId) {
    return this.createRequest(IframeEventType.InjectWalletExportBundle, {
      value: bundle,
      organizationId
    });
  }
  /**
   * Function to inject an import bundle into the iframe
   * This is used to initiate either the wallet import flow or the private key import flow.
   */
  async injectImportBundle(bundle, organizationId, userId) {
    return this.createRequest(IframeEventType.InjectImportBundle, {
      value: bundle,
      organizationId,
      userId
    });
  }
  /**
   * Function to extract an encrypted bundle from the iframe
   * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during the wallet import flow.
   */
  async extractWalletEncryptedBundle() {
    return this.createRequest(IframeEventType.ExtractWalletEncryptedBundle);
  }
  /**
   * Function to extract an encrypted bundle from the iframe
   * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
   * This is used during the private key import flow.
   */
  async extractKeyEncryptedBundle(keyFormat) {
    return this.createRequest(IframeEventType.ExtractKeyEncryptedBundle, { keyFormat });
  }
  /**
   * Function to apply settings on allowed parameters in the iframe
   * This is used to style the HTML element used for plaintext in wallet and private key import.
   */
  async applySettings(settings) {
    return this.createRequest(IframeEventType.ApplySettings, {
      value: JSON.stringify(settings)
    });
  }
  /**
   * Function to sign a payload with the underlying iframe
   */
  async stamp(payload) {
    if (this.iframePublicKey === null) {
      throw new Error("null iframe public key. Have you called/awaited .init()?");
    }
    return this.createRequest(IframeEventType.StampRequest, {
      value: payload
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/BaseTurnkeyHandler.js
var BaseTurnkeyHandler = class {
  get client() {
    return this.__turnkeyClient;
  }
  get publicKey() {
    return this.__publicKey;
  }
  clear() {
    var _a21;
    (_a21 = this.__iframeStamper) === null || _a21 === void 0 ? void 0 : _a21.clear();
    this.__iframeStamper = void 0;
    this.__publicKey = void 0;
    this.__turnkeyClient = void 0;
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/constants.js
var TURNKEY_API_BASE_URL = "https://api.turnkey.com";
var TURNKEY_API_KEY_EXPIRY_MESSAGE = "Turnkey error 16: expired api key";
var TURNKEY_API_KEY_NOT_FOUND_MESSAGE = "Turnkey error 16: could not find public key";
var WEBAUTHN_NOT_SUPPORTED_OR_CANCELLED_ERROR_MESSAGE = "The operation either timed out or was not allowed";
var WEBAUTHN_NOT_SUPPORTED_OR_DISABLED_ERROR_MESSAGE = "The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.";
var INVALID_PASSKEY_SELECTED_ERROR_MESSAGE = "Turnkey error 5: webauthn authenticator not found in organization or parent organization";
var USER_CANCELLED_REQUEST_ERROR_MESSAGE = "The user cancelled the request";
var TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS = [
  TURNKEY_API_KEY_EXPIRY_MESSAGE,
  TURNKEY_API_KEY_NOT_FOUND_MESSAGE
];
var TURNKEY_SDK_BENIGN_ERRORS = [
  WEBAUTHN_NOT_SUPPORTED_OR_CANCELLED_ERROR_MESSAGE,
  WEBAUTHN_NOT_SUPPORTED_OR_DISABLED_ERROR_MESSAGE,
  INVALID_PASSKEY_SELECTED_ERROR_MESSAGE,
  USER_CANCELLED_REQUEST_ERROR_MESSAGE
];

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/convertAttestationTransports/convertAttestationTransports.js
var transportMap = {
  AUTHENTICATOR_TRANSPORT_BLE: AuthenticatorTransportProtocol.Ble,
  AUTHENTICATOR_TRANSPORT_HYBRID: AuthenticatorTransportProtocol.Hybrid,
  AUTHENTICATOR_TRANSPORT_INTERNAL: AuthenticatorTransportProtocol.Internal,
  AUTHENTICATOR_TRANSPORT_NFC: AuthenticatorTransportProtocol.Nfc,
  AUTHENTICATOR_TRANSPORT_USB: AuthenticatorTransportProtocol.Usb
};
var convertAttestationTransports = (attestationTransports) => attestationTransports.map((transport) => transportMap[transport]);

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/logger/logger.js
var DynamicEmbeddedWalletsLogger = class extends Logger {
  constructor(name2, level) {
    super(name2, level);
  }
  error(message, ...args) {
    const [err] = args;
    if (!(err === null || err === void 0 ? void 0 : err.message) || !TURNKEY_SDK_BENIGN_ERRORS.some((errorMsg) => err.message.includes(errorMsg))) {
      this.log(LogLevel.ERROR, message, ...args);
    } else {
      this.warn(message, ...args);
    }
  }
};
var logger3 = new DynamicEmbeddedWalletsLogger("Dynamic embedded wallets", LogLevel.INFO);

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs
function bufferToBase64url2(buffer) {
  const byteView = new Uint8Array(buffer);
  let str = "";
  for (const charCode of byteView) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  const base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return base64urlString;
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs
var copyValue2 = "copy";
var convertValue2 = "convert";
function convert2(conversionFn, schema, input) {
  if (schema === copyValue2) {
    return input;
  }
  if (schema === convertValue2) {
    return conversionFn(input);
  }
  if (schema instanceof Array) {
    return input.map((v6) => convert2(conversionFn, schema[0], v6));
  }
  if (schema instanceof Object) {
    const output2 = {};
    for (const [key, schemaField] of Object.entries(schema)) {
      if (schemaField.derive) {
        const v6 = schemaField.derive(input);
        if (v6 !== void 0) {
          input[key] = v6;
        }
      }
      if (!(key in input)) {
        if (schemaField.required) {
          throw new Error(`Missing key: ${key}`);
        }
        continue;
      }
      if (input[key] == null) {
        output2[key] = null;
        continue;
      }
      output2[key] = convert2(conversionFn, schemaField.schema, input[key]);
    }
    return output2;
  }
}
function derived2(schema, derive) {
  return {
    required: true,
    schema,
    derive
  };
}
function required2(schema) {
  return {
    required: true,
    schema
  };
}
function optional3(schema) {
  return {
    required: false,
    schema
  };
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs
var simplifiedClientExtensionResultsSchema2 = {
  appid: optional3(copyValue2),
  appidExclude: optional3(copyValue2),
  credProps: optional3(copyValue2)
};
var publicKeyCredentialWithAssertion2 = {
  type: required2(copyValue2),
  id: required2(copyValue2),
  rawId: required2(convertValue2),
  authenticatorAttachment: optional3(copyValue2),
  response: required2({
    clientDataJSON: required2(convertValue2),
    authenticatorData: required2(convertValue2),
    signature: required2(convertValue2),
    userHandle: required2(convertValue2)
  }),
  clientExtensionResults: derived2(simplifiedClientExtensionResultsSchema2, (pkc) => pkc.getClientExtensionResults())
};

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs
function getResponseToJSON2(credential) {
  return convert2(bufferToBase64url2, publicKeyCredentialWithAssertion2, credential);
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs
async function get5(options) {
  const response = await navigator.credentials.get(options);
  response.toJSON = () => getResponseToJSON2(response);
  return response;
}

// node_modules/@turnkey/webauthn-stamper/dist/index.mjs
var stampHeaderName3 = "X-Stamp-Webauthn";
var defaultTimeout2 = 5 * 60 * 1e3;
var defaultUserVerification = "preferred";
var WebauthnStamper = class {
  constructor(config) {
    this.rpId = config.rpId;
    this.timeout = config.timeout || defaultTimeout2;
    this.userVerification = config.userVerification || defaultUserVerification;
    this.allowCredentials = config.allowCredentials || [];
  }
  async stamp(payload) {
    const challenge3 = getChallengeFromPayload(payload);
    const signingOptions = {
      publicKey: {
        rpId: this.rpId,
        challenge: challenge3,
        allowCredentials: this.allowCredentials,
        timeout: this.timeout,
        userVerification: this.userVerification
      }
    };
    const clientGetResult = await get5(signingOptions);
    const assertion = clientGetResult.toJSON();
    const stamp = {
      authenticatorData: assertion.response.authenticatorData,
      clientDataJson: assertion.response.clientDataJSON,
      credentialId: assertion.id,
      signature: assertion.response.signature
    };
    return {
      stampHeaderName: stampHeaderName3,
      stampHeaderValue: JSON.stringify(stamp)
    };
  }
};
function getChallengeFromPayload(payload) {
  const hexString = createHash().update(payload).digest("hex");
  return new TextEncoder().encode(hexString);
}

// node_modules/@dynamic-labs/webauthn/package.js
var version7 = "4.57.1";

// node_modules/@dynamic-labs/webauthn/src/lib/errors/WebauthnNotSupportedError.js
var WebauthnNotSupportedError = class extends Error {
  constructor() {
    super("Webauthn is not supported on this device");
  }
};

// node_modules/@dynamic-labs/webauthn/_virtual/_tslib.js
function __awaiter7(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js
function bufferToBase64URLString(buffer) {
  const bytes2 = new Uint8Array(buffer);
  let str = "";
  for (const charCode of bytes2) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js
function base64URLStringToBuffer(base64URLString) {
  const base643 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
  const padLength = (4 - base643.length % 4) % 4;
  const padded = base643.padEnd(base643.length + padLength, "=");
  const binary = atob(padded);
  const buffer = new ArrayBuffer(binary.length);
  const bytes2 = new Uint8Array(buffer);
  for (let i4 = 0; i4 < binary.length; i4++) {
    bytes2[i4] = binary.charCodeAt(i4);
  }
  return buffer;
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js
function browserSupportsWebAuthn() {
  return _browserSupportsWebAuthnInternals.stubThis((globalThis == null ? void 0 : globalThis.PublicKeyCredential) !== void 0 && typeof globalThis.PublicKeyCredential === "function");
}
var _browserSupportsWebAuthnInternals = {
  stubThis: (value) => value
};

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js
function toPublicKeyCredentialDescriptor(descriptor) {
  const { id } = descriptor;
  return {
    ...descriptor,
    id: base64URLStringToBuffer(id),
    /**
     * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer
     * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports
     * are fine to pass to WebAuthn since browsers will recognize the new value.
     */
    transports: descriptor.transports
  };
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js
var WebAuthnError = class extends Error {
  constructor({ message, code: code2, cause, name: name2 }) {
    super(message, { cause });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name2 ?? cause.name;
    this.code = code2;
  }
};

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js
function identifyRegistrationError({ error, options }) {
  var _a21, _b, _c3;
  const { publicKey: publicKey5 } = options;
  if (!publicKey5) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "ConstraintError") {
    if (((_a21 = publicKey5.authenticatorSelection) == null ? void 0 : _a21.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey5.authenticatorSelection) == null ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error
      });
    } else if (((_c3 = publicKey5.authenticatorSelection) == null ? void 0 : _c3.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error
      });
    }
  } else if (error.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error
    });
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey5.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = globalThis.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${globalThis.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey5.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey5.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "TypeError") {
    if (publicKey5.user.id.byteLength < 1 || publicKey5.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return error;
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js
var BaseWebAuthnAbortService = class {
  constructor() {
    Object.defineProperty(this, "controller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
};
var WebAuthnAbortService = new BaseWebAuthnAbortService();

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js
var attachments = ["cross-platform", "platform"];
function toAuthenticatorAttachment(attachment) {
  if (!attachment) {
    return;
  }
  if (attachments.indexOf(attachment) < 0) {
    return;
  }
  return attachment;
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js
async function startRegistration(options) {
  var _a21;
  if (!options.optionsJSON && options.challenge) {
    console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
    options = { optionsJSON: options };
  }
  const { optionsJSON, useAutoRegister = false } = options;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  const publicKey5 = {
    ...optionsJSON,
    challenge: base64URLStringToBuffer(optionsJSON.challenge),
    user: {
      ...optionsJSON.user,
      id: base64URLStringToBuffer(optionsJSON.user.id)
    },
    excludeCredentials: (_a21 = optionsJSON.excludeCredentials) == null ? void 0 : _a21.map(toPublicKeyCredentialDescriptor)
  };
  const createOptions = {};
  if (useAutoRegister) {
    createOptions.mediation = "conditional";
  }
  createOptions.publicKey = publicKey5;
  createOptions.signal = WebAuthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.create(createOptions);
  } catch (err) {
    throw identifyRegistrationError({ error: err, options: createOptions });
  }
  if (!credential) {
    throw new Error("Registration was not completed");
  }
  const { id, rawId, response, type: type3 } = credential;
  let transports = void 0;
  if (typeof response.getTransports === "function") {
    transports = response.getTransports();
  }
  let responsePublicKeyAlgorithm = void 0;
  if (typeof response.getPublicKeyAlgorithm === "function") {
    try {
      responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();
    } catch (error) {
      warnOnBrokenImplementation("getPublicKeyAlgorithm()", error);
    }
  }
  let responsePublicKey = void 0;
  if (typeof response.getPublicKey === "function") {
    try {
      const _publicKey = response.getPublicKey();
      if (_publicKey !== null) {
        responsePublicKey = bufferToBase64URLString(_publicKey);
      }
    } catch (error) {
      warnOnBrokenImplementation("getPublicKey()", error);
    }
  }
  let responseAuthenticatorData;
  if (typeof response.getAuthenticatorData === "function") {
    try {
      responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());
    } catch (error) {
      warnOnBrokenImplementation("getAuthenticatorData()", error);
    }
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      attestationObject: bufferToBase64URLString(response.attestationObject),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      transports,
      publicKeyAlgorithm: responsePublicKeyAlgorithm,
      publicKey: responsePublicKey,
      authenticatorData: responseAuthenticatorData
    },
    type: type3,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
  };
}
function warnOnBrokenImplementation(methodName, cause) {
  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.
`, cause);
}

// node_modules/@dynamic-labs/webauthn/src/lib/logger.js
var logger4 = new Logger("Webauthn");

// node_modules/@dynamic-labs/webauthn/src/lib/createWebauthnCredential.js
var createWebauthnCredential = (options) => __awaiter7(void 0, void 0, void 0, function* () {
  if (!browserSupportsWebAuthn()) {
    throw new WebauthnNotSupportedError();
  }
  let attestationResp;
  try {
    attestationResp = yield startRegistration({
      optionsJSON: options
    });
  } catch (error) {
    logger4.debug("Failed to create webauthn credential", error);
    throw error;
  }
  return attestationResp;
});

// node_modules/@dynamic-labs/webauthn/src/lib/adapters/convertTransportEnumToTurnkeyEnum.js
var convertTransportEnumToTurnkeyEnum = (transportEnum) => {
  switch (transportEnum) {
    case "internal": {
      return "AUTHENTICATOR_TRANSPORT_INTERNAL";
    }
    case "usb": {
      return "AUTHENTICATOR_TRANSPORT_USB";
    }
    case "nfc": {
      return "AUTHENTICATOR_TRANSPORT_NFC";
    }
    case "ble": {
      return "AUTHENTICATOR_TRANSPORT_BLE";
    }
    case "hybrid": {
      return "AUTHENTICATOR_TRANSPORT_HYBRID";
    }
    default: {
      throw new Error("unsupported transport format " + transportEnum);
    }
  }
};

// node_modules/@dynamic-labs/webauthn/src/lib/adapters/getWebAuthnAttestationTurnkeyAdapter.js
var getWebAuthnAttestationTurnkeyAdapter = (options) => __awaiter7(void 0, void 0, void 0, function* () {
  if (!options.publicKey) {
    throw new Error("Invalid options. Public key attribute must be defined");
  }
  const attestation = yield createWebauthnCredential(convertPublicKeyToWebauthn(options.publicKey));
  return convertAttestationResultToTurnkey(attestation);
});
var convertAttestationResultToTurnkey = (attestation) => {
  var _a21;
  return {
    attestationObject: attestation.response.attestationObject,
    clientDataJson: attestation.response.clientDataJSON,
    credentialId: attestation.rawId,
    transports: ((_a21 = attestation.response.transports) === null || _a21 === void 0 ? void 0 : _a21.map(convertTransportEnumToTurnkeyEnum)) || []
  };
};
var convertPublicKeyToWebauthn = (publicKey5) => {
  var _a21;
  return Object.assign(Object.assign({}, publicKey5), { challenge: bufferSourceToString(publicKey5.challenge), excludeCredentials: (_a21 = publicKey5.excludeCredentials) === null || _a21 === void 0 ? void 0 : _a21.map((cred) => Object.assign(Object.assign({}, cred), { id: bufferSourceToString(cred.id) })), user: Object.assign(Object.assign({}, publicKey5.user), { id: bufferSourceToString(publicKey5.user.id) }) });
};
var bufferSourceToString = (buf) => {
  if (buf instanceof ArrayBuffer) {
    return bufferToBase64URLString(buf);
  } else {
    const arr = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    return bufferToBase64URLString(arr);
  }
};

// node_modules/@dynamic-labs/webauthn/src/index.js
assertPackageVersion("@dynamic-labs/webauthn", version7);

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/TurnkeyPasskeyService/utils/createTurnkeyPasskeyService/createTurnkeyPasskeyService.js
var createTurnkeyPasskeyService = () => ({
  createWebauthnStamper: (config) => new WebauthnStamper(config),
  getWebAuthnAttestation: getWebAuthnAttestationTurnkeyAdapter
});

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/TurnkeyPasskeyService/TurnkeyPasskeyService.js
var _a2;
var _TurnkeyPasskeyService_implementation;
var TurnkeyPasskeyService = class {
  /**
   * Gets the current passkey service implementation.
   * If no implementation is set, it will create a new turnkey passkey service.
   * @returns {ITurnkeyPasskeyService} The passkey service implementation.
   */
  static get implementation() {
    if (!__classPrivateFieldGet4(_a2, _a2, "f", _TurnkeyPasskeyService_implementation)) {
      return createTurnkeyPasskeyService();
    }
    return __classPrivateFieldGet4(_a2, _a2, "f", _TurnkeyPasskeyService_implementation);
  }
  /**
   * Sets the passkey service implementation.
   * @param {ITurnkeyPasskeyService} implementation The passkey service implementation to set.
   */
  static set implementation(implementation) {
    __classPrivateFieldSet4(_a2, _a2, implementation, "f", _TurnkeyPasskeyService_implementation);
  }
  /**
   * Gets the WebAuthn attestation method from the current implementation.
   */
  static get getWebAuthnAttestation() {
    return _a2.implementation.getWebAuthnAttestation;
  }
  /**
   * Gets the createWebauthnStamper method from the current implementation.
   */
  static get createWebauthnStamper() {
    return _a2.implementation.createWebauthnStamper;
  }
};
_a2 = TurnkeyPasskeyService;
_TurnkeyPasskeyService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/AuthenticatorHandler/TurnkeyAuthenticatorRecoveryHandler.js
var turnkeyPasskeyRecoveryUrl = "https://recovery.turnkey.com";
var turnkeyEmailRecoveryUrl = "https://auth.turnkey.com";
var TURNKEY_RECOVERY_CREDENTIAL_EXPIRATION_SECONDS = 900;
var TURNKEY_SESSION_EXPIRATION_SECONDS = 1800;
var EMAIL_AUTH_CREDENTIAL_TYPE = "CREDENTIAL_TYPE_API_KEY_P256";
var PASSKEY_RECOVERY_CREDENTIAL_TYPE = "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256";
var TurnkeyAuthenticatorRecoveryHandler = class extends BaseTurnkeyHandler {
  constructor() {
    super(...arguments);
    this.isSessionActive = () => {
      if (!this.__createdAt || this.__recoveryType !== "email") {
        return false;
      }
      const isExpired = this.isExpired(this.__createdAt, this.__sessionExpiration || TURNKEY_SESSION_EXPIRATION_SECONDS);
      if (isExpired) {
        this.clear();
        return false;
      }
      return true;
    };
    this.isValidCode = (organizationId) => __awaiter6(this, void 0, void 0, function* () {
      var _a21, _b, _c3, _d;
      if (!organizationId || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      const userResponse = yield (_a21 = this.__turnkeyClient) === null || _a21 === void 0 ? void 0 : _a21.getUser({
        organizationId,
        userId: this.__turnkeyRecoveryUserId
      });
      const credentialTypeMap = {
        email: EMAIL_AUTH_CREDENTIAL_TYPE,
        passkey: PASSKEY_RECOVERY_CREDENTIAL_TYPE
      };
      const recoveryCredential = (_d = (_c3 = (_b = userResponse === null || userResponse === void 0 ? void 0 : userResponse.user) === null || _b === void 0 ? void 0 : _b.apiKeys) === null || _c3 === void 0 ? void 0 : _c3.filter((k6) => k6.credential.type === credentialTypeMap[this.__recoveryType])) === null || _d === void 0 ? void 0 : _d.pop();
      if (!recoveryCredential) {
        return false;
      }
      const isExpired = this.isExpired(parseInt(recoveryCredential.createdAt.seconds, 10), TURNKEY_RECOVERY_CREDENTIAL_EXPIRATION_SECONDS);
      if (isExpired) {
        return false;
      }
      this.__createdAt = parseInt(recoveryCredential.createdAt.seconds, 10);
      return true;
    });
    this.isExpired = (createdAtSeconds, expirationTimeSeconds) => {
      const recoveryExpirationSeconds = createdAtSeconds + expirationTimeSeconds;
      const expirationTime = new Date(recoveryExpirationSeconds * 1e3);
      if (/* @__PURE__ */ new Date() >= expirationTime) {
        return true;
      }
      return false;
    };
  }
  get recoveryType() {
    return this.__recoveryType;
  }
  get recoveryUserId() {
    return this.__turnkeyRecoveryUserId || "";
  }
  set recoveryUserId(turnkeyRecoveryUserId) {
    this.__turnkeyRecoveryUserId = turnkeyRecoveryUserId;
  }
  clear() {
    super.clear();
    this.__recoveryType = void 0;
    this.__turnkeyRecoveryUserId = void 0;
    this.__createdAt = void 0;
  }
  initRecovery(authType, iframeContainer, iframeElementId, sessionExpiration) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (this.__recoveryType) {
        this.clear();
      }
      this.__sessionExpiration = sessionExpiration;
      this.__recoveryType = authType;
      const iframeUrl = authType === "passkey" ? turnkeyPasskeyRecoveryUrl : turnkeyEmailRecoveryUrl;
      this.__iframeStamper = new IframeStamper({
        iframeContainer,
        iframeElementId,
        iframeUrl
      });
      yield this.__iframeStamper.init();
      this.__publicKey = this.__iframeStamper.publicKey();
      return this.__publicKey;
    });
  }
  verifyRecoveryCode(recoveryBundle, organizationId) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        yield this.__iframeStamper.injectCredentialBundle(recoveryBundle);
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, this.__iframeStamper);
        if (!organizationId || !this.__turnkeyRecoveryUserId) {
          throw new DynamicError("Cannot proceed with your request");
        }
        if (!(yield this.isValidCode(organizationId))) {
          throw new DynamicError("The code is invalid or expired.");
        }
      } catch (err) {
        logger3.error("Error while verifying recovery code", err);
        if (err instanceof DynamicError) {
          throw err;
        }
        throw new DynamicError("The code is invalid or expired.");
      }
    });
  }
  completeRecovery(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ attestation, challenge: challenge3, turnkeySubOrganizationId }) {
      if (!this.__turnkeyClient || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return this.__turnkeyClient.recoverUser({
          organizationId: turnkeySubOrganizationId,
          parameters: {
            authenticator: {
              attestation,
              authenticatorName: "Passkey",
              challenge: challenge3
            },
            userId: this.__turnkeyRecoveryUserId
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_RECOVER_USER"
        });
      } catch (err) {
        logger3.error("[TK] Error while completing recovery process", err);
        throw err;
      }
    });
  }
  addPasskeyAuthenticator(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ attestation, challenge: challenge3, turnkeySubOrganizationId }) {
      if (!this.__turnkeyClient || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return this.__turnkeyClient.createAuthenticators({
          organizationId: turnkeySubOrganizationId,
          parameters: {
            authenticators: [
              {
                attestation,
                authenticatorName: "Passkey",
                challenge: challenge3
              }
            ],
            userId: this.__turnkeyRecoveryUserId
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
        });
      } catch (err) {
        logger3.error("[TK] Error while creating new authenticator", err);
        throw err;
      }
    });
  }
  addEmailRecovery(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ organizationId, email, turnkeyUserId }) {
      let rpId = getTLD();
      if (!rpId) {
        rpId = PlatformService.getHostname();
      }
      const stamper = TurnkeyPasskeyService.createWebauthnStamper({
        rpId
      });
      const client = new TurnkeyClient({
        baseUrl: TURNKEY_API_BASE_URL
      }, stamper);
      try {
        const signedRequest2 = yield client.stampUpdateUser({
          organizationId,
          parameters: {
            userEmail: email,
            userId: turnkeyUserId,
            userTagIds: []
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_UPDATE_USER"
        });
        return { signedRequest: signedRequest2, userId: turnkeyUserId };
      } catch (err) {
        logger3.error("Error while adding email recovery", err);
        throw err;
      }
    });
  }
};
var turnkeyAuthenticatorRecoveryHandler = new TurnkeyAuthenticatorRecoveryHandler();

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/ExportHandler/TurnkeyExportHandler.js
var turnkeyExportUrl = "https://export.turnkey.com";
var TurnkeyExportHandler = class _TurnkeyExportHandler extends BaseTurnkeyHandler {
  initExport(iframeContainer, iframeElementId) {
    return __awaiter6(this, void 0, void 0, function* () {
      this.__iframeStamper = new IframeStamper({
        iframeContainer,
        iframeElementId,
        iframeUrl: turnkeyExportUrl
      });
      yield this.__iframeStamper.init();
      this.__publicKey = this.__iframeStamper.publicKey();
      if (turnkeyAuthenticatorRecoveryHandler.isSessionActive()) {
        this.__turnkeyClient = turnkeyAuthenticatorRecoveryHandler.client;
      } else {
        let rpId = getTLD();
        if (!rpId) {
          rpId = PlatformService.getHostname();
        }
        const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
          rpId
        });
        const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
        const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, stamper);
      }
      return this.__publicKey;
    });
  }
  verifyExportWallet(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ exportBundle, organizationId }) {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return yield this.__iframeStamper.injectWalletExportBundle(exportBundle, organizationId);
      } catch (err) {
        logger3.error("Error while verifying export wallet", err);
        throw err;
      }
    });
  }
  verifyExportPrivateKey(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ exportBundle, organizationId, chain: chain6 }) {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      const keyFormat = chain6 === "solana" || chain6 === "SOL" ? KeyFormat.Solana : KeyFormat.Hexadecimal;
      try {
        return yield this.__iframeStamper.injectKeyExportBundle(exportBundle, organizationId, keyFormat);
      } catch (err) {
        logger3.error("Error while verifying export private key", err);
        throw err;
      }
    });
  }
  exportPrivateKey(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ privateKeyId, organizationId }) {
      const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
      if (apiKeyStamper) {
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, apiKeyStamper);
      }
      if (!this.__iframeStamper || !this.__publicKey || !this.__turnkeyClient || !privateKeyId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        const newActivity = yield this.__turnkeyClient.exportPrivateKey({
          organizationId,
          parameters: { privateKeyId, targetPublicKey: this.__publicKey },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
        });
        return newActivity.activity;
      } catch (err) {
        logger3.error("[TK] Error while completing export private key process", err);
        throw err;
      }
    });
  }
  exportWallet(_a21) {
    return __awaiter6(this, arguments, void 0, function* ({ walletId, organizationId, address }) {
      const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
      if (apiKeyStamper) {
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, apiKeyStamper);
      }
      if (!this.__iframeStamper || !this.__publicKey || !this.__turnkeyClient || !walletId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        if (address) {
          const newActivity2 = yield this.__turnkeyClient.exportWalletAccount({
            organizationId,
            parameters: { address, targetPublicKey: this.__publicKey },
            timestampMs: String(Date.now()),
            type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
          });
          return newActivity2.activity;
        }
        const newActivity = yield this.__turnkeyClient.exportWallet({
          organizationId,
          parameters: { targetPublicKey: this.__publicKey, walletId },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_EXPORT_WALLET"
        });
        return newActivity.activity;
      } catch (err) {
        logger3.error("[TK] Error while completing export wallet process", err);
        throw err;
      }
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/base64UrlEncode/base64UrlEncode.js
var base64UrlEncode = (challenge3) => Buffer.from(challenge3).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/generateRandomBuffer/generateRandomBuffer.js
var generateRandomBuffer = () => {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  return arr.buffer;
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/TurnkeyWalletConnectorBase/TurnkeyWalletConnectorBase.js
var TurnkeyWalletConnectorBase = class _TurnkeyWalletConnectorBase extends WalletConnectorBase {
  constructor(nameAndKey, props) {
    super(props);
    this.requiresNonDynamicEmailOtp = false;
    this.isEmbeddedWallet = true;
    this.removeSessionKeys = () => __awaiter6(this, void 0, void 0, function* () {
      _TurnkeyWalletConnectorBase.sessionKeys = void 0;
      _TurnkeyWalletConnectorBase.apiKeyStamper = void 0;
      TurnkeyExportHandler.apiKeyStamper = void 0;
    });
    this.stampCreateWalletAccountRequest = (_a21) => __awaiter6(this, [_a21], void 0, function* ({ request: request2 }) {
      yield this.createOrRestoreSession();
      const turnkeyClient = yield this.getTurnkeyClient();
      return turnkeyClient.stampCreateWalletAccounts(request2);
    });
    this.stampDeleteSubOrganizationRequest = (_b) => __awaiter6(this, [_b], void 0, function* ({ request: request2 }) {
      yield this.createOrRestoreSession();
      const turnkeyClient = yield this.getTurnkeyClient();
      return turnkeyClient.stampDeleteSubOrganization(request2);
    });
    if (!props.appName) {
      throw new Error("appName not set");
    }
    this.name = nameAndKey.name;
    this.overrideKey = nameAndKey.key;
    this.appName = props.appName;
    this.__authenticatorMethodHandler = turnkeyAuthenticatorRecoveryHandler;
  }
  getWebAuthnAttestation() {
    return __awaiter6(this, void 0, void 0, function* () {
      const challenge3 = generateRandomBuffer();
      const authenticatorUserId = generateRandomBuffer();
      const { email, passkeyIdentifier } = this;
      if (!email && !passkeyIdentifier) {
        throw new Error("Email or passkeyIdentifier must be set to register a webauthn credential.");
      }
      const displayName = email || `${this.appName} - ${passkeyIdentifier}`;
      const webAuthnCreateParams = {
        publicKey: {
          authenticatorSelection: {
            authenticatorAttachment: void 0,
            requireResidentKey: false,
            residentKey: "preferred",
            userVerification: "discouraged"
          },
          challenge: challenge3,
          pubKeyCredParams: [
            {
              alg: -7,
              type: "public-key"
            }
          ],
          rp: {
            id: getTLD(),
            name: this.appName
          },
          user: {
            displayName,
            id: authenticatorUserId,
            name: email || `${this.appName} - ${passkeyIdentifier}`
          }
        }
      };
      let attestation;
      try {
        attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
      } catch (error) {
        logger3.warn(`Unable to register webauthn credential on the current page's TLD ${getTLD()}. Falling back to using hostname. ${PlatformService.getHostname()}`, error);
        webAuthnCreateParams.publicKey.rp.id = PlatformService.getHostname();
        attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
      }
      return {
        attestation: {
          attestationObject: attestation.attestationObject,
          clientDataJson: attestation.clientDataJson,
          credentialId: attestation.credentialId,
          transports: convertAttestationTransports(attestation.transports)
        },
        challenge: base64UrlEncode(challenge3),
        displayName
      };
    });
  }
  getAuthenticatorHandler() {
    return this.__authenticatorMethodHandler;
  }
  getExportHandler() {
    if (!_TurnkeyWalletConnectorBase.__exportHandler) {
      _TurnkeyWalletConnectorBase.__exportHandler = new TurnkeyExportHandler();
    }
    return _TurnkeyWalletConnectorBase.__exportHandler;
  }
  // Public methods
  get email() {
    return this._email;
  }
  setEmail(email) {
    this._email = email;
  }
  get phone() {
    return this._phone;
  }
  setPhone(phone) {
    this._phone = phone;
  }
  get passkeyIdentifier() {
    return this._passkeyIdentifier;
  }
  setPasskeyIdentifier(passkeyIdentifier) {
    this._passkeyIdentifier = passkeyIdentifier;
  }
  clearEmail() {
    this._email = null;
  }
  getAddress() {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a21;
      return (_a21 = this.verifiedCredential) === null || _a21 === void 0 ? void 0 : _a21.address;
    });
  }
  getConnectedAccounts() {
    return __awaiter6(this, void 0, void 0, function* () {
      const verifiedCredentials = this.verifiedCredentials || [];
      const addresses = verifiedCredentials.map((vc3) => vc3 === null || vc3 === void 0 ? void 0 : vc3.address).filter((a3) => typeof a3 === "string");
      return addresses;
    });
  }
  get turnkeyAddress() {
    var _a21;
    const { address } = (_a21 = this.verifiedCredential) !== null && _a21 !== void 0 ? _a21 : {};
    return address;
  }
  get walletProperties() {
    const { walletProperties } = this.verifiedCredential || {};
    return walletProperties;
  }
  // Private methods
  set verifiedCredentials(verifiedCredentials) {
    this._verifiedCredentials = verifiedCredentials;
  }
  get verifiedCredentials() {
    return this._verifiedCredentials;
  }
  set verifiedCredential(verifiedCredential) {
    this._verifiedCredential = verifiedCredential;
  }
  get verifiedCredential() {
    return this._verifiedCredential;
  }
  setSessionKeyFetcher(func) {
    this.createOrRestoreSessionFetcherFunction = func;
  }
  setSessionKeyRemoveFunction(func) {
    this.removeSessionKeysFunction = func;
  }
  createOrRestoreSession() {
    return __awaiter6(this, arguments, void 0, function* ({ ignoreRestore } = {}) {
      var _a21, _b, _c3;
      if (!this.isSessionKeyCompatible() || _TurnkeyWalletConnectorBase.isLoadingSession) {
        return;
      }
      if (!this.createOrRestoreSessionFetcherFunction) {
        throw new DynamicError("Cannot register session key to init provider");
      }
      const { sessionKeys } = _TurnkeyWalletConnectorBase;
      if (sessionKeys === null || sessionKeys === void 0 ? void 0 : sessionKeys.publicKey) {
        const isExpired = /* @__PURE__ */ new Date() >= new Date(sessionKeys.expirationDate);
        if (!isExpired)
          return sessionKeys.publicKey;
      }
      try {
        _TurnkeyWalletConnectorBase.isLoadingSession = true;
        this.isLoadingSessionDeferredPromise = new DeferredPromise();
        if (!((_a21 = this.verifiedCredential) === null || _a21 === void 0 ? void 0 : _a21.id)) {
          throw new DynamicError("No wallet ID found");
        }
        const sessionKeys2 = yield this.createOrRestoreSessionFetcherFunction({
          ignoreRestore,
          walletId: (_b = this.verifiedCredential) === null || _b === void 0 ? void 0 : _b.id
        });
        _TurnkeyWalletConnectorBase.sessionKeys = sessionKeys2;
        _TurnkeyWalletConnectorBase.apiKeyStamper = new ApiKeyStamper({
          apiPrivateKey: sessionKeys2.privateKey,
          apiPublicKey: sessionKeys2.publicKey
        });
        TurnkeyExportHandler.apiKeyStamper = _TurnkeyWalletConnectorBase.apiKeyStamper;
        logger3.metaData.set("sessionApiPublicKey", sessionKeys2.publicKey);
        return sessionKeys2.publicKey;
      } catch (error) {
        logger3.error(error);
        throw new DynamicError("Failed to create or restore session");
      } finally {
        _TurnkeyWalletConnectorBase.isLoadingSession = false;
        (_c3 = this.isLoadingSessionDeferredPromise) === null || _c3 === void 0 ? void 0 : _c3.resolve();
      }
    });
  }
  isSessionKeyCompatible() {
    var _a21;
    const walletProperties = (_a21 = this.verifiedCredential) === null || _a21 === void 0 ? void 0 : _a21.walletProperties;
    const isSessionKeyCompatible = walletProperties === null || walletProperties === void 0 ? void 0 : walletProperties.isSessionKeyCompatible;
    return Boolean(isSessionKeyCompatible);
  }
  isSessionActive() {
    return __awaiter6(this, void 0, void 0, function* () {
      const hasWallet = yield this.getAddress();
      return Boolean(hasWallet && _TurnkeyWalletConnectorBase.sessionKeys && _TurnkeyWalletConnectorBase.apiKeyStamper);
    });
  }
  get sessionKeys() {
    return _TurnkeyWalletConnectorBase.sessionKeys;
  }
  getTurnkeyClient() {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a21, _b;
      if (_TurnkeyWalletConnectorBase.isLoadingSession) {
        yield (_a21 = this.isLoadingSessionDeferredPromise) === null || _a21 === void 0 ? void 0 : _a21.promise;
      }
      let rpId = getTLD();
      if (!rpId) {
        rpId = PlatformService.getHostname();
      }
      const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
        rpId
      });
      const apiKeyStamper = _TurnkeyWalletConnectorBase === null || _TurnkeyWalletConnectorBase === void 0 ? void 0 : _TurnkeyWalletConnectorBase.apiKeyStamper;
      const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
      this.__turnkeyClient = (_b = this.getAuthenticatorHandler().client) !== null && _b !== void 0 ? _b : new TurnkeyClient({
        baseUrl: TURNKEY_API_BASE_URL
      }, stamper);
      return this.__turnkeyClient;
    });
  }
  setLoggerMetadata() {
    var _a21, _b, _c3;
    logger3.metaData.set("turnkeySubOrganizationId", (_b = (_a21 = this._verifiedCredential) === null || _a21 === void 0 ? void 0 : _a21.walletProperties) === null || _b === void 0 ? void 0 : _b.turnkeySubOrganizationId);
    logger3.metaData.set("walletId", (_c3 = this._verifiedCredential) === null || _c3 === void 0 ? void 0 : _c3.id);
    let authMethod = "Unknown";
    if (this.isSessionKeyCompatible()) {
      authMethod = "SessionKeys";
    } else if (this.__authenticatorMethodHandler.recoveryType === "passkey") {
      authMethod = "Passkey";
    } else if (this.__authenticatorMethodHandler.recoveryType === "email") {
      authMethod = "EmailAuth";
    }
    logger3.metaData.set("authMethod", authMethod);
  }
};
TurnkeyWalletConnectorBase.isLoadingSession = false;

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/findTurnkeyVerifiedCredentials/findTurnkeyVerifiedCredentials.js
var findTurnkeyVerifiedCredentials = (verifiedCredentials, chain6) => verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.filter(({ walletName, chain: vcChain }) => (walletName === null || walletName === void 0 ? void 0 : walletName.startsWith("turnkey")) && chain6 === vcChain);

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/types.js
var TurnkeyWalletConnectorInfo = {
  Turnkey: {
    key: "turnkey",
    name: "Turnkey"
  },
  TurnkeyHD: {
    key: "turnkeyhd",
    name: "Turnkey HD"
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@dynamic-labs/embedded-wallet/src/index.js
assertPackageVersion("@dynamic-labs/embedded-wallet", version6);

// node_modules/@dynamic-labs/embedded-wallet-solana/_virtual/_tslib.js
function __rest3(s3, e2) {
  var t = {};
  for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
    t[p4] = s3[p4];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s3); i4 < p4.length; i4++) {
      if (e2.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i4]))
        t[p4[i4]] = s3[p4[i4]];
    }
  return t;
}
function __awaiter8(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_buffer3 = __toESM(require_buffer());

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/_assert.js
function anumber3(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0)
    throw new Error("positive integer expected, got " + n5);
}
function isBytes5(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes3(b4, ...lengths) {
  if (!isBytes5(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function ahash(h5) {
  if (typeof h5 !== "function" || typeof h5.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber3(h5.outputLen);
  anumber3(h5.blockLen);
}
function aexists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance2) {
  abytes3(out);
  const min4 = instance2.outputLen;
  if (out.length < min4) {
    throw new Error("digestInto() expects output buffer of length at least " + min4);
  }
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/utils.js
function u323(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i4 = 0; i4 < arr.length; i4++) {
    arr[i4] = byteSwap(arr[i4]);
  }
}
var hasHexBuiltin2 = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
var hexes = Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  abytes3(data);
  return data;
}
function concatBytes4(...arrays) {
  let sum = 0;
  for (let i4 = 0; i4 < arrays.length; i4++) {
    const a3 = arrays[i4];
    abytes3(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i4 = 0, pad3 = 0; i4 < arrays.length; i4++) {
    const a3 = arrays[i4];
    res.set(a3, pad3);
    pad3 += a3.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts2) => hashCons(opts2).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts2) => hashCons(opts2);
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE6);
  const _32n5 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n5 & _u32_max);
  const wl = Number(value & _u32_max);
  const h5 = isLE6 ? 4 : 0;
  const l6 = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h5, wh, isLE6);
  view.setUint32(byteOffset + l6, wl, isLE6);
}
function Chi2(a3, b4, c6) {
  return a3 & b4 ^ ~a3 & c6;
}
function Maj2(a3, b4, c6) {
  return a3 & b4 ^ a3 & c6 ^ b4 & c6;
}
var HashMD2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE6 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos; i4 < blockLen; i4++)
      buffer[i4] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0; i4 < outLen; i4++)
      oview.setUint32(4 * i4, state[i4], isLE6);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to5) {
    to5 || (to5 = new this.constructor());
    to5.set(...this.get());
    const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
    to5.length = length2;
    to5.pos = pos;
    to5.finished = finished;
    to5.destroyed = destroyed;
    if (length2 % blockLen)
      to5.buffer.set(buffer);
    return to5;
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD2 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4, E: E4, F: F5, G: G5, H: H2 } = this;
    return [A4, B3, C4, D4, E4, F5, G5, H2];
  }
  // prettier-ignore
  set(A4, B3, C4, D4, E4, F5, G5, H2) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
    this.E = E4 | 0;
    this.F = F5 | 0;
    this.G = G5 | 0;
    this.H = H2 | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4)
      SHA256_W[i4] = view.getUint32(offset5, false);
    for (let i4 = 16; i4 < 64; i4++) {
      const W15 = SHA256_W[i4 - 15];
      const W22 = SHA256_W[i4 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
    }
    let { A: A4, B: B3, C: C4, D: D4, E: E4, F: F5, G: G5, H: H2 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      const sigma1 = rotr(E4, 6) ^ rotr(E4, 11) ^ rotr(E4, 25);
      const T1 = H2 + sigma1 + Chi2(E4, F5, G5) + SHA256_K[i4] + SHA256_W[i4] | 0;
      const sigma0 = rotr(A4, 2) ^ rotr(A4, 13) ^ rotr(A4, 22);
      const T22 = sigma0 + Maj2(A4, B3, C4) | 0;
      H2 = G5;
      G5 = F5;
      F5 = E4;
      E4 = D4 + T1 | 0;
      D4 = C4;
      C4 = B3;
      B3 = A4;
      A4 = T1 + T22 | 0;
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    E4 = E4 + this.E | 0;
    F5 = F5 + this.F | 0;
    G5 = G5 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A4, B3, C4, D4, E4, F5, G5, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
  }
};
var sha2566 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n5, le5 = false) {
  if (le5)
    return { h: Number(n5 & U32_MASK64), l: Number(n5 >> _32n & U32_MASK64) };
  return { h: Number(n5 >> _32n & U32_MASK64) | 0, l: Number(n5 & U32_MASK64) | 0 };
}
function split(lst, le5 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i4 = 0; i4 < lst.length; i4++) {
    const { h: h5, l: l6 } = fromBig(lst[i4], le5);
    [Ah[i4], Al[i4]] = [h5, l6];
  }
  return [Ah, Al];
}
var toBig = (h5, l6) => BigInt(h5 >>> 0) << _32n | BigInt(l6 >>> 0);
var shrSH = (h5, _l, s3) => h5 >>> s3;
var shrSL = (h5, l6, s3) => h5 << 32 - s3 | l6 >>> s3;
var rotrSH = (h5, l6, s3) => h5 >>> s3 | l6 << 32 - s3;
var rotrSL = (h5, l6, s3) => h5 << 32 - s3 | l6 >>> s3;
var rotrBH = (h5, l6, s3) => h5 << 64 - s3 | l6 >>> s3 - 32;
var rotrBL = (h5, l6, s3) => h5 >>> s3 - 32 | l6 << 64 - s3;
var rotr32H = (_h, l6) => l6;
var rotr32L = (h5, _l) => h5;
var rotlSH = (h5, l6, s3) => h5 << s3 | l6 >>> 32 - s3;
var rotlSL = (h5, l6, s3) => l6 << s3 | h5 >>> 32 - s3;
var rotlBH = (h5, l6, s3) => l6 << s3 - 32 | h5 >>> 64 - s3;
var rotlBL = (h5, l6, s3) => h5 << s3 - 32 | l6 >>> 64 - s3;
function add(Ah, Al, Bh, Bl) {
  const l6 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l6 / 2 ** 32 | 0) | 0, l: l6 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u643 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u643;

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD2 {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4) {
      SHA512_W_H[i4] = view.getUint32(offset5);
      SHA512_W_L[i4] = view.getUint32(offset5 += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H[i4 - 15] | 0;
      const W15l = SHA512_W_L[i4 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i4 - 2] | 0;
      const W2l = SHA512_W_L[i4 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
      SHA512_W_H[i4] = SUMh | 0;
      SHA512_W_L[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
  }
};
var sha5123 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/utils.js
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
function isBytes6(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes4(item) {
  if (!isBytes6(item))
    throw new Error("Uint8Array expected");
}
function abool2(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded2(num3) {
  const hex2 = num3.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber3(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n8 : BigInt("0x" + hex2);
}
var hasHexBuiltin3 = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
var hexes2 = Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex4(bytes2) {
  abytes4(bytes2);
  if (hasHexBuiltin3)
    return bytes2.toHex();
  let hex2 = "";
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    hex2 += hexes2[bytes2[i4]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes4(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin3)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai3 = 0, hi3 = 0; ai3 < al; ai3++, hi3 += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi3));
    const n22 = asciiToBase16(hex2.charCodeAt(hi3 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi3] + hex2[hi3 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi3);
    }
    array2[ai3] = n1 * 16 + n22;
  }
  return array2;
}
function bytesToNumberBE2(bytes2) {
  return hexToNumber3(bytesToHex4(bytes2));
}
function bytesToNumberLE2(bytes2) {
  abytes4(bytes2);
  return hexToNumber3(bytesToHex4(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE2(n5, len) {
  return hexToBytes4(n5.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n5, len) {
  return numberToBytesBE2(n5, len).reverse();
}
function ensureBytes2(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes4(hex2);
    } catch (e2) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e2);
    }
  } else if (isBytes6(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes5(...arrays) {
  let sum = 0;
  for (let i4 = 0; i4 < arrays.length; i4++) {
    const a3 = arrays[i4];
    abytes4(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i4 = 0, pad3 = 0; i4 < arrays.length; i4++) {
    const a3 = arrays[i4];
    res.set(a3, pad3);
    pad3 += a3.length;
  }
  return res;
}
function equalBytes2(a3, b4) {
  if (a3.length !== b4.length)
    return false;
  let diff = 0;
  for (let i4 = 0; i4 < a3.length; i4++)
    diff |= a3[i4] ^ b4[i4];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n5) => typeof n5 === "bigint" && _0n8 <= n5;
function inRange2(n5, min4, max4) {
  return isPosBig(n5) && isPosBig(min4) && isPosBig(max4) && min4 <= n5 && n5 < max4;
}
function aInRange2(title, n5, min4, max4) {
  if (!inRange2(n5, min4, max4))
    throw new Error("expected valid " + title + ": " + min4 + " <= n < " + max4 + ", got " + n5);
}
function bitLen2(n5) {
  let len;
  for (len = 0; n5 > _0n8; n5 >>= _1n8, len += 1)
    ;
  return len;
}
var bitMask2 = (n5) => (_1n8 << BigInt(n5)) - _1n8;
var u8n = (len) => new Uint8Array(len);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v6 = u8n(hashLen);
  let k6 = u8n(hashLen);
  let i4 = 0;
  const reset3 = () => {
    v6.fill(1);
    k6.fill(0);
    i4 = 0;
  };
  const h5 = (...b4) => hmacFn(k6, v6, ...b4);
  const reseed = (seed = u8n(0)) => {
    k6 = h5(u8fr([0]), seed);
    v6 = h5();
    if (seed.length === 0)
      return;
    k6 = h5(u8fr([1]), seed);
    v6 = h5();
  };
  const gen2 = () => {
    if (i4++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v6 = h5();
      const sl = v6.slice();
      out.push(sl);
      len += v6.length;
    }
    return concatBytes5(...out);
  };
  const genUntil = (seed, pred) => {
    reset3();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset3();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes6(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject2(object2, validators5, optValidators = {}) {
  const checkField = (fieldName, type3, isOptional) => {
    const checkVal = validatorFns[type3];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type3 + ", got " + val);
    }
  };
  for (const [fieldName, type3] of Object.entries(validators5))
    checkField(fieldName, type3, false);
  for (const [fieldName, type3] of Object.entries(optValidators))
    checkField(fieldName, type3, true);
  return object2;
}
function memoized2(fn4) {
  const map36 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map36.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn4(arg, ...args);
    map36.set(arg, computed);
    return computed;
  };
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/modular.js
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n7 = BigInt(2);
var _3n4 = BigInt(3);
var _4n3 = BigInt(4);
var _5n3 = BigInt(5);
var _8n4 = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a3, b4) {
  const result = a3 % b4;
  return result >= _0n9 ? result : b4 + result;
}
function pow(num3, power, modulo) {
  if (power < _0n9)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n9)
    throw new Error("invalid modulus");
  if (modulo === _1n9)
    return _0n9;
  let res = _1n9;
  while (power > _0n9) {
    if (power & _1n9)
      res = res * num3 % modulo;
    num3 = num3 * num3 % modulo;
    power >>= _1n9;
  }
  return res;
}
function pow22(x5, power, modulo) {
  let res = x5;
  while (power-- > _0n9) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number3, modulo) {
  if (number3 === _0n9)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n9)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a3 = mod2(number3, modulo);
  let b4 = modulo;
  let x5 = _0n9, y5 = _1n9, u2 = _1n9, v6 = _0n9;
  while (a3 !== _0n9) {
    const q = b4 / a3;
    const r3 = b4 % a3;
    const m3 = x5 - u2 * q;
    const n5 = y5 - v6 * q;
    b4 = a3, a3 = r3, x5 = u2, y5 = v6, u2 = m3, v6 = n5;
  }
  const gcd2 = b4;
  if (gcd2 !== _1n9)
    throw new Error("invert: does not exist");
  return mod2(x5, modulo);
}
function tonelliShanks2(P4) {
  const legendreC = (P4 - _1n9) / _2n7;
  let Q6, S4, Z2;
  for (Q6 = P4 - _1n9, S4 = 0; Q6 % _2n7 === _0n9; Q6 /= _2n7, S4++)
    ;
  for (Z2 = _2n7; Z2 < P4 && pow(Z2, legendreC, P4) !== P4 - _1n9; Z2++) {
    if (Z2 > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S4 === 1) {
    const p1div4 = (P4 + _1n9) / _4n3;
    return function tonelliFast(Fp3, n5) {
      const root = Fp3.pow(n5, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q6 + _1n9) / _2n7;
  return function tonelliSlow(Fp3, n5) {
    if (Fp3.pow(n5, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r3 = S4;
    let g3 = Fp3.pow(Fp3.mul(Fp3.ONE, Z2), Q6);
    let x5 = Fp3.pow(n5, Q1div2);
    let b4 = Fp3.pow(n5, Q6);
    while (!Fp3.eql(b4, Fp3.ONE)) {
      if (Fp3.eql(b4, Fp3.ZERO))
        return Fp3.ZERO;
      let m3 = 1;
      for (let t2 = Fp3.sqr(b4); m3 < r3; m3++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge4 = Fp3.pow(g3, _1n9 << BigInt(r3 - m3 - 1));
      g3 = Fp3.sqr(ge4);
      x5 = Fp3.mul(x5, ge4);
      b4 = Fp3.mul(b4, g3);
      r3 = m3;
    }
    return x5;
  };
}
function FpSqrt2(P4) {
  if (P4 % _4n3 === _3n4) {
    const p1div4 = (P4 + _1n9) / _4n3;
    return function sqrt3mod42(Fp3, n5) {
      const root = Fp3.pow(n5, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P4 % _8n4 === _5n3) {
    const c1 = (P4 - _5n3) / _8n4;
    return function sqrt5mod82(Fp3, n5) {
      const n22 = Fp3.mul(n5, _2n7);
      const v6 = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n5, v6);
      const i4 = Fp3.mul(Fp3.mul(nv, _2n7), v6);
      const root = Fp3.mul(nv, Fp3.sub(i4, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P4 % _16n === _9n) {
  }
  return tonelliShanks2(P4);
}
var isNegativeLE2 = (num3, modulo) => (mod2(num3, modulo) & _1n9) === _1n9;
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts2 = FIELD_FIELDS2.reduce((map36, val) => {
    map36[val] = "function";
    return map36;
  }, initial);
  return validateObject2(field, opts2);
}
function FpPow2(f8, num3, power) {
  if (power < _0n9)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n9)
    return f8.ONE;
  if (power === _1n9)
    return num3;
  let p4 = f8.ONE;
  let d4 = num3;
  while (power > _0n9) {
    if (power & _1n9)
      p4 = f8.mul(p4, d4);
    d4 = f8.sqr(d4);
    power >>= _1n9;
  }
  return p4;
}
function FpInvertBatch2(f8, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num3, i4) => {
    if (f8.is0(num3))
      return acc;
    tmp[i4] = acc;
    return f8.mul(acc, num3);
  }, f8.ONE);
  const inverted = f8.inv(lastMultiplied);
  nums.reduceRight((acc, num3, i4) => {
    if (f8.is0(num3))
      return acc;
    tmp[i4] = f8.mul(acc, tmp[i4]);
    return f8.mul(acc, num3);
  }, inverted);
  return tmp;
}
function nLength2(n5, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLen3, isLE6 = false, redef = {}) {
  if (ORDER <= _0n9)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f8 = Object.freeze({
    ORDER,
    isLE: isLE6,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n9,
    ONE: _1n9,
    create: (num3) => mod2(num3, ORDER),
    isValid: (num3) => {
      if (typeof num3 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num3);
      return _0n9 <= num3 && num3 < ORDER;
    },
    is0: (num3) => num3 === _0n9,
    isOdd: (num3) => (num3 & _1n9) === _1n9,
    neg: (num3) => mod2(-num3, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num3) => mod2(num3 * num3, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num3, power) => FpPow2(f8, num3, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num3) => num3 * num3,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num3) => invert2(num3, ORDER),
    sqrt: redef.sqrt || ((n5) => {
      if (!sqrtP)
        sqrtP = FpSqrt2(ORDER);
      return sqrtP(f8, n5);
    }),
    invertBatch: (lst) => FpInvertBatch2(f8, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a3, b4, c6) => c6 ? b4 : a3,
    toBytes: (num3) => isLE6 ? numberToBytesLE2(num3, BYTES) : numberToBytesBE2(num3, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE6 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
    }
  });
  return Object.freeze(f8);
}
function FpSqrtEven2(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp3.sqrt(elm);
  return Fp3.isOdd(root) ? Fp3.neg(root) : root;
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length2 = getFieldBytesLength2(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField2(key, fieldOrder, isLE6 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num3 = isLE6 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
  const reduced = mod2(num3, fieldOrder - _1n9) + _1n9;
  return isLE6 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/curve.js
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW2(W5, bits) {
  if (!Number.isSafeInteger(W5) || W5 <= 0 || W5 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W5);
}
function calcWOpts2(W5, scalarBits) {
  validateW2(W5, scalarBits);
  const windows = Math.ceil(scalarBits / W5) + 1;
  const windowSize = 2 ** (W5 - 1);
  const maxNumber = 2 ** W5;
  const mask = bitMask2(W5);
  const shiftBy = BigInt(W5);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets2(n5, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n5 & mask);
  let nextN = n5 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n10;
  }
  const offsetStart = window2 * windowSize;
  const offset5 = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset: offset5, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints2(points, c6) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p4, i4) => {
    if (!(p4 instanceof c6))
      throw new Error("invalid point at index " + i4);
  });
}
function validateMSMScalars2(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s3, i4) => {
    if (!field.isValid(s3))
      throw new Error("invalid scalar at index " + i4);
  });
}
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
function getW2(P4) {
  return pointWindowSizes2.get(P4) || 1;
}
function wNAF2(c6, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW2(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n5, p4 = c6.ZERO) {
      let d4 = elm;
      while (n5 > _0n10) {
        if (n5 & _1n10)
          p4 = p4.add(d4);
        d4 = d4.double();
        n5 >>= _1n10;
      }
      return p4;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W5) {
      const { windows, windowSize } = calcWOpts2(W5, bits);
      const points = [];
      let p4 = elm;
      let base3 = p4;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p4;
        points.push(base3);
        for (let i4 = 1; i4 < windowSize; i4++) {
          base3 = base3.add(p4);
          points.push(base3);
        }
        p4 = base3.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W5, precomputes, n5) {
      let p4 = c6.ZERO;
      let f8 = c6.BASE;
      const wo5 = calcWOpts2(W5, bits);
      for (let window2 = 0; window2 < wo5.windows; window2++) {
        const { nextN, offset: offset5, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n5, window2, wo5);
        n5 = nextN;
        if (isZero) {
          f8 = f8.add(constTimeNegate(isNegF, precomputes[offsetF]));
        } else {
          p4 = p4.add(constTimeNegate(isNeg, precomputes[offset5]));
        }
      }
      return { p: p4, f: f8 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W5, precomputes, n5, acc = c6.ZERO) {
      const wo5 = calcWOpts2(W5, bits);
      for (let window2 = 0; window2 < wo5.windows; window2++) {
        if (n5 === _0n10)
          break;
        const { nextN, offset: offset5, isZero, isNeg } = calcOffsets2(n5, window2, wo5);
        n5 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset5];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      return acc;
    },
    getPrecomputes(W5, P4, transform) {
      let comp = pointPrecomputes2.get(P4);
      if (!comp) {
        comp = this.precomputeWindow(P4, W5);
        if (W5 !== 1)
          pointPrecomputes2.set(P4, transform(comp));
      }
      return comp;
    },
    wNAFCached(P4, n5, transform) {
      const W5 = getW2(P4);
      return this.wNAF(W5, this.getPrecomputes(W5, P4, transform), n5);
    },
    wNAFCachedUnsafe(P4, n5, transform, prev) {
      const W5 = getW2(P4);
      if (W5 === 1)
        return this.unsafeLadder(P4, n5, prev);
      return this.wNAFUnsafe(W5, this.getPrecomputes(W5, P4, transform), n5, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P4, W5) {
      validateW2(W5, bits);
      pointWindowSizes2.set(P4, W5);
      pointPrecomputes2.delete(P4);
    }
  };
}
function pippenger2(c6, fieldN, points, scalars) {
  validateMSMPoints2(points, c6);
  validateMSMScalars2(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero7 = c6.ZERO;
  const wbits = bitLen2(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = bitMask2(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero7);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero7;
  for (let i4 = lastBits; i4 >= 0; i4 -= windowSize) {
    buckets.fill(zero7);
    for (let j3 = 0; j3 < scalars.length; j3++) {
      const scalar = scalars[j3];
      const wbits2 = Number(scalar >> BigInt(i4) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j3]);
    }
    let resI = zero7;
    for (let j3 = buckets.length - 1, sumI = zero7; j3 > 0; j3--) {
      sumI = sumI.add(buckets[j3]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i4 !== 0)
      for (let j3 = 0; j3 < windowSize; j3++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField2(curve.Fp);
  validateObject2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength2(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n8 = BigInt(2);
var _8n5 = BigInt(8);
var VERIFY_DEFAULT2 = { zip215: true };
function validateOpts2(curve) {
  const opts2 = validateBasic(curve);
  validateObject2(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts2 });
}
function twistedEdwards2(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes7, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n8 << BigInt(nByteLength * 8) - _1n11;
  const modP3 = Fp3.create;
  const Fn5 = Field2(CURVE.n, CURVE.nBitLength);
  const uvRatio3 = CURVE.uvRatio || ((u2, v6) => {
    try {
      return { isValid: true, value: Fp3.sqrt(u2 * Fp3.inv(v6)) };
    } catch (e2) {
      return { isValid: false, value: _0n11 };
    }
  });
  const adjustScalarBytes3 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool2("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n5, banZero = false) {
    const min4 = banZero ? _1n11 : _0n11;
    aInRange2("coordinate " + title, n5, min4, MASK);
  }
  function aextpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized2((p4, iz) => {
    const { ex: x5, ey: y5, ez: z4 } = p4;
    const is0 = p4.is0();
    if (iz == null)
      iz = is0 ? _8n5 : Fp3.inv(z4);
    const ax = modP3(x5 * iz);
    const ay = modP3(y5 * iz);
    const zz = modP3(z4 * iz);
    if (is0)
      return { x: _0n11, y: _1n11 };
    if (zz !== _1n11)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized2((p4) => {
    const { a: a3, d: d4 } = CURVE;
    if (p4.is0())
      throw new Error("bad point: ZERO");
    const { ex: X4, ey: Y4, ez: Z2, et: T3 } = p4;
    const X22 = modP3(X4 * X4);
    const Y22 = modP3(Y4 * Y4);
    const Z22 = modP3(Z2 * Z2);
    const Z4 = modP3(Z22 * Z22);
    const aX2 = modP3(X22 * a3);
    const left13 = modP3(Z22 * modP3(aX2 + Y22));
    const right13 = modP3(Z4 + modP3(d4 * modP3(X22 * Y22)));
    if (left13 !== right13)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP3(X4 * Y4);
    const ZT = modP3(Z2 * T3);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point3 {
    constructor(ex, ey, ez, et) {
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez, true);
      aCoordinate("t", et);
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p4) {
      if (p4 instanceof Point3)
        throw new Error("extended point not allowed");
      const { x: x5, y: y5 } = p4 || {};
      aCoordinate("x", x5);
      aCoordinate("y", y5);
      return new Point3(x5, y5, _1n11, modP3(x5 * y5));
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p4) => p4.ez));
      return points.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point3.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger2(Point3, Fn5, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X22, ey: Y22, ez: Z2 } = other;
      const X1Z2 = modP3(X1 * Z2);
      const X2Z1 = modP3(X22 * Z1);
      const Y1Z2 = modP3(Y1 * Z2);
      const Y2Z1 = modP3(Y22 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    negate() {
      return new Point3(modP3(-this.ex), this.ey, this.ez, modP3(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a3 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A4 = modP3(X1 * X1);
      const B3 = modP3(Y1 * Y1);
      const C4 = modP3(_2n8 * modP3(Z1 * Z1));
      const D4 = modP3(a3 * A4);
      const x1y1 = X1 + Y1;
      const E4 = modP3(modP3(x1y1 * x1y1) - A4 - B3);
      const G6 = D4 + B3;
      const F5 = G6 - C4;
      const H2 = D4 - B3;
      const X32 = modP3(E4 * F5);
      const Y32 = modP3(G6 * H2);
      const T3 = modP3(E4 * H2);
      const Z3 = modP3(F5 * G6);
      return new Point3(X32, Y32, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a: a3, d: d4 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X22, ey: Y22, ez: Z2, et: T22 } = other;
      const A4 = modP3(X1 * X22);
      const B3 = modP3(Y1 * Y22);
      const C4 = modP3(T1 * d4 * T22);
      const D4 = modP3(Z1 * Z2);
      const E4 = modP3((X1 + Y1) * (X22 + Y22) - A4 - B3);
      const F5 = D4 - C4;
      const G6 = D4 + C4;
      const H2 = modP3(B3 - a3 * A4);
      const X32 = modP3(E4 * F5);
      const Y32 = modP3(G6 * H2);
      const T3 = modP3(E4 * H2);
      const Z3 = modP3(F5 * G6);
      return new Point3(X32, Y32, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n5) {
      return wnaf.wNAFCached(this, n5, Point3.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n5 = scalar;
      aInRange2("scalar", n5, _1n11, CURVE_ORDER);
      const { p: p4, f: f8 } = this.wNAF(n5);
      return Point3.normalizeZ([p4, f8])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point3.ZERO) {
      const n5 = scalar;
      aInRange2("scalar", n5, _0n11, CURVE_ORDER);
      if (n5 === _0n11)
        return I4;
      if (this.is0() || n5 === _1n11)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n5, Point3.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n11)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d: d4, a: a3 } = CURVE;
      const len = Fp3.BYTES;
      hex2 = ensureBytes2("pointHex", hex2, len);
      abool2("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y5 = bytesToNumberLE2(normed);
      const max4 = zip215 ? MASK : Fp3.ORDER;
      aInRange2("pointHex.y", y5, _0n11, max4);
      const y22 = modP3(y5 * y5);
      const u2 = modP3(y22 - _1n11);
      const v6 = modP3(d4 * y22 - a3);
      let { isValid, value: x5 } = uvRatio3(u2, v6);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x5 & _1n11) === _1n11;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x5 === _0n11 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x5 = modP3(-x5);
      return Point3.fromAffine({ x: x5, y: y5 });
    }
    static fromPrivateKey(privKey) {
      const { scalar } = getPrivateScalar(privKey);
      return G5.multiply(scalar);
    }
    toRawBytes() {
      const { x: x5, y: y5 } = this.toAffine();
      const bytes2 = numberToBytesLE2(y5, Fp3.BYTES);
      bytes2[bytes2.length - 1] |= x5 & _1n11 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex4(this.toRawBytes());
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, _1n11, modP3(CURVE.Gx * CURVE.Gy));
  Point3.ZERO = new Point3(_0n11, _1n11, _1n11, _0n11);
  const { BASE: G5, ZERO: I4 } = Point3;
  const wnaf = wNAF2(Point3, nByteLength * 8);
  function modN3(a3) {
    return mod2(a3, CURVE_ORDER);
  }
  function modN_LE(hash) {
    return modN3(bytesToNumberLE2(hash));
  }
  function getPrivateScalar(key) {
    const len = Fp3.BYTES;
    key = ensureBytes2("private key", key, len);
    const hashed = ensureBytes2("hashed private key", cHash(key), 2 * len);
    const head5 = adjustScalarBytes3(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head5);
    return { head: head5, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head: head5, prefix, scalar } = getPrivateScalar(key);
    const point = G5.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head: head5, prefix, scalar, point, pointBytes };
  }
  function getPublicKey5(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes5(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
  }
  function sign5(msg, privKey, options = {}) {
    msg = ensureBytes2("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r3 = hashDomainToScalar(options.context, prefix, msg);
    const R3 = G5.multiply(r3).toRawBytes();
    const k6 = hashDomainToScalar(options.context, R3, pointBytes, msg);
    const s3 = modN3(r3 + k6 * scalar);
    aInRange2("signature.s", s3, _0n11, CURVE_ORDER);
    const res = concatBytes5(R3, numberToBytesLE2(s3, Fp3.BYTES));
    return ensureBytes2("result", res, Fp3.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT2;
  function verify5(sig, msg, publicKey5, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes2("signature", sig, 2 * len);
    msg = ensureBytes2("message", msg);
    publicKey5 = ensureBytes2("publicKey", publicKey5, len);
    if (zip215 !== void 0)
      abool2("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s3 = bytesToNumberLE2(sig.slice(len, 2 * len));
    let A4, R3, SB;
    try {
      A4 = Point3.fromHex(publicKey5, zip215);
      R3 = Point3.fromHex(sig.slice(0, len), zip215);
      SB = G5.multiplyUnsafe(s3);
    } catch (error) {
      return false;
    }
    if (!zip215 && A4.isSmallOrder())
      return false;
    const k6 = hashDomainToScalar(context, R3.toRawBytes(), A4.toRawBytes(), msg);
    const RkA = R3.add(A4.multiplyUnsafe(k6));
    return RkA.subtract(SB).clearCofactor().equals(Point3.ZERO);
  }
  G5._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes7(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey: getPublicKey5,
    sign: sign5,
    verify: verify5,
    ExtendedPoint: Point3,
    utils
  };
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip2 = bytesToNumberBE2;
function i2osp2(value, length2) {
  anum2(value);
  anum2(length2);
  if (value < 0 || value >= 1 << 8 * length2)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length: length2 }).fill(0);
  for (let i4 = length2 - 1; i4 >= 0; i4--) {
    res[i4] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor2(a3, b4) {
  const arr = new Uint8Array(a3.length);
  for (let i4 = 0; i4 < a3.length; i4++) {
    arr[i4] = a3[i4] ^ b4[i4];
  }
  return arr;
}
function anum2(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd2(msg, DST, lenInBytes, H2) {
  abytes4(msg);
  abytes4(DST);
  anum2(lenInBytes);
  if (DST.length > 255)
    DST = H2(concatBytes5(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H2;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes5(DST, i2osp2(DST.length, 1));
  const Z_pad = i2osp2(0, r_in_bytes);
  const l_i_b_str = i2osp2(lenInBytes, 2);
  const b4 = new Array(ell);
  const b_0 = H2(concatBytes5(Z_pad, msg, l_i_b_str, i2osp2(0, 1), DST_prime));
  b4[0] = H2(concatBytes5(b_0, i2osp2(1, 1), DST_prime));
  for (let i4 = 1; i4 <= ell; i4++) {
    const args = [strxor2(b_0, b4[i4 - 1]), i2osp2(i4 + 1, 1), DST_prime];
    b4[i4] = H2(concatBytes5(...args));
  }
  const pseudo_random_bytes = concatBytes5(...b4);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof2(msg, DST, lenInBytes, k6, H2) {
  abytes4(msg);
  abytes4(DST);
  anum2(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k6 / 8);
    DST = H2.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H2.create({ dkLen: lenInBytes }).update(msg).update(i2osp2(lenInBytes, 2)).update(DST).update(i2osp2(DST.length, 1)).digest();
}
function hash_to_field2(msg, count, options) {
  validateObject2(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p4, k: k6, m: m3, hash, expand: expand2, DST: _DST } = options;
  abytes4(msg);
  anum2(count);
  const DST = typeof _DST === "string" ? utf8ToBytes3(_DST) : _DST;
  const log2p = p4.toString(2).length;
  const L3 = Math.ceil((log2p + k6) / 8);
  const len_in_bytes = count * m3 * L3;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd2(msg, DST, len_in_bytes, hash);
  } else if (expand2 === "xof") {
    prb = expand_message_xof2(msg, DST, len_in_bytes, k6, hash);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u2 = new Array(count);
  for (let i4 = 0; i4 < count; i4++) {
    const e2 = new Array(m3);
    for (let j3 = 0; j3 < m3; j3++) {
      const elm_offset = L3 * (j3 + i4 * m3);
      const tv = prb.subarray(elm_offset, elm_offset + L3);
      e2[j3] = mod2(os2ip2(tv), p4);
    }
    u2[i4] = e2;
  }
  return u2;
}
function isogenyMap2(field, map36) {
  const COEFF = map36.map((i4) => Array.from(i4).reverse());
  return (x5, y5) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i4) => field.add(field.mul(acc, x5), i4)));
    if (field.is0(xDen) || field.is0(yDen))
      throw new Error("bad point: ZERO");
    x5 = field.div(xNum, xDen);
    y5 = field.mul(y5, field.div(yNum, yDen));
    return { x: x5, y: y5 };
  };
}
function createHasher3(Point3, mapToCurve, def2) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u2 = hash_to_field2(msg, 2, { ...def2, DST: def2.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u2[0]));
      const u1 = Point3.fromAffine(mapToCurve(u2[1]));
      const P4 = u0.add(u1).clearCofactor();
      P4.assertValidity();
      return P4;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u2 = hash_to_field2(msg, 1, { ...def2, DST: def2.encodeDST, ...options });
      const P4 = Point3.fromAffine(mapToCurve(u2[0])).clearCofactor();
      P4.assertValidity();
      return P4;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i4 of scalars)
        if (typeof i4 !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P4 = Point3.fromAffine(mapToCurve(scalars)).clearCofactor();
      P4.assertValidity();
      return P4;
    }
  };
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n12 = BigInt(0);
var _1n12 = BigInt(1);
function validateOpts3(curve) {
  validateObject2(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery2(curveDef) {
  const CURVE = validateOpts3(curveDef);
  const { P: P4 } = CURVE;
  const modP3 = (n5) => mod2(n5, P4);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes3 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const powPminus2 = CURVE.powPminus2 || ((x5) => pow(x5, P4 - BigInt(2), P4));
  function cswap(swap10, x_2, x_3) {
    const dummy = modP3(swap10 * (x_2 - x_3));
    x_2 = modP3(x_2 - dummy);
    x_3 = modP3(x_3 + dummy);
    return [x_2, x_3];
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u2, scalar) {
    aInRange2("u", u2, _0n12, P4);
    aInRange2("scalar", scalar, _0n12, P4);
    const k6 = scalar;
    const x_1 = u2;
    let x_2 = _1n12;
    let z_2 = _0n12;
    let x_3 = u2;
    let z_3 = _1n12;
    let swap10 = _0n12;
    let sw;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n12; t--) {
      const k_t = k6 >> t & _1n12;
      swap10 ^= k_t;
      sw = cswap(swap10, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap10, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap10 = k_t;
      const A4 = x_2 + z_2;
      const AA = modP3(A4 * A4);
      const B3 = x_2 - z_2;
      const BB = modP3(B3 * B3);
      const E4 = AA - BB;
      const C4 = x_3 + z_3;
      const D4 = x_3 - z_3;
      const DA = modP3(D4 * A4);
      const CB = modP3(C4 * B3);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP3(dacb * dacb);
      z_3 = modP3(x_1 * modP3(da_cb * da_cb));
      x_2 = modP3(AA * BB);
      z_2 = modP3(E4 * (AA + modP3(a24 * E4)));
    }
    sw = cswap(swap10, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap10, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z22 = powPminus2(z_2);
    return modP3(x_2 * z22);
  }
  function encodeUCoordinate(u2) {
    return numberToBytesLE2(modP3(u2), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u2 = ensureBytes2("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === 32)
      u2[31] &= 127;
    return bytesToNumberLE2(u2);
  }
  function decodeScalar(n5) {
    const bytes2 = ensureBytes2("scalar", n5);
    const len = bytes2.length;
    if (len !== montgomeryBytes && len !== fieldLen) {
      let valid = "" + montgomeryBytes + " or " + fieldLen;
      throw new Error("invalid scalar, expected " + valid + " bytes, got " + len);
    }
    return bytesToNumberLE2(adjustScalarBytes3(bytes2));
  }
  function scalarMult(scalar, u2) {
    const pointU = decodeUCoordinate(u2);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n12)
      throw new Error("invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey5) => scalarMult(privateKey, publicKey5),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M12 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n13 = BigInt(0);
var _1n13 = BigInt(1);
var _2n9 = BigInt(2);
var _3n5 = BigInt(3);
var _5n4 = BigInt(5);
var _8n6 = BigInt(8);
function ed25519_pow_2_252_32(x5) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P4 = ED25519_P;
  const x22 = x5 * x5 % P4;
  const b22 = x22 * x5 % P4;
  const b4 = pow22(b22, _2n9, P4) * b22 % P4;
  const b5 = pow22(b4, _1n13, P4) * x5 % P4;
  const b10 = pow22(b5, _5n4, P4) * b5 % P4;
  const b20 = pow22(b10, _10n, P4) * b10 % P4;
  const b40 = pow22(b20, _20n, P4) * b20 % P4;
  const b80 = pow22(b40, _40n, P4) * b40 % P4;
  const b160 = pow22(b80, _80n, P4) * b80 % P4;
  const b240 = pow22(b160, _80n, P4) * b80 % P4;
  const b250 = pow22(b240, _10n, P4) * b10 % P4;
  const pow_p_5_8 = pow22(b250, _2n9, P4) * x5 % P4;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes2(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio2(u2, v6) {
  const P4 = ED25519_P;
  const v34 = mod2(v6 * v6 * v6, P4);
  const v7 = mod2(v34 * v34 * v6, P4);
  const pow3 = ed25519_pow_2_252_32(u2 * v7).pow_p_5_8;
  let x5 = mod2(u2 * v34 * pow3, P4);
  const vx2 = mod2(v6 * x5 * x5, P4);
  const root1 = x5;
  const root2 = mod2(x5 * ED25519_SQRT_M12, P4);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod2(-u2, P4);
  const noRoot = vx2 === mod2(-u2 * ED25519_SQRT_M12, P4);
  if (useRoot1)
    x5 = root1;
  if (useRoot2 || noRoot)
    x5 = root2;
  if (isNegativeLE2(x5, P4))
    x5 = mod2(-x5, P4);
  return { isValid: useRoot1 || useRoot2, value: x5 };
}
var Fp2 = (() => Field2(ED25519_P, void 0, true))();
var ed25519Defaults2 = (() => ({
  // Removing Fp.create() will still work, and is 10% faster on sign
  a: Fp2.create(BigInt(-1)),
  // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 2n**255n - 19n
  Fp: Fp2,
  // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  h: _8n6,
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha5123,
  randomBytes: randomBytes2,
  adjustScalarBytes: adjustScalarBytes2,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio: uvRatio2
}))();
var ed255193 = (() => twistedEdwards2(ed25519Defaults2))();
function ed25519_domain2(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes4(utf8ToBytes2("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx2 = (() => twistedEdwards2({
  ...ed25519Defaults2,
  domain: ed25519_domain2
}))();
var ed25519ph2 = (() => twistedEdwards2(Object.assign({}, ed25519Defaults2, {
  domain: ed25519_domain2,
  prehash: sha5123
})))();
var x255192 = (() => montgomery2({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x5) => {
    const P4 = ED25519_P;
    const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_32(x5);
    return mod2(pow22(pow_p_5_8, _3n5, P4) * b22, P4);
  },
  adjustScalarBytes: adjustScalarBytes2,
  randomBytes: randomBytes2
}))();
var ELL2_C12 = (() => (Fp2.ORDER + _3n5) / _8n6)();
var ELL2_C22 = (() => Fp2.pow(_2n9, ELL2_C12))();
var ELL2_C32 = (() => Fp2.sqrt(Fp2.neg(Fp2.ONE)))();
function map_to_curve_elligator2_curve255192(u2) {
  const ELL2_C4 = (Fp2.ORDER - _5n4) / _8n6;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp2.sqr(u2);
  tv1 = Fp2.mul(tv1, _2n9);
  let xd = Fp2.add(tv1, Fp2.ONE);
  let x1n = Fp2.neg(ELL2_J);
  let tv2 = Fp2.sqr(xd);
  let gxd = Fp2.mul(tv2, xd);
  let gx1 = Fp2.mul(tv1, ELL2_J);
  gx1 = Fp2.mul(gx1, x1n);
  gx1 = Fp2.add(gx1, tv2);
  gx1 = Fp2.mul(gx1, x1n);
  let tv3 = Fp2.sqr(gxd);
  tv2 = Fp2.sqr(tv3);
  tv3 = Fp2.mul(tv3, gxd);
  tv3 = Fp2.mul(tv3, gx1);
  tv2 = Fp2.mul(tv2, tv3);
  let y11 = Fp2.pow(tv2, ELL2_C4);
  y11 = Fp2.mul(y11, tv3);
  let y12 = Fp2.mul(y11, ELL2_C32);
  tv2 = Fp2.sqr(y11);
  tv2 = Fp2.mul(tv2, gxd);
  let e1 = Fp2.eql(tv2, gx1);
  let y1 = Fp2.cmov(y12, y11, e1);
  let x2n = Fp2.mul(x1n, tv1);
  let y21 = Fp2.mul(y11, u2);
  y21 = Fp2.mul(y21, ELL2_C22);
  let y22 = Fp2.mul(y21, ELL2_C32);
  let gx2 = Fp2.mul(gx1, tv1);
  tv2 = Fp2.sqr(y21);
  tv2 = Fp2.mul(tv2, gxd);
  let e2 = Fp2.eql(tv2, gx2);
  let y23 = Fp2.cmov(y22, y21, e2);
  tv2 = Fp2.sqr(y1);
  tv2 = Fp2.mul(tv2, gxd);
  let e3 = Fp2.eql(tv2, gx1);
  let xn5 = Fp2.cmov(x2n, x1n, e3);
  let y5 = Fp2.cmov(y23, y1, e3);
  let e4 = Fp2.isOdd(y5);
  y5 = Fp2.cmov(y5, Fp2.neg(y5), e3 !== e4);
  return { xMn: xn5, xMd: xd, yMn: y5, yMd: _1n13 };
}
var ELL2_C1_EDWARDS2 = (() => FpSqrtEven2(Fp2, Fp2.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards255192(u2) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve255192(u2);
  let xn5 = Fp2.mul(xMn, yMd);
  xn5 = Fp2.mul(xn5, ELL2_C1_EDWARDS2);
  let xd = Fp2.mul(xMd, yMn);
  let yn5 = Fp2.sub(xMn, xMd);
  let yd = Fp2.add(xMn, xMd);
  let tv1 = Fp2.mul(xd, yd);
  let e2 = Fp2.eql(tv1, Fp2.ZERO);
  xn5 = Fp2.cmov(xn5, Fp2.ZERO, e2);
  xd = Fp2.cmov(xd, Fp2.ONE, e2);
  yn5 = Fp2.cmov(yn5, Fp2.ONE, e2);
  yd = Fp2.cmov(yd, Fp2.ONE, e2);
  const inv = Fp2.invertBatch([xd, yd]);
  return { x: Fp2.mul(xn5, inv[0]), y: Fp2.mul(yn5, inv[1]) };
}
var htf = (() => createHasher3(ed255193.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards255192(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp2.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha5123
}))();
var hashToCurve3 = (() => htf.hashToCurve)();
var encodeToCurve3 = (() => htf.encodeToCurve)();
function aristp2(other) {
  if (!(other instanceof RistPoint2))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M12 = ED25519_SQRT_M12;
var SQRT_AD_MINUS_ONE2 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D2 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ2 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ2 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt2 = (number3) => uvRatio2(_1n13, number3);
var MAX_255B2 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE2 = (bytes2) => ed255193.CURVE.Fp.create(bytesToNumberLE2(bytes2) & MAX_255B2);
function calcElligatorRistrettoMap2(r0) {
  const { d: d4 } = ed255193.CURVE;
  const P4 = ed255193.CURVE.Fp.ORDER;
  const mod4 = ed255193.CURVE.Fp.create;
  const r3 = mod4(SQRT_M12 * r0 * r0);
  const Ns3 = mod4((r3 + _1n13) * ONE_MINUS_D_SQ2);
  let c6 = BigInt(-1);
  const D4 = mod4((c6 - d4 * r3) * mod4(r3 + d4));
  let { isValid: Ns_D_is_sq, value: s3 } = uvRatio2(Ns3, D4);
  let s_ = mod4(s3 * r0);
  if (!isNegativeLE2(s_, P4))
    s_ = mod4(-s_);
  if (!Ns_D_is_sq)
    s3 = s_;
  if (!Ns_D_is_sq)
    c6 = r3;
  const Nt5 = mod4(c6 * (r3 - _1n13) * D_MINUS_ONE_SQ2 - D4);
  const s22 = s3 * s3;
  const W0 = mod4((s3 + s3) * D4);
  const W1 = mod4(Nt5 * SQRT_AD_MINUS_ONE2);
  const W22 = mod4(_1n13 - s22);
  const W32 = mod4(_1n13 + s22);
  return new ed255193.ExtendedPoint(mod4(W0 * W32), mod4(W22 * W1), mod4(W1 * W32), mod4(W0 * W22));
}
var RistPoint2 = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap26) {
    return new _RistPoint(ed255193.ExtendedPoint.fromAffine(ap26));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex2) {
    hex2 = ensureBytes2("ristrettoHash", hex2, 64);
    const r1 = bytes255ToNumberLE2(hex2.slice(0, 32));
    const R1 = calcElligatorRistrettoMap2(r1);
    const r22 = bytes255ToNumberLE2(hex2.slice(32, 64));
    const R22 = calcElligatorRistrettoMap2(r22);
    return new _RistPoint(R1.add(R22));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex2) {
    hex2 = ensureBytes2("ristrettoHex", hex2, 32);
    const { a: a3, d: d4 } = ed255193.CURVE;
    const P4 = ed255193.CURVE.Fp.ORDER;
    const mod4 = ed255193.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s3 = bytes255ToNumberLE2(hex2);
    if (!equalBytes2(numberToBytesLE2(s3, 32), hex2) || isNegativeLE2(s3, P4))
      throw new Error(emsg);
    const s22 = mod4(s3 * s3);
    const u1 = mod4(_1n13 + a3 * s22);
    const u2 = mod4(_1n13 - a3 * s22);
    const u1_2 = mod4(u1 * u1);
    const u2_2 = mod4(u2 * u2);
    const v6 = mod4(a3 * d4 * u1_2 - u2_2);
    const { isValid, value: I4 } = invertSqrt2(mod4(v6 * u2_2));
    const Dx = mod4(I4 * u2);
    const Dy = mod4(I4 * Dx * v6);
    let x5 = mod4((s3 + s3) * Dx);
    if (isNegativeLE2(x5, P4))
      x5 = mod4(-x5);
    const y5 = mod4(u1 * Dy);
    const t = mod4(x5 * y5);
    if (!isValid || isNegativeLE2(t, P4) || y5 === _0n13)
      throw new Error(emsg);
    return new _RistPoint(new ed255193.ExtendedPoint(x5, y5, _1n13, t));
  }
  static msm(points, scalars) {
    const Fn5 = Field2(ed255193.CURVE.n, ed255193.CURVE.nBitLength);
    return pippenger2(_RistPoint, Fn5, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x5, ey: y5, ez: z4, et: t } = this.ep;
    const P4 = ed255193.CURVE.Fp.ORDER;
    const mod4 = ed255193.CURVE.Fp.create;
    const u1 = mod4(mod4(z4 + y5) * mod4(z4 - y5));
    const u2 = mod4(x5 * y5);
    const u2sq = mod4(u2 * u2);
    const { value: invsqrt } = invertSqrt2(mod4(u1 * u2sq));
    const D1 = mod4(invsqrt * u1);
    const D22 = mod4(invsqrt * u2);
    const zInv = mod4(D1 * D22 * t);
    let D4;
    if (isNegativeLE2(t * zInv, P4)) {
      let _x = mod4(y5 * SQRT_M12);
      let _y = mod4(x5 * SQRT_M12);
      x5 = _x;
      y5 = _y;
      D4 = mod4(D1 * INVSQRT_A_MINUS_D2);
    } else {
      D4 = D22;
    }
    if (isNegativeLE2(x5 * zInv, P4))
      y5 = mod4(-y5);
    let s3 = mod4((z4 - y5) * D4);
    if (isNegativeLE2(s3, P4))
      s3 = mod4(-s3);
    return numberToBytesLE2(s3, 32);
  }
  toHex() {
    return bytesToHex4(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    aristp2(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X22, ey: Y22 } = other.ep;
    const mod4 = ed255193.CURVE.Fp.create;
    const one = mod4(X1 * Y22) === mod4(Y1 * X22);
    const two = mod4(Y1 * Y22) === mod4(X1 * X22);
    return one || two;
  }
  add(other) {
    aristp2(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    aristp2(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint2 = (() => {
  if (!RistPoint2.BASE)
    RistPoint2.BASE = new RistPoint2(ed255193.ExtendedPoint.BASE);
  if (!RistPoint2.ZERO)
    RistPoint2.ZERO = new RistPoint2(ed255193.ExtendedPoint.ZERO);
  return RistPoint2;
})();

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_bn3 = __toESM(require_bn());
var import_bs586 = __toESM(require_bs584());
var import_borsh3 = __toESM(require_lib());
var BufferLayout3 = __toESM(require_Layout());
var import_buffer_layout3 = __toESM(require_Layout());

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/errors/dist/index.browser.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED3 = 1;
var SOLANA_ERROR__INVALID_NONCE3 = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND3 = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE3 = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH3 = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE3 = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING3 = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING3 = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE3 = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR3 = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR3 = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR3 = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS3 = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND3 = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST3 = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED3 = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION3 = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET3 = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH3 = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR3 = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE3 = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX3 = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED3 = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT3 = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED3 = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE3 = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY3 = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE3 = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE3 = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE3 = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP3 = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH3 = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE3 = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS3 = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY3 = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA3 = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE3 = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED3 = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED3 = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE3 = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED3 = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER3 = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS3 = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND3 = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND3 = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT3 = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT3 = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED3 = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT3 = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED3 = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED3 = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED3 = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED3 = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED3 = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED3 = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY3 = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED3 = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH3 = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH3 = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH3 = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE3 = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY3 = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS3 = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA3 = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH3 = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN3 = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR3 = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT3 = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA3 = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA3 = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL3 = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS3 = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID3 = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE3 = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED3 = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT3 = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION3 = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID3 = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND3 = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED3 = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE3 = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED3 = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX3 = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED3 = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED3 = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS3 = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED3 = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE3 = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED3 = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING3 = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC3 = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM3 = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR3 = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED3 = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE3 = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT3 = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID3 = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH3 = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT3 = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED3 = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED3 = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS3 = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC3 = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED3 = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION3 = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE3 = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE3 = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE3 = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE3 = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY3 = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR3 = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT3 = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER3 = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW3 = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR3 = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER3 = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED3 = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED3 = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED3 = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS3 = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS3 = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER3 = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER3 = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER3 = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER3 = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER3 = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER3 = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER3 = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER3 = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS3 = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING3 = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED3 = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES3 = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE3 = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME3 = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME3 = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE3 = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING3 = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE3 = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND3 = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING3 = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING3 = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING3 = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING3 = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING3 = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING3 = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE3 = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION3 = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES3 = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH3 = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT3 = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT3 = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT3 = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN3 = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE3 = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE3 = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND3 = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND3 = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE3 = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE3 = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED3 = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND3 = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP3 = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE3 = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX3 = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE3 = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION3 = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE3 = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE3 = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING3 = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT3 = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION3 = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT3 = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT3 = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT3 = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS3 = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND3 = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER3 = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA3 = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX3 = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT3 = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT3 = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT3 = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION3 = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT3 = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED3 = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT3 = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED3 = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED3 = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION3 = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY3 = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH3 = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH3 = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH3 = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH3 = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH3 = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH3 = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS3 = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE3 = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT3 = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT3 = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE3 = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE3 = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH3 = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE3 = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT3 = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE3 = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE3 = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT3 = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE3 = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL3 = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES3 = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS3 = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW3 = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN3 = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR3 = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD3 = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN3 = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID3 = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED3 = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED3 = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT3 = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING3 = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE3 = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING3 = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE3 = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED3 = 9900004;
var SolanaErrorMessages3 = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND3]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED3]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT3]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT3]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND3]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED3]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS3]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH3]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY3]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS3]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE3]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA3]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED3]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED3]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE3]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER3]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE3]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE3]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED3]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY3]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS3]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL3]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH3]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH3]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH3]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE3]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH3]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH3]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH3]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE3]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH3]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT3]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT3]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT3]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT3]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS3]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE3]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE3]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE3]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE3]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES3]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE3]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED3]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED3]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED3]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING3]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED3]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL3]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE3]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT3]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW3]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR3]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS3]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH3]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED3]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM3]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX3]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC3]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT3]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED3]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE3]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED3]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED3]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND3]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR3]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER3]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE3]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY3]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID3]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS3]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA3]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER3]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT3]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR3]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA3]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC3]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS3]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED3]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED3]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED3]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED3]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT3]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE3]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID3]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS3]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION3]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE3]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE3]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE3]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED3]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE3]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED3]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED3]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION3]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT3]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN3]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID3]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR3]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS3]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA3]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH3]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH3]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE3]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING3]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED3]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE3]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING3]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE3]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR3]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS3]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST3]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND3]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR3]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED3]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY3]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT3]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE3]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE3]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE3]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH3]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE3]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION3]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH3]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH3]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH3]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY3]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE3]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE3]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING3]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR3]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING3]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND3]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN3]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED3]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED3]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT3]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID3]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD3]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW3]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR3]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN3]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS3]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER3]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER3]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER3]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER3]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER3]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER3]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER3]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER3]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS3]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING3]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED3]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY3]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED3]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT3]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED3]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED3]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED3]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED3]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED3]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE3]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING3]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE3]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE3]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND3]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND3]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED3]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND3]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP3]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE3]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION3]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE3]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT3]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE3]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX3]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA3]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX3]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER3]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT3]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION3]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT3]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT3]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED3]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE3]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND3]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED3]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED3]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE3]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE3]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS3]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION3]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN3]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION3]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT3]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT3]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT3]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT3]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT3]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION3]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING3]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES3]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT3]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME3]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME3]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING3]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE3]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING3]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND3]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT3]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT3]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING3]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING3]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE3]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING3]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES3]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE3]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH3]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING3]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE3]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX3 = "i";
var TYPE3 = "t";
function getHumanReadableErrorMessage3(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages3[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE3] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX3] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE3] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX3], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii3) => {
    if (ii3 === 0) {
      state = {
        [START_INDEX3]: 0,
        [TYPE3]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE3]) {
      case 0:
        nextState = {
          [START_INDEX3]: ii3,
          [TYPE3]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX3]: ii3,
            [TYPE3]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX3]: ii3,
            [TYPE3]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX3]: ii3,
            [TYPE3]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX3]: ii3,
            [TYPE3]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX3]: ii3,
            [TYPE3]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii3);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage3(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage3(code2, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code2}; Decode this error by running \`npx @solana/errors decode -- ${code2}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError3 = class extends Error {
  constructor(...[code2, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage3(code2, context);
    super(message, errorOptions);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    __publicField(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    __publicField(this, "context");
    this.context = {
      __code: code2,
      ...context
    };
    this.name = "SolanaError";
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize3(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder3(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes2 = new Uint8Array(getEncodedSize3(value, encoder));
      encoder.write(value, bytes2, 0);
      return bytes2;
    }
  });
}
function createDecoder3(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes2, offset5 = 0) => decoder.read(bytes2, offset5)[0]
  });
}
function isFixedSize3(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec3(encoder, decoder) {
  if (isFixedSize3(encoder) !== isFixedSize3(decoder)) {
    throw new SolanaError3(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH3);
  }
  if (isFixedSize3(encoder) && isFixedSize3(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError3(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH3, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize3(encoder) && !isFixedSize3(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError3(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH3, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec3(codecDescription, bytes2, offset5 = 0) {
  if (bytes2.length - offset5 <= 0) {
    throw new SolanaError3(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY3, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec3(codecDescription, expected, bytes2, offset5 = 0) {
  const bytesLength = bytes2.length - offset5;
  if (bytesLength < expected) {
    throw new SolanaError3(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH3, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec3(codecDescription, min4, max4, value) {
  if (value < min4 || value > max4) {
    throw new SolanaError3(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE3, {
      codecDescription,
      max: max4,
      min: min4,
      value
    });
  }
}
var Endian3 = ((Endian22) => {
  Endian22[Endian22["Little"] = 0] = "Little";
  Endian22[Endian22["Big"] = 1] = "Big";
  return Endian22;
})(Endian3 || {});
function isLittleEndian3(config) {
  return (config == null ? void 0 : config.endian) === 1 ? false : true;
}
function numberEncoderFactory3(input) {
  return createEncoder3({
    fixedSize: input.size,
    write(value, bytes2, offset5) {
      if (input.range) {
        assertNumberIsBetweenForCodec3(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian3(input.config));
      bytes2.set(new Uint8Array(arrayBuffer), offset5);
      return offset5 + input.size;
    }
  });
}
function numberDecoderFactory3(input) {
  return createDecoder3({
    fixedSize: input.size,
    read(bytes2, offset5 = 0) {
      assertByteArrayIsNotEmptyForCodec3(input.name, bytes2, offset5);
      assertByteArrayHasEnoughBytesForCodec3(input.name, input.size, bytes2, offset5);
      const view = new DataView(toArrayBuffer3(bytes2, offset5, input.size));
      return [input.get(view, isLittleEndian3(input.config)), offset5 + input.size];
    }
  });
}
function toArrayBuffer3(bytes2, offset5, length2) {
  const bytesOffset = bytes2.byteOffset + (offset5 ?? 0);
  const bytesLength = length2 ?? bytes2.byteLength;
  return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder3 = (config = {}) => numberEncoderFactory3({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le5) => view.setBigUint64(0, BigInt(value), le5),
  size: 8
});
var getU64Decoder3 = (config = {}) => numberDecoderFactory3({
  config,
  get: (view, le5) => view.getBigUint64(0, le5),
  name: "u64",
  size: 8
});
var getU64Codec3 = (config = {}) => combineCodec3(getU64Encoder3(config), getU64Decoder3(config));

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_browser6 = __toESM(require_browser());

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n14 = BigInt(0);
var _1n14 = BigInt(1);
var _2n10 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R3 = _1n14, x5 = 1, y5 = 0; round < 24; round++) {
  [x5, y5] = [y5, (2 * x5 + 3 * y5) % 5];
  SHA3_PI.push(2 * (5 * y5 + x5));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n14;
  for (let j3 = 0; j3 < 7; j3++) {
    R3 = (R3 << _1n14 ^ (R3 >> _7n) * _0x71n) % _256n;
    if (R3 & _2n10)
      t ^= _1n14 << (_1n14 << BigInt(j3)) - _1n14;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h5, l6, s3) => s3 > 32 ? rotlBH(h5, l6, s3) : rotlSH(h5, l6, s3);
var rotlL = (h5, l6, s3) => s3 > 32 ? rotlBL(h5, l6, s3) : rotlSL(h5, l6, s3);
function keccakP(s3, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x5 = 0; x5 < 10; x5++)
      B3[x5] = s3[x5] ^ s3[x5 + 10] ^ s3[x5 + 20] ^ s3[x5 + 30] ^ s3[x5 + 40];
    for (let x5 = 0; x5 < 10; x5 += 2) {
      const idx1 = (x5 + 8) % 10;
      const idx0 = (x5 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y5 = 0; y5 < 50; y5 += 10) {
        s3[x5 + y5] ^= Th;
        s3[x5 + y5 + 1] ^= Tl;
      }
    }
    let curH = s3[2];
    let curL = s3[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s3[PI];
      curL = s3[PI + 1];
      s3[PI] = Th;
      s3[PI + 1] = Tl;
    }
    for (let y5 = 0; y5 < 50; y5 += 10) {
      for (let x5 = 0; x5 < 10; x5++)
        B3[x5] = s3[y5 + x5];
      for (let x5 = 0; x5 < 10; x5++)
        s3[y5 + x5] ^= ~B3[(x5 + 2) % 10] & B3[(x5 + 4) % 10];
    }
    s3[0] ^= SHA3_IOTA_H[round];
    s3[1] ^= SHA3_IOTA_L[round];
  }
  B3.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber3(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u323(this.state);
  }
  keccak() {
    if (!isLE)
      byteSwap32(this.state32);
    keccakP(this.state32, this.rounds);
    if (!isLE)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    const { blockLen, state } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i4 = 0; i4 < take; i4++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes3(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber3(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to5) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to5 || (to5 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to5.state32.set(this.state32);
    to5.pos = this.pos;
    to5.posOut = this.posOut;
    to5.finished = this.finished;
    to5.rounds = rounds;
    to5.suffix = suffix;
    to5.outputLen = outputLen;
    to5.enableXOF = enableXOF;
    to5.destroyed = this.destroyed;
    return to5;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_2562 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts2 = {}) => new Keccak(blockLen, suffix, opts2.dkLen === void 0 ? outputLen : opts2.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes3(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i4 = 0; i4 < pad3.length; i4++)
      pad3[i4] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash.create();
    for (let i4 = 0; i4 < pad3.length; i4++)
      pad3[i4] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes3(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to5) {
    to5 || (to5 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to5 = to5;
    to5.finished = finished;
    to5.destroyed = destroyed;
    to5.blockLen = blockLen;
    to5.outputLen = outputLen;
    to5.oHash = oHash._cloneInto(to5.oHash);
    to5.iHash = iHash._cloneInto(to5.iHash);
    return to5;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac2.create = (hash, key) => new HMAC(hash, key);

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts2(opts2) {
  if (opts2.lowS !== void 0)
    abool2("lowS", opts2.lowS);
  if (opts2.prehash !== void 0)
    abool2("prehash", opts2.prehash);
}
function validatePointOpts(curve) {
  const opts2 = validateBasic(curve);
  validateObject2(opts2, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a3 } = opts2;
  if (endo) {
    if (!Fp3.eql(a3, Fp3.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts2 });
}
var DERErr2 = class extends Error {
  constructor(m3 = "") {
    super(m3);
  }
};
var DER2 = {
  // asn.1 DER encoding utils
  Err: DERErr2,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E4 } = DER2;
      if (tag < 0 || tag > 256)
        throw new E4("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E4("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded2(dataLen);
      if (len.length / 2 & 128)
        throw new E4("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded2(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E4 } = DER2;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E4("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E4("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length2 = 0;
      if (!isLong)
        length2 = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E4("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E4("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E4("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E4("tlv.decode(long): zero leftmost byte");
        for (const b4 of lengthBytes)
          length2 = length2 << 8 | b4;
        pos += lenLen;
        if (length2 < 128)
          throw new E4("tlv.decode(long): not minimal encoding");
      }
      const v6 = data.subarray(pos, pos + length2);
      if (v6.length !== length2)
        throw new E4("tlv.decode: wrong value length");
      return { v: v6, l: data.subarray(pos + length2) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num3) {
      const { Err: E4 } = DER2;
      if (num3 < _0n15)
        throw new E4("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded2(num3);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E4("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E4 } = DER2;
      if (data[0] & 128)
        throw new E4("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E4("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE2(data);
    }
  },
  toSig(hex2) {
    const { Err: E4, _int: int, _tlv: tlv } = DER2;
    const data = ensureBytes2("signature", hex2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E4("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E4("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER2;
    const rs2 = tlv.encode(2, int.encode(sig.r));
    const ss2 = tlv.encode(2, int.encode(sig.s));
    const seq5 = rs2 + ss2;
    return tlv.encode(48, seq5);
  }
};
var _0n15 = BigInt(0);
var _1n15 = BigInt(1);
var _2n11 = BigInt(2);
var _3n6 = BigInt(3);
var _4n4 = BigInt(4);
function weierstrassPoints(opts2) {
  const CURVE = validatePointOpts(opts2);
  const { Fp: Fp3 } = CURVE;
  const Fn5 = Field2(CURVE.n, CURVE.nBitLength);
  const toBytes5 = CURVE.toBytes || ((_c3, point, _isCompressed) => {
    const a3 = point.toAffine();
    return concatBytes5(Uint8Array.from([4]), Fp3.toBytes(a3.x), Fp3.toBytes(a3.y));
  });
  const fromBytes5 = CURVE.fromBytes || ((bytes2) => {
    const tail4 = bytes2.subarray(1);
    const x5 = Fp3.fromBytes(tail4.subarray(0, Fp3.BYTES));
    const y5 = Fp3.fromBytes(tail4.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x: x5, y: y5 };
  });
  function weierstrassEquation(x5) {
    const { a: a3, b: b4 } = CURVE;
    const x22 = Fp3.sqr(x5);
    const x32 = Fp3.mul(x22, x5);
    return Fp3.add(Fp3.add(x32, Fp3.mul(x5, a3)), b4);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num3) {
    return inRange2(num3, _1n15, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N15 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes6(key))
        key = bytesToHex4(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num3;
    try {
      num3 = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes2("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num3 = mod2(num3, N15);
    aInRange2("private key", num3, _1n15, N15);
    return num3;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized2((p4, iz) => {
    const { px: x5, py: y5, pz: z4 } = p4;
    if (Fp3.eql(z4, Fp3.ONE))
      return { x: x5, y: y5 };
    const is0 = p4.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z4);
    const ax = Fp3.mul(x5, iz);
    const ay = Fp3.mul(y5, iz);
    const zz = Fp3.mul(z4, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized2((p4) => {
    if (p4.is0()) {
      if (CURVE.allowInfinityPoint && !Fp3.is0(p4.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x5, y: y5 } = p4.toAffine();
    if (!Fp3.isValid(x5) || !Fp3.isValid(y5))
      throw new Error("bad point: x or y not FE");
    const left13 = Fp3.sqr(y5);
    const right13 = weierstrassEquation(x5);
    if (!Fp3.eql(left13, right13))
      throw new Error("bad point: equation left != right");
    if (!p4.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point3 {
    constructor(px, py, pz) {
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
      this.px = px;
      this.py = py;
      this.pz = pz;
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p4) {
      const { x: x5, y: y5 } = p4 || {};
      if (!p4 || !Fp3.isValid(x5) || !Fp3.isValid(y5))
        throw new Error("invalid affine point");
      if (p4 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i4) => Fp3.eql(i4, Fp3.ZERO);
      if (is0(x5) && is0(y5))
        return Point3.ZERO;
      return new Point3(x5, y5, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p4) => p4.pz));
      return points.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P4 = Point3.fromAffine(fromBytes5(ensureBytes2("pointHex", hex2)));
      P4.assertValidity();
      return P4;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger2(Point3, Fn5, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y5 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y5);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X22, Z1));
      const U22 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a3, b: b4 } = CURVE;
      const b32 = Fp3.mul(b4, _3n6);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp3.ZERO, Y32 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X32 = Fp3.mul(a3, Z3);
      Y32 = Fp3.mul(b32, t2);
      Y32 = Fp3.add(X32, Y32);
      X32 = Fp3.sub(t1, Y32);
      Y32 = Fp3.add(t1, Y32);
      Y32 = Fp3.mul(X32, Y32);
      X32 = Fp3.mul(t3, X32);
      Z3 = Fp3.mul(b32, Z3);
      t2 = Fp3.mul(a3, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a3, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y32 = Fp3.add(Y32, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X32 = Fp3.sub(X32, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X32, Y32, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z2 } = other;
      let X32 = Fp3.ZERO, Y32 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a3 = CURVE.a;
      const b32 = Fp3.mul(CURVE.b, _3n6);
      let t0 = Fp3.mul(X1, X22);
      let t1 = Fp3.mul(Y1, Y22);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X22, Y22);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X22, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X32 = Fp3.add(Y22, Z2);
      t5 = Fp3.mul(t5, X32);
      X32 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X32);
      Z3 = Fp3.mul(a3, t4);
      X32 = Fp3.mul(b32, t2);
      Z3 = Fp3.add(X32, Z3);
      X32 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y32 = Fp3.mul(X32, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a3, t2);
      t4 = Fp3.mul(b32, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a3, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y32 = Fp3.add(Y32, t0);
      t0 = Fp3.mul(t5, t4);
      X32 = Fp3.mul(t3, X32);
      X32 = Fp3.sub(X32, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X32, Y32, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n5) {
      return wnaf.wNAFCached(this, n5, Point3.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc3) {
      const { endo, n: N15 } = CURVE;
      aInRange2("scalar", sc3, _0n15, N15);
      const I4 = Point3.ZERO;
      if (sc3 === _0n15)
        return I4;
      if (this.is0() || sc3 === _1n15)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc3, Point3.normalizeZ);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(sc3);
      let k1p = I4;
      let k2p = I4;
      let d4 = this;
      while (k1 > _0n15 || k22 > _0n15) {
        if (k1 & _1n15)
          k1p = k1p.add(d4);
        if (k22 & _1n15)
          k2p = k2p.add(d4);
        d4 = d4.double();
        k1 >>= _1n15;
        k22 >>= _1n15;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N15 } = CURVE;
      aInRange2("scalar", scalar, _1n15, N15);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p4, f: f8 } = this.wNAF(scalar);
        point = p4;
        fake = f8;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q6, a3, b4) {
      const G5 = Point3.BASE;
      const mul3 = (P4, a4) => a4 === _0n15 || a4 === _1n15 || !P4.equals(G5) ? P4.multiplyUnsafe(a4) : P4.multiply(a4);
      const sum = mul3(this, a3).add(mul3(Q6, b4));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n15)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n15)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool2("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes5(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool2("isCompressed", isCompressed);
      return bytesToHex4(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF2(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts4(curve) {
  const opts2 = validateBasic(curve);
  validateObject2(opts2, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts2 });
}
function weierstrass2(curveDef) {
  const CURVE = validateOpts4(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function modN3(a3) {
    return mod2(a3, CURVE_ORDER);
  }
  function invN(a3) {
    return invert2(a3, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c3, point, isCompressed) {
      const a3 = point.toAffine();
      const x5 = Fp3.toBytes(a3.x);
      const cat = concatBytes5;
      abool2("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x5);
      } else {
        return cat(Uint8Array.from([4]), x5, Fp3.toBytes(a3.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head5 = bytes2[0];
      const tail4 = bytes2.subarray(1);
      if (len === compressedLen && (head5 === 2 || head5 === 3)) {
        const x5 = bytesToNumberBE2(tail4);
        if (!inRange2(x5, _1n15, Fp3.ORDER))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x5);
        let y5;
        try {
          y5 = Fp3.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y5 & _1n15) === _1n15;
        const isHeadOdd = (head5 & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y5 = Fp3.neg(y5);
        return { x: x5, y: y5 };
      } else if (len === uncompressedLen && head5 === 4) {
        const x5 = Fp3.fromBytes(tail4.subarray(0, Fp3.BYTES));
        const y5 = Fp3.fromBytes(tail4.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x: x5, y: y5 };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteHex = (num3) => bytesToHex4(numberToBytesBE2(num3, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n15;
    return number3 > HALF;
  }
  function normalizeS(s3) {
    return isBiggerThanHalfOrder(s3) ? modN3(-s3) : s3;
  }
  const slcNum = (b4, from13, to5) => bytesToNumberBE2(b4.slice(from13, to5));
  class Signature {
    constructor(r3, s3, recovery) {
      aInRange2("r", r3, _1n15, CURVE_ORDER);
      aInRange2("s", s3, _1n15, CURVE_ORDER);
      this.r = r3;
      this.s = s3;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l6 = CURVE.nByteLength;
      hex2 = ensureBytes2("compactSignature", hex2, l6 * 2);
      return new Signature(slcNum(hex2, 0, l6), slcNum(hex2, l6, 2 * l6));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r3, s: s3 } = DER2.toSig(ensureBytes2("DER", hex2));
      return new Signature(r3, s3);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r3, s: s3, recovery: rec } = this;
      const h5 = bits2int_modN(ensureBytes2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE.n : r3;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R3 = Point3.fromHex(prefix + numToNByteHex(radj));
      const ir4 = invN(radj);
      const u1 = modN3(-h5 * ir4);
      const u2 = modN3(s3 * ir4);
      const Q6 = Point3.BASE.multiplyAndAddUnsafe(R3, u1, u2);
      if (!Q6)
        throw new Error("point at infinify");
      Q6.assertValidity();
      return Q6;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN3(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes4(this.toDERHex());
    }
    toDERHex() {
      return DER2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes4(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteHex(this.r) + numToNByteHex(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength2(CURVE.n);
      return mapHashToField2(CURVE.randomBytes(length2), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey5(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes6(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b4 = Point3.fromHex(publicB);
    return b4.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num3 = bytesToNumberBE2(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num3 >> BigInt(delta) : num3;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN3(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask2(CURVE.nBitLength);
  function int2octets(num3) {
    aInRange2("num < 2^" + CURVE.nBitLength, num3, _0n15, ORDER_MASK);
    return numberToBytesBE2(num3, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts2 = defaultSigOpts) {
    if (["recovered", "canonical"].some((k6) => k6 in opts2))
      throw new Error("sign() legacy options not supported");
    const { hash, randomBytes: randomBytes7 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts2;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    validateSigVerOpts2(opts2);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d4 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d4), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes7(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e2));
    }
    const seed = concatBytes5(...seedArgs);
    const m3 = h1int;
    function k2sig(kBytes) {
      const k6 = bits2int(kBytes);
      if (!isWithinCurveOrder(k6))
        return;
      const ik = invN(k6);
      const q = Point3.BASE.multiply(k6).toAffine();
      const r3 = modN3(q.x);
      if (r3 === _0n15)
        return;
      const s3 = modN3(ik * modN3(m3 + r3 * d4));
      if (s3 === _0n15)
        return;
      let recovery = (q.x === r3 ? 0 : 2) | Number(q.y & _1n15);
      let normS = s3;
      if (lowS && isBiggerThanHalfOrder(s3)) {
        normS = normalizeS(s3);
        recovery ^= 1;
      }
      return new Signature(r3, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign5(msgHash, privKey, opts2 = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts2);
    const C4 = CURVE;
    const drbg = createHmacDrbg2(C4.hash.outputLen, C4.nByteLength, C4.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify5(signature4, msgHash, publicKey5, opts2 = defaultVerOpts) {
    var _a21;
    const sg = signature4;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey5 = ensureBytes2("publicKey", publicKey5);
    const { lowS, prehash, format } = opts2;
    validateSigVerOpts2(opts2);
    if ("strict" in opts2)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex3 = typeof sg === "string" || isBytes6(sg);
    const isObj = !isHex3 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex3 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P4;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex3) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P4 = Point3.fromHex(publicKey5);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r3, s: s3 } = _sig;
    const h5 = bits2int_modN(msgHash);
    const is2 = invN(s3);
    const u1 = modN3(h5 * is2);
    const u2 = modN3(r3 * is2);
    const R3 = (_a21 = Point3.BASE.multiplyAndAddUnsafe(P4, u1, u2)) == null ? void 0 : _a21.toAffine();
    if (!R3)
      return false;
    const v6 = modN3(R3.x);
    return v6 === r3;
  }
  return {
    CURVE,
    getPublicKey: getPublicKey5,
    getSharedSecret,
    sign: sign5,
    verify: verify5,
    ProjectivePoint: Point3,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio2(Fp3, Z2) {
  const q = Fp3.ORDER;
  let l6 = _0n15;
  for (let o4 = q - _1n15; o4 % _2n11 === _0n15; o4 /= _2n11)
    l6 += _1n15;
  const c1 = l6;
  const _2n_pow_c1_1 = _2n11 << c1 - _1n15 - _1n15;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n11;
  const c22 = (q - _1n15) / _2n_pow_c1;
  const c32 = (c22 - _1n15) / _2n11;
  const c42 = _2n_pow_c1 - _1n15;
  const c52 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z2, c22);
  const c7 = Fp3.pow(Z2, (c22 + _1n15) / _2n11);
  let sqrtRatio = (u2, v6) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v6, c42);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v6);
    let tv5 = Fp3.mul(u2, tv3);
    tv5 = Fp3.pow(tv5, c32);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v6);
    tv3 = Fp3.mul(tv5, u2);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c52);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i4 = c1; i4 > _1n15; i4--) {
      let tv52 = i4 - _2n11;
      tv52 = _2n11 << tv52 - _1n15;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n4 === _3n6) {
    const c12 = (Fp3.ORDER - _3n6) / _4n4;
    const c23 = Fp3.sqrt(Fp3.neg(Z2));
    sqrtRatio = (u2, v6) => {
      let tv1 = Fp3.sqr(v6);
      const tv2 = Fp3.mul(u2, v6);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y22 = Fp3.mul(y1, c23);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v6);
      const isQR = Fp3.eql(tv3, u2);
      let y5 = Fp3.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y5 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU2(Fp3, opts2) {
  validateField2(Fp3);
  if (!Fp3.isValid(opts2.A) || !Fp3.isValid(opts2.B) || !Fp3.isValid(opts2.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio2(Fp3, opts2.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u2) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x5, y5;
    tv1 = Fp3.sqr(u2);
    tv1 = Fp3.mul(tv1, opts2.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts2.B);
    tv4 = Fp3.cmov(opts2.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts2.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts2.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts2.B);
    tv2 = Fp3.add(tv2, tv5);
    x5 = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y5 = Fp3.mul(tv1, u2);
    y5 = Fp3.mul(y5, value);
    x5 = Fp3.cmov(x5, tv3, isValid);
    y5 = Fp3.cmov(y5, value, isValid);
    const e1 = Fp3.isOdd(u2) === Fp3.isOdd(y5);
    y5 = Fp3.cmov(Fp3.neg(y5), y5, e1);
    x5 = Fp3.div(x5, tv4);
    return { x: x5, y: y5 };
  };
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash) {
  return {
    hash,
    hmac: (key, ...msgs) => hmac2(hash, key, concatBytes4(...msgs)),
    randomBytes: randomBytes2
  };
}
function createCurve2(curveDef, defHash) {
  const create6 = (hash) => weierstrass2({ ...curveDef, ...getHash(hash) });
  return { ...create6(defHash), create: create6 };
}

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n16 = BigInt(1);
var _2n12 = BigInt(2);
var divNearest2 = (a3, b4) => (a3 + b4 / _2n12) / b4;
function sqrtMod2(y5) {
  const P4 = secp256k1P;
  const _3n7 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y5 * y5 * y5 % P4;
  const b32 = b22 * b22 * y5 % P4;
  const b6 = pow22(b32, _3n7, P4) * b32 % P4;
  const b9 = pow22(b6, _3n7, P4) * b32 % P4;
  const b11 = pow22(b9, _2n12, P4) * b22 % P4;
  const b222 = pow22(b11, _11n, P4) * b11 % P4;
  const b44 = pow22(b222, _22n, P4) * b222 % P4;
  const b88 = pow22(b44, _44n, P4) * b44 % P4;
  const b176 = pow22(b88, _88n, P4) * b88 % P4;
  const b220 = pow22(b176, _44n, P4) * b44 % P4;
  const b223 = pow22(b220, _3n7, P4) * b32 % P4;
  const t1 = pow22(b223, _23n, P4) * b222 % P4;
  const t2 = pow22(t1, _6n, P4) * b22 % P4;
  const root = pow22(t2, _2n12, P4);
  if (!Fpk12.eql(Fpk12.sqr(root), y5))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk12 = Field2(secp256k1P, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k15 = createCurve2({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fpk12,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k6) => {
      const n5 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n16 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b22 * k6, n5);
      const c22 = divNearest2(-b1 * k6, n5);
      let k1 = mod2(k6 - c1 * a1 - c22 * a22, n5);
      let k22 = mod2(-c1 * b1 - c22 * b22, n5);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n5 - k1;
      if (k2neg)
        k22 = n5 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k6);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha2566);
var _0n16 = BigInt(0);
var TAGGED_HASH_PREFIXES2 = {};
function taggedHash2(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES2[tag];
  if (tagP === void 0) {
    const tagH = sha2566(Uint8Array.from(tag, (c6) => c6.charCodeAt(0)));
    tagP = concatBytes5(tagH, tagH);
    TAGGED_HASH_PREFIXES2[tag] = tagP;
  }
  return sha2566(concatBytes5(tagP, ...messages));
}
var pointToBytes2 = (point) => point.toRawBytes(true).slice(1);
var numTo32b2 = (n5) => numberToBytesBE2(n5, 32);
var modP2 = (x5) => mod2(x5, secp256k1P);
var modN2 = (x5) => mod2(x5, secp256k1N);
var Point2 = secp256k15.ProjectivePoint;
var GmulAdd = (Q6, a3, b4) => Point2.BASE.multiplyAndAddUnsafe(Q6, a3, b4);
function schnorrGetExtPubKey2(priv) {
  let d_ = secp256k15.utils.normPrivateKeyToScalar(priv);
  let p4 = Point2.fromPrivateKey(d_);
  const scalar = p4.hasEvenY() ? d_ : modN2(-d_);
  return { scalar, bytes: pointToBytes2(p4) };
}
function lift_x2(x5) {
  aInRange2("x", x5, _1n16, secp256k1P);
  const xx = modP2(x5 * x5);
  const c6 = modP2(xx * x5 + BigInt(7));
  let y5 = sqrtMod2(c6);
  if (y5 % _2n12 !== _0n16)
    y5 = modP2(-y5);
  const p4 = new Point2(x5, y5, _1n16);
  p4.assertValidity();
  return p4;
}
var num2 = bytesToNumberBE2;
function challenge2(...args) {
  return modN2(num2(taggedHash2("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey2(privateKey) {
  return schnorrGetExtPubKey2(privateKey).bytes;
}
function schnorrSign2(message, privateKey, auxRand = randomBytes2(32)) {
  const m3 = ensureBytes2("message", message);
  const { bytes: px, scalar: d4 } = schnorrGetExtPubKey2(privateKey);
  const a3 = ensureBytes2("auxRand", auxRand, 32);
  const t = numTo32b2(d4 ^ num2(taggedHash2("BIP0340/aux", a3)));
  const rand = taggedHash2("BIP0340/nonce", t, px, m3);
  const k_ = modN2(num2(rand));
  if (k_ === _0n16)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k6 } = schnorrGetExtPubKey2(k_);
  const e2 = challenge2(rx, px, m3);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b2(modN2(k6 + e2 * d4)), 32);
  if (!schnorrVerify2(sig, m3, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify2(signature4, message, publicKey5) {
  const sig = ensureBytes2("signature", signature4, 64);
  const m3 = ensureBytes2("message", message);
  const pub = ensureBytes2("publicKey", publicKey5, 32);
  try {
    const P4 = lift_x2(num2(pub));
    const r3 = num2(sig.subarray(0, 32));
    if (!inRange2(r3, _1n16, secp256k1P))
      return false;
    const s3 = num2(sig.subarray(32, 64));
    if (!inRange2(s3, _1n16, secp256k1N))
      return false;
    const e2 = challenge2(numTo32b2(r3), pointToBytes2(P4), m3);
    const R3 = GmulAdd(P4, s3, modN2(-e2));
    if (!R3 || !R3.hasEvenY() || R3.toAffine().x !== r3)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr2 = (() => ({
  getPublicKey: schnorrGetPublicKey2,
  sign: schnorrSign2,
  verify: schnorrVerify2,
  utils: {
    randomPrivateKey: secp256k15.utils.randomPrivateKey,
    lift_x: lift_x2,
    pointToBytes: pointToBytes2,
    numberToBytesBE: numberToBytesBE2,
    bytesToNumberBE: bytesToNumberBE2,
    taggedHash: taggedHash2,
    mod: mod2
  }
}))();
var isoMap2 = (() => isogenyMap2(Fpk12, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i4) => i4.map((j3) => BigInt(j3)))))();
var mapSWU2 = (() => mapToCurveSimpleSWU2(Fpk12, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk12.create(BigInt("-11"))
}))();
var htf2 = (() => createHasher3(secp256k15.ProjectivePoint, (scalars) => {
  const { x: x5, y: y5 } = mapSWU2(Fpk12.create(scalars[0]));
  return isoMap2(x5, y5);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk12.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2566
}))();
var hashToCurve4 = (() => htf2.hashToCurve)();
var encodeToCurve4 = (() => htf2.encodeToCurve)();

// node_modules/@dynamic-labs/embedded-wallet-solana/node_modules/@solana/web3.js/lib/index.browser.esm.js
var generatePrivateKey3 = ed255193.utils.randomPrivateKey;
var generateKeypair3 = () => {
  const privateScalar = ed255193.utils.randomPrivateKey();
  const publicKey5 = getPublicKey3(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey5, 32);
  return {
    publicKey: publicKey5,
    secretKey
  };
};
var getPublicKey3 = ed255193.getPublicKey;
function isOnCurve3(publicKey5) {
  try {
    ed255193.ExtendedPoint.fromHex(publicKey5);
    return true;
  } catch {
    return false;
  }
}
var sign3 = (message, secretKey) => ed255193.sign(message, secretKey.slice(0, 32));
var verify3 = ed255193.verify;
var toBuffer3 = (arr) => {
  if (import_buffer3.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return import_buffer3.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return import_buffer3.Buffer.from(arr);
  }
};
var Struct3 = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return import_buffer3.Buffer.from((0, import_borsh3.serialize)(SOLANA_SCHEMA3, this));
  }
  static decode(data) {
    return (0, import_borsh3.deserialize)(SOLANA_SCHEMA3, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh3.deserializeUnchecked)(SOLANA_SCHEMA3, this, data);
  }
};
var SOLANA_SCHEMA3 = /* @__PURE__ */ new Map();
var _PublicKey3;
var MAX_SEED_LENGTH3 = 32;
var PUBLIC_KEY_LENGTH3 = 32;
function isPublicKeyData3(value) {
  return value._bn !== void 0;
}
var uniquePublicKeyCounter3 = 1;
var PublicKey4 = class _PublicKey5 extends Struct3 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData3(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs586.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH3) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn3.default(decoded);
      } else {
        this._bn = new import_bn3.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH3) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new _PublicKey5(uniquePublicKeyCounter3);
    uniquePublicKeyCounter3 += 1;
    return new _PublicKey5(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey5) {
    return this._bn.eq(publicKey5._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return import_bs586.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b4 = this._bn.toArrayLike(import_buffer3.Buffer);
    if (b4.length === PUBLIC_KEY_LENGTH3) {
      return b4;
    }
    const zeroPad = import_buffer3.Buffer.alloc(32);
    b4.copy(zeroPad, 32 - b4.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = import_buffer3.Buffer.concat([fromPublicKey.toBuffer(), import_buffer3.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha2566(buffer);
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = import_buffer3.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH3) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = import_buffer3.Buffer.concat([buffer, toBuffer3(seed)]);
    });
    buffer = import_buffer3.Buffer.concat([buffer, programId.toBuffer(), import_buffer3.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha2566(buffer);
    if (isOnCurve3(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(import_buffer3.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new _PublicKey5(pubkeyData);
    return isOnCurve3(pubkey.toBytes());
  }
};
_PublicKey3 = PublicKey4;
PublicKey4.default = new _PublicKey3("11111111111111111111111111111111");
SOLANA_SCHEMA3.set(PublicKey4, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID3 = new PublicKey4("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE3 = 1280 - 40 - 8;
var VERSION_PREFIX_MASK3 = 127;
var SIGNATURE_LENGTH_IN_BYTES3 = 64;
var TransactionExpiredBlockheightExceededError3 = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError3.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
var TransactionExpiredTimeoutError3 = class extends Error {
  constructor(signature4, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature4} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredTimeoutError3.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
var TransactionExpiredNonceInvalidError3 = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredNonceInvalidError3.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
var MessageAccountKeys3 = class {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
};
var publicKey3 = (property = "publicKey") => {
  return BufferLayout3.blob(32, property);
};
var signature3 = (property = "signature") => {
  return BufferLayout3.blob(64, property);
};
var rustString3 = (property = "string") => {
  const rsl = BufferLayout3.struct([BufferLayout3.u32("length"), BufferLayout3.u32("lengthPadding"), BufferLayout3.blob(BufferLayout3.offset(BufferLayout3.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b4, offset5) => {
    const data = _decode(b4, offset5);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b4, offset5) => {
    const data = {
      chars: import_buffer3.Buffer.from(str, "utf8")
    };
    return _encode(data, b4, offset5);
  };
  rslShim.alloc = (str) => {
    return BufferLayout3.u32().span + BufferLayout3.u32().span + import_buffer3.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized3 = (property = "authorized") => {
  return BufferLayout3.struct([publicKey3("staker"), publicKey3("withdrawer")], property);
};
var lockup3 = (property = "lockup") => {
  return BufferLayout3.struct([BufferLayout3.ns64("unixTimestamp"), BufferLayout3.ns64("epoch"), publicKey3("custodian")], property);
};
var voteInit3 = (property = "voteInit") => {
  return BufferLayout3.struct([publicKey3("nodePubkey"), publicKey3("authorizedVoter"), publicKey3("authorizedWithdrawer"), BufferLayout3.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs3 = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout3.struct([BufferLayout3.u32("voteAuthorizationType"), publicKey3("currentAuthorityDerivedKeyOwnerPubkey"), rustString3("currentAuthorityDerivedKeySeed"), publicKey3("newAuthorized")], property);
};
function getAlloc3(type3, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc3({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type3.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength3(bytes2) {
  let len = 0;
  let size9 = 0;
  for (; ; ) {
    let elem6 = bytes2.shift();
    len |= (elem6 & 127) << size9 * 7;
    size9 += 1;
    if ((elem6 & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength3(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem6 = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem6);
      break;
    } else {
      elem6 |= 128;
      bytes2.push(elem6);
    }
  }
}
function assert6(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var CompiledKeys3 = class _CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new _CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert6(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert6(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert6(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey4(address)), ...readonlySigners.map(([address]) => new PublicKey4(address)), ...writableNonSigners.map(([address]) => new PublicKey4(address)), ...readonlyNonSigners.map(([address]) => new PublicKey4(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey4(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert6(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
};
var END_OF_BUFFER_ERROR_MESSAGE3 = "Reached end of buffer unexpectedly";
function guardedShift3(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE3);
  }
  return byteArray.shift();
}
function guardedSplice3(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE3);
  }
  return byteArray.splice(...args);
}
var Message3 = class _Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey4(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs586.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys3(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys3.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys3(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs586.default.encode(ix.data)
    }));
    return new _Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_3, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength3(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs586.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength3(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength3(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: import_buffer3.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: import_buffer3.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength3(instructionCount, instructions.length);
    let instructionBuffer = import_buffer3.Buffer.alloc(PACKET_DATA_SIZE3);
    import_buffer3.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout3.struct([BufferLayout3.u8("programIdIndex"), BufferLayout3.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout3.seq(BufferLayout3.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout3.blob(instruction.dataLength.length, "dataLength"), BufferLayout3.seq(BufferLayout3.u8("userdatum"), instruction.data.length, "data")]);
      const length3 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length3;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout3.struct([BufferLayout3.blob(1, "numRequiredSignatures"), BufferLayout3.blob(1, "numReadonlySignedAccounts"), BufferLayout3.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout3.blob(keyCount.length, "keyCount"), BufferLayout3.seq(publicKey3("key"), numKeys, "keys"), publicKey3("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: import_buffer3.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: import_buffer3.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: import_buffer3.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: import_buffer3.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer3(key.toBytes())),
      recentBlockhash: import_bs586.default.decode(this.recentBlockhash)
    };
    let signData = import_buffer3.Buffer.alloc(2048);
    const length2 = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length2);
    return signData.slice(0, length2 + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift3(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK3)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift3(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift3(byteArray);
    const accountCount = decodeLength3(byteArray);
    let accountKeys = [];
    for (let i4 = 0; i4 < accountCount; i4++) {
      const account = guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3);
      accountKeys.push(new PublicKey4(import_buffer3.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3);
    const instructionCount = decodeLength3(byteArray);
    let instructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift3(byteArray);
      const accountCount2 = decodeLength3(byteArray);
      const accounts = guardedSplice3(byteArray, 0, accountCount2);
      const dataLength = decodeLength3(byteArray);
      const dataSlice = guardedSplice3(byteArray, 0, dataLength);
      const data = import_bs586.default.encode(import_buffer3.Buffer.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs586.default.encode(import_buffer3.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new _Message(messageArgs);
  }
};
var MessageV03 = class _MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup4 of this.addressTableLookups) {
      count += lookup4.readonlyIndexes.length + lookup4.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys3(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup4) => count + lookup4.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys3.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== void 0) {
        const [addressTableLookup, {
          writable,
          readonly: readonly3
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly3);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys3(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new _MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength3(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength3(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength3(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = BufferLayout3.struct([BufferLayout3.u8("prefix"), BufferLayout3.struct([BufferLayout3.u8("numRequiredSignatures"), BufferLayout3.u8("numReadonlySignedAccounts"), BufferLayout3.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout3.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout3.seq(publicKey3(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey3("recentBlockhash"), BufferLayout3.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout3.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout3.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout3.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE3);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: import_bs586.default.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE3);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength3(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength3(encodedDataLength, instruction.data.length);
      const instructionLayout = BufferLayout3.struct([BufferLayout3.u8("programIdIndex"), BufferLayout3.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout3.seq(BufferLayout3.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout3.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout3.blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE3);
    for (const lookup4 of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength3(encodedWritableIndexesLength, lookup4.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength3(encodedReadonlyIndexesLength, lookup4.readonlyIndexes.length);
      const addressTableLookupLayout = BufferLayout3.struct([publicKey3("accountKey"), BufferLayout3.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout3.seq(BufferLayout3.u8(), lookup4.writableIndexes.length, "writableIndexes"), BufferLayout3.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout3.seq(BufferLayout3.u8(), lookup4.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup4.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup4.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup4.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = guardedShift3(byteArray);
    const maskedPrefix = prefix & VERSION_PREFIX_MASK3;
    assert6(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version11 = maskedPrefix;
    assert6(version11 === 0, `Expected versioned message with version 0 but found version ${version11}`);
    const header = {
      numRequiredSignatures: guardedShift3(byteArray),
      numReadonlySignedAccounts: guardedShift3(byteArray),
      numReadonlyUnsignedAccounts: guardedShift3(byteArray)
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength3(byteArray);
    for (let i4 = 0; i4 < staticAccountKeysLength; i4++) {
      staticAccountKeys.push(new PublicKey4(guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3)));
    }
    const recentBlockhash = import_bs586.default.encode(guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3));
    const instructionCount = decodeLength3(byteArray);
    const compiledInstructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift3(byteArray);
      const accountKeyIndexesLength = decodeLength3(byteArray);
      const accountKeyIndexes = guardedSplice3(byteArray, 0, accountKeyIndexesLength);
      const dataLength = decodeLength3(byteArray);
      const data = new Uint8Array(guardedSplice3(byteArray, 0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength3(byteArray);
    const addressTableLookups = [];
    for (let i4 = 0; i4 < addressTableLookupsCount; i4++) {
      const accountKey = new PublicKey4(guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3));
      const writableIndexesLength = decodeLength3(byteArray);
      const writableIndexes = guardedSplice3(byteArray, 0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength3(byteArray);
      const readonlyIndexes = guardedSplice3(byteArray, 0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new _MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
};
var VersionedMessage3 = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK3;
    if (maskedPrefix === prefix) {
      return "legacy";
    }
    return maskedPrefix;
  },
  deserialize: (serializedMessage) => {
    const version11 = VersionedMessage3.deserializeMessageVersion(serializedMessage);
    if (version11 === "legacy") {
      return Message3.from(serializedMessage);
    }
    if (version11 === 0) {
      return MessageV03.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version11} deserialization is not supported`);
    }
  }
};
var TransactionStatus3 = (function(TransactionStatus5) {
  TransactionStatus5[TransactionStatus5["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus5[TransactionStatus5["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus5[TransactionStatus5["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus5[TransactionStatus5["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus5;
})({});
var DEFAULT_SIGNATURE3 = import_buffer3.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES3).fill(0);
var TransactionInstruction3 = class {
  constructor(opts2) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = import_buffer3.Buffer.alloc(0);
    this.programId = opts2.programId;
    this.keys = opts2.keys;
    if (opts2.data) {
      this.data = opts2.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
};
var Transaction4 = class _Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts2) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts2) {
      return;
    }
    if (opts2.feePayer) {
      this.feePayer = opts2.feePayer;
    }
    if (opts2.signatures) {
      this.signatures = opts2.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts2, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts2;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts2, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts2;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts2;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey5
      }) => {
        return publicKey5.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction3(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i4 = 0; i4 < instructions.length; i4++) {
      if (instructions[i4].programId === void 0) {
        throw new Error(`Transaction instruction index ${i4} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey4(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x5, y5) {
      if (x5.isSigner !== y5.isSigner) {
        return x5.isSigner ? -1 : 1;
      }
      if (x5.isWritable !== y5.isWritable) {
        return x5.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x5.pubkey.toBase58().localeCompare(y5.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x5) => {
      return x5.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature4 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.equals(signature4.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature4.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs586.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert6(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert6(keyIndex >= 0));
    });
    return new Message3({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey5) => {
      const key = publicKey5.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature4 = sign3(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer3(signature4));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature4) {
    this._compile();
    this._addSignature(pubkey, signature4);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature4) {
    assert6(signature4.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = import_buffer3.Buffer.from(signature4);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature: signature4,
      publicKey: publicKey5
    } of this.signatures) {
      if (signature4 === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey5);
        }
      } else {
        if (!verify3(signature4, message, publicKey5.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey5);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength3(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = import_buffer3.Buffer.alloc(transactionLength);
    assert6(signatures.length < 256);
    import_buffer3.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature4
    }, index) => {
      if (signature4 !== null) {
        assert6(signature4.length === 64, `signature has invalid length`);
        import_buffer3.Buffer.from(signature4).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert6(wireTransaction.length <= PACKET_DATA_SIZE3, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE3}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert6(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert6(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert6(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength3(byteArray);
    let signatures = [];
    for (let i4 = 0; i4 < signatureCount; i4++) {
      const signature4 = guardedSplice3(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES3);
      signatures.push(import_bs586.default.encode(import_buffer3.Buffer.from(signature4)));
    }
    return _Transaction.populate(Message3.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message, signatures = []) {
    const transaction = new _Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature4, index) => {
      const sigPubkeyPair = {
        signature: signature4 == import_bs586.default.encode(DEFAULT_SIGNATURE3) ? null : import_bs586.default.decode(signature4),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys4 = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction3({
        keys: keys4,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs586.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
};
var VersionedTransaction4 = class _VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(message, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== void 0) {
      assert6(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i4 = 0; i4 < message.header.numRequiredSignatures; i4++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES3));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength3(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = BufferLayout3.struct([BufferLayout3.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout3.seq(signature3(), this.signatures.length, "signatures"), BufferLayout3.blob(serializedMessage.length, "serializedMessage")]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength3(byteArray);
    for (let i4 = 0; i4 < signaturesLength; i4++) {
      signatures.push(new Uint8Array(guardedSplice3(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES3)));
    }
    const message = VersionedMessage3.deserialize(new Uint8Array(byteArray));
    return new _VersionedTransaction(message, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
      assert6(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign3(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey5, signature4) {
    assert6(signature4.byteLength === 64, "Signature must be 64 bytes long");
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey5));
    assert6(signerIndex >= 0, `Can not add signature; \`${publicKey5.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature4;
  }
};
var NUM_TICKS_PER_SECOND3 = 160;
var DEFAULT_TICKS_PER_SLOT3 = 64;
var NUM_SLOTS_PER_SECOND3 = NUM_TICKS_PER_SECOND3 / DEFAULT_TICKS_PER_SLOT3;
var MS_PER_SLOT3 = 1e3 / NUM_SLOTS_PER_SECOND3;
var SYSVAR_CLOCK_PUBKEY3 = new PublicKey4("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY3 = new PublicKey4("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY3 = new PublicKey4("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY3 = new PublicKey4("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY3 = new PublicKey4("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY3 = new PublicKey4("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY3 = new PublicKey4("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY3 = new PublicKey4("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY3 = new PublicKey4("SysvarStakeHistory1111111111111111111111111");
var SendTransactionError3 = class extends Error {
  constructor({
    action,
    signature: signature4,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature4} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${/* @__PURE__ */ ((a3) => a3)(action)}'`;
      }
    }
    super(message);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature4;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
};
var SolanaJSONRPCError2 = class extends Error {
  constructor({
    code: code2,
    message,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message}` : message);
    this.code = void 0;
    this.data = void 0;
    this.code = code2;
    this.data = data;
    this.name = "SolanaJSONRPCError";
  }
};
async function sendAndConfirmTransaction3(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature4 = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature: signature4,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature: signature4
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature4, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature4 != null) {
      throw new SendTransactionError3({
        action: "send",
        signature: signature4,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature4} failed (${JSON.stringify(status)})`);
  }
  return signature4;
}
function sleep3(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function encodeData5(type3, fields) {
  const allocLength = type3.layout.span >= 0 ? type3.layout.span : getAlloc3(type3, fields);
  const data = import_buffer3.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type3.index
  }, fields);
  type3.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout3 = BufferLayout3.nu64("lamportsPerSignature");
var NonceAccountLayout3 = BufferLayout3.struct([BufferLayout3.u32("version"), BufferLayout3.u32("state"), publicKey3("authorizedPubkey"), publicKey3("nonce"), BufferLayout3.struct([FeeCalculatorLayout3], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH3 = NonceAccountLayout3.span;
var NonceAccount2 = class _NonceAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer) {
    const nonceAccount = NonceAccountLayout3.decode(toBuffer3(buffer), 0);
    return new _NonceAccount({
      authorizedPubkey: new PublicKey4(nonceAccount.authorizedPubkey),
      nonce: new PublicKey4(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
};
function u644(property) {
  const layout = (0, import_buffer_layout3.blob)(8, property);
  const decode9 = layout.decode.bind(layout);
  const encode16 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec3();
  bigIntLayout.decode = (buffer, offset5) => {
    const src2 = decode9(buffer, offset5);
    return codec.decode(src2);
  };
  bigIntLayout.encode = (bigInt, buffer, offset5) => {
    const src2 = codec.encode(bigInt);
    return encode16(src2, buffer, offset5);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS3 = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports"), BufferLayout3.ns64("space"), publicKey3("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u644("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("base"), rustString3("seed"), BufferLayout3.ns64("lamports"), BufferLayout3.ns64("space"), publicKey3("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("base"), rustString3("seed"), BufferLayout3.ns64("space"), publicKey3("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("base"), rustString3("seed"), publicKey3("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u644("lamports"), rustString3("seed"), publicKey3("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  }
});
var SystemProgram3 = class _SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.Create;
    const data = encodeData5(type3, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer3(params.programId.toBuffer())
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.TransferWithSeed;
      data = encodeData5(type3, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.Transfer;
      data = encodeData5(type3, {
        lamports: BigInt(params.lamports)
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction3({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.AssignWithSeed;
      data = encodeData5(type3, {
        base: toBuffer3(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.Assign;
      data = encodeData5(type3, {
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction3({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.CreateWithSeed;
    const data = encodeData5(type3, {
      base: toBuffer3(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer3(params.programId.toBuffer())
    });
    let keys4 = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys4.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction3({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction4();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(_SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH3,
        programId: this.programId
      }));
    } else {
      transaction.add(_SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH3,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.InitializeNonceAccount;
    const data = encodeData5(type3, {
      authorized: toBuffer3(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.AdvanceNonceAccount;
    const data = encodeData5(type3);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.WithdrawNonceAccount;
    const data = encodeData5(type3, {
      lamports: params.lamports
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.AuthorizeNonceAccount;
    const data = encodeData5(type3, {
      authorized: toBuffer3(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.AllocateWithSeed;
      data = encodeData5(type3, {
        base: toBuffer3(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS3.Allocate;
      data = encodeData5(type3, {
        space: params.space
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction3({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
SystemProgram3.programId = new PublicKey4("11111111111111111111111111111111");
var CHUNK_SIZE4 = PACKET_DATA_SIZE3 - 300;
var Loader3 = class _Loader {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Amount of program data placed in each load Transaction
   */
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * // Every transaction requires two signatures (payer + program)
    (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
    1);
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction4();
          transaction.add(SystemProgram3.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction4();
          transaction.add(SystemProgram3.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction4();
          transaction.add(SystemProgram3.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction4().add(SystemProgram3.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction3(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.u32("offset"), BufferLayout3.u32("bytesLength"), BufferLayout3.u32("bytesLengthPadding"), BufferLayout3.seq(BufferLayout3.u8("byte"), BufferLayout3.offset(BufferLayout3.u32(), -8), "bytes")]);
    const chunkSize = _Loader.chunkSize;
    let offset5 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes2 = array2.slice(0, chunkSize);
      const data2 = import_buffer3.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset: offset5,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction4().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction3(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep3(1e3 / REQUESTS_PER_SECOND);
      }
      offset5 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout3.struct([BufferLayout3.u32("instruction")]);
      const data2 = import_buffer3.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
        // Finalize instruction
      }, data2);
      const transaction = new Transaction4().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY3,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT3 / 2)));
      }
    }
    return true;
  }
};
Loader3.chunkSize = CHUNK_SIZE4;
var BPF_LOADER_PROGRAM_ID3 = new PublicKey4("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs3(x5) {
  return x5 && x5.__esModule && Object.prototype.hasOwnProperty.call(x5, "default") ? x5["default"] : x5;
}
var fastStableStringify$13;
var hasRequiredFastStableStringify3;
function requireFastStableStringify3() {
  if (hasRequiredFastStableStringify3) return fastStableStringify$13;
  hasRequiredFastStableStringify3 = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys4 = [];
    for (var name2 in obj) {
      keys4.push(name2);
    }
    return keys4;
  };
  function stringify6(val, isArrayProp) {
    var i4, max4, str, keys4, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify6(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str = "[";
            max4 = val.length - 1;
            for (i4 = 0; i4 < max4; i4++) {
              str += stringify6(val[i4], true) + ",";
            }
            if (max4 > -1) {
              str += stringify6(val[i4], true);
            }
            return str + "]";
          } else if (toStr === "[object Object]") {
            keys4 = objKeys(val).sort();
            max4 = keys4.length;
            str = "";
            i4 = 0;
            while (i4 < max4) {
              key = keys4[i4];
              propVal = stringify6(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i4++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$13 = function(val) {
    var returnVal = stringify6(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$13;
}
var fastStableStringifyExports3 = requireFastStableStringify3();
var fastStableStringify3 = getDefaultExportFromCjs3(fastStableStringifyExports3);
var MINIMUM_SLOT_PER_EPOCH2 = 32;
function trailingZeros2(n5) {
  let trailingZeros3 = 0;
  while (n5 > 1) {
    n5 /= 2;
    trailingZeros3++;
  }
  return trailingZeros3;
}
function nextPowerOfTwo2(n5) {
  if (n5 === 0) return 1;
  n5--;
  n5 |= n5 >> 1;
  n5 |= n5 >> 2;
  n5 |= n5 >> 4;
  n5 |= n5 >> 8;
  n5 |= n5 >> 16;
  n5 |= n5 >> 32;
  return n5 + 1;
}
var EpochSchedule2 = class {
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros2(nextPowerOfTwo2(slot + MINIMUM_SLOT_PER_EPOCH2 + 1)) - trailingZeros2(MINIMUM_SLOT_PER_EPOCH2) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH2);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH2;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros2(MINIMUM_SLOT_PER_EPOCH2));
    } else {
      return this.slotsPerEpoch;
    }
  }
};
var fetchImpl3 = globalThis.fetch;
var RpcWebSocketClient2 = class extends CommonClient {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = (url) => {
      const rpc3 = WebSocket2(url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1e3,
        ...options
      });
      if ("socket" in rpc3) {
        this.underlyingSocket = rpc3.socket;
      } else {
        this.underlyingSocket = rpc3;
      }
      return rpc3;
    };
    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = void 0;
  }
  call(...args) {
    var _a21;
    const readyState = (_a21 = this.underlyingSocket) == null ? void 0 : _a21.readyState;
    if (readyState === 1) {
      return super.call(...args);
    }
    return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
  notify(...args) {
    var _a21;
    const readyState = (_a21 = this.underlyingSocket) == null ? void 0 : _a21.readyState;
    if (readyState === 1) {
      return super.notify(...args);
    }
    return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
};
function decodeData2(type3, data) {
  let decoded;
  try {
    decoded = type3.layout.decode(data);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (decoded.typeIndex !== type3.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type3.index}`);
  }
  return decoded;
}
var LOOKUP_TABLE_META_SIZE2 = 56;
var AddressLookupTableAccount2 = class {
  constructor(args) {
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  isActive() {
    const U64_MAX = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData2(LookupTableMetaLayout3, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE2;
    assert6(serializedAddressesLen >= 0, "lookup table is invalid");
    assert6(serializedAddressesLen % 32 === 0, "lookup table is invalid");
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = BufferLayout3.struct([BufferLayout3.seq(publicKey3(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE2));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey4(meta.authority[0]) : void 0,
      addresses: addresses.map((address) => new PublicKey4(address))
    };
  }
};
var LookupTableMetaLayout3 = {
  index: 1,
  layout: BufferLayout3.struct([
    BufferLayout3.u32("typeIndex"),
    u644("deactivationSlot"),
    BufferLayout3.nu64("lastExtendedSlot"),
    BufferLayout3.u8("lastExtendedStartIndex"),
    BufferLayout3.u8(),
    // option
    BufferLayout3.seq(publicKey3(), BufferLayout3.offset(BufferLayout3.u8(), -1), "authority")
  ])
};
var URL_RE2 = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl2(endpoint) {
  const matches = endpoint.match(URL_RE2);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
  }
  const [
    _3,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to agave-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
var PublicKeyFromString3 = coerce(instance(PublicKey4), string(), (value) => new PublicKey4(value));
var RawAccountDataResult3 = tuple([string(), literal("base64")]);
var BufferFromRawAccountData3 = coerce(instance(import_buffer3.Buffer), RawAccountDataResult3, (value) => import_buffer3.Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS3 = 30 * 1e3;
function assertEndpointUrl2(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig2(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}
function applyDefaultMemcmpEncodingToFilters2(filters) {
  return filters.map((filter10) => "memcmp" in filter10 ? {
    ...filter10,
    memcmp: {
      ...filter10.memcmp,
      encoding: filter10.memcmp.encoding ?? "base58"
    }
  } : filter10);
}
function createRpcResult3(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult3 = createRpcResult3(unknown());
function jsonRpcResult3(schema) {
  return coerce(createRpcResult3(schema), UnknownRpcResult3, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext3(value) {
  return jsonRpcResult3(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext3(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
function versionedMessageFromResponse2(version11, response) {
  if (version11 === 0) {
    return new MessageV03({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey4(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: import_bs586.default.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message3(response);
  }
}
var GetInflationGovernorResult3 = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
var GetInflationRewardResult3 = jsonRpcResult3(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
var GetRecentPrioritizationFeesResult3 = array(type({
  slot: number(),
  prioritizationFee: number()
}));
var GetInflationRateResult3 = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});
var GetEpochInfoResult3 = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult3 = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
var GetLeaderScheduleResult3 = record(string(), array(number()));
var TransactionErrorResult3 = nullable(union([type({}), string()]));
var SignatureStatusResult3 = type({
  err: TransactionErrorResult3
});
var SignatureReceivedResult3 = literal("receivedSignature");
var VersionResult3 = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
var ParsedInstructionStruct3 = type({
  program: string(),
  programId: PublicKeyFromString3,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct3 = type({
  programId: PublicKeyFromString3,
  accounts: array(PublicKeyFromString3),
  data: string()
});
var SimulatedTransactionResponseStruct3 = jsonRpcResultAndContext3(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct3, PartiallyDecodedInstructionStruct3]))
  }))))
}));
var BlockProductionResponseStruct3 = jsonRpcResultAndContext3(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient2(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch3 = customFetch ? customFetch : fetchImpl3;
  let agent;
  {
    if (httpAgent != null) {
      console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init4) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init4, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch3(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new import_browser6.default(async (request2, callback) => {
    const options = {
      method: "POST",
      body: request2,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS2)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch3(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep3(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error) callback(err);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest2(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest2(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0) resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
var GetInflationGovernorRpcResult3 = jsonRpcResult3(GetInflationGovernorResult3);
var GetInflationRateRpcResult3 = jsonRpcResult3(GetInflationRateResult3);
var GetRecentPrioritizationFeesRpcResult3 = jsonRpcResult3(GetRecentPrioritizationFeesResult3);
var GetEpochInfoRpcResult3 = jsonRpcResult3(GetEpochInfoResult3);
var GetEpochScheduleRpcResult3 = jsonRpcResult3(GetEpochScheduleResult3);
var GetLeaderScheduleRpcResult3 = jsonRpcResult3(GetLeaderScheduleResult3);
var SlotRpcResult3 = jsonRpcResult3(number());
var GetSupplyRpcResult3 = jsonRpcResultAndContext3(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString3)
}));
var TokenAmountResult3 = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult3 = jsonRpcResultAndContext3(array(type({
  address: PublicKeyFromString3,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner3 = jsonRpcResultAndContext3(array(type({
  pubkey: PublicKeyFromString3,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString3,
    lamports: number(),
    data: BufferFromRawAccountData3,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult3 = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
var GetParsedTokenAccountsByOwner3 = jsonRpcResultAndContext3(array(type({
  pubkey: PublicKeyFromString3,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString3,
    lamports: number(),
    data: ParsedAccountDataResult3,
    rentEpoch: number()
  })
})));
var GetLargestAccountsRpcResult3 = jsonRpcResultAndContext3(array(type({
  lamports: number(),
  address: PublicKeyFromString3
})));
var AccountInfoResult3 = type({
  executable: boolean(),
  owner: PublicKeyFromString3,
  lamports: number(),
  data: BufferFromRawAccountData3,
  rentEpoch: number()
});
var KeyedAccountInfoResult3 = type({
  pubkey: PublicKeyFromString3,
  account: AccountInfoResult3
});
var ParsedOrRawAccountData3 = coerce(union([instance(import_buffer3.Buffer), ParsedAccountDataResult3]), union([RawAccountDataResult3, ParsedAccountDataResult3]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData3);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult3 = type({
  executable: boolean(),
  owner: PublicKeyFromString3,
  lamports: number(),
  data: ParsedOrRawAccountData3,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult3 = type({
  pubkey: PublicKeyFromString3,
  account: ParsedAccountInfoResult3
});
var StakeActivationResult3 = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
var GetConfirmedSignaturesForAddress2RpcResult3 = jsonRpcResult3(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult3,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var GetSignaturesForAddressRpcResult3 = jsonRpcResult3(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult3,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var AccountNotificationResult3 = type({
  subscription: number(),
  result: notificationResultAndContext3(AccountInfoResult3)
});
var ProgramAccountInfoResult3 = type({
  pubkey: PublicKeyFromString3,
  account: AccountInfoResult3
});
var ProgramAccountNotificationResult3 = type({
  subscription: number(),
  result: notificationResultAndContext3(ProgramAccountInfoResult3)
});
var SlotInfoResult3 = type({
  parent: number(),
  slot: number(),
  root: number()
});
var SlotNotificationResult3 = type({
  subscription: number(),
  result: SlotInfoResult3
});
var SlotUpdateResult3 = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
var SlotUpdateNotificationResult3 = type({
  subscription: number(),
  result: SlotUpdateResult3
});
var SignatureNotificationResult3 = type({
  subscription: number(),
  result: notificationResultAndContext3(union([SignatureStatusResult3, SignatureReceivedResult3]))
});
var RootNotificationResult3 = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult3 = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult3 = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
var GetVoteAccounts3 = jsonRpcResult3(type({
  current: array(VoteAccountInfoResult3),
  delinquent: array(VoteAccountInfoResult3)
}));
var ConfirmationStatus3 = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse3 = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult3,
  confirmationStatus: optional(ConfirmationStatus3)
});
var GetSignatureStatusesRpcResult3 = jsonRpcResultAndContext3(array(nullable(SignatureStatusResponse3)));
var GetMinimumBalanceForRentExemptionRpcResult3 = jsonRpcResult3(number());
var AddressTableLookupStruct3 = type({
  accountKey: PublicKeyFromString3,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult3 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct3))
  })
});
var AnnotatedAccountKey3 = type({
  pubkey: PublicKeyFromString3,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult3 = type({
  accountKeys: array(AnnotatedAccountKey3),
  signatures: array(string())
});
var ParsedInstructionResult3 = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString3
});
var RawInstructionResult3 = type({
  accounts: array(PublicKeyFromString3),
  data: string(),
  programId: PublicKeyFromString3
});
var InstructionResult3 = union([RawInstructionResult3, ParsedInstructionResult3]);
var UnknownInstructionResult3 = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction3 = coerce(InstructionResult3, UnknownInstructionResult3, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult3);
  } else {
    return create(value, ParsedInstructionResult3);
  }
});
var ParsedConfirmedTransactionResult3 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey3),
    instructions: array(ParsedOrRawInstruction3),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct3)))
  })
});
var TokenBalanceResult3 = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult3
});
var LoadedAddressesResult3 = type({
  writable: array(PublicKeyFromString3),
  readonly: array(PublicKeyFromString3)
});
var ConfirmedTransactionMetaResult3 = type({
  err: TransactionErrorResult3,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  loadedAddresses: optional(LoadedAddressesResult3),
  computeUnitsConsumed: optional(number())
});
var ParsedConfirmedTransactionMetaResult3 = type({
  err: TransactionErrorResult3,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction3)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  loadedAddresses: optional(LoadedAddressesResult3),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct3 = union([literal(0), literal("legacy")]);
var RewardsResult3 = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
var GetBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult3,
    meta: nullable(ConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetNoneModeBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetAccountsModeBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult3,
    meta: nullable(ConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult3,
    meta: nullable(ParsedConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedAccountsModeBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult3,
    meta: nullable(ParsedConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedNoneModeBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetConfirmedBlockRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult3,
    meta: nullable(ConfirmedTransactionMetaResult3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number())
})));
var GetBlockSignaturesRpcResult3 = jsonRpcResult3(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
var GetTransactionRpcResult3 = jsonRpcResult3(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult3),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult3,
  version: optional(TransactionVersionStruct3)
})));
var GetParsedTransactionRpcResult3 = jsonRpcResult3(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult3,
  meta: nullable(ParsedConfirmedTransactionMetaResult3),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct3)
})));
var GetLatestBlockhashRpcResult3 = jsonRpcResultAndContext3(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
var IsBlockhashValidRpcResult3 = jsonRpcResultAndContext3(boolean());
var PerfSampleResult3 = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
var GetRecentPerformanceSamplesRpcResult3 = jsonRpcResult3(array(PerfSampleResult3));
var GetFeeCalculatorRpcResult3 = jsonRpcResultAndContext3(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
var RequestAirdropRpcResult3 = jsonRpcResult3(string());
var SendTransactionRpcResult3 = jsonRpcResult3(string());
var LogsResult3 = type({
  err: TransactionErrorResult3,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult3 = type({
  result: notificationResultAndContext3(LogsResult3),
  subscription: number()
});
var COMMON_HTTP_HEADERS2 = {
  "solana-client": `js/${"1.0.0-maintenance"}`
};
var Connection2 = class {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint, _commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    this.getBlockHeight = /* @__PURE__ */ (() => {
      const requestPromises = {};
      return async (commitmentOrConfig) => {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig2(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const requestHash = fastStableStringify3(args);
        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
          try {
            const unsafeRes = await this._rpcRequest("getBlockHeight", args);
            const res = create(unsafeRes, jsonRpcResult3(number()));
            if ("error" in res) {
              throw new SolanaJSONRPCError2(res.error, "failed to get block height information");
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        })();
        return await requestPromises[requestHash];
      };
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch3;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch3 = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl2(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl2(endpoint);
    this._rpcClient = createRpcClient2(endpoint, httpHeaders, fetch3, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest2(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest2(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient2(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(publicKey5, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get balance for ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(publicKey5, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey5, commitmentOrConfig).then((x5) => x5.value).catch((e2) => {
      throw new Error("failed to get balance of account " + publicKey5.toBase58() + ": " + e2);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
    const res = create(unsafeRes, jsonRpcResult3(nullable(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get block time for slot ${slot}`);
    }
    return res.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
    const res = create(unsafeRes, jsonRpcResult3(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get minimum ledger slot");
    }
    return res.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
    const res = create(unsafeRes, SlotRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get first available block");
    }
    return res.result;
  }
  /**
   * Fetch information about the current supply
   */
  async getSupply(config) {
    let configArg = {};
    if (typeof config === "string") {
      configArg = {
        commitment: config
      };
    } else if (config) {
      configArg = {
        ...config,
        commitment: config && config.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
    const res = create(unsafeRes, GetSupplyRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get supply");
    }
    return res.result;
  }
  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenSupply", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(TokenAmountResult3));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get token supply");
    }
    return res.result;
  }
  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(TokenAmountResult3));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get token account balance");
    }
    return res.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */
  async getTokenAccountsByOwner(ownerAddress, filter10, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter10) {
      _args.push({
        mint: filter10.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter10.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetTokenAccountsByOwner3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(ownerAddress, filter10, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter10) {
      _args.push({
        mint: filter10.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter10.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetParsedTokenAccountsByOwner3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(config) {
    const arg = {
      ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
    const res = create(unsafeRes, GetLargestAccountsRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
    const res = create(unsafeRes, GetTokenLargestAccountsResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get token largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(publicKey5, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(nullable(AccountInfoResult3)));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get info about account ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(publicKey5, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(nullable(ParsedAccountInfoResult3)));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get info about account ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(publicKey5, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey5, commitmentOrConfig);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get info about account " + publicKey5.toBase58() + ": " + e2);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(rawConfig);
    const keys4 = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys4], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(array(nullable(ParsedAccountInfoResult3))));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get info for accounts ${keys4}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const keys4 = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys4], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(array(nullable(AccountInfoResult3))));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get info for accounts ${keys4}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   *
   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
   */
  async getStakeActivation(publicKey5, commitmentOrConfig, epoch) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([publicKey5.toBase58()], commitment, void 0, {
      ...config,
      epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
    });
    const unsafeRes = await this._rpcRequest("getStakeActivation", args);
    const res = create(unsafeRes, jsonRpcResult3(StakeActivationResult3));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get Stake Activation ${publicKey5.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(configOrCommitment);
    const {
      encoding,
      ...configWithoutEncoding
    } = config || {};
    const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
      ...configWithoutEncoding,
      ...configWithoutEncoding.filters ? {
        filters: applyDefaultMemcmpEncodingToFilters2(configWithoutEncoding.filters)
      } : null
    });
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const baseSchema = array(KeyedAccountInfoResult3);
    const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext3(baseSchema)) : create(unsafeRes, jsonRpcResult3(baseSchema));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(configOrCommitment);
    const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = create(unsafeRes, jsonRpcResult3(array(KeyedParsedAccountInfoResult3)));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(strategy, commitment) {
    var _a21;
    let rawSignature;
    if (typeof strategy == "string") {
      rawSignature = strategy;
    } else {
      const config = strategy;
      if ((_a21 = config.abortSignal) == null ? void 0 : _a21.aborted) {
        return Promise.reject(config.abortSignal.reason);
      }
      rawSignature = config.signature;
    }
    let decodedSignature;
    try {
      decodedSignature = import_bs586.default.decode(rawSignature);
    } catch (err) {
      throw new Error("signature must be base58 encoded: " + rawSignature);
    }
    assert6(decodedSignature.length === 64, "signature has invalid length");
    if (typeof strategy === "string") {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ("lastValidBlockHeight" in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }
  getCancellationPromise(signal) {
    return new Promise((_3, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature: signature4
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature4, (result, context) => {
          signatureSubscriptionId = void 0;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus3.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
              if (nextState === "subscribed") {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (async () => {
          await subscriptionSetupPromise;
          if (done) return;
          const response = await this.getSignatureStatus(signature4);
          if (done) return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value == null ? void 0 : value.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case "confirmed":
              case "single":
              case "singleGossip": {
                if (value.confirmationStatus === "processed") {
                  return;
                }
                break;
              }
              case "finalized":
              case "max":
              case "root": {
                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                  return;
                }
                break;
              }
              // exhaust enums to ensure full coverage
              case "processed":
              case "recent":
            }
            done = true;
            resolve({
              __type: TransactionStatus3.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = void 0;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = void 0;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature: signature4
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e6) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done) return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep3(1e3);
          if (done) return;
          currentBlockHeight = await checkBlockHeight();
          if (done) return;
        }
        resolve({
          __type: TransactionStatus3.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature4
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus3.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError3(signature4);
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature: signature4
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;
      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount == null ? void 0 : nonceAccount.nonce;
        } catch (e2) {
          return currentNonceValue;
        }
      };
      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done) return;
        while (true) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: TransactionStatus3.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }
          await sleep3(2e3);
          if (done) return;
          currentNonceValue = await getCurrentNonceValue();
          if (done) return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature4
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus3.PROCESSED) {
        result = outcome.response;
      } else {
        let signatureStatus;
        while (true) {
          const status = await this.getSignatureStatus(signature4);
          if (status == null) {
            break;
          }
          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep3(400);
            continue;
          }
          signatureStatus = status;
          break;
        }
        if (signatureStatus == null ? void 0 : signatureStatus.value) {
          const commitmentForStatus = commitment || "finalized";
          const {
            confirmationStatus
          } = signatureStatus.value;
          switch (commitmentForStatus) {
            case "processed":
            case "recent":
              if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError3(signature4);
              }
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError3(signature4);
              }
              break;
            case "finalized":
            case "max":
            case "root":
              if (confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError3(signature4);
              }
              break;
            default:
              /* @__PURE__ */ ((_3) => {
              })(commitmentForStatus);
          }
          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError3(signature4);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature: signature4
  }) {
    let timeoutId;
    const expiryPromise = new Promise((resolve) => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
      switch (commitment) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
          break;
        }
      }
      timeoutId = setTimeout(() => resolve({
        __type: TransactionStatus3.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature4
    });
    let result;
    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus3.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError3(signature4, outcome.timeoutMs / 1e3);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }
    return result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest("getClusterNodes", []);
    const res = create(unsafeRes, jsonRpcResult3(array(ContactInfoResult3)));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get cluster nodes");
    }
    return res.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
    const res = create(unsafeRes, GetVoteAccounts3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get vote accounts");
    }
    return res.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getSlot", args);
    const res = create(unsafeRes, jsonRpcResult3(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get slot");
    }
    return res.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getSlotLeader", args);
    const res = create(unsafeRes, jsonRpcResult3(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get slot leader");
    }
    return res.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(startSlot, limit2) {
    const args = [startSlot, limit2];
    const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
    const res = create(unsafeRes, jsonRpcResult3(array(PublicKeyFromString3)));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get slot leaders");
    }
    return res.result;
  }
  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(signature4, config) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature4], config);
    assert6(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(signatures, config) {
    const params = [signatures];
    if (config) {
      params.push(config);
    }
    const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
    const res = create(unsafeRes, GetSignatureStatusesRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get signature status");
    }
    return res.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getTransactionCount", args);
    const res = create(unsafeRes, jsonRpcResult3(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get transaction count");
    }
    return res.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
    const res = create(unsafeRes, GetInflationGovernorRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get inflation");
    }
    return res.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
      ...config,
      epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
    });
    const unsafeRes = await this._rpcRequest("getInflationReward", args);
    const res = create(unsafeRes, GetInflationRewardResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get inflation reward");
    }
    return res.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const unsafeRes = await this._rpcRequest("getInflationRate", []);
    const res = create(unsafeRes, GetInflationRateRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get inflation rate");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getEpochInfo", args);
    const res = create(unsafeRes, GetEpochInfoRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get epoch info");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
    const res = create(unsafeRes, GetEpochScheduleRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get epoch schedule");
    }
    const epochSchedule = res.result;
    return new EpochSchedule2(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
    const res = create(unsafeRes, GetLeaderScheduleRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get leader schedule");
    }
    return res.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);
    const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
    const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult3);
    if ("error" in res) {
      console.warn("Unable to fetch minimum balance for rent exemption");
      return 0;
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(commitment) {
    const {
      context,
      value: {
        blockhash
      }
    } = await this.getLatestBlockhashAndContext(commitment);
    const feeCalculator = {
      get lamportsPerSignature() {
        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
      },
      toJSON() {
        return {};
      }
    };
    return {
      context,
      value: {
        blockhash,
        feeCalculator
      }
    };
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(limit2) {
    const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit2 ? [limit2] : []);
    const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get recent performance samples");
    }
    return res.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
    const res = create(unsafeRes, GetFeeCalculatorRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get fee calculator");
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(message, commitment) {
    const wireMessage = toBuffer3(message.serialize()).toString("base64");
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(nullable(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get fee for message");
    }
    if (res.result === null) {
      throw new Error("invalid blockhash");
    }
    return res.result;
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(config) {
    var _a21;
    const accounts = (_a21 = config == null ? void 0 : config.lockedWritableAccounts) == null ? void 0 : _a21.map((key) => key.toBase58());
    const args = (accounts == null ? void 0 : accounts.length) ? [accounts] : [];
    const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
    const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get recent prioritization fees");
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get recent blockhash: " + e2);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get recent blockhash: " + e2);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
    const res = create(unsafeRes, GetLatestBlockhashRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get latest blockhash");
    }
    return res.result;
  }
  /**
   * Returns whether a blockhash is still valid or not
   */
  async isBlockhashValid(blockhash, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(rawConfig);
    const args = this._buildArgs([blockhash], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
    const res = create(unsafeRes, IsBlockhashValidRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
    }
    return res.result;
  }
  /**
   * Fetch the node version
   */
  async getVersion() {
    const unsafeRes = await this._rpcRequest("getVersion", []);
    const res = create(unsafeRes, jsonRpcResult3(VersionResult3));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get version");
    }
    return res.result;
  }
  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest("getGenesisHash", []);
    const res = create(unsafeRes, jsonRpcResult3(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get genesis hash");
    }
    return res.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config == null ? void 0 : config.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetAccountsModeBlockRpcResult3);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetNoneModeBlockRpcResult3);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetBlockRpcResult3);
          if ("error" in res) {
            throw res.error;
          }
          const {
            result
          } = res;
          return result ? {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta,
              version: version11
            }) => ({
              meta,
              transaction: {
                ...transaction,
                message: versionedMessageFromResponse2(version11, transaction.message)
              },
              version: version11
            }))
          } : null;
        }
      }
    } catch (e2) {
      throw new SolanaJSONRPCError2(e2, "failed to get confirmed block");
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config == null ? void 0 : config.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult3);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult3);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetParsedBlockRpcResult3);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
      }
    } catch (e2) {
      throw new SolanaJSONRPCError2(e2, "failed to get block");
    }
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;
    if (typeof configOrCommitment === "string") {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c6,
        ...rest
      } = configOrCommitment;
      commitment = c6;
      extra = rest;
    }
    const args = this._buildArgs([], commitment, "base64", extra);
    const unsafeRes = await this._rpcRequest("getBlockProduction", args);
    const res = create(unsafeRes, BlockProductionResponseStruct3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get block production information");
    }
    return res.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(signature4, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result) return result;
    return {
      ...result,
      transaction: {
        ...result.transaction,
        message: versionedMessageFromResponse2(result.version, result.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(signature4, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const batch = signatures.map((signature4) => {
      const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed", config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult3);
      if ("error" in res2) {
        throw new SolanaJSONRPCError2(res2.error, "failed to get transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const batch = signatures.map((signature4) => {
      const args = this._buildArgsAtLeastConfirmed([signature4], commitment, void 0, config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetTransactionRpcResult3);
      if ("error" in res2) {
        throw new SolanaJSONRPCError2(res2.error, "failed to get transactions");
      }
      const result = res2.result;
      if (!result) return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse2(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetConfirmedBlockRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    const block = {
      ...result,
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message3(transaction.message);
        return {
          meta,
          transaction: {
            ...transaction,
            message
          }
        };
      })
    };
    return {
      ...block,
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction4.populate(transaction.message, transaction.signatures)
        };
      })
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest("getBlocks", args);
    const res = create(unsafeRes, jsonRpcResult3(array(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get blocks");
    }
    return res.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(signature4, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result) return result;
    const message = new Message3(result.transaction.message);
    const signatures = result.transaction.signatures;
    return {
      ...result,
      transaction: Transaction4.populate(message, signatures)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(signature4, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get confirmed transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map((signature4) => {
      const args = this._buildArgsAtLeastConfirmed([signature4], commitment, "jsonParsed");
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult3);
      if ("error" in res2) {
        throw new SolanaJSONRPCError2(res2.error, "failed to get confirmed transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!("until" in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot("finalized");
    while (!("before" in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map((info) => info.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
   */
  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
    const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get confirmed signatures for address");
    }
    return res.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
    const res = create(unsafeRes, GetSignaturesForAddressRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, "failed to get signatures for address");
    }
    return res.result;
  }
  async getAddressLookupTable(accountKey, config) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config);
    let value = null;
    if (accountInfo !== null) {
      value = new AddressLookupTableAccount2({
        key: accountKey,
        state: AddressLookupTableAccount2.deserialize(accountInfo.data)
      });
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount2.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x5) => x5.value).catch((e2) => {
      throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e2);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(to5, lamports) {
    const unsafeRes = await this._rpcRequest("requestAirdrop", [to5.toBase58(), lamports]);
    const res = create(unsafeRes, RequestAirdropRpcResult3);
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `airdrop to ${to5.toBase58()} failed`);
    }
    return res.result;
  }
  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      while (this._pollingBlockhash) {
        await sleep3(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS3;
      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
      for (let i4 = 0; i4 < 50; i4++) {
        const latestBlockhash = await this.getLatestBlockhash("finalized");
        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        }
        await sleep3(MS_PER_SLOT3 / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(config) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig2(config);
    const args = this._buildArgs([], commitment, "base64", configArg);
    const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
    const res = create(unsafeRes, jsonRpcResultAndContext3(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError2(res.error, `failed to get stake minimum delegation`);
    }
    return res.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ("message" in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction2 = versionedTx.serialize();
      const encodedTransaction2 = import_buffer3.Buffer.from(wireTransaction2).toString("base64");
      if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
        throw new Error("Invalid arguments");
      }
      const config2 = configOrSigners || {};
      config2.encoding = "base64";
      if (!("commitment" in config2)) {
        config2.commitment = this.commitment;
      }
      if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
        config2.innerInstructions = configOrSigners.innerInstructions;
      }
      const args2 = [encodedTransaction2, config2];
      const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
      const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct3);
      if ("error" in res2) {
        throw new Error("failed to simulate transaction: " + res2.error.message);
      }
      return res2.result;
    }
    let transaction;
    if (transactionOrMessage instanceof Transaction4) {
      let originalTx = transactionOrMessage;
      transaction = new Transaction4();
      transaction.feePayer = originalTx.feePayer;
      transaction.instructions = transactionOrMessage.instructions;
      transaction.nonceInfo = originalTx.nonceInfo;
      transaction.signatures = originalTx.signatures;
    } else {
      transaction = Transaction4.populate(transactionOrMessage);
      transaction._message = transaction._json = void 0;
    }
    if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
      throw new Error("Invalid arguments");
    }
    const signers = configOrSigners;
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        if (!signers) break;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature4 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(signature4) && !this._blockhashInfo.transactionSignatures.includes(signature4)) {
          this._blockhashInfo.simulatedSignatures.push(signature4);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config.sigVerify = true;
    }
    if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
      config.innerInstructions = configOrSigners.innerInstructions;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct3);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError3({
        action: "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Send a signed transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(transaction, signersOrOptions, options) {
    if ("version" in transaction) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const wireTransaction2 = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
    }
    if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
      throw new Error("Invalid arguments");
    }
    const signers = signersOrOptions;
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature4 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.transactionSignatures.includes(signature4)) {
          this._blockhashInfo.transactionSignatures.push(signature4);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer3(rawTransaction).toString("base64");
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: "base64"
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries != null) {
      config.maxRetries = options.maxRetries;
    }
    if (options && options.minContextSlot != null) {
      config.minContextSlot = options.minContextSlot;
    }
    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("sendTransaction", args);
    const res = create(unsafeRes, SendTransactionRpcResult3);
    if ("error" in res) {
      let logs = void 0;
      if ("data" in res.error) {
        logs = res.error.data.logs;
      }
      throw new SendTransactionError3({
        action: skipPreflight ? "send" : "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5e3);
    this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error("ws error:", err.message);
  }
  /**
   * @internal
   */
  _wsOnClose(code2) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code2 === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
      this._setSubscription(hash, {
        ...subscription,
        state: "pending"
      });
    });
  }
  /**
   * @internal
   */
  _setSubscription(hash, nextSubscription) {
    var _a21;
    const prevState = (_a21 = this._subscriptionsByHash[hash]) == null ? void 0 : _a21.state;
    this._subscriptionsByHash[hash] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach((cb) => {
          try {
            cb(nextSubscription.state);
          } catch {
          }
        });
      }
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _a21;
    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash == null) {
      return () => {
      };
    }
    const stateChangeCallbacks = (_a21 = this._subscriptionStateChangeCallbacksByHash)[hash] || (_a21[hash] = /* @__PURE__ */ new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash];
      }
    };
  }
  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };
    await Promise.all(
      // Don't be tempted to change this to `Object.entries`. We call
      // `_updateSubscriptions` recursively when processing the state,
      // so it's important that we look up the *current* version of
      // each subscription, every time we process a hash.
      Object.keys(this._subscriptionsByHash).map(async (hash) => {
        const subscription = this._subscriptionsByHash[hash];
        if (subscription === void 0) {
          return;
        }
        switch (subscription.state) {
          case "pending":
          case "unsubscribed":
            if (subscription.callbacks.size === 0) {
              delete this._subscriptionsByHash[hash];
              if (subscription.state === "unsubscribed") {
                delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
              }
              await this._updateSubscriptions();
              return;
            }
            await (async () => {
              const {
                args,
                method
              } = subscription;
              try {
                this._setSubscription(hash, {
                  ...subscription,
                  state: "subscribing"
                });
                const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                this._setSubscription(hash, {
                  ...subscription,
                  serverSubscriptionId,
                  state: "subscribed"
                });
                this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                await this._updateSubscriptions();
              } catch (e2) {
                console.error(`Received ${e2 instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                  args,
                  error: e2
                });
                if (!isCurrentConnectionStillActive()) {
                  return;
                }
                this._setSubscription(hash, {
                  ...subscription,
                  state: "pending"
                });
                await this._updateSubscriptions();
              }
            })();
            break;
          case "subscribed":
            if (subscription.callbacks.size === 0) {
              await (async () => {
                const {
                  serverSubscriptionId,
                  unsubscribeMethod
                } = subscription;
                if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                  this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                } else {
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                  } catch (e2) {
                    if (e2 instanceof Error) {
                      console.error(`${unsubscribeMethod} error:`, e2.message);
                    }
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash, {
                      ...subscription,
                      state: "subscribed"
                    });
                    await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(hash, {
                  ...subscription,
                  state: "unsubscribed"
                });
                await this._updateSubscriptions();
              })();
            }
            break;
        }
      })
    );
  }
  /**
   * @internal
   */
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === void 0) {
      return;
    }
    callbacks.forEach((cb) => {
      try {
        cb(
          ...callbackArgs
        );
      } catch (e2) {
        console.error(e2);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, AccountNotificationResult3);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(subscriptionConfig, args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash = fastStableStringify3([subscriptionConfig.method, args]);
    const existingSubscription = this._subscriptionsByHash[hash];
    if (existingSubscription === void 0) {
      this._subscriptionsByHash[hash] = {
        ...subscriptionConfig,
        args,
        callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
        state: "pending"
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash];
      assert6(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };
    this._updateSubscriptions();
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onAccountChange(publicKey5, callback, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs(
      [publicKey5.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config
    );
    return this._makeSubscription({
      callback,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, ProgramAccountNotificationResult3);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig2(commitmentOrConfig);
    const args = this._buildArgs(
      [programId.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config ? config : maybeFilters ? {
        filters: applyDefaultMemcmpEncodingToFilters2(maybeFilters)
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(filter10, callback, commitment) {
    const args = this._buildArgs(
      [typeof filter10 === "object" ? {
        mentions: [filter10.toString()]
      } : filter10],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, args);
  }
  /**
   * Deregister a logs callback.
   *
   * @param clientSubscriptionId client subscription id to deregister.
   */
  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, LogsNotificationResult3);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotNotificationResult3);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotUpdateNotificationResult3);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
  }
  /**
   * @internal
   */
  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose2 = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    if (dispose2) {
      await dispose2();
    } else {
      console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
    }
  }
  _buildArgs(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding || extra) {
      let options = {};
      if (encoding) {
        options.encoding = encoding;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args, override, encoding, extra);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SignatureNotificationResult3);
    if (result.value !== "receivedSignature") {
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
      type: "received"
    }, result.context] : [{
      type: "status",
      result: result.value
    }, result.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(signature4, callback, commitment) {
    const args = this._buildArgs(
      [signature4],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(signature4, callback, options) {
    const {
      commitment,
      ...extra
    } = {
      ...options,
      commitment: options && options.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    };
    const args = this._buildArgs([signature4], commitment, void 0, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        try {
          this.removeSignatureListener(clientSubscriptionId);
        } catch (_err) {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
  }
  /**
   * @internal
   */
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, RootNotificationResult3);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
  }
};
var Keypair3 = class _Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair3();
  }
  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  static generate() {
    return new _Keypair(generateKeypair3());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey5 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey3(privateScalar);
      for (let ii3 = 0; ii3 < 32; ii3++) {
        if (publicKey5[ii3] !== computedPublicKey[ii3]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */
  static fromSeed(seed) {
    const publicKey5 = getPublicKey3(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey5, 32);
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */
  get publicKey() {
    return new PublicKey4(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
};
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS3 = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u644("recentSlot"), BufferLayout3.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u644(), BufferLayout3.seq(publicKey3(), BufferLayout3.offset(BufferLayout3.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  }
});
var AddressLookupTableProgram3 = class {
  /**
   * @internal
   */
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey4.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder3().encode(params.recentSlot)], this.programId);
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.CreateLookupTable;
    const data = encodeData5(type3, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys4 = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram3.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction3({
      programId: this.programId,
      keys: keys4,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.FreezeLookupTable;
    const data = encodeData5(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction3({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static extendLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.ExtendLookupTable;
    const data = encodeData5(type3, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys4.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram3.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction3({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.DeactivateLookupTable;
    const data = encodeData5(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction3({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static closeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.CloseLookupTable;
    const data = encodeData5(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction3({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
};
AddressLookupTableProgram3.programId = new PublicKey4("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3 = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), BufferLayout3.u32("units"), BufferLayout3.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), BufferLayout3.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), BufferLayout3.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), u644("microLamports")])
  }
});
var ComputeBudgetProgram3 = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.RequestUnits;
    const data = encodeData5(type3, params);
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.RequestHeapFrame;
    const data = encodeData5(type3, params);
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.SetComputeUnitLimit;
    const data = encodeData5(type3, params);
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.SetComputeUnitPrice;
    const data = encodeData5(type3, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
};
ComputeBudgetProgram3.programId = new PublicKey4("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$13 = 64;
var PUBLIC_KEY_BYTES$13 = 32;
var SIGNATURE_BYTES3 = 64;
var ED25519_INSTRUCTION_LAYOUT3 = BufferLayout3.struct([BufferLayout3.u8("numSignatures"), BufferLayout3.u8("padding"), BufferLayout3.u16("signatureOffset"), BufferLayout3.u16("signatureInstructionIndex"), BufferLayout3.u16("publicKeyOffset"), BufferLayout3.u16("publicKeyInstructionIndex"), BufferLayout3.u16("messageDataOffset"), BufferLayout3.u16("messageDataSize"), BufferLayout3.u16("messageInstructionIndex")]);
var Ed25519Program3 = class _Ed25519Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the ed25519 program
   */
  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      instructionIndex
    } = params;
    assert6(publicKey5.length === PUBLIC_KEY_BYTES$13, `Public Key must be ${PUBLIC_KEY_BYTES$13} bytes but received ${publicKey5.length} bytes`);
    assert6(signature4.length === SIGNATURE_BYTES3, `Signature must be ${SIGNATURE_BYTES3} bytes but received ${signature4.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT3.span;
    const signatureOffset = publicKeyOffset + publicKey5.length;
    const messageDataOffset = signatureOffset + signature4.length;
    const numSignatures = 1;
    const instructionData = import_buffer3.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT3.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey5, publicKeyOffset);
    instructionData.fill(signature4, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction3({
      keys: [],
      programId: _Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert6(privateKey.length === PRIVATE_KEY_BYTES$13, `Private key must be ${PRIVATE_KEY_BYTES$13} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair3.fromSecretKey(privateKey);
      const publicKey5 = keypair.publicKey.toBytes();
      const signature4 = sign3(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program3.programId = new PublicKey4("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign3 = (msgHash, privKey) => {
  const signature4 = secp256k15.sign(msgHash, privKey);
  return [signature4.toCompactRawBytes(), signature4.recovery];
};
secp256k15.utils.isValidPrivateKey;
var publicKeyCreate3 = secp256k15.getPublicKey;
var PRIVATE_KEY_BYTES3 = 32;
var ETHEREUM_ADDRESS_BYTES3 = 20;
var PUBLIC_KEY_BYTES3 = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE3 = 11;
var SECP256K1_INSTRUCTION_LAYOUT3 = BufferLayout3.struct([BufferLayout3.u8("numSignatures"), BufferLayout3.u16("signatureOffset"), BufferLayout3.u8("signatureInstructionIndex"), BufferLayout3.u16("ethAddressOffset"), BufferLayout3.u8("ethAddressInstructionIndex"), BufferLayout3.u16("messageDataOffset"), BufferLayout3.u16("messageDataSize"), BufferLayout3.u8("messageInstructionIndex"), BufferLayout3.blob(20, "ethAddress"), BufferLayout3.blob(64, "signature"), BufferLayout3.u8("recoveryId")]);
var Secp256k1Program3 = class _Secp256k1Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the secp256k1 program
   */
  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey5) {
    assert6(publicKey5.length === PUBLIC_KEY_BYTES3, `Public key must be ${PUBLIC_KEY_BYTES3} bytes but received ${publicKey5.length} bytes`);
    try {
      return import_buffer3.Buffer.from(keccak_2562(toBuffer3(publicKey5))).slice(-ETHEREUM_ADDRESS_BYTES3);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    } = params;
    return _Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey5),
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress3;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress3 = import_buffer3.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress3 = import_buffer3.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress3 = rawAddress;
    }
    assert6(ethAddress3.length === ETHEREUM_ADDRESS_BYTES3, `Address must be ${ETHEREUM_ADDRESS_BYTES3} bytes but received ${ethAddress3.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE3;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress3.length;
    const messageDataOffset = signatureOffset + signature4.length + 1;
    const numSignatures = 1;
    const instructionData = import_buffer3.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT3.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT3.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer3(signature4),
      ethAddress: toBuffer3(ethAddress3),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer3(message), SECP256K1_INSTRUCTION_LAYOUT3.span);
    return new TransactionInstruction3({
      keys: [],
      programId: _Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert6(pkey.length === PRIVATE_KEY_BYTES3, `Private key must be ${PRIVATE_KEY_BYTES3} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer3(pkey);
      const publicKey5 = publicKeyCreate3(
        privateKey,
        false
        /* isCompressed */
      ).slice(1);
      const messageHash = import_buffer3.Buffer.from(keccak_2562(toBuffer3(message)));
      const [signature4, recoveryId] = ecdsaSign3(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program3.programId = new PublicKey4("KeccakSecp256k11111111111111111111111111111");
var _Lockup3;
var STAKE_CONFIG_ID3 = new PublicKey4("StakeConfig11111111111111111111111111111111");
var Lockup3 = class {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
_Lockup3 = Lockup3;
Lockup3.default = new _Lockup3(0, 0, PublicKey4.default);
var STAKE_INSTRUCTION_LAYOUTS3 = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), authorized3(), lockup3()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("newAuthorized"), BufferLayout3.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("newAuthorized"), BufferLayout3.u32("stakeAuthorizationType"), rustString3("authoritySeed"), publicKey3("authorityOwner")])
  }
});
var StakeAuthorizationLayout3 = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram3 = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Stake program
   */
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: maybeLockup
    } = params;
    const lockup5 = maybeLockup || Lockup3.default;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Initialize;
    const data = encodeData5(type3, {
      authorized: {
        staker: toBuffer3(authorized5.staker.toBuffer()),
        withdrawer: toBuffer3(authorized5.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup5.unixTimestamp,
        epoch: lockup5.epoch,
        custodian: toBuffer3(lockup5.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction4();
    transaction.add(SystemProgram3.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction4();
    transaction.add(SystemProgram3.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Delegate;
    const data = encodeData5(type3);
    return new Transaction4().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Authorize;
    const data = encodeData5(type3, {
      newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.AuthorizeWithSeed;
    const data = encodeData5(type3, {
      newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer3(authorityOwner.toBuffer())
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Split;
    const data = encodeData5(type3, {
      lamports
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params, rentExemptReserve) {
    const transaction = new Transaction4();
    transaction.add(SystemProgram3.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction4();
    transaction.add(SystemProgram3.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram3.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Merge;
    const data = encodeData5(type3);
    return new Transaction4().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Withdraw;
    const data = encodeData5(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS3.Deactivate;
    const data = encodeData5(type3);
    return new Transaction4().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram3.programId = new PublicKey4("Stake11111111111111111111111111111111111111");
StakeProgram3.space = 200;
var VOTE_INSTRUCTION_LAYOUTS3 = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), voteInit3()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey3("newAuthorized"), BufferLayout3.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), voteAuthorizeWithSeedArgs3()])
  }
});
var VoteAuthorizationLayout3 = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var VoteProgram3 = class _VoteProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Vote program
   */
  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit5
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS3.InitializeAccount;
    const data = encodeData5(type3, {
      voteInit: {
        nodePubkey: toBuffer3(voteInit5.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer3(voteInit5.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer3(voteInit5.authorizedWithdrawer.toBuffer()),
        commission: voteInit5.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction4();
    transaction.add(SystemProgram3.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS3.Authorize;
    const data = encodeData5(type3, {
      newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS3.AuthorizeWithSeed;
    const data = encodeData5(type3, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer3(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS3.Withdraw;
    const data = encodeData5(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return _VoteProgram.withdraw(params);
  }
  /**
   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
   */
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS3.UpdateValidatorIdentity;
    const data = encodeData5(type3);
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
VoteProgram3.programId = new PublicKey4("Vote111111111111111111111111111111111111111");
VoteProgram3.space = 3762;
var VALIDATOR_INFO_KEY3 = new PublicKey4("Va1idator1nfo111111111111111111111111111111");
var InfoString3 = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID3 = new PublicKey4("Vote111111111111111111111111111111111111111");
var VoteAccountLayout3 = BufferLayout3.struct([
  publicKey3("nodePubkey"),
  publicKey3("authorizedWithdrawer"),
  BufferLayout3.u8("commission"),
  BufferLayout3.nu64(),
  // votes.length
  BufferLayout3.seq(BufferLayout3.struct([BufferLayout3.nu64("slot"), BufferLayout3.u32("confirmationCount")]), BufferLayout3.offset(BufferLayout3.u32(), -8), "votes"),
  BufferLayout3.u8("rootSlotValid"),
  BufferLayout3.nu64("rootSlot"),
  BufferLayout3.nu64(),
  // authorizedVoters.length
  BufferLayout3.seq(BufferLayout3.struct([BufferLayout3.nu64("epoch"), publicKey3("authorizedVoter")]), BufferLayout3.offset(BufferLayout3.u32(), -8), "authorizedVoters"),
  BufferLayout3.struct([BufferLayout3.seq(BufferLayout3.struct([publicKey3("authorizedPubkey"), BufferLayout3.nu64("epochOfLastAuthorizedSwitch"), BufferLayout3.nu64("targetEpoch")]), 32, "buf"), BufferLayout3.nu64("idx"), BufferLayout3.u8("isEmpty")], "priorVoters"),
  BufferLayout3.nu64(),
  // epochCredits.length
  BufferLayout3.seq(BufferLayout3.struct([BufferLayout3.nu64("epoch"), BufferLayout3.nu64("credits"), BufferLayout3.nu64("prevCredits")]), BufferLayout3.offset(BufferLayout3.u32(), -8), "epochCredits"),
  BufferLayout3.struct([BufferLayout3.nu64("slot"), BufferLayout3.nu64("timestamp")], "lastTimestamp")
]);
var LAMPORTS_PER_SOL2 = 1e9;

// node_modules/@turnkey/solana/dist/index.mjs
var TurnkeySigner = class {
  constructor(input) {
    this.organizationId = input.organizationId;
    this.client = input.client;
  }
  /**
   * This function takes an array of Solana transactions and adds a signature with Turnkey to each of them
   *
   * @param txs array of Transaction | VersionedTransaction (native @solana/web3.js type)
   * @param fromAddress Solana address (base58 encoded)
   */
  async signAllTransactions(txs, fromAddress, organizationId) {
    var _a21, _b;
    const fromKey = new PublicKey(fromAddress);
    let messages = txs.map((tx) => this.getMessageToSign(tx).toString("hex"));
    const signRawPayloadsResult = await this.signRawPayloads(messages, fromAddress, organizationId);
    const signatures = (_a21 = signRawPayloadsResult == null ? void 0 : signRawPayloadsResult.signatures) == null ? void 0 : _a21.map((sig) => `${sig == null ? void 0 : sig.r}${sig == null ? void 0 : sig.s}`);
    for (let i4 in txs) {
      (_b = txs[i4]) == null ? void 0 : _b.addSignature(fromKey, Buffer.from(signatures[i4], "hex"));
    }
    return txs;
  }
  /**
   * This function takes a Solana transaction and adds a signature with Turnkey
   *
   * @param tx Transaction | VersionedTransaction object (native @solana/web3.js type)
   * @param fromAddress Solana address (base58 encoded)
   */
  async addSignature(tx, fromAddress, organizationId) {
    const fromKey = new PublicKey(fromAddress);
    const messageToSign = this.getMessageToSign(tx);
    const signRawPayloadResult = await this.signRawPayload(messageToSign.toString("hex"), fromAddress, organizationId ?? this.organizationId);
    const signature4 = `${signRawPayloadResult == null ? void 0 : signRawPayloadResult.r}${signRawPayloadResult == null ? void 0 : signRawPayloadResult.s}`;
    tx.addSignature(fromKey, Buffer.from(signature4, "hex"));
  }
  /**
   * This function takes a message and returns it after being signed with Turnkey
   *
   * @param message The message to sign (Uint8Array)
   * @param fromAddress Solana address (base58 encoded)
   */
  async signMessage(message, fromAddress, organizationId) {
    const signRawPayloadResult = await this.signRawPayload(Buffer.from(message).toString("hex"), fromAddress, organizationId);
    return Buffer.from(`${signRawPayloadResult == null ? void 0 : signRawPayloadResult.r}${signRawPayloadResult == null ? void 0 : signRawPayloadResult.s}`, "hex");
  }
  /**
   * This function takes a Solana transaction, adds a signature via Turnkey,
   * and returns a new transaction
   *
   * @param tx Transaction | VersionedTransaction object (native @solana/web3.js type)
   * @param fromAddress Solana address (base58 encoded)
   */
  async signTransaction(tx, fromAddress, organizationId) {
    const payloadToSign = Buffer.from(tx.serialize({
      requireAllSignatures: false,
      verifySignatures: false
    })).toString("hex");
    const signedTransaction = await this.signTransactionImpl(payloadToSign, fromAddress, organizationId);
    const decodedTransaction = Buffer.from(signedTransaction, "hex");
    const recoveredTransaction = "version" in tx ? VersionedTransaction.deserialize(decodedTransaction) : Transaction.from(decodedTransaction);
    return recoveredTransaction;
  }
  async signTransactionImpl(unsignedTransaction, signWith, organizationId) {
    var _a21, _b;
    if (isHttpClient(this.client)) {
      const response = await this.client.signTransaction({
        type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
        organizationId: organizationId ?? this.organizationId,
        timestampMs: String(Date.now()),
        parameters: {
          signWith,
          unsignedTransaction,
          type: "TRANSACTION_TYPE_SOLANA"
        }
      });
      const { activity } = response;
      assertActivityCompleted(activity);
      return assertNonNull((_b = (_a21 = activity == null ? void 0 : activity.result) == null ? void 0 : _a21.signTransactionResult) == null ? void 0 : _b.signedTransaction);
    } else {
      const { activity, signedTransaction } = await this.client.signTransaction({
        ...organizationId !== void 0 && { organizationId },
        signWith,
        unsignedTransaction,
        type: "TRANSACTION_TYPE_SOLANA"
      });
      assertActivityCompleted(activity);
      return assertNonNull(signedTransaction);
    }
  }
  async signRawPayload(payload, signWith, organizationId) {
    var _a21;
    if (isHttpClient(this.client)) {
      const response = await this.client.signRawPayload({
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
        organizationId: organizationId ?? this.organizationId,
        timestampMs: String(Date.now()),
        parameters: {
          signWith,
          payload,
          encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
          // Note: unlike ECDSA, EdDSA's API does not support signing raw digests (see RFC 8032).
          // Turnkey's signer requires an explicit value to be passed here to minimize ambiguity.
          hashFunction: "HASH_FUNCTION_NOT_APPLICABLE"
        }
      });
      const { activity } = response;
      assertActivityCompleted(activity);
      return assertNonNull((_a21 = activity == null ? void 0 : activity.result) == null ? void 0 : _a21.signRawPayloadResult);
    } else {
      const { activity, r: r3, s: s3, v: v6 } = await this.client.signRawPayload({
        ...organizationId !== void 0 && { organizationId },
        signWith,
        payload,
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        // Note: unlike ECDSA, EdDSA's API does not support signing raw digests (see RFC 8032).
        // Turnkey's signer requires an explicit value to be passed here to minimize ambiguity.
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE"
      });
      assertActivityCompleted(activity);
      return assertNonNull({
        r: r3,
        s: s3,
        v: v6
      });
    }
  }
  async signRawPayloads(payloads, signWith, organizationId) {
    var _a21;
    if (isHttpClient(this.client)) {
      const response = await this.client.signRawPayloads({
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS",
        organizationId: organizationId ?? this.organizationId,
        timestampMs: String(Date.now()),
        parameters: {
          signWith,
          payloads,
          encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
          // Note: unlike ECDSA, EdDSA's API does not support signing raw digests (see RFC 8032).
          // Turnkey's signer requires an explicit value to be passed here to minimize ambiguity.
          hashFunction: "HASH_FUNCTION_NOT_APPLICABLE"
        }
      });
      const { activity } = response;
      assertActivityCompleted(activity);
      return assertNonNull((_a21 = activity == null ? void 0 : activity.result) == null ? void 0 : _a21.signRawPayloadsResult);
    } else {
      const { activity, signatures } = await this.client.signRawPayloads({
        ...organizationId !== void 0 && { organizationId },
        signWith,
        payloads,
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        // Note: unlike ECDSA, EdDSA's API does not support signing raw digests (see RFC 8032).
        // Turnkey's signer requires an explicit value to be passed here to minimize ambiguity.
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE"
      });
      assertActivityCompleted(activity);
      return assertNonNull({
        signatures
      });
    }
  }
  getMessageToSign(tx) {
    let messageToSign;
    if (typeof tx.serializeMessage === "function") {
      messageToSign = tx.serializeMessage();
    } else {
      messageToSign = Buffer.from(tx.message.serialize());
    }
    return messageToSign;
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/src/lib/utils/createSolanaConnection/createSolanaConnection.js
var createSolanaConnection = (rpcUrl, commitmentOrConfig) => {
  if (!rpcUrl)
    throw new Error("rpcUrl is required");
  return new Connection2(rpcUrl, commitmentOrConfig);
};

// node_modules/@dynamic-labs/embedded-wallet-solana/src/lib/utils/api/api.js
var serializeTransaction3 = (transaction) => {
  if (transaction instanceof VersionedTransaction4) {
    return Buffer.from(transaction.serialize()).toString("base64");
  } else {
    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString("base64");
  }
};
var deserializeTransaction = (serializedTransaction) => {
  const transactionBuffer = Buffer.from(serializedTransaction, "base64");
  return VersionedTransaction4.deserialize(transactionBuffer);
};
var optimizeSolanaTransaction = (environmentId, transaction, address) => __awaiter8(void 0, void 0, void 0, function* () {
  const serializedTransaction = serializeTransaction3(transaction);
  const request2 = {
    environmentId,
    solanaTransactionOptimizationRequest: {
      address,
      transaction: serializedTransaction
    }
  };
  const response = yield createApiClient({}, getDefaultClient()).optimizeTransaction(request2);
  const optimizedTransaction = deserializeTransaction(response.transaction);
  return optimizedTransaction;
});

// node_modules/@dynamic-labs/embedded-wallet-solana/src/lib/TurnkeySolanaWalletConnector/TurnkeySolanaSigner.js
var TurnkeySolanaSigner = class {
  constructor({ walletConnector }) {
    this.isConnected = true;
    this.providers = [this];
    this.walletConnector = walletConnector;
    this.turnkeyAddress = this.walletConnector.turnkeyAddress;
    this.publicKey = this.turnkeyAddress ? new PublicKey4(this.turnkeyAddress) : void 0;
  }
  signMessage(encodedMessage) {
    return __awaiter8(this, void 0, void 0, function* () {
      const signedMessage = yield this.walletConnector.signUint8ArrayMessage(encodedMessage);
      return { signature: signedMessage };
    });
  }
  signTransaction(transaction) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this.walletConnector.signTransaction(transaction);
    });
  }
  signAllTransactions(transactions) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this.walletConnector.signAllTransactions(transactions);
    });
  }
  signAndSendTransaction(transaction, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      const signature4 = yield this.walletConnector.signAndSendTransaction(transaction, options);
      return { signature: signature4 };
    });
  }
  connect(_args) {
    return __awaiter8(this, void 0, void 0, function* () {
      return { address: this.turnkeyAddress, publicKey: this.publicKey };
    });
  }
  disconnect() {
    return __awaiter8(this, void 0, void 0, function* () {
      return;
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/src/lib/TurnkeySolanaWalletConnector/TurnkeySolanaWalletConnector.js
var TurnkeySolanaWalletConnector = class extends TurnkeyWalletConnectorBase {
  constructor(nameAndKey, props) {
    var _a21;
    super(nameAndKey, props);
    this.ChainWallet = SolanaWallet;
    this.connectedChain = "SOL";
    this.supportedChains = ["SOL"];
    this.verifiedCredentialChain = "solana";
    this.getEnvId = () => {
      const dynamicNonce = localStorage.getItem("dynamic_nonce");
      if (dynamicNonce) {
        const parsed = JSON.parse(dynamicNonce);
        if (parsed && parsed.environmentId) {
          return parsed.environmentId;
        }
      }
      const dynamicNonceDemo = localStorage.getItem("dynamic_nonce_demo");
      if (dynamicNonceDemo) {
        const parsed = JSON.parse(dynamicNonceDemo);
        if (parsed && parsed.environmentId) {
          return parsed.environmentId;
        }
      }
      throw new Error("Failed to get environment id");
    };
    this.solNetworks = getBackwardsCompatibleSolNetworks(props.solNetworks, props.connectionConfig);
    this.walletUiUtils = props.walletUiUtils;
    this._turnkeyAccount = void 0;
    this.connectionConfig = props.connectionConfig;
    this.chainRpcProviders = props.chainRpcProviders;
    (_a21 = this.chainRpcProviders) === null || _a21 === void 0 ? void 0 : _a21.registerSolanaProviders(this.connectionConfig);
    this.getTurnkeyClient().then((client) => {
      this.__turnkeyClient = client;
    });
  }
  getRpcUrl() {
    const network = this.getSelectedNetwork();
    if (!network) {
      throw new DynamicError("No enabled networks");
    }
    return getOverrideRpcUrlForNetwork(this.connectionConfig, network);
  }
  getConnection(commitmentOrConfig) {
    const rpcUrl = this.getRpcUrl();
    if (!rpcUrl)
      throw new DynamicError("No rpcUrl");
    const config = typeof commitmentOrConfig === "string" ? Object.assign(Object.assign({}, this.connectionConfig), { commitment: commitmentOrConfig }) : Object.assign(Object.assign({}, this.connectionConfig), commitmentOrConfig);
    return createSolanaConnection(rpcUrl, config);
  }
  getWalletClient() {
    return this.getConnection();
  }
  getNetworkId() {
    var _a21;
    const defaultChainId = (_a21 = this.solNetworks[0]) === null || _a21 === void 0 ? void 0 : _a21.networkId.toString();
    const storedChainId = localStorage.getItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY);
    return storedChainId !== null && storedChainId !== void 0 ? storedChainId : defaultChainId;
  }
  setNetworkId(networkId) {
    if (!networkId) {
      localStorage.removeItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY);
    } else {
      localStorage.setItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY, networkId);
    }
  }
  getSelectedNetwork() {
    const selectedNetwork = this.solNetworks.find((network) => network.networkId.toString() === this.getNetworkId());
    return selectedNetwork;
  }
  /**
   * @param returnDynamicNetworkId - If true, the dynamic network ID will be returned instead of the network cluster
   * @returns The network cluster (e.g. 'mainnet', 'testnet', 'devnet') or dynamic network (used for switching networks)
   */
  getNetwork() {
    return __awaiter8(this, arguments, void 0, function* (returnDynamicNetworkId = false) {
      const network = this.getSelectedNetwork();
      if (!network) {
        return "";
      }
      const { networkId, genesisHash } = network;
      if (returnDynamicNetworkId) {
        return networkId.toString();
      }
      if (genesisHash === "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp") {
        return "mainnet";
      }
      if (genesisHash === "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z") {
        return "testnet";
      }
      if (genesisHash === "EtWTRABZaYq6iMfeYKouRu166VU2xqa1") {
        return "devnet";
      }
      return networkId.toString();
    });
  }
  switchNetwork(_a21) {
    return __awaiter8(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId)
        return;
      const networkIdString = networkChainId.toString();
      const isNetworkIdValid = this.solNetworks.some((network) => network.networkId.toString() === networkIdString);
      if (!isNetworkIdValid) {
        return;
      }
      this.setNetworkId(networkIdString);
      this.emit("chainChange", { chain: networkIdString });
    });
  }
  getPublicClient() {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21;
      const network = this.getSelectedNetwork();
      if (!network) {
        return;
      }
      const networkId = network.networkId.toString();
      const configurations = {
        cosmos: [],
        evm: void 0,
        solana: this.solNetworks,
        starknet: void 0
      };
      if (!this.chainRpcProviders)
        return void 0;
      const providers = this.chainRpcProviders.getProviders(configurations);
      return (_a21 = this.chainRpcProviders.getSolanaProviderByChainId(providers, networkId)) === null || _a21 === void 0 ? void 0 : _a21.provider;
    });
  }
  supportsNetworkSwitching() {
    return true;
  }
  setVerifiedCredentials(verifiedCredentials) {
    const turnkeyVerifiedCredentials = findTurnkeyVerifiedCredentials(verifiedCredentials, ProviderChain.SOLANA);
    const [turnkeyVerifiedCredential] = turnkeyVerifiedCredentials;
    const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !== JSON.stringify(turnkeyVerifiedCredentials);
    if (!didTurnkeyVerifiedCredentialsChanged) {
      return;
    }
    this.verifiedCredential = turnkeyVerifiedCredential;
    this.verifiedCredentials = turnkeyVerifiedCredentials;
    this.refreshTurnkeyAccount();
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21, _b;
      const activeAddress = ((_a21 = this.verifiedCredential) === null || _a21 === void 0 ? void 0 : _a21.address) || "";
      const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (!isWalletActive) {
        const targetActiveAccount = (_b = this.verifiedCredentials) === null || _b === void 0 ? void 0 : _b.find((vc3) => (vc3 === null || vc3 === void 0 ? void 0 : vc3.address) === expectedAddress);
        if (!targetActiveAccount) {
          throw new DynamicError("Account not found");
        }
        this.verifiedCredential = targetActiveAccount;
        this.refreshTurnkeyAccount();
      }
    });
  }
  getAccount() {
    return this.turnkeyAddress;
  }
  endSession() {
    return __awaiter8(this, void 0, void 0, function* () {
      this.setNetworkId(null);
    });
  }
  refreshTurnkeyAccount() {
    return __awaiter8(this, void 0, void 0, function* () {
      this._turnkeyAccount = void 0;
      return this.getTurnkeyAccount();
    });
  }
  createTurnkeyAccount(_a21) {
    return __awaiter8(this, arguments, void 0, function* ({ organizationId }) {
      const turnkeyClient = yield this.getTurnkeyClient();
      const signer = new TurnkeySigner({ client: turnkeyClient, organizationId });
      return signer;
    });
  }
  getTurnkeyAccount() {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21, _b, _c3, _d;
      if (this._turnkeyAccount && (this.getAuthenticatorHandler().recoveryType === "passkey" && ((_a21 = this.__turnkeyClient) === null || _a21 === void 0 ? void 0 : _a21.stamper) instanceof WebauthnStamper || this.getAuthenticatorHandler().recoveryType === "email" && ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper) && this.__turnkeyClient === this.getAuthenticatorHandler().client) {
        return this._turnkeyAccount;
      }
      const { turnkeySubOrganizationId } = (_c3 = this.walletProperties) !== null && _c3 !== void 0 ? _c3 : {};
      const { address } = (_d = this.verifiedCredential) !== null && _d !== void 0 ? _d : {};
      if (!turnkeySubOrganizationId || !address) {
        return;
      }
      this._turnkeyAccount = yield this.createTurnkeyAccount({
        organizationId: turnkeySubOrganizationId
      });
      this.setLoggerMetadata();
      return this._turnkeyAccount;
    });
  }
  getSigner() {
    return __awaiter8(this, void 0, void 0, function* () {
      return new TurnkeySolanaSigner({ walletConnector: this });
    });
  }
  getBalance(address) {
    return __awaiter8(this, void 0, void 0, function* () {
      const connectionClient = this.getConnection();
      const publicKey5 = new PublicKey4(address);
      const balance = yield connectionClient.getBalance(publicKey5);
      const solBalance = this.lamportsToSol(balance);
      return solBalance.toString();
    });
  }
  signUint8ArrayMessage(encodedMessage) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this.turnkeyAddress) {
        throw new DynamicError("No turnkey account");
      }
      const address = this.turnkeyAddress;
      let signedMessageRaw;
      yield this.createOrRestoreSession();
      yield this.walletUiUtils.signMessage({
        handler: () => __awaiter8(this, void 0, void 0, function* () {
          var _a21;
          let account = yield this.getTurnkeyAccount();
          try {
            signedMessageRaw = yield account === null || account === void 0 ? void 0 : account.signMessage(encodedMessage, address);
          } catch (err) {
            yield this.removeSessionKeys();
            yield this.createOrRestoreSession({
              ignoreRestore: true
            });
            account = yield this.getTurnkeyAccount();
            signedMessageRaw = yield account === null || account === void 0 ? void 0 : account.signMessage(encodedMessage, address);
            logger3.error("[TK - removeSessionKeys] failed to perform signUint8ArrayMessage activity", {
              address,
              err,
              turnkeySubOrganizationId: (_a21 = this.walletProperties) === null || _a21 === void 0 ? void 0 : _a21.turnkeySubOrganizationId
            });
          }
          return bufferToBase64(signedMessageRaw || Buffer.from([]));
        }),
        message: new TextDecoder().decode(encodedMessage)
      });
      if (!signedMessageRaw) {
        throw new Error("Failed to sign message");
      }
      return signedMessageRaw;
    });
  }
  signMessage(messageToSign) {
    return __awaiter8(this, void 0, void 0, function* () {
      const enc = new TextEncoder();
      const encodedMessage = enc.encode(messageToSign);
      const signedRawMessage = yield this.signUint8ArrayMessage(encodedMessage);
      return bufferToBase64(signedRawMessage);
    });
  }
  internalSignTransaction(transaction) {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21;
      yield this.createOrRestoreSession();
      let account = yield this.getTurnkeyAccount();
      const address = this.turnkeyAddress;
      if (!account || !address) {
        throw new Error("No turnkey account");
      }
      try {
        yield account.addSignature(transaction, address);
      } catch (err) {
        if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message.toLowerCase().includes(errorMsg.toLowerCase()))) {
          yield this.removeSessionKeys();
          yield this.createOrRestoreSession({
            ignoreRestore: true
          });
          account = yield this.getTurnkeyAccount();
          yield account.addSignature(transaction, address);
          logger3.error("[TK - removeSessionKeys] failed to perform SignTransaction activity", {
            address,
            err,
            turnkeySubOrganizationId: (_a21 = this.walletProperties) === null || _a21 === void 0 ? void 0 : _a21.turnkeySubOrganizationId
          });
        } else {
          logger3.error("[TK] failed to perform SignTransaction activity", err);
          throw err;
        }
      }
      try {
        transaction.serialize({ requireAllSignatures: false });
      } catch (e2) {
        logger3.error("[SignTransaction] likely invalid signature, failed to serialize", e2);
      }
      return transaction;
    });
  }
  signTransaction(transaction) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this.turnkeyAddress)
        throw new DynamicError("No turnkey account");
      const uiTransaction = new SolanaUiTransaction({
        connection: this.getConnection("confirmed"),
        from: this.turnkeyAddress,
        multipleTransactions: [transaction],
        onSubmit: () => __awaiter8(this, void 0, void 0, function* () {
          return this.internalSignTransaction(transaction);
        })
      });
      return this.walletUiUtils.signTransaction(this, uiTransaction);
    });
  }
  createUiTransaction(from13) {
    return __awaiter8(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from13);
      const transaction = new SolanaUiTransaction({
        connection: this.getConnection("confirmed"),
        from: from13,
        onSubmit: (transaction2) => __awaiter8(this, void 0, void 0, function* () {
          if (!transaction2)
            return void 0;
          return this.internalSignAndSendTransaction(transaction2);
        })
      });
      return transaction;
    });
  }
  internalSignAllTransactions(transactions) {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21;
      yield this.createOrRestoreSession();
      let account = yield this.getTurnkeyAccount();
      const address = this.turnkeyAddress;
      let signedTransactions;
      if (!account || !address) {
        throw new Error("No turnkey account");
      }
      try {
        signedTransactions = yield account.signAllTransactions(transactions, address);
      } catch (err) {
        if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message.toLowerCase().includes(errorMsg.toLowerCase()))) {
          yield this.removeSessionKeys();
          yield this.createOrRestoreSession({
            ignoreRestore: true
          });
          account = yield this.getTurnkeyAccount();
          signedTransactions = yield account.signAllTransactions(transactions, address);
          logger3.error("[TK - removeSessionKeys] failed to perform SignAllTransactions activity", {
            address,
            err,
            turnkeySubOrganizationId: (_a21 = this.walletProperties) === null || _a21 === void 0 ? void 0 : _a21.turnkeySubOrganizationId
          });
        } else {
          logger3.error("[TK] failed to perform SignAllTransactions activity", err);
          throw err;
        }
      }
      try {
        signedTransactions.forEach((transaction) => {
          transaction.serialize({ requireAllSignatures: false });
        });
      } catch (e2) {
        logger3.error("[SignAllTransactions] likely invalid signature, failed to serialize", e2);
      }
      return signedTransactions;
    });
  }
  signAllTransactions(transactions) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this.turnkeyAddress)
        throw new DynamicError("No turnkey account");
      const uiTransaction = new SolanaUiTransaction({
        connection: this.getConnection("confirmed"),
        from: this.turnkeyAddress,
        multipleTransactions: transactions,
        onSubmit: () => __awaiter8(this, void 0, void 0, function* () {
          return this.internalSignAllTransactions(transactions);
        })
      });
      return this.walletUiUtils.signTransaction(this, uiTransaction);
    });
  }
  internalSignAndSendTransaction(transaction, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21, _b;
      if (!this.turnkeyAddress)
        throw new DynamicError("Solana wallet not found");
      const currentConnection = this.getConnection((_b = (_a21 = this.connectionConfig) === null || _a21 === void 0 ? void 0 : _a21.commitment) !== null && _b !== void 0 ? _b : "confirmed");
      const signedTransaction = yield this.internalSignTransaction(transaction);
      const signature4 = yield currentConnection.sendRawTransaction(signedTransaction.serialize(), options);
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new DynamicError("Transaction timed out"));
        }, 6e4);
        currentConnection.onSignature(signature4, (result) => {
          clearTimeout(timeout);
          if (result.err) {
            reject(new DynamicError("Transaction failed"));
          } else {
            resolve(signature4);
          }
        }, "confirmed");
      });
    });
  }
  signAndSendTransaction(transaction, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this.turnkeyAddress)
        throw new DynamicError("Solana wallet not found");
      const optimizedTransaction = yield this.optimizeTransaction(transaction);
      const uiTransaction = new SolanaUiTransaction({
        connection: this.getConnection("confirmed"),
        from: this.turnkeyAddress,
        multipleTransactions: [optimizedTransaction],
        onSubmit: () => __awaiter8(this, void 0, void 0, function* () {
          return this.internalSignAndSendTransaction(optimizedTransaction, options);
        })
      });
      return this.walletUiUtils.sendTransaction(this, uiTransaction);
    });
  }
  sendTransaction(transaction_1, connection_1) {
    return __awaiter8(this, arguments, void 0, function* (transaction, connection, options = {}) {
      var _a21;
      if (!this.turnkeyAddress)
        throw new DynamicError("Solana wallet not found");
      if (!transaction || !connection) {
        throw new DynamicError("Transaction and connection are required");
      }
      const { signers } = options, sendOptions = __rest3(options, ["signers"]);
      const blockhash = yield connection.getLatestBlockhash({
        commitment: options.preflightCommitment,
        minContextSlot: options.minContextSlot
      });
      if ("version" in transaction) {
        (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.sign(signers);
      } else {
        transaction.feePayer = transaction.feePayer || new PublicKey4(this.turnkeyAddress);
        transaction.recentBlockhash = transaction.recentBlockhash || blockhash.blockhash;
        (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);
      }
      sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
      const signature4 = yield connection.sendRawTransaction(transaction.serialize(), options);
      const transactionConfirmationStrategy = {
        blockhash: blockhash.blockhash,
        lastValidBlockHeight: blockhash.lastValidBlockHeight,
        signature: signature4
      };
      const result = yield connection === null || connection === void 0 ? void 0 : connection.confirmTransaction(transactionConfirmationStrategy);
      return ((_a21 = result === null || result === void 0 ? void 0 : result.value) === null || _a21 === void 0 ? void 0 : _a21.err) ? JSON.stringify(result.value.err) : signature4;
    });
  }
  lamportsToSol(lamports) {
    return lamports / LAMPORTS_PER_SOL2;
  }
  optimizeTransaction(transaction) {
    return __awaiter8(this, void 0, void 0, function* () {
      var _a21;
      let optimizedTransaction = transaction;
      try {
        if ((yield this.getNetwork(true)) === "101" && !isTxAlreadySigned(transaction)) {
          optimizedTransaction = yield optimizeSolanaTransaction(this.getEnvId(), transaction, (_a21 = this.turnkeyAddress) !== null && _a21 !== void 0 ? _a21 : "");
        }
      } catch (e2) {
        logger3.warn("Failed to optimize transaction", e2);
      }
      return optimizedTransaction;
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter8(this, void 0, void 0, function* () {
      const network = this.getSelectedNetwork();
      if (!network) {
        return [];
      }
      return network.blockExplorerUrls;
    });
  }
  getEnabledNetworks() {
    return this.solNetworks;
  }
};

// node_modules/@dynamic-labs/embedded-wallet-solana/src/TurnkeySolanaWalletConnectors.js
var TurnkeySolanaWalletConnectors = (props) => {
  var _a21;
  if ((_a21 = props.apiProviders) === null || _a21 === void 0 ? void 0 : _a21.turnkey) {
    const TurnkeySolanaWalletConnectorConstructor = class extends TurnkeySolanaWalletConnector {
      constructor(innerProps) {
        super(TurnkeyWalletConnectorInfo.TurnkeyHD, Object.assign(Object.assign({}, props), innerProps));
      }
    };
    Object.defineProperty(TurnkeySolanaWalletConnectorConstructor, "key", {
      value: "turnkeyhd",
      writable: false
    });
    return [TurnkeySolanaWalletConnectorConstructor];
  }
  return [];
};

// node_modules/@dynamic-labs/embedded-wallet-solana/src/index.js
assertPackageVersion("@dynamic-labs/embedded-wallet-solana", version5);

// node_modules/@dynamic-labs/waas-svm/package.js
var version8 = "4.57.1";

// node_modules/@dynamic-labs/waas-svm/_virtual/_tslib.js
function __awaiter9(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_buffer4 = __toESM(require_buffer());
var import_bn4 = __toESM(require_bn());
var import_bs587 = __toESM(require_bs585());
var import_borsh4 = __toESM(require_lib());
var BufferLayout4 = __toESM(require_Layout());
var import_buffer_layout4 = __toESM(require_Layout());

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/errors/dist/index.browser.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED4 = 1;
var SOLANA_ERROR__INVALID_NONCE4 = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND4 = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE4 = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH4 = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE4 = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING4 = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING4 = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE4 = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR4 = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR4 = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR4 = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS4 = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND4 = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST4 = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED4 = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION4 = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET4 = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH4 = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR4 = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE4 = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX4 = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED4 = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT4 = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED4 = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE4 = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY4 = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE4 = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE4 = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE4 = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP4 = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH4 = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE4 = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS4 = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY4 = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA4 = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE4 = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED4 = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED4 = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE4 = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED4 = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER4 = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS4 = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND4 = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND4 = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT4 = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT4 = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED4 = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT4 = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED4 = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED4 = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED4 = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED4 = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED4 = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED4 = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY4 = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED4 = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH4 = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH4 = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH4 = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE4 = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY4 = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS4 = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA4 = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH4 = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN4 = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR4 = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT4 = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA4 = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA4 = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL4 = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS4 = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID4 = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE4 = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED4 = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT4 = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION4 = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID4 = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND4 = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED4 = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE4 = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED4 = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX4 = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED4 = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED4 = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS4 = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED4 = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE4 = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED4 = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING4 = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC4 = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM4 = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR4 = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED4 = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE4 = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT4 = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID4 = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH4 = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT4 = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED4 = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED4 = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS4 = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC4 = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED4 = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION4 = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE4 = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE4 = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE4 = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE4 = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY4 = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR4 = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT4 = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER4 = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW4 = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR4 = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER4 = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED4 = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED4 = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED4 = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS4 = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS4 = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER4 = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER4 = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER4 = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER4 = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER4 = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER4 = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER4 = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER4 = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS4 = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING4 = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED4 = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES4 = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE4 = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME4 = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME4 = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE4 = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING4 = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE4 = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND4 = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING4 = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING4 = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING4 = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING4 = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING4 = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING4 = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE4 = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION4 = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES4 = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH4 = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT4 = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT4 = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT4 = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN4 = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE4 = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE4 = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND4 = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND4 = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE4 = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE4 = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED4 = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND4 = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP4 = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE4 = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX4 = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE4 = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION4 = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE4 = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE4 = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING4 = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT4 = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION4 = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT4 = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT4 = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT4 = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS4 = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND4 = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER4 = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA4 = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX4 = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT4 = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT4 = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT4 = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION4 = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT4 = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED4 = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT4 = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED4 = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED4 = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION4 = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY4 = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH4 = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH4 = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH4 = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH4 = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH4 = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH4 = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS4 = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE4 = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT4 = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT4 = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE4 = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE4 = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH4 = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE4 = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT4 = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE4 = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE4 = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT4 = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE4 = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL4 = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES4 = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS4 = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW4 = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN4 = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR4 = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD4 = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN4 = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID4 = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED4 = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED4 = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT4 = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING4 = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE4 = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING4 = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE4 = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED4 = 9900004;
var SolanaErrorMessages4 = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND4]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED4]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT4]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT4]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND4]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED4]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS4]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH4]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY4]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS4]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE4]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA4]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED4]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED4]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE4]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER4]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE4]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE4]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED4]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY4]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS4]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL4]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH4]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH4]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH4]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE4]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH4]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH4]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH4]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE4]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH4]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT4]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT4]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT4]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT4]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS4]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE4]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE4]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE4]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE4]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES4]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE4]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED4]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED4]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED4]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING4]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED4]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL4]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE4]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT4]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW4]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR4]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS4]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH4]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED4]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM4]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX4]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC4]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT4]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED4]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE4]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED4]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED4]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND4]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR4]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER4]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE4]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY4]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID4]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS4]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA4]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER4]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT4]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR4]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA4]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC4]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS4]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED4]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED4]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED4]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED4]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT4]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE4]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID4]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS4]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION4]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE4]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE4]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE4]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED4]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE4]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED4]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED4]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION4]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT4]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN4]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID4]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR4]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS4]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA4]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH4]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH4]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE4]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING4]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED4]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE4]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING4]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE4]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR4]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS4]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST4]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND4]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR4]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED4]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY4]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT4]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE4]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE4]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE4]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH4]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE4]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION4]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH4]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH4]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH4]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY4]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE4]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE4]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING4]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR4]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING4]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND4]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN4]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED4]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED4]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT4]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID4]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD4]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW4]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR4]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN4]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS4]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER4]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER4]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER4]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER4]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER4]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER4]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER4]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER4]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS4]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING4]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED4]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY4]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED4]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT4]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED4]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED4]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED4]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED4]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED4]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE4]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING4]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE4]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE4]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND4]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND4]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED4]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND4]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP4]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE4]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION4]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE4]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT4]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE4]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX4]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA4]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX4]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER4]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT4]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION4]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT4]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT4]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED4]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE4]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND4]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED4]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED4]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE4]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE4]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS4]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION4]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN4]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION4]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT4]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT4]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT4]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT4]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT4]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION4]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING4]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES4]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT4]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME4]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME4]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING4]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE4]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING4]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND4]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT4]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT4]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING4]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING4]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE4]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING4]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES4]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE4]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH4]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING4]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE4]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX4 = "i";
var TYPE4 = "t";
function getHumanReadableErrorMessage4(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages4[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE4] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX4] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE4] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX4], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii3) => {
    if (ii3 === 0) {
      state = {
        [START_INDEX4]: 0,
        [TYPE4]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE4]) {
      case 0:
        nextState = {
          [START_INDEX4]: ii3,
          [TYPE4]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX4]: ii3,
            [TYPE4]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX4]: ii3,
            [TYPE4]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX4]: ii3,
            [TYPE4]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX4]: ii3,
            [TYPE4]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX4]: ii3,
            [TYPE4]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii3);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage4(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage4(code2, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code2}; Decode this error by running \`npx @solana/errors decode -- ${code2}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError4 = class extends Error {
  constructor(...[code2, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage4(code2, context);
    super(message, errorOptions);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    __publicField(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    __publicField(this, "context");
    this.context = {
      __code: code2,
      ...context
    };
    this.name = "SolanaError";
  }
};

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize4(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder4(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes2 = new Uint8Array(getEncodedSize4(value, encoder));
      encoder.write(value, bytes2, 0);
      return bytes2;
    }
  });
}
function createDecoder4(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes2, offset5 = 0) => decoder.read(bytes2, offset5)[0]
  });
}
function isFixedSize4(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec4(encoder, decoder) {
  if (isFixedSize4(encoder) !== isFixedSize4(decoder)) {
    throw new SolanaError4(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH4);
  }
  if (isFixedSize4(encoder) && isFixedSize4(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError4(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH4, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize4(encoder) && !isFixedSize4(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError4(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH4, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec4(codecDescription, bytes2, offset5 = 0) {
  if (bytes2.length - offset5 <= 0) {
    throw new SolanaError4(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY4, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec4(codecDescription, expected, bytes2, offset5 = 0) {
  const bytesLength = bytes2.length - offset5;
  if (bytesLength < expected) {
    throw new SolanaError4(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH4, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec4(codecDescription, min4, max4, value) {
  if (value < min4 || value > max4) {
    throw new SolanaError4(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE4, {
      codecDescription,
      max: max4,
      min: min4,
      value
    });
  }
}
var Endian4 = ((Endian22) => {
  Endian22[Endian22["Little"] = 0] = "Little";
  Endian22[Endian22["Big"] = 1] = "Big";
  return Endian22;
})(Endian4 || {});
function isLittleEndian4(config) {
  return (config == null ? void 0 : config.endian) === 1 ? false : true;
}
function numberEncoderFactory4(input) {
  return createEncoder4({
    fixedSize: input.size,
    write(value, bytes2, offset5) {
      if (input.range) {
        assertNumberIsBetweenForCodec4(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian4(input.config));
      bytes2.set(new Uint8Array(arrayBuffer), offset5);
      return offset5 + input.size;
    }
  });
}
function numberDecoderFactory4(input) {
  return createDecoder4({
    fixedSize: input.size,
    read(bytes2, offset5 = 0) {
      assertByteArrayIsNotEmptyForCodec4(input.name, bytes2, offset5);
      assertByteArrayHasEnoughBytesForCodec4(input.name, input.size, bytes2, offset5);
      const view = new DataView(toArrayBuffer4(bytes2, offset5, input.size));
      return [input.get(view, isLittleEndian4(input.config)), offset5 + input.size];
    }
  });
}
function toArrayBuffer4(bytes2, offset5, length2) {
  const bytesOffset = bytes2.byteOffset + (offset5 ?? 0);
  const bytesLength = length2 ?? bytes2.byteLength;
  return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder4 = (config = {}) => numberEncoderFactory4({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le5) => view.setBigUint64(0, BigInt(value), le5),
  size: 8
});
var getU64Decoder4 = (config = {}) => numberDecoderFactory4({
  config,
  get: (view, le5) => view.getBigUint64(0, le5),
  name: "u64",
  size: 8
});
var getU64Codec4 = (config = {}) => combineCodec4(getU64Encoder4(config), getU64Decoder4(config));

// node_modules/@dynamic-labs/waas-svm/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_browser7 = __toESM(require_browser());
var generatePrivateKey4 = ed25519.utils.randomPrivateKey;
var generateKeypair4 = () => {
  const privateScalar = ed25519.utils.randomPrivateKey();
  const publicKey5 = getPublicKey4(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey5, 32);
  return {
    publicKey: publicKey5,
    secretKey
  };
};
var getPublicKey4 = ed25519.getPublicKey;
function isOnCurve4(publicKey5) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey5);
    return true;
  } catch {
    return false;
  }
}
var sign4 = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
var verify4 = ed25519.verify;
var toBuffer4 = (arr) => {
  if (import_buffer4.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return import_buffer4.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return import_buffer4.Buffer.from(arr);
  }
};
var Struct4 = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return import_buffer4.Buffer.from((0, import_borsh4.serialize)(SOLANA_SCHEMA4, this));
  }
  static decode(data) {
    return (0, import_borsh4.deserialize)(SOLANA_SCHEMA4, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh4.deserializeUnchecked)(SOLANA_SCHEMA4, this, data);
  }
};
var SOLANA_SCHEMA4 = /* @__PURE__ */ new Map();
var _PublicKey4;
var MAX_SEED_LENGTH4 = 32;
var PUBLIC_KEY_LENGTH4 = 32;
function isPublicKeyData4(value) {
  return value._bn !== void 0;
}
var uniquePublicKeyCounter4 = 1;
var PublicKey5 = class _PublicKey5 extends Struct4 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData4(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs587.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH4) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn4.default(decoded);
      } else {
        this._bn = new import_bn4.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH4) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new _PublicKey5(uniquePublicKeyCounter4);
    uniquePublicKeyCounter4 += 1;
    return new _PublicKey5(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey5) {
    return this._bn.eq(publicKey5._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return import_bs587.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b4 = this._bn.toArrayLike(import_buffer4.Buffer);
    if (b4.length === PUBLIC_KEY_LENGTH4) {
      return b4;
    }
    const zeroPad = import_buffer4.Buffer.alloc(32);
    b4.copy(zeroPad, 32 - b4.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = import_buffer4.Buffer.concat([fromPublicKey.toBuffer(), import_buffer4.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha2562(buffer);
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = import_buffer4.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH4) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = import_buffer4.Buffer.concat([buffer, toBuffer4(seed)]);
    });
    buffer = import_buffer4.Buffer.concat([buffer, programId.toBuffer(), import_buffer4.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha2562(buffer);
    if (isOnCurve4(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new _PublicKey5(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(import_buffer4.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new _PublicKey5(pubkeyData);
    return isOnCurve4(pubkey.toBytes());
  }
};
_PublicKey4 = PublicKey5;
PublicKey5.default = new _PublicKey4("11111111111111111111111111111111");
SOLANA_SCHEMA4.set(PublicKey5, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID4 = new PublicKey5("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE4 = 1280 - 40 - 8;
var VERSION_PREFIX_MASK4 = 127;
var SIGNATURE_LENGTH_IN_BYTES4 = 64;
var TransactionExpiredBlockheightExceededError4 = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError4.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
var TransactionExpiredTimeoutError4 = class extends Error {
  constructor(signature4, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature4} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredTimeoutError4.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
var TransactionExpiredNonceInvalidError4 = class extends Error {
  constructor(signature4) {
    super(`Signature ${signature4} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature4;
  }
};
Object.defineProperty(TransactionExpiredNonceInvalidError4.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
var MessageAccountKeys4 = class {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
};
var publicKey4 = (property = "publicKey") => {
  return BufferLayout4.blob(32, property);
};
var rustString4 = (property = "string") => {
  const rsl = BufferLayout4.struct([BufferLayout4.u32("length"), BufferLayout4.u32("lengthPadding"), BufferLayout4.blob(BufferLayout4.offset(BufferLayout4.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b4, offset5) => {
    const data = _decode(b4, offset5);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b4, offset5) => {
    const data = {
      chars: import_buffer4.Buffer.from(str, "utf8")
    };
    return _encode(data, b4, offset5);
  };
  rslShim.alloc = (str) => {
    return BufferLayout4.u32().span + BufferLayout4.u32().span + import_buffer4.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized4 = (property = "authorized") => {
  return BufferLayout4.struct([publicKey4("staker"), publicKey4("withdrawer")], property);
};
var lockup4 = (property = "lockup") => {
  return BufferLayout4.struct([BufferLayout4.ns64("unixTimestamp"), BufferLayout4.ns64("epoch"), publicKey4("custodian")], property);
};
var voteInit4 = (property = "voteInit") => {
  return BufferLayout4.struct([publicKey4("nodePubkey"), publicKey4("authorizedVoter"), publicKey4("authorizedWithdrawer"), BufferLayout4.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs4 = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout4.struct([BufferLayout4.u32("voteAuthorizationType"), publicKey4("currentAuthorityDerivedKeyOwnerPubkey"), rustString4("currentAuthorityDerivedKeySeed"), publicKey4("newAuthorized")], property);
};
function getAlloc4(type3, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc4({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type3.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength4(bytes2) {
  let len = 0;
  let size9 = 0;
  for (; ; ) {
    let elem6 = bytes2.shift();
    len |= (elem6 & 127) << size9 * 7;
    size9 += 1;
    if ((elem6 & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength4(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem6 = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem6);
      break;
    } else {
      elem6 |= 128;
      bytes2.push(elem6);
    }
  }
}
function assert7(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var CompiledKeys4 = class _CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new _CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert7(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert7(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert7(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey5(address)), ...readonlySigners.map(([address]) => new PublicKey5(address)), ...writableNonSigners.map(([address]) => new PublicKey5(address)), ...readonlyNonSigners.map(([address]) => new PublicKey5(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey5(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert7(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
};
var END_OF_BUFFER_ERROR_MESSAGE4 = "Reached end of buffer unexpectedly";
function guardedShift4(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE4);
  }
  return byteArray.shift();
}
function guardedSplice4(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE4);
  }
  return byteArray.splice(...args);
}
var Message4 = class _Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey5(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs587.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys4(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys4.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys4(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs587.default.encode(ix.data)
    }));
    return new _Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_3, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength4(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs587.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength4(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength4(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: import_buffer4.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: import_buffer4.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength4(instructionCount, instructions.length);
    let instructionBuffer = import_buffer4.Buffer.alloc(PACKET_DATA_SIZE4);
    import_buffer4.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout4.struct([BufferLayout4.u8("programIdIndex"), BufferLayout4.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout4.seq(BufferLayout4.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout4.blob(instruction.dataLength.length, "dataLength"), BufferLayout4.seq(BufferLayout4.u8("userdatum"), instruction.data.length, "data")]);
      const length3 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length3;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout4.struct([BufferLayout4.blob(1, "numRequiredSignatures"), BufferLayout4.blob(1, "numReadonlySignedAccounts"), BufferLayout4.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout4.blob(keyCount.length, "keyCount"), BufferLayout4.seq(publicKey4("key"), numKeys, "keys"), publicKey4("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: import_buffer4.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: import_buffer4.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: import_buffer4.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: import_buffer4.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer4(key.toBytes())),
      recentBlockhash: import_bs587.default.decode(this.recentBlockhash)
    };
    let signData = import_buffer4.Buffer.alloc(2048);
    const length2 = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length2);
    return signData.slice(0, length2 + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift4(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK4)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift4(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift4(byteArray);
    const accountCount = decodeLength4(byteArray);
    let accountKeys = [];
    for (let i4 = 0; i4 < accountCount; i4++) {
      const account = guardedSplice4(byteArray, 0, PUBLIC_KEY_LENGTH4);
      accountKeys.push(new PublicKey5(import_buffer4.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice4(byteArray, 0, PUBLIC_KEY_LENGTH4);
    const instructionCount = decodeLength4(byteArray);
    let instructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift4(byteArray);
      const accountCount2 = decodeLength4(byteArray);
      const accounts = guardedSplice4(byteArray, 0, accountCount2);
      const dataLength = decodeLength4(byteArray);
      const dataSlice = guardedSplice4(byteArray, 0, dataLength);
      const data = import_bs587.default.encode(import_buffer4.Buffer.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs587.default.encode(import_buffer4.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new _Message(messageArgs);
  }
};
var TransactionStatus4 = (function(TransactionStatus5) {
  TransactionStatus5[TransactionStatus5["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus5[TransactionStatus5["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus5[TransactionStatus5["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus5[TransactionStatus5["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus5;
})({});
var DEFAULT_SIGNATURE4 = import_buffer4.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES4).fill(0);
var TransactionInstruction4 = class {
  constructor(opts2) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = import_buffer4.Buffer.alloc(0);
    this.programId = opts2.programId;
    this.keys = opts2.keys;
    if (opts2.data) {
      this.data = opts2.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
};
var Transaction5 = class _Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts2) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts2) {
      return;
    }
    if (opts2.feePayer) {
      this.feePayer = opts2.feePayer;
    }
    if (opts2.signatures) {
      this.signatures = opts2.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts2, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts2;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts2, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts2;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts2;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey5
      }) => {
        return publicKey5.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction4(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i4 = 0; i4 < instructions.length; i4++) {
      if (instructions[i4].programId === void 0) {
        throw new Error(`Transaction instruction index ${i4} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey5(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x5, y5) {
      if (x5.isSigner !== y5.isSigner) {
        return x5.isSigner ? -1 : 1;
      }
      if (x5.isWritable !== y5.isWritable) {
        return x5.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x5.pubkey.toBase58().localeCompare(y5.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x5) => {
      return x5.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature4 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.equals(signature4.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature4.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs587.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert7(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert7(keyIndex >= 0));
    });
    return new Message4({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey5) => {
      const key = publicKey5.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature4 = sign4(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer4(signature4));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature4) {
    this._compile();
    this._addSignature(pubkey, signature4);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature4) {
    assert7(signature4.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = import_buffer4.Buffer.from(signature4);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature: signature4,
      publicKey: publicKey5
    } of this.signatures) {
      if (signature4 === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey5);
        }
      } else {
        if (!verify4(signature4, message, publicKey5.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey5);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength4(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = import_buffer4.Buffer.alloc(transactionLength);
    assert7(signatures.length < 256);
    import_buffer4.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature4
    }, index) => {
      if (signature4 !== null) {
        assert7(signature4.length === 64, `signature has invalid length`);
        import_buffer4.Buffer.from(signature4).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert7(wireTransaction.length <= PACKET_DATA_SIZE4, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE4}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert7(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert7(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert7(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength4(byteArray);
    let signatures = [];
    for (let i4 = 0; i4 < signatureCount; i4++) {
      const signature4 = guardedSplice4(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES4);
      signatures.push(import_bs587.default.encode(import_buffer4.Buffer.from(signature4)));
    }
    return _Transaction.populate(Message4.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message, signatures = []) {
    const transaction = new _Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature4, index) => {
      const sigPubkeyPair = {
        signature: signature4 == import_bs587.default.encode(DEFAULT_SIGNATURE4) ? null : import_bs587.default.decode(signature4),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys4 = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction4({
        keys: keys4,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs587.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
};
var NUM_TICKS_PER_SECOND4 = 160;
var DEFAULT_TICKS_PER_SLOT4 = 64;
var NUM_SLOTS_PER_SECOND4 = NUM_TICKS_PER_SECOND4 / DEFAULT_TICKS_PER_SLOT4;
var MS_PER_SLOT4 = 1e3 / NUM_SLOTS_PER_SECOND4;
var SYSVAR_CLOCK_PUBKEY4 = new PublicKey5("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY4 = new PublicKey5("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY4 = new PublicKey5("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY4 = new PublicKey5("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY4 = new PublicKey5("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY4 = new PublicKey5("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY4 = new PublicKey5("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY4 = new PublicKey5("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY4 = new PublicKey5("SysvarStakeHistory1111111111111111111111111");
var SendTransactionError4 = class extends Error {
  constructor({
    action,
    signature: signature4,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature4} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${/* @__PURE__ */ ((a3) => a3)(action)}'`;
      }
    }
    super(message);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature4;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
};
async function sendAndConfirmTransaction4(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature4 = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature: signature4,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature: signature4
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature4, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature4 != null) {
      throw new SendTransactionError4({
        action: "send",
        signature: signature4,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature4} failed (${JSON.stringify(status)})`);
  }
  return signature4;
}
function sleep4(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function encodeData6(type3, fields) {
  const allocLength = type3.layout.span >= 0 ? type3.layout.span : getAlloc4(type3, fields);
  const data = import_buffer4.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type3.index
  }, fields);
  type3.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout4 = BufferLayout4.nu64("lamportsPerSignature");
var NonceAccountLayout4 = BufferLayout4.struct([BufferLayout4.u32("version"), BufferLayout4.u32("state"), publicKey4("authorizedPubkey"), publicKey4("nonce"), BufferLayout4.struct([FeeCalculatorLayout4], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH4 = NonceAccountLayout4.span;
function u645(property) {
  const layout = (0, import_buffer_layout4.blob)(8, property);
  const decode9 = layout.decode.bind(layout);
  const encode16 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec4();
  bigIntLayout.decode = (buffer, offset5) => {
    const src2 = decode9(buffer, offset5);
    return codec.decode(src2);
  };
  bigIntLayout.encode = (bigInt, buffer, offset5) => {
    const src2 = codec.encode(bigInt);
    return encode16(src2, buffer, offset5);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS4 = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.ns64("lamports"), BufferLayout4.ns64("space"), publicKey4("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), u645("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("base"), rustString4("seed"), BufferLayout4.ns64("lamports"), BufferLayout4.ns64("space"), publicKey4("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("base"), rustString4("seed"), BufferLayout4.ns64("space"), publicKey4("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("base"), rustString4("seed"), publicKey4("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), u645("lamports"), rustString4("seed"), publicKey4("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  }
});
var SystemProgram4 = class _SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.Create;
    const data = encodeData6(type3, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer4(params.programId.toBuffer())
    });
    return new TransactionInstruction4({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.TransferWithSeed;
      data = encodeData6(type3, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer4(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.Transfer;
      data = encodeData6(type3, {
        lamports: BigInt(params.lamports)
      });
      keys4 = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction4({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.AssignWithSeed;
      data = encodeData6(type3, {
        base: toBuffer4(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer4(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.Assign;
      data = encodeData6(type3, {
        programId: toBuffer4(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction4({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.CreateWithSeed;
    const data = encodeData6(type3, {
      base: toBuffer4(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer4(params.programId.toBuffer())
    });
    let keys4 = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys4.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction4({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction5();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(_SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH4,
        programId: this.programId
      }));
    } else {
      transaction.add(_SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH4,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.InitializeNonceAccount;
    const data = encodeData6(type3, {
      authorized: toBuffer4(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY4,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction4(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.AdvanceNonceAccount;
    const data = encodeData6(type3);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction4(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.WithdrawNonceAccount;
    const data = encodeData6(type3, {
      lamports: params.lamports
    });
    return new TransactionInstruction4({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.AuthorizeNonceAccount;
    const data = encodeData6(type3, {
      authorized: toBuffer4(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction4({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys4;
    if ("basePubkey" in params) {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.AllocateWithSeed;
      data = encodeData6(type3, {
        base: toBuffer4(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer4(params.programId.toBuffer())
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type3 = SYSTEM_INSTRUCTION_LAYOUTS4.Allocate;
      data = encodeData6(type3, {
        space: params.space
      });
      keys4 = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction4({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
SystemProgram4.programId = new PublicKey5("11111111111111111111111111111111");
var CHUNK_SIZE5 = PACKET_DATA_SIZE4 - 300;
var Loader4 = class _Loader {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Amount of program data placed in each load Transaction
   */
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * // Every transaction requires two signatures (payer + program)
    (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
    1);
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction5();
          transaction.add(SystemProgram4.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction5();
          transaction.add(SystemProgram4.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction5();
          transaction.add(SystemProgram4.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction5().add(SystemProgram4.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction4(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.u32("offset"), BufferLayout4.u32("bytesLength"), BufferLayout4.u32("bytesLengthPadding"), BufferLayout4.seq(BufferLayout4.u8("byte"), BufferLayout4.offset(BufferLayout4.u32(), -8), "bytes")]);
    const chunkSize = _Loader.chunkSize;
    let offset5 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes2 = array2.slice(0, chunkSize);
      const data2 = import_buffer4.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset: offset5,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction5().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction4(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep4(1e3 / REQUESTS_PER_SECOND);
      }
      offset5 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout4.struct([BufferLayout4.u32("instruction")]);
      const data2 = import_buffer4.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
        // Finalize instruction
      }, data2);
      const transaction = new Transaction5().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY4,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT4 / 2)));
      }
    }
    return true;
  }
};
Loader4.chunkSize = CHUNK_SIZE5;
var BPF_LOADER_PROGRAM_ID4 = new PublicKey5("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs4(x5) {
  return x5 && x5.__esModule && Object.prototype.hasOwnProperty.call(x5, "default") ? x5["default"] : x5;
}
var fastStableStringify$14;
var hasRequiredFastStableStringify4;
function requireFastStableStringify4() {
  if (hasRequiredFastStableStringify4) return fastStableStringify$14;
  hasRequiredFastStableStringify4 = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys4 = [];
    for (var name2 in obj) {
      keys4.push(name2);
    }
    return keys4;
  };
  function stringify6(val, isArrayProp) {
    var i4, max4, str, keys4, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify6(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str = "[";
            max4 = val.length - 1;
            for (i4 = 0; i4 < max4; i4++) {
              str += stringify6(val[i4], true) + ",";
            }
            if (max4 > -1) {
              str += stringify6(val[i4], true);
            }
            return str + "]";
          } else if (toStr === "[object Object]") {
            keys4 = objKeys(val).sort();
            max4 = keys4.length;
            str = "";
            i4 = 0;
            while (i4 < max4) {
              key = keys4[i4];
              propVal = stringify6(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i4++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$14 = function(val) {
    var returnVal = stringify6(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$14;
}
var fastStableStringifyExports4 = requireFastStableStringify4();
var fastStableStringify4 = getDefaultExportFromCjs4(fastStableStringifyExports4);
var fetchImpl4 = globalThis.fetch;
var LookupTableMetaLayout4 = {
  index: 1,
  layout: BufferLayout4.struct([
    BufferLayout4.u32("typeIndex"),
    u645("deactivationSlot"),
    BufferLayout4.nu64("lastExtendedSlot"),
    BufferLayout4.u8("lastExtendedStartIndex"),
    BufferLayout4.u8(),
    // option
    BufferLayout4.seq(publicKey4(), BufferLayout4.offset(BufferLayout4.u8(), -1), "authority")
  ])
};
var PublicKeyFromString4 = coerce(instance(PublicKey5), string(), (value) => new PublicKey5(value));
var RawAccountDataResult4 = tuple([string(), literal("base64")]);
var BufferFromRawAccountData4 = coerce(instance(import_buffer4.Buffer), RawAccountDataResult4, (value) => import_buffer4.Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS4 = 30 * 1e3;
function createRpcResult4(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult4 = createRpcResult4(unknown());
function jsonRpcResult4(schema) {
  return coerce(createRpcResult4(schema), UnknownRpcResult4, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext4(value) {
  return jsonRpcResult4(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext4(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
var GetInflationGovernorResult4 = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
var GetInflationRewardResult4 = jsonRpcResult4(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
var GetRecentPrioritizationFeesResult4 = array(type({
  slot: number(),
  prioritizationFee: number()
}));
var GetInflationRateResult4 = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});
var GetEpochInfoResult4 = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult4 = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
var GetLeaderScheduleResult4 = record(string(), array(number()));
var TransactionErrorResult4 = nullable(union([type({}), string()]));
var SignatureStatusResult4 = type({
  err: TransactionErrorResult4
});
var SignatureReceivedResult4 = literal("receivedSignature");
var VersionResult4 = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
var ParsedInstructionStruct4 = type({
  program: string(),
  programId: PublicKeyFromString4,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct4 = type({
  programId: PublicKeyFromString4,
  accounts: array(PublicKeyFromString4),
  data: string()
});
var SimulatedTransactionResponseStruct4 = jsonRpcResultAndContext4(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct4, PartiallyDecodedInstructionStruct4]))
  }))))
}));
var BlockProductionResponseStruct4 = jsonRpcResultAndContext4(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
var GetInflationGovernorRpcResult4 = jsonRpcResult4(GetInflationGovernorResult4);
var GetInflationRateRpcResult4 = jsonRpcResult4(GetInflationRateResult4);
var GetRecentPrioritizationFeesRpcResult4 = jsonRpcResult4(GetRecentPrioritizationFeesResult4);
var GetEpochInfoRpcResult4 = jsonRpcResult4(GetEpochInfoResult4);
var GetEpochScheduleRpcResult4 = jsonRpcResult4(GetEpochScheduleResult4);
var GetLeaderScheduleRpcResult4 = jsonRpcResult4(GetLeaderScheduleResult4);
var SlotRpcResult4 = jsonRpcResult4(number());
var GetSupplyRpcResult4 = jsonRpcResultAndContext4(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString4)
}));
var TokenAmountResult4 = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult4 = jsonRpcResultAndContext4(array(type({
  address: PublicKeyFromString4,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner4 = jsonRpcResultAndContext4(array(type({
  pubkey: PublicKeyFromString4,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString4,
    lamports: number(),
    data: BufferFromRawAccountData4,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult4 = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
var GetParsedTokenAccountsByOwner4 = jsonRpcResultAndContext4(array(type({
  pubkey: PublicKeyFromString4,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString4,
    lamports: number(),
    data: ParsedAccountDataResult4,
    rentEpoch: number()
  })
})));
var GetLargestAccountsRpcResult4 = jsonRpcResultAndContext4(array(type({
  lamports: number(),
  address: PublicKeyFromString4
})));
var AccountInfoResult4 = type({
  executable: boolean(),
  owner: PublicKeyFromString4,
  lamports: number(),
  data: BufferFromRawAccountData4,
  rentEpoch: number()
});
var KeyedAccountInfoResult4 = type({
  pubkey: PublicKeyFromString4,
  account: AccountInfoResult4
});
var ParsedOrRawAccountData4 = coerce(union([instance(import_buffer4.Buffer), ParsedAccountDataResult4]), union([RawAccountDataResult4, ParsedAccountDataResult4]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData4);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult4 = type({
  executable: boolean(),
  owner: PublicKeyFromString4,
  lamports: number(),
  data: ParsedOrRawAccountData4,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult4 = type({
  pubkey: PublicKeyFromString4,
  account: ParsedAccountInfoResult4
});
var StakeActivationResult4 = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
var GetConfirmedSignaturesForAddress2RpcResult4 = jsonRpcResult4(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult4,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var GetSignaturesForAddressRpcResult4 = jsonRpcResult4(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult4,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var AccountNotificationResult4 = type({
  subscription: number(),
  result: notificationResultAndContext4(AccountInfoResult4)
});
var ProgramAccountInfoResult4 = type({
  pubkey: PublicKeyFromString4,
  account: AccountInfoResult4
});
var ProgramAccountNotificationResult4 = type({
  subscription: number(),
  result: notificationResultAndContext4(ProgramAccountInfoResult4)
});
var SlotInfoResult4 = type({
  parent: number(),
  slot: number(),
  root: number()
});
var SlotNotificationResult4 = type({
  subscription: number(),
  result: SlotInfoResult4
});
var SlotUpdateResult4 = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
var SlotUpdateNotificationResult4 = type({
  subscription: number(),
  result: SlotUpdateResult4
});
var SignatureNotificationResult4 = type({
  subscription: number(),
  result: notificationResultAndContext4(union([SignatureStatusResult4, SignatureReceivedResult4]))
});
var RootNotificationResult4 = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult4 = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult4 = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
var GetVoteAccounts4 = jsonRpcResult4(type({
  current: array(VoteAccountInfoResult4),
  delinquent: array(VoteAccountInfoResult4)
}));
var ConfirmationStatus4 = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse4 = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult4,
  confirmationStatus: optional(ConfirmationStatus4)
});
var GetSignatureStatusesRpcResult4 = jsonRpcResultAndContext4(array(nullable(SignatureStatusResponse4)));
var GetMinimumBalanceForRentExemptionRpcResult4 = jsonRpcResult4(number());
var AddressTableLookupStruct4 = type({
  accountKey: PublicKeyFromString4,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult4 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct4))
  })
});
var AnnotatedAccountKey4 = type({
  pubkey: PublicKeyFromString4,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult4 = type({
  accountKeys: array(AnnotatedAccountKey4),
  signatures: array(string())
});
var ParsedInstructionResult4 = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString4
});
var RawInstructionResult4 = type({
  accounts: array(PublicKeyFromString4),
  data: string(),
  programId: PublicKeyFromString4
});
var InstructionResult4 = union([RawInstructionResult4, ParsedInstructionResult4]);
var UnknownInstructionResult4 = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction4 = coerce(InstructionResult4, UnknownInstructionResult4, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult4);
  } else {
    return create(value, ParsedInstructionResult4);
  }
});
var ParsedConfirmedTransactionResult4 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey4),
    instructions: array(ParsedOrRawInstruction4),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct4)))
  })
});
var TokenBalanceResult4 = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult4
});
var LoadedAddressesResult4 = type({
  writable: array(PublicKeyFromString4),
  readonly: array(PublicKeyFromString4)
});
var ConfirmedTransactionMetaResult4 = type({
  err: TransactionErrorResult4,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult4))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult4))),
  loadedAddresses: optional(LoadedAddressesResult4),
  computeUnitsConsumed: optional(number())
});
var ParsedConfirmedTransactionMetaResult4 = type({
  err: TransactionErrorResult4,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction4)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult4))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult4))),
  loadedAddresses: optional(LoadedAddressesResult4),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct4 = union([literal(0), literal("legacy")]);
var RewardsResult4 = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
var GetBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult4,
    meta: nullable(ConfirmedTransactionMetaResult4),
    version: optional(TransactionVersionStruct4)
  })),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetNoneModeBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetAccountsModeBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult4,
    meta: nullable(ConfirmedTransactionMetaResult4),
    version: optional(TransactionVersionStruct4)
  })),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult4,
    meta: nullable(ParsedConfirmedTransactionMetaResult4),
    version: optional(TransactionVersionStruct4)
  })),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedAccountsModeBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult4,
    meta: nullable(ParsedConfirmedTransactionMetaResult4),
    version: optional(TransactionVersionStruct4)
  })),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedNoneModeBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetConfirmedBlockRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult4,
    meta: nullable(ConfirmedTransactionMetaResult4)
  })),
  rewards: optional(array(RewardsResult4)),
  blockTime: nullable(number())
})));
var GetBlockSignaturesRpcResult4 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
var GetTransactionRpcResult4 = jsonRpcResult4(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult4),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult4,
  version: optional(TransactionVersionStruct4)
})));
var GetParsedTransactionRpcResult4 = jsonRpcResult4(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult4,
  meta: nullable(ParsedConfirmedTransactionMetaResult4),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct4)
})));
var GetLatestBlockhashRpcResult4 = jsonRpcResultAndContext4(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
var IsBlockhashValidRpcResult4 = jsonRpcResultAndContext4(boolean());
var PerfSampleResult4 = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
var GetRecentPerformanceSamplesRpcResult4 = jsonRpcResult4(array(PerfSampleResult4));
var GetFeeCalculatorRpcResult4 = jsonRpcResultAndContext4(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
var RequestAirdropRpcResult4 = jsonRpcResult4(string());
var SendTransactionRpcResult4 = jsonRpcResult4(string());
var LogsResult4 = type({
  err: TransactionErrorResult4,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult4 = type({
  result: notificationResultAndContext4(LogsResult4),
  subscription: number()
});
var Keypair4 = class _Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair4();
  }
  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  static generate() {
    return new _Keypair(generateKeypair4());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey5 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey4(privateScalar);
      for (let ii3 = 0; ii3 < 32; ii3++) {
        if (publicKey5[ii3] !== computedPublicKey[ii3]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */
  static fromSeed(seed) {
    const publicKey5 = getPublicKey4(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey5, 32);
    return new _Keypair({
      publicKey: publicKey5,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */
  get publicKey() {
    return new PublicKey5(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
};
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS4 = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), u645("recentSlot"), BufferLayout4.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), u645(), BufferLayout4.seq(publicKey4(), BufferLayout4.offset(BufferLayout4.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  }
});
var AddressLookupTableProgram4 = class {
  /**
   * @internal
   */
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey5.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder4().encode(params.recentSlot)], this.programId);
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS4.CreateLookupTable;
    const data = encodeData6(type3, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys4 = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram4.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction4({
      programId: this.programId,
      keys: keys4,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS4.FreezeLookupTable;
    const data = encodeData6(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction4({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static extendLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS4.ExtendLookupTable;
    const data = encodeData6(type3, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys4.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram4.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction4({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS4.DeactivateLookupTable;
    const data = encodeData6(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction4({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
  static closeLookupTable(params) {
    const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS4.CloseLookupTable;
    const data = encodeData6(type3);
    const keys4 = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction4({
      programId: this.programId,
      keys: keys4,
      data
    });
  }
};
AddressLookupTableProgram4.programId = new PublicKey5("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS4 = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout4.struct([BufferLayout4.u8("instruction"), BufferLayout4.u32("units"), BufferLayout4.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout4.struct([BufferLayout4.u8("instruction"), BufferLayout4.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout4.struct([BufferLayout4.u8("instruction"), BufferLayout4.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout4.struct([BufferLayout4.u8("instruction"), u645("microLamports")])
  }
});
var ComputeBudgetProgram4 = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS4.RequestUnits;
    const data = encodeData6(type3, params);
    return new TransactionInstruction4({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS4.RequestHeapFrame;
    const data = encodeData6(type3, params);
    return new TransactionInstruction4({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS4.SetComputeUnitLimit;
    const data = encodeData6(type3, params);
    return new TransactionInstruction4({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS4.SetComputeUnitPrice;
    const data = encodeData6(type3, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction4({
      keys: [],
      programId: this.programId,
      data
    });
  }
};
ComputeBudgetProgram4.programId = new PublicKey5("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$14 = 64;
var PUBLIC_KEY_BYTES$14 = 32;
var SIGNATURE_BYTES4 = 64;
var ED25519_INSTRUCTION_LAYOUT4 = BufferLayout4.struct([BufferLayout4.u8("numSignatures"), BufferLayout4.u8("padding"), BufferLayout4.u16("signatureOffset"), BufferLayout4.u16("signatureInstructionIndex"), BufferLayout4.u16("publicKeyOffset"), BufferLayout4.u16("publicKeyInstructionIndex"), BufferLayout4.u16("messageDataOffset"), BufferLayout4.u16("messageDataSize"), BufferLayout4.u16("messageInstructionIndex")]);
var Ed25519Program4 = class _Ed25519Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the ed25519 program
   */
  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      instructionIndex
    } = params;
    assert7(publicKey5.length === PUBLIC_KEY_BYTES$14, `Public Key must be ${PUBLIC_KEY_BYTES$14} bytes but received ${publicKey5.length} bytes`);
    assert7(signature4.length === SIGNATURE_BYTES4, `Signature must be ${SIGNATURE_BYTES4} bytes but received ${signature4.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT4.span;
    const signatureOffset = publicKeyOffset + publicKey5.length;
    const messageDataOffset = signatureOffset + signature4.length;
    const numSignatures = 1;
    const instructionData = import_buffer4.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT4.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey5, publicKeyOffset);
    instructionData.fill(signature4, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction4({
      keys: [],
      programId: _Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert7(privateKey.length === PRIVATE_KEY_BYTES$14, `Private key must be ${PRIVATE_KEY_BYTES$14} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair4.fromSecretKey(privateKey);
      const publicKey5 = keypair.publicKey.toBytes();
      const signature4 = sign4(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program4.programId = new PublicKey5("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign4 = (msgHash, privKey) => {
  const signature4 = secp256k1.sign(msgHash, privKey);
  return [signature4.toCompactRawBytes(), signature4.recovery];
};
secp256k1.utils.isValidPrivateKey;
var publicKeyCreate4 = secp256k1.getPublicKey;
var PRIVATE_KEY_BYTES4 = 32;
var ETHEREUM_ADDRESS_BYTES4 = 20;
var PUBLIC_KEY_BYTES4 = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE4 = 11;
var SECP256K1_INSTRUCTION_LAYOUT4 = BufferLayout4.struct([BufferLayout4.u8("numSignatures"), BufferLayout4.u16("signatureOffset"), BufferLayout4.u8("signatureInstructionIndex"), BufferLayout4.u16("ethAddressOffset"), BufferLayout4.u8("ethAddressInstructionIndex"), BufferLayout4.u16("messageDataOffset"), BufferLayout4.u16("messageDataSize"), BufferLayout4.u8("messageInstructionIndex"), BufferLayout4.blob(20, "ethAddress"), BufferLayout4.blob(64, "signature"), BufferLayout4.u8("recoveryId")]);
var Secp256k1Program4 = class _Secp256k1Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the secp256k1 program
   */
  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey5) {
    assert7(publicKey5.length === PUBLIC_KEY_BYTES4, `Public key must be ${PUBLIC_KEY_BYTES4} bytes but received ${publicKey5.length} bytes`);
    try {
      return import_buffer4.Buffer.from(keccak_256(toBuffer4(publicKey5))).slice(-ETHEREUM_ADDRESS_BYTES4);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    } = params;
    return _Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey5),
      message,
      signature: signature4,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature: signature4,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress3;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress3 = import_buffer4.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress3 = import_buffer4.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress3 = rawAddress;
    }
    assert7(ethAddress3.length === ETHEREUM_ADDRESS_BYTES4, `Address must be ${ETHEREUM_ADDRESS_BYTES4} bytes but received ${ethAddress3.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE4;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress3.length;
    const messageDataOffset = signatureOffset + signature4.length + 1;
    const numSignatures = 1;
    const instructionData = import_buffer4.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT4.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT4.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer4(signature4),
      ethAddress: toBuffer4(ethAddress3),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer4(message), SECP256K1_INSTRUCTION_LAYOUT4.span);
    return new TransactionInstruction4({
      keys: [],
      programId: _Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert7(pkey.length === PRIVATE_KEY_BYTES4, `Private key must be ${PRIVATE_KEY_BYTES4} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer4(pkey);
      const publicKey5 = publicKeyCreate4(
        privateKey,
        false
        /* isCompressed */
      ).slice(1);
      const messageHash = import_buffer4.Buffer.from(keccak_256(toBuffer4(message)));
      const [signature4, recoveryId] = ecdsaSign4(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature: signature4,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program4.programId = new PublicKey5("KeccakSecp256k11111111111111111111111111111");
var _Lockup4;
var STAKE_CONFIG_ID4 = new PublicKey5("StakeConfig11111111111111111111111111111111");
var Lockup4 = class {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
_Lockup4 = Lockup4;
Lockup4.default = new _Lockup4(0, 0, PublicKey5.default);
var STAKE_INSTRUCTION_LAYOUTS4 = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), authorized4(), lockup4()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("newAuthorized"), BufferLayout4.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("newAuthorized"), BufferLayout4.u32("stakeAuthorizationType"), rustString4("authoritySeed"), publicKey4("authorityOwner")])
  }
});
var StakeAuthorizationLayout4 = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram4 = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Stake program
   */
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: maybeLockup
    } = params;
    const lockup5 = maybeLockup || Lockup4.default;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Initialize;
    const data = encodeData6(type3, {
      authorized: {
        staker: toBuffer4(authorized5.staker.toBuffer()),
        withdrawer: toBuffer4(authorized5.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup5.unixTimestamp,
        epoch: lockup5.epoch,
        custodian: toBuffer4(lockup5.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY4,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction4(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction5();
    transaction.add(SystemProgram4.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction5();
    transaction.add(SystemProgram4.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized5,
      lockup: lockup5
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Delegate;
    const data = encodeData6(type3);
    return new Transaction5().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Authorize;
    const data = encodeData6(type3, {
      newAuthorized: toBuffer4(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY4,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.AuthorizeWithSeed;
    const data = encodeData6(type3, {
      newAuthorized: toBuffer4(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer4(authorityOwner.toBuffer())
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY4,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Split;
    const data = encodeData6(type3, {
      lamports
    });
    return new TransactionInstruction4({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params, rentExemptReserve) {
    const transaction = new Transaction5();
    transaction.add(SystemProgram4.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction5();
    transaction.add(SystemProgram4.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram4.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Merge;
    const data = encodeData6(type3);
    return new Transaction5().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Withdraw;
    const data = encodeData6(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY4,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY4,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys4.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type3 = STAKE_INSTRUCTION_LAYOUTS4.Deactivate;
    const data = encodeData6(type3);
    return new Transaction5().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram4.programId = new PublicKey5("Stake11111111111111111111111111111111111111");
StakeProgram4.space = 200;
var VOTE_INSTRUCTION_LAYOUTS4 = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), voteInit4()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), publicKey4("newAuthorized"), BufferLayout4.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), BufferLayout4.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout4.struct([BufferLayout4.u32("instruction"), voteAuthorizeWithSeedArgs4()])
  }
});
var VoteAuthorizationLayout4 = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var VoteProgram4 = class _VoteProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Vote program
   */
  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit5
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS4.InitializeAccount;
    const data = encodeData6(type3, {
      voteInit: {
        nodePubkey: toBuffer4(voteInit5.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer4(voteInit5.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer4(voteInit5.authorizedWithdrawer.toBuffer()),
        commission: voteInit5.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY4,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction4(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction5();
    transaction.add(SystemProgram4.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS4.Authorize;
    const data = encodeData6(type3, {
      newAuthorized: toBuffer4(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY4,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS4.AuthorizeWithSeed;
    const data = encodeData6(type3, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer4(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer4(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY4,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS4.Withdraw;
    const data = encodeData6(type3, {
      lamports
    });
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return _VoteProgram.withdraw(params);
  }
  /**
   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
   */
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type3 = VOTE_INSTRUCTION_LAYOUTS4.UpdateValidatorIdentity;
    const data = encodeData6(type3);
    const keys4 = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction5().add({
      keys: keys4,
      programId: this.programId,
      data
    });
  }
};
VoteProgram4.programId = new PublicKey5("Vote111111111111111111111111111111111111111");
VoteProgram4.space = 3762;
var VALIDATOR_INFO_KEY4 = new PublicKey5("Va1idator1nfo111111111111111111111111111111");
var InfoString4 = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID4 = new PublicKey5("Vote111111111111111111111111111111111111111");
var VoteAccountLayout4 = BufferLayout4.struct([
  publicKey4("nodePubkey"),
  publicKey4("authorizedWithdrawer"),
  BufferLayout4.u8("commission"),
  BufferLayout4.nu64(),
  // votes.length
  BufferLayout4.seq(BufferLayout4.struct([BufferLayout4.nu64("slot"), BufferLayout4.u32("confirmationCount")]), BufferLayout4.offset(BufferLayout4.u32(), -8), "votes"),
  BufferLayout4.u8("rootSlotValid"),
  BufferLayout4.nu64("rootSlot"),
  BufferLayout4.nu64(),
  // authorizedVoters.length
  BufferLayout4.seq(BufferLayout4.struct([BufferLayout4.nu64("epoch"), publicKey4("authorizedVoter")]), BufferLayout4.offset(BufferLayout4.u32(), -8), "authorizedVoters"),
  BufferLayout4.struct([BufferLayout4.seq(BufferLayout4.struct([publicKey4("authorizedPubkey"), BufferLayout4.nu64("epochOfLastAuthorizedSwitch"), BufferLayout4.nu64("targetEpoch")]), 32, "buf"), BufferLayout4.nu64("idx"), BufferLayout4.u8("isEmpty")], "priorVoters"),
  BufferLayout4.nu64(),
  // epochCredits.length
  BufferLayout4.seq(BufferLayout4.struct([BufferLayout4.nu64("epoch"), BufferLayout4.nu64("credits"), BufferLayout4.nu64("prevCredits")]), BufferLayout4.offset(BufferLayout4.u32(), -8), "epochCredits"),
  BufferLayout4.struct([BufferLayout4.nu64("slot"), BufferLayout4.nu64("timestamp")], "lastTimestamp")
]);

// node_modules/@dynamic-labs/waas/package.js
var version9 = "4.57.1";

// node_modules/@dynamic-labs/waas/_virtual/_tslib.js
function __awaiter10(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/validate.js
function validate7(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate7;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  return Uint8Array.of((v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v6 >>> 16 & 255, v6 >>> 8 & 255, v6 & 255, (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v6 / 4294967296 & 255, v6 >>> 24 & 255, v6 >>> 16 & 255, v6 >>> 8 & 255, v6 & 255);
}
var parse_default = parse;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset5 = 0) {
  return (byteToHex[arr[offset5 + 0]] + byteToHex[arr[offset5 + 1]] + byteToHex[arr[offset5 + 2]] + byteToHex[arr[offset5 + 3]] + "-" + byteToHex[arr[offset5 + 4]] + byteToHex[arr[offset5 + 5]] + "-" + byteToHex[arr[offset5 + 6]] + byteToHex[arr[offset5 + 7]] + "-" + byteToHex[arr[offset5 + 8]] + byteToHex[arr[offset5 + 9]] + "-" + byteToHex[arr[offset5 + 10]] + byteToHex[arr[offset5 + 11]] + byteToHex[arr[offset5 + 12]] + byteToHex[arr[offset5 + 13]] + byteToHex[arr[offset5 + 14]] + byteToHex[arr[offset5 + 15]]).toLowerCase();
}

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/md5.js
function md52(bytes2) {
  const words = uint8ToUint32(bytes2);
  const md5Bytes = wordsToMd5(words, bytes2.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes2 = new Uint8Array(input.length * 4);
  for (let i4 = 0; i4 < input.length * 4; i4++) {
    bytes2[i4] = input[i4 >> 2] >>> i4 % 4 * 8 & 255;
  }
  return bytes2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x5, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x5);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x5 = xpad;
  let a3 = 1732584193;
  let b4 = -271733879;
  let c6 = -1732584194;
  let d4 = 271733878;
  for (let i4 = 0; i4 < x5.length; i4 += 16) {
    const olda = a3;
    const oldb = b4;
    const oldc = c6;
    const oldd = d4;
    a3 = md5ff(a3, b4, c6, d4, x5[i4], 7, -680876936);
    d4 = md5ff(d4, a3, b4, c6, x5[i4 + 1], 12, -389564586);
    c6 = md5ff(c6, d4, a3, b4, x5[i4 + 2], 17, 606105819);
    b4 = md5ff(b4, c6, d4, a3, x5[i4 + 3], 22, -1044525330);
    a3 = md5ff(a3, b4, c6, d4, x5[i4 + 4], 7, -176418897);
    d4 = md5ff(d4, a3, b4, c6, x5[i4 + 5], 12, 1200080426);
    c6 = md5ff(c6, d4, a3, b4, x5[i4 + 6], 17, -1473231341);
    b4 = md5ff(b4, c6, d4, a3, x5[i4 + 7], 22, -45705983);
    a3 = md5ff(a3, b4, c6, d4, x5[i4 + 8], 7, 1770035416);
    d4 = md5ff(d4, a3, b4, c6, x5[i4 + 9], 12, -1958414417);
    c6 = md5ff(c6, d4, a3, b4, x5[i4 + 10], 17, -42063);
    b4 = md5ff(b4, c6, d4, a3, x5[i4 + 11], 22, -1990404162);
    a3 = md5ff(a3, b4, c6, d4, x5[i4 + 12], 7, 1804603682);
    d4 = md5ff(d4, a3, b4, c6, x5[i4 + 13], 12, -40341101);
    c6 = md5ff(c6, d4, a3, b4, x5[i4 + 14], 17, -1502002290);
    b4 = md5ff(b4, c6, d4, a3, x5[i4 + 15], 22, 1236535329);
    a3 = md5gg(a3, b4, c6, d4, x5[i4 + 1], 5, -165796510);
    d4 = md5gg(d4, a3, b4, c6, x5[i4 + 6], 9, -1069501632);
    c6 = md5gg(c6, d4, a3, b4, x5[i4 + 11], 14, 643717713);
    b4 = md5gg(b4, c6, d4, a3, x5[i4], 20, -373897302);
    a3 = md5gg(a3, b4, c6, d4, x5[i4 + 5], 5, -701558691);
    d4 = md5gg(d4, a3, b4, c6, x5[i4 + 10], 9, 38016083);
    c6 = md5gg(c6, d4, a3, b4, x5[i4 + 15], 14, -660478335);
    b4 = md5gg(b4, c6, d4, a3, x5[i4 + 4], 20, -405537848);
    a3 = md5gg(a3, b4, c6, d4, x5[i4 + 9], 5, 568446438);
    d4 = md5gg(d4, a3, b4, c6, x5[i4 + 14], 9, -1019803690);
    c6 = md5gg(c6, d4, a3, b4, x5[i4 + 3], 14, -187363961);
    b4 = md5gg(b4, c6, d4, a3, x5[i4 + 8], 20, 1163531501);
    a3 = md5gg(a3, b4, c6, d4, x5[i4 + 13], 5, -1444681467);
    d4 = md5gg(d4, a3, b4, c6, x5[i4 + 2], 9, -51403784);
    c6 = md5gg(c6, d4, a3, b4, x5[i4 + 7], 14, 1735328473);
    b4 = md5gg(b4, c6, d4, a3, x5[i4 + 12], 20, -1926607734);
    a3 = md5hh(a3, b4, c6, d4, x5[i4 + 5], 4, -378558);
    d4 = md5hh(d4, a3, b4, c6, x5[i4 + 8], 11, -2022574463);
    c6 = md5hh(c6, d4, a3, b4, x5[i4 + 11], 16, 1839030562);
    b4 = md5hh(b4, c6, d4, a3, x5[i4 + 14], 23, -35309556);
    a3 = md5hh(a3, b4, c6, d4, x5[i4 + 1], 4, -1530992060);
    d4 = md5hh(d4, a3, b4, c6, x5[i4 + 4], 11, 1272893353);
    c6 = md5hh(c6, d4, a3, b4, x5[i4 + 7], 16, -155497632);
    b4 = md5hh(b4, c6, d4, a3, x5[i4 + 10], 23, -1094730640);
    a3 = md5hh(a3, b4, c6, d4, x5[i4 + 13], 4, 681279174);
    d4 = md5hh(d4, a3, b4, c6, x5[i4], 11, -358537222);
    c6 = md5hh(c6, d4, a3, b4, x5[i4 + 3], 16, -722521979);
    b4 = md5hh(b4, c6, d4, a3, x5[i4 + 6], 23, 76029189);
    a3 = md5hh(a3, b4, c6, d4, x5[i4 + 9], 4, -640364487);
    d4 = md5hh(d4, a3, b4, c6, x5[i4 + 12], 11, -421815835);
    c6 = md5hh(c6, d4, a3, b4, x5[i4 + 15], 16, 530742520);
    b4 = md5hh(b4, c6, d4, a3, x5[i4 + 2], 23, -995338651);
    a3 = md5ii(a3, b4, c6, d4, x5[i4], 6, -198630844);
    d4 = md5ii(d4, a3, b4, c6, x5[i4 + 7], 10, 1126891415);
    c6 = md5ii(c6, d4, a3, b4, x5[i4 + 14], 15, -1416354905);
    b4 = md5ii(b4, c6, d4, a3, x5[i4 + 5], 21, -57434055);
    a3 = md5ii(a3, b4, c6, d4, x5[i4 + 12], 6, 1700485571);
    d4 = md5ii(d4, a3, b4, c6, x5[i4 + 3], 10, -1894986606);
    c6 = md5ii(c6, d4, a3, b4, x5[i4 + 10], 15, -1051523);
    b4 = md5ii(b4, c6, d4, a3, x5[i4 + 1], 21, -2054922799);
    a3 = md5ii(a3, b4, c6, d4, x5[i4 + 8], 6, 1873313359);
    d4 = md5ii(d4, a3, b4, c6, x5[i4 + 15], 10, -30611744);
    c6 = md5ii(c6, d4, a3, b4, x5[i4 + 6], 15, -1560198380);
    b4 = md5ii(b4, c6, d4, a3, x5[i4 + 13], 21, 1309151649);
    a3 = md5ii(a3, b4, c6, d4, x5[i4 + 4], 6, -145523070);
    d4 = md5ii(d4, a3, b4, c6, x5[i4 + 11], 10, -1120210379);
    c6 = md5ii(c6, d4, a3, b4, x5[i4 + 2], 15, 718787259);
    b4 = md5ii(b4, c6, d4, a3, x5[i4 + 9], 21, -343485551);
    a3 = safeAdd(a3, olda);
    b4 = safeAdd(b4, oldb);
    c6 = safeAdd(c6, oldc);
    d4 = safeAdd(d4, oldd);
  }
  return Uint32Array.of(a3, b4, c6, d4);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output2 = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i4 = 0; i4 < input.length; i4++) {
    output2[i4 >> 2] |= (input[i4] & 255) << i4 % 4 * 8;
  }
  return output2;
}
function safeAdd(x5, y5) {
  const lsw = (x5 & 65535) + (y5 & 65535);
  const msw = (x5 >> 16) + (y5 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num3, cnt) {
  return num3 << cnt | num3 >>> 32 - cnt;
}
function md5cmn(q, a3, b4, x5, s3, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a3, q), safeAdd(x5, t)), s3), b4);
}
function md5ff(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn(b4 & c6 | ~b4 & d4, a3, b4, x5, s3, t);
}
function md5gg(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn(b4 & d4 | c6 & ~d4, a3, b4, x5, s3, t);
}
function md5hh(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn(b4 ^ c6 ^ d4, a3, b4, x5, s3, t);
}
function md5ii(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn(c6 ^ (b4 | ~d4), a3, b4, x5, s3, t);
}
var md5_default = md52;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes3(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = new Uint8Array(str.length);
  for (let i4 = 0; i4 < str.length; ++i4) {
    bytes2[i4] = str.charCodeAt(i4);
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version11, hash, value, namespace, buf, offset5) {
  const valueBytes = typeof value === "string" ? stringToBytes3(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes2 = new Uint8Array(16 + valueBytes.length);
  bytes2.set(namespaceBytes);
  bytes2.set(valueBytes, namespaceBytes.length);
  bytes2 = hash(bytes2);
  bytes2[6] = bytes2[6] & 15 | version11;
  bytes2[8] = bytes2[8] & 63 | 128;
  if (buf) {
    offset5 = offset5 || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset5 + i4] = bytes2[i4];
    }
    return buf;
  }
  return unsafeStringify(bytes2);
}

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/v3.js
function v32(value, namespace, buf, offset5) {
  return v35(48, md5_default, value, namespace, buf, offset5);
}
v32.DNS = DNS;
v32.URL = URL2;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset5) {
  var _a21;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a21 = options.rng) == null ? void 0 : _a21.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset5 = offset5 || 0;
    if (offset5 < 0 || offset5 + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset5}:${offset5 + 15} is out of buffer bounds`);
    }
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset5 + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v42;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/sha1.js
function f6(s3, x5, y5, z4) {
  switch (s3) {
    case 0:
      return x5 & y5 ^ ~x5 & z4;
    case 1:
      return x5 ^ y5 ^ z4;
    case 2:
      return x5 & y5 ^ x5 & z4 ^ y5 & z4;
    case 3:
      return x5 ^ y5 ^ z4;
  }
}
function ROTL(x5, n5) {
  return x5 << n5 | x5 >>> 32 - n5;
}
function sha12(bytes2) {
  const K4 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes2.length + 1);
  newBytes.set(bytes2);
  newBytes[bytes2.length] = 128;
  bytes2 = newBytes;
  const l6 = bytes2.length / 4 + 2;
  const N15 = Math.ceil(l6 / 16);
  const M4 = new Array(N15);
  for (let i4 = 0; i4 < N15; ++i4) {
    const arr = new Uint32Array(16);
    for (let j3 = 0; j3 < 16; ++j3) {
      arr[j3] = bytes2[i4 * 64 + j3 * 4] << 24 | bytes2[i4 * 64 + j3 * 4 + 1] << 16 | bytes2[i4 * 64 + j3 * 4 + 2] << 8 | bytes2[i4 * 64 + j3 * 4 + 3];
    }
    M4[i4] = arr;
  }
  M4[N15 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M4[N15 - 1][14] = Math.floor(M4[N15 - 1][14]);
  M4[N15 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i4 = 0; i4 < N15; ++i4) {
    const W5 = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W5[t] = M4[i4][t];
    }
    for (let t = 16; t < 80; ++t) {
      W5[t] = ROTL(W5[t - 3] ^ W5[t - 8] ^ W5[t - 14] ^ W5[t - 16], 1);
    }
    let a3 = H2[0];
    let b4 = H2[1];
    let c6 = H2[2];
    let d4 = H2[3];
    let e2 = H2[4];
    for (let t = 0; t < 80; ++t) {
      const s3 = Math.floor(t / 20);
      const T3 = ROTL(a3, 5) + f6(s3, b4, c6, d4) + e2 + K4[s3] + W5[t] >>> 0;
      e2 = d4;
      d4 = c6;
      c6 = ROTL(b4, 30) >>> 0;
      b4 = a3;
      a3 = T3;
    }
    H2[0] = H2[0] + a3 >>> 0;
    H2[1] = H2[1] + b4 >>> 0;
    H2[2] = H2[2] + c6 >>> 0;
    H2[3] = H2[3] + d4 >>> 0;
    H2[4] = H2[4] + e2 >>> 0;
  }
  return Uint8Array.of(H2[0] >> 24, H2[0] >> 16, H2[0] >> 8, H2[0], H2[1] >> 24, H2[1] >> 16, H2[1] >> 8, H2[1], H2[2] >> 24, H2[2] >> 16, H2[2] >> 8, H2[2], H2[3] >> 24, H2[3] >> 16, H2[3] >> 8, H2[3], H2[4] >> 24, H2[4] >> 16, H2[4] >> 8, H2[4]);
}
var sha1_default = sha12;

// node_modules/@dynamic-labs/waas/node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset5) {
  return v35(80, sha1_default, value, namespace, buf, offset5);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/axios/lib/helpers/bind.js
function bind(fn4, thisArg) {
  return function wrap() {
    return fn4.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString5 } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString5.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type3) => {
  type3 = type3.toLowerCase();
  return (thing) => kindOf(thing) === type3;
};
var typeOfTest = (type3) => (thing) => typeof thing === type3;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype5 = getPrototypeOf(val);
  return (prototype5 === null || prototype5 === Object.prototype || Object.getPrototypeOf(prototype5) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e2) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim3 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn4, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i4;
  let l6;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i4 = 0, l6 = obj.length; i4 < l6; i4++) {
      fn4.call(null, obj[i4], i4, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys4 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys4.length;
    let key;
    for (i4 = 0; i4 < len; i4++) {
      key = keys4[i4];
      fn4.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys4 = Object.keys(obj);
  let i4 = keys4.length;
  let _key;
  while (i4-- > 0) {
    _key = keys4[i4];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i4 = 0, l6 = arguments.length; i4 < l6; i4++) {
    arguments[i4] && forEach(arguments[i4], assignValue);
  }
  return result;
}
var extend = (a3, b4, thisArg, { allOwnKeys } = {}) => {
  forEach(b4, (val, key) => {
    if (thisArg && isFunction(val)) {
      a3[key] = bind(val, thisArg);
    } else {
      a3[key] = val;
    }
  }, { allOwnKeys });
  return a3;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors3) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors3);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter10, propFilter) => {
  let props;
  let i4;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i4 = props.length;
    while (i4-- > 0) {
      prop = props[i4];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter10 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter10 || filter10(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i4 = thing.length;
  if (!isNumber(i4)) return null;
  const arr = new Array(i4);
  while (i4-- > 0) {
    arr[i4] = thing[i4];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn4) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn4.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m3, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty7 }) => (obj, prop) => hasOwnProperty7.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors3 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors3, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i4) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i4] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i4 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i4] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim: trim3,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code2, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter10(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code2 == null && error ? error.code : code2;
  AxiosError.call(axiosError, msg, errCode, config, request2, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i4) {
    token = removeBrackets(token);
    return !dots && i4 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue3(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue3(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue3(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue: convertValue3,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode12(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match14) {
    return charMap[match14];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype2.toString = function toString6(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode12);
  } : encode12;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode13(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode13;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn4) {
    utils_default.forEach(this.handlers, function forEachHandler(h5) {
      if (h5 !== null) {
        fn4(h5);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name2) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match14) => {
    return match14[0] === "[]" ? "" : match14[1] || match14[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys4 = Object.keys(arr);
  let i4;
  const len = keys4.length;
  let key;
  for (i4 = 0; i4 < len; i4++) {
    key = keys4[i4];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    if (name2 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils_default.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData3 = utils_default.isFormData(data);
    if (isFormData3) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList3;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList3 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList3 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional3 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i4;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i4 = line.indexOf(":");
    key = line.substring(0, i4).trim().toLowerCase();
    val = line.substring(i4 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match14;
  while (match14 = tokensRE.exec(str)) {
    tokens[match14[1]] = match14[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter10, isHeaderNameFilter) {
  if (utils_default.isFunction(filter10)) {
    return filter10.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter10)) {
    return value.indexOf(filter10) !== -1;
  }
  if (utils_default.isRegExp(filter10)) {
    return filter10.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w4, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys4 = Object.keys(this);
    let i4 = keys4.length;
    let deleted = false;
    while (i4--) {
      const key = keys4[i4];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype5 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype5, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn4) {
    data = fn4.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus3 = response.config.validateStatus;
  if (!response.status || !validateStatus3 || validateStatus3(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match14 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match14 && match14[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min4) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head5 = 0;
  let tail4 = 0;
  let firstSampleTS;
  min4 = min4 !== void 0 ? min4 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail4];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head5] = chunkLength;
    timestamps[head5] = now;
    let i4 = tail4;
    let bytesCount = 0;
    while (i4 !== head5) {
      bytesCount += bytes2[i4++];
      i4 = i4 % samplesCount;
    }
    head5 = (head5 + 1) % samplesCount;
    if (head5 === tail4) {
      tail4 = (tail4 + 1) % samplesCount;
    }
    if (now - firstSampleTS < min4) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn4, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn4(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange3 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange3 ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn4) => (...args) => utils_default.asap(() => fn4(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin3, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin3.protocol === url.protocol && origin3.host === url.host && (isMSIE || origin3.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure, sameSite) {
      if (typeof document === "undefined") return;
      const cookie = [`${name2}=${encodeURIComponent(value)}`];
      if (utils_default.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils_default.isString(path)) {
        cookie.push(`path=${path}`);
      }
      if (utils_default.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils_default.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      if (typeof document === "undefined") return null;
      const match14 = document.cookie.match(new RegExp("(?:^|; )" + name2 + "=([^;]*)"));
      return match14 ? decodeURIComponent(match14[1]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a3, b4, prop, caseless) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(a3, b4, prop, caseless);
    } else if (!utils_default.isUndefined(a3)) {
      return getMergedValue(void 0, a3, prop, caseless);
    }
  }
  function valueFromConfig2(a3, b4) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    }
  }
  function defaultToConfig2(a3, b4) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    } else if (!utils_default.isUndefined(a3)) {
      return getMergedValue(void 0, a3);
    }
  }
  function mergeDirectKeys(a3, b4, prop) {
    if (prop in config2) {
      return getMergedValue(a3, b4);
    } else if (prop in config1) {
      return getMergedValue(void 0, a3);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a3, b4, prop) => mergeDeepProperties(headersToObject(a3), headersToObject(b4), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request2);
      err.event = event || null;
      reject(err);
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional3 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional3.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator4 = readBytes(stream, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator4.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator4.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
  Request: Request2,
  Response: Response2
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn4, ...args) => {
  try {
    return !!fn4(...args);
  } catch (e2) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request: Request2, Response: Response2 } = env;
  const isFetchSupported2 = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request2);
  const isResponseSupported = isFunction2(Response2);
  if (!isFetchSupported2) {
    return false;
  }
  const isReadableStreamSupported2 = isFetchSupported2 && isFunction2(ReadableStream2);
  const encodeText2 = isFetchSupported2 && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request2(str).arrayBuffer()));
  const supportsRequestStream2 = isRequestSupported && isReadableStreamSupported2 && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request2(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream2 = isResponseSupported && isReadableStreamSupported2 && test(() => utils_default.isReadableStream(new Response2("").body));
  const resolvers2 = {
    stream: supportsResponseStream2 && ((res) => res.body)
  };
  isFetchSupported2 && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type3) => {
      !resolvers2[type3] && (resolvers2[type3] = (res, config) => {
        let method = res && res[type3];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type3}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength2 = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request2(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText2(body)).byteLength;
    }
  };
  const resolveBodyLength2 = async (headers, body) => {
    const length2 = utils_default.toFiniteNumber(headers.getContentLength());
    return length2 == null ? getBodyLength2(body) : length2;
  };
  return async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request2 = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream2 && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength2(headers, data)) !== 0) {
        let _request = new Request2(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request2 = isRequestSupported && new Request2(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request2, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream2 && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream2 && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response2(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers2[utils_default.findKey(resolvers2, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request: request2
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request2),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request2);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config) => {
  let env = config && config.env || {};
  const { fetch: fetch3, Request: Request2, Response: Response2 } = env;
  const seeds = [
    Request2,
    Response2,
    fetch3
  ];
  let len = seeds.length, i4 = len, seed, target, map36 = seedCache;
  while (i4--) {
    seed = seeds[i4];
    target = map36.get(seed);
    target === void 0 && map36.set(seed, target = i4 ? /* @__PURE__ */ new Map() : factory(env));
    map36 = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn4, value) => {
  if (fn4) {
    try {
      Object.defineProperty(fn4, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn4, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
function getAdapter(adapters, config) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length: length2 } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i4 = 0; i4 < length2; i4++) {
    nameOrAdapter = adapters[i4];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === void 0) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
      break;
    }
    rejectedReasons[id || "#" + i4] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s3 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(
      `There is no suitable adapter to dispatch the request ` + s3,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter2;
}
var adapters_default = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION2 = "1.13.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type3, i4) => {
  validators[type3] = function validator(thing) {
    return typeof thing === type3 || "a" + (i4 < 1 ? "n " : " ") + type3;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version11, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts2) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version11 ? " in " + version11 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version11 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version11 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts2) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys4 = Object.keys(options);
  let i4 = keys4.length;
  while (i4-- > 0) {
    const opt = keys4[i4];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional3, paramsSerializer, headers } = config;
    if (transitional3 !== void 0) {
      validator_default.assertOptions(transitional3, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i4 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain6 = [dispatchRequest.bind(this), void 0];
      chain6.unshift(...requestInterceptorChain);
      chain6.push(...responseInterceptorChain);
      len = chain6.length;
      promise = Promise.resolve(config);
      while (i4 < len) {
        promise = promise.then(chain6[i4++], chain6[i4++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i4 < len) {
      const onFulfilled = requestInterceptorChain[i4++];
      const onRejected = requestInterceptorChain[i4++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i4 = 0;
    len = responseInterceptorChain.length;
    while (i4 < len) {
      promise = promise.then(responseInterceptorChain[i4++], responseInterceptorChain[i4++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i4 = token._listeners.length;
      while (i4-- > 0) {
        token._listeners[i4](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c6) {
      cancel = c6;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance2 = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance2, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create6(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION2;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION3,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter: getAdapter2,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@dynamic-labs-wallet/forward-mpc-client/dist/index.js
var ws5 = __toESM(require_browser4());

// node_modules/fp-ts/es6/function.js
var __spreadArray2 = function(to5, from13, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l6 = from13.length, ar3; i4 < l6; i4++) {
    if (ar3 || !(i4 in from13)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from13, 0, i4);
      ar3[i4] = from13[i4];
    }
  }
  return to5.concat(ar3 || Array.prototype.slice.call(from13));
};
function identity3(a3) {
  return a3;
}
var unsafeCoerce = identity3;
function constant(a3) {
  return function() {
    return a3;
  };
}
var constTrue = constant(true);
var constFalse = constant(false);
var constNull = constant(null);
var constUndefined = constant(void 0);
function flow(ab, bc3, cd, de5, ef3, fg, gh, hi3, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc3(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc3(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de5(cd(bc3(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef3(de5(cd(bc3(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef3(de5(cd(bc3(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef3(de5(cd(bc3(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi3(gh(fg(ef3(de5(cd(bc3(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi3(gh(fg(ef3(de5(cd(bc3(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a3, ab, bc3, cd, de5, ef3, fg, gh, hi3) {
  switch (arguments.length) {
    case 1:
      return a3;
    case 2:
      return ab(a3);
    case 3:
      return bc3(ab(a3));
    case 4:
      return cd(bc3(ab(a3)));
    case 5:
      return de5(cd(bc3(ab(a3))));
    case 6:
      return ef3(de5(cd(bc3(ab(a3)))));
    case 7:
      return fg(ef3(de5(cd(bc3(ab(a3))))));
    case 8:
      return gh(fg(ef3(de5(cd(bc3(ab(a3)))))));
    case 9:
      return hi3(gh(fg(ef3(de5(cd(bc3(ab(a3))))))));
    default: {
      var ret = arguments[0];
      for (var i4 = 1; i4 < arguments.length; i4++) {
        ret = arguments[i4](ret);
      }
      return ret;
    }
  }
}
var SK = function(_3, b4) {
  return b4;
};
var dual = function(arity, body) {
  var isDataFirst = typeof arity === "number" ? function(args) {
    return args.length >= arity;
  } : arity;
  return function() {
    var args = Array.from(arguments);
    if (isDataFirst(arguments)) {
      return body.apply(this, args);
    }
    return function(self2) {
      return body.apply(void 0, __spreadArray2([self2], args, false));
    };
  };
};

// node_modules/fp-ts/es6/internal.js
var __spreadArray3 = function(to5, from13, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l6 = from13.length, ar3; i4 < l6; i4++) {
    if (ar3 || !(i4 in from13)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from13, 0, i4);
      ar3[i4] = from13[i4];
    }
  }
  return to5.concat(ar3 || Array.prototype.slice.call(from13));
};
var isNone = function(fa2) {
  return fa2._tag === "None";
};
var isSome = function(fa2) {
  return fa2._tag === "Some";
};
var none = { _tag: "None" };
var some = function(a3) {
  return { _tag: "Some", value: a3 };
};
var isLeft = function(ma2) {
  return ma2._tag === "Left";
};
var isRight = function(ma2) {
  return ma2._tag === "Right";
};
var left = function(e2) {
  return { _tag: "Left", left: e2 };
};
var right = function(a3) {
  return { _tag: "Right", right: a3 };
};
var singleton = function(a3) {
  return [a3];
};
var isNonEmpty = function(as16) {
  return as16.length > 0;
};
var head = function(as16) {
  return as16[0];
};
var tail = function(as16) {
  return as16.slice(1);
};
var emptyReadonlyArray = [];
var emptyRecord = {};
var has = Object.prototype.hasOwnProperty;
var fromReadonlyNonEmptyArray = function(as16) {
  return __spreadArray3([as16[0]], as16.slice(1), true);
};
var liftNullable = function(F5) {
  return function(f8, onNullable) {
    return function() {
      var a3 = [];
      for (var _i4 = 0; _i4 < arguments.length; _i4++) {
        a3[_i4] = arguments[_i4];
      }
      var o4 = f8.apply(void 0, a3);
      return F5.fromEither(o4 == null ? left(onNullable.apply(void 0, a3)) : right(o4));
    };
  };
};
var liftOption = function(F5) {
  return function(f8, onNone) {
    return function() {
      var a3 = [];
      for (var _i4 = 0; _i4 < arguments.length; _i4++) {
        a3[_i4] = arguments[_i4];
      }
      var o4 = f8.apply(void 0, a3);
      return F5.fromEither(isNone(o4) ? left(onNone.apply(void 0, a3)) : right(o4.value));
    };
  };
};
var flatMapNullable = function(F5, M4) {
  return dual(3, function(self2, f8, onNullable) {
    return M4.flatMap(self2, liftNullable(F5)(f8, onNullable));
  });
};
var flatMapOption = function(F5, M4) {
  return dual(3, function(self2, f8, onNone) {
    return M4.flatMap(self2, liftOption(F5)(f8, onNone));
  });
};
var flatMapEither = function(F5, M4) {
  return dual(2, function(self2, f8) {
    return M4.flatMap(self2, function(a3) {
      return F5.fromEither(f8(a3));
    });
  });
};
var flatMapIO = function(F5, M4) {
  return dual(2, function(self2, f8) {
    return M4.flatMap(self2, function(a3) {
      return F5.fromIO(f8(a3));
    });
  });
};
var flatMapTask = function(F5, M4) {
  return dual(2, function(self2, f8) {
    return M4.flatMap(self2, function(a3) {
      return F5.fromTask(f8(a3));
    });
  });
};
var flatMapReader = function(F5, M4) {
  return dual(2, function(self2, f8) {
    return M4.flatMap(self2, function(a3) {
      return F5.fromReader(f8(a3));
    });
  });
};

// node_modules/fp-ts/es6/Apply.js
function ap(F5, G5) {
  return function(fa2) {
    return function(fab) {
      return F5.ap(F5.map(fab, function(gab) {
        return function(ga2) {
          return G5.ap(gab, ga2);
        };
      }), fa2);
    };
  };
}
function apFirst(A4) {
  return function(second) {
    return function(first2) {
      return A4.ap(A4.map(first2, function(a3) {
        return function() {
          return a3;
        };
      }), second);
    };
  };
}
function apSecond(A4) {
  return function(second) {
    return function(first2) {
      return A4.ap(A4.map(first2, function() {
        return function(b4) {
          return b4;
        };
      }), second);
    };
  };
}
function apS(F5) {
  return function(name2, fb) {
    return function(fa2) {
      return F5.ap(F5.map(fa2, function(a3) {
        return function(b4) {
          var _a21;
          return Object.assign({}, a3, (_a21 = {}, _a21[name2] = b4, _a21));
        };
      }), fb);
    };
  };
}
function getApplySemigroup(F5) {
  return function(S4) {
    return {
      concat: function(first2, second) {
        return F5.ap(F5.map(first2, function(x5) {
          return function(y5) {
            return S4.concat(x5, y5);
          };
        }), second);
      }
    };
  };
}

// node_modules/fp-ts/es6/Functor.js
function map(F5, G5) {
  return function(f8) {
    return function(fa2) {
      return F5.map(fa2, function(ga2) {
        return G5.map(ga2, f8);
      });
    };
  };
}
function flap(F5) {
  return function(a3) {
    return function(fab) {
      return F5.map(fab, function(f8) {
        return f8(a3);
      });
    };
  };
}
function bindTo(F5) {
  return function(name2) {
    return function(fa2) {
      return F5.map(fa2, function(a3) {
        var _a21;
        return _a21 = {}, _a21[name2] = a3, _a21;
      });
    };
  };
}
function let_(F5) {
  return function(name2, f8) {
    return function(fa2) {
      return F5.map(fa2, function(a3) {
        var _a21;
        return Object.assign({}, a3, (_a21 = {}, _a21[name2] = f8(a3), _a21));
      });
    };
  };
}
function as2(F5) {
  return function(self2, b4) {
    return F5.map(self2, function() {
      return b4;
    });
  };
}
function asUnit(F5) {
  var asM = as2(F5);
  return function(self2) {
    return asM(self2, void 0);
  };
}

// node_modules/fp-ts/es6/Applicative.js
function getApplicativeMonoid(F5) {
  var f8 = getApplySemigroup(F5);
  return function(M4) {
    return {
      concat: f8(M4).concat,
      empty: F5.of(M4.empty)
    };
  };
}

// node_modules/fp-ts/es6/Chain.js
function chainFirst(M4) {
  var tapM = tap(M4);
  return function(f8) {
    return function(first2) {
      return tapM(first2, f8);
    };
  };
}
function tap(M4) {
  return function(first2, f8) {
    return M4.chain(first2, function(a3) {
      return M4.map(f8(a3), function() {
        return a3;
      });
    });
  };
}
function bind2(M4) {
  return function(name2, f8) {
    return function(ma2) {
      return M4.chain(ma2, function(a3) {
        return M4.map(f8(a3), function(b4) {
          var _a21;
          return Object.assign({}, a3, (_a21 = {}, _a21[name2] = b4, _a21));
        });
      });
    };
  };
}

// node_modules/fp-ts/es6/FromEither.js
function fromOption(F5) {
  return function(onNone) {
    return function(ma2) {
      return F5.fromEither(isNone(ma2) ? left(onNone()) : right(ma2.value));
    };
  };
}
function fromPredicate(F5) {
  return function(predicate, onFalse) {
    return function(a3) {
      return F5.fromEither(predicate(a3) ? right(a3) : left(onFalse(a3)));
    };
  };
}
function fromOptionK(F5) {
  var fromOptionF = fromOption(F5);
  return function(onNone) {
    var from13 = fromOptionF(onNone);
    return function(f8) {
      return flow(f8, from13);
    };
  };
}
function chainOptionK(F5, M4) {
  var fromOptionKF = fromOptionK(F5);
  return function(onNone) {
    var from13 = fromOptionKF(onNone);
    return function(f8) {
      return function(ma2) {
        return M4.chain(ma2, from13(f8));
      };
    };
  };
}
function fromEitherK(F5) {
  return function(f8) {
    return flow(f8, F5.fromEither);
  };
}
function chainEitherK(F5, M4) {
  var fromEitherKF = fromEitherK(F5);
  return function(f8) {
    return function(ma2) {
      return M4.chain(ma2, fromEitherKF(f8));
    };
  };
}
function filterOrElse(F5, M4) {
  return function(predicate, onFalse) {
    return function(ma2) {
      return M4.chain(ma2, function(a3) {
        return F5.fromEither(predicate(a3) ? right(a3) : left(onFalse(a3)));
      });
    };
  };
}
function tapEither(F5, M4) {
  var fromEither13 = fromEitherK(F5);
  var tapM = tap(M4);
  return function(self2, f8) {
    return tapM(self2, fromEither13(f8));
  };
}

// node_modules/fp-ts/es6/Eq.js
var eqStrict = {
  equals: function(a3, b4) {
    return a3 === b4;
  }
};
var strictEqual = eqStrict.equals;

// node_modules/fp-ts/es6/Ord.js
var equalsDefault = function(compare3) {
  return function(first2, second) {
    return first2 === second || compare3(first2, second) === 0;
  };
};
var fromCompare = function(compare3) {
  return {
    equals: equalsDefault(compare3),
    compare: function(first2, second) {
      return first2 === second ? 0 : compare3(first2, second);
    }
  };
};
var contramap = function(f8) {
  return function(fa2) {
    return fromCompare(function(first2, second) {
      return fa2.compare(f8(first2), f8(second));
    });
  };
};
var trivial = {
  equals: constTrue,
  compare: constant(0)
};
function compare2(first2, second) {
  return first2 < second ? -1 : first2 > second ? 1 : 0;
}
var strictOrd = {
  equals: eqStrict.equals,
  compare: compare2
};
var ordNumber = strictOrd;
var ordDate = pipe(
  ordNumber,
  contramap(function(date) {
    return date.valueOf();
  })
);

// node_modules/fp-ts/es6/Semigroup.js
var constant2 = function(a3) {
  return {
    concat: function() {
      return a3;
    }
  };
};
var semigroupVoid = constant2(void 0);
var semigroupAll = {
  concat: function(x5, y5) {
    return x5 && y5;
  }
};
var semigroupAny = {
  concat: function(x5, y5) {
    return x5 || y5;
  }
};
var semigroupString = {
  concat: function(x5, y5) {
    return x5 + y5;
  }
};
var semigroupSum = {
  concat: function(x5, y5) {
    return x5 + y5;
  }
};
var semigroupProduct = {
  concat: function(x5, y5) {
    return x5 * y5;
  }
};

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray4 = function(to5, from13, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l6 = from13.length, ar3; i4 < l6; i4++) {
    if (ar3 || !(i4 in from13)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from13, 0, i4);
      ar3[i4] = from13[i4];
    }
  }
  return to5.concat(ar3 || Array.prototype.slice.call(from13));
};
var empty2 = emptyReadonlyArray;
var isNonEmpty2 = isNonEmpty;
var appendW = function(end) {
  return function(init4) {
    return __spreadArray4(__spreadArray4([], init4, true), [end], false);
  };
};
var append2 = appendW;
var chainWithIndex = function(f8) {
  return function(as16) {
    var out = fromReadonlyNonEmptyArray(f8(0, head2(as16)));
    for (var i4 = 1; i4 < as16.length; i4++) {
      var bs3 = f8(i4, as16[i4]);
      for (var j3 = 0; j3 < bs3.length; j3++) {
        out.push(bs3[j3]);
      }
    }
    return out;
  };
};
var _map = function(fa2, f8) {
  return pipe(fa2, map2(f8));
};
var _ap = function(fab, fa2) {
  return pipe(fab, ap2(fa2));
};
var of2 = singleton;
var ap2 = function(as16) {
  return flatMap(function(f8) {
    return pipe(as16, map2(f8));
  });
};
var flatMap = dual(2, function(ma2, f8) {
  return pipe(ma2, chainWithIndex(function(i4, a3) {
    return f8(a3, i4);
  }));
});
var extend2 = function(f8) {
  return function(as16) {
    var next = tail2(as16);
    var out = [f8(as16)];
    while (isNonEmpty2(next)) {
      out.push(f8(next));
      next = tail2(next);
    }
    return out;
  };
};
var duplicate = extend2(identity3);
var flatten = flatMap(identity3);
var map2 = function(f8) {
  return mapWithIndex(function(_3, a3) {
    return f8(a3);
  });
};
var mapWithIndex = function(f8) {
  return function(as16) {
    var out = [f8(0, head2(as16))];
    for (var i4 = 1; i4 < as16.length; i4++) {
      out.push(f8(i4, as16[i4]));
    }
    return out;
  };
};
var extract3 = head;
var URI = "ReadonlyNonEmptyArray";
var Functor = {
  URI,
  map: _map
};
var flap2 = flap(Functor);
var Apply = {
  URI,
  map: _map,
  ap: _ap
};
var apFirst2 = apFirst(Apply);
var apSecond2 = apSecond(Apply);
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var chainFirst2 = chainFirst(Chain);
var Do4 = of2(emptyRecord);
var bindTo2 = bindTo(Functor);
var let_2 = let_(Functor);
var bind3 = bind2(Chain);
var apS2 = apS(Apply);
var head2 = extract3;
var tail2 = tail;

// node_modules/fp-ts/es6/NonEmptyArray.js
var __spreadArray5 = function(to5, from13, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l6 = from13.length, ar3; i4 < l6; i4++) {
    if (ar3 || !(i4 in from13)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from13, 0, i4);
      ar3[i4] = from13[i4];
    }
  }
  return to5.concat(ar3 || Array.prototype.slice.call(from13));
};
var isNonEmpty3 = function(as16) {
  return as16.length > 0;
};
var appendW2 = function(end) {
  return function(init4) {
    return __spreadArray5(__spreadArray5([], init4, true), [end], false);
  };
};
var append3 = appendW2;
var fromReadonlyNonEmptyArray2 = fromReadonlyNonEmptyArray;
var of3 = function(a3) {
  return [a3];
};
var chainWithIndex2 = function(f8) {
  return function(as16) {
    var out = fromReadonlyNonEmptyArray2(f8(0, head3(as16)));
    for (var i4 = 1; i4 < as16.length; i4++) {
      var bs3 = f8(i4, as16[i4]);
      for (var j3 = 0; j3 < bs3.length; j3++) {
        out.push(bs3[j3]);
      }
    }
    return out;
  };
};
var _map2 = function(fa2, f8) {
  return pipe(fa2, map3(f8));
};
var _ap2 = function(fab, fa2) {
  return pipe(fab, ap3(fa2));
};
var ap3 = function(as16) {
  return flatMap2(function(f8) {
    return pipe(as16, map3(f8));
  });
};
var flatMap2 = dual(2, function(ma2, f8) {
  return pipe(ma2, chainWithIndex2(function(i4, a3) {
    return f8(a3, i4);
  }));
});
var extend3 = function(f8) {
  return function(as16) {
    var next = tail3(as16);
    var out = [f8(as16)];
    while (isNonEmpty3(next)) {
      out.push(f8(next));
      next = tail3(next);
    }
    return out;
  };
};
var duplicate2 = extend3(identity3);
var flatten2 = flatMap2(identity3);
var map3 = function(f8) {
  return mapWithIndex2(function(_3, a3) {
    return f8(a3);
  });
};
var mapWithIndex2 = function(f8) {
  return function(as16) {
    var out = [f8(0, head3(as16))];
    for (var i4 = 1; i4 < as16.length; i4++) {
      out.push(f8(i4, as16[i4]));
    }
    return out;
  };
};
var URI2 = "NonEmptyArray";
var Functor2 = {
  URI: URI2,
  map: _map2
};
var flap3 = flap(Functor2);
var Apply2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2
};
var apFirst3 = apFirst(Apply2);
var apSecond3 = apSecond(Apply2);
var Chain2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  chain: flatMap2
};
var chainFirst3 = chainFirst(Chain2);
var Do5 = of3(emptyRecord);
var bindTo3 = bindTo(Functor2);
var let_3 = let_(Functor2);
var bind4 = bind2(Chain2);
var apS3 = apS(Apply2);
var head3 = head2;
var tail3 = function(as16) {
  return as16.slice(1);
};

// node_modules/fp-ts/es6/number.js
var Eq = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var Ord = {
  equals: Eq.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};
var Bounded = {
  equals: Eq.equals,
  compare: Ord.compare,
  top: Infinity,
  bottom: -Infinity
};
var MagmaSub = {
  concat: function(first2, second) {
    return first2 - second;
  }
};
var SemigroupSum = {
  concat: function(first2, second) {
    return first2 + second;
  }
};
var SemigroupProduct = {
  concat: function(first2, second) {
    return first2 * second;
  }
};
var MonoidSum = {
  concat: SemigroupSum.concat,
  empty: 0
};
var MonoidProduct = {
  concat: SemigroupProduct.concat,
  empty: 1
};
var Field3 = {
  add: SemigroupSum.concat,
  zero: 0,
  mul: SemigroupProduct.concat,
  one: 1,
  sub: MagmaSub.concat,
  degree: function(_3) {
    return 1;
  },
  div: function(first2, second) {
    return first2 / second;
  },
  mod: function(first2, second) {
    return first2 % second;
  }
};

// node_modules/fp-ts/es6/Separated.js
var separated = function(left13, right13) {
  return { left: left13, right: right13 };
};
var _map3 = function(fa2, f8) {
  return pipe(fa2, map4(f8));
};
var map4 = function(f8) {
  return function(fa2) {
    return separated(left2(fa2), f8(right2(fa2)));
  };
};
var URI3 = "Separated";
var Functor3 = {
  URI: URI3,
  map: _map3
};
var flap4 = flap(Functor3);
var left2 = function(s3) {
  return s3.left;
};
var right2 = function(s3) {
  return s3.right;
};

// node_modules/fp-ts/es6/Witherable.js
function wiltDefault(T3, C4) {
  return function(F5) {
    var traverseF = T3.traverse(F5);
    return function(wa2, f8) {
      return F5.map(traverseF(wa2, f8), C4.separate);
    };
  };
}
function witherDefault(T3, C4) {
  return function(F5) {
    var traverseF = T3.traverse(F5);
    return function(wa2, f8) {
      return F5.map(traverseF(wa2, f8), C4.compact);
    };
  };
}
function filterE(W5) {
  return function(F5) {
    var witherF = W5.wither(F5);
    return function(predicate) {
      return function(ga2) {
        return witherF(ga2, function(a3) {
          return F5.map(predicate(a3), function(b4) {
            return b4 ? some(a3) : none;
          });
        });
      };
    };
  };
}

// node_modules/fp-ts/es6/Zero.js
function guard2(F5, P4) {
  return function(b4) {
    return b4 ? P4.of(void 0) : F5.zero();
  };
}

// node_modules/fp-ts/es6/ReadonlyArray.js
var isEmpty = function(as16) {
  return as16.length === 0;
};
var append4 = append2;
var fromEither = function(e2) {
  return isLeft(e2) ? empty3 : [e2.right];
};
var chainWithIndex3 = function(f8) {
  return function(as16) {
    if (isEmpty(as16)) {
      return empty3;
    }
    var out = [];
    for (var i4 = 0; i4 < as16.length; i4++) {
      var bs3 = f8(i4, as16[i4]);
      for (var j3 = 0; j3 < bs3.length; j3++) {
        out.push(bs3[j3]);
      }
    }
    return out;
  };
};
var _map4 = function(fa2, f8) {
  return pipe(fa2, map5(f8));
};
var _ap3 = function(fab, fa2) {
  return pipe(fab, ap4(fa2));
};
var _filter = function(fa2, predicate) {
  return pipe(fa2, filter2(predicate));
};
var _filterMap = function(fa2, f8) {
  return pipe(fa2, filterMap(f8));
};
var _partition = function(fa2, predicate) {
  return pipe(fa2, partition(predicate));
};
var _partitionMap = function(fa2, f8) {
  return pipe(fa2, partitionMap(f8));
};
var _reduce = function(fa2, b4, f8) {
  return pipe(fa2, reduce2(b4, f8));
};
var _foldMap = function(M4) {
  var foldMapM = foldMap2(M4);
  return function(fa2, f8) {
    return pipe(fa2, foldMapM(f8));
  };
};
var _reduceRight = function(fa2, b4, f8) {
  return pipe(fa2, reduceRight2(b4, f8));
};
var _traverse = function(F5) {
  var traverseF = traverse(F5);
  return function(ta2, f8) {
    return pipe(ta2, traverseF(f8));
  };
};
var of4 = of2;
var zero = function() {
  return empty3;
};
var ap4 = function(fa2) {
  return flatMap3(function(f8) {
    return pipe(fa2, map5(f8));
  });
};
var flatMap3 = dual(2, function(ma2, f8) {
  return pipe(ma2, chainWithIndex3(function(i4, a3) {
    return f8(a3, i4);
  }));
});
var flatten3 = flatMap3(identity3);
var map5 = function(f8) {
  return function(fa2) {
    return fa2.map(function(a3) {
      return f8(a3);
    });
  };
};
var separate = function(fa2) {
  var left13 = [];
  var right13 = [];
  for (var _i4 = 0, fa_1 = fa2; _i4 < fa_1.length; _i4++) {
    var e2 = fa_1[_i4];
    if (e2._tag === "Left") {
      left13.push(e2.left);
    } else {
      right13.push(e2.right);
    }
  }
  return separated(left13, right13);
};
var filter2 = function(predicate) {
  return function(as16) {
    return as16.filter(predicate);
  };
};
var filterMapWithIndex = function(f8) {
  return function(fa2) {
    var out = [];
    for (var i4 = 0; i4 < fa2.length; i4++) {
      var optionB = f8(i4, fa2[i4]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap = function(f8) {
  return filterMapWithIndex(function(_3, a3) {
    return f8(a3);
  });
};
var compact = filterMap(identity3);
var partition = function(predicate) {
  return partitionWithIndex(function(_3, a3) {
    return predicate(a3);
  });
};
var partitionWithIndex = function(predicateWithIndex) {
  return function(as16) {
    var left13 = [];
    var right13 = [];
    for (var i4 = 0; i4 < as16.length; i4++) {
      var a3 = as16[i4];
      if (predicateWithIndex(i4, a3)) {
        right13.push(a3);
      } else {
        left13.push(a3);
      }
    }
    return separated(left13, right13);
  };
};
var partitionMap = function(f8) {
  return partitionMapWithIndex(function(_3, a3) {
    return f8(a3);
  });
};
var partitionMapWithIndex = function(f8) {
  return function(fa2) {
    var left13 = [];
    var right13 = [];
    for (var i4 = 0; i4 < fa2.length; i4++) {
      var e2 = f8(i4, fa2[i4]);
      if (e2._tag === "Left") {
        left13.push(e2.left);
      } else {
        right13.push(e2.right);
      }
    }
    return separated(left13, right13);
  };
};
var extend4 = function(f8) {
  return function(wa2) {
    return wa2.map(function(_3, i4) {
      return f8(wa2.slice(i4));
    });
  };
};
var duplicate3 = extend4(identity3);
var foldMapWithIndex2 = function(M4) {
  return function(f8) {
    return function(fa2) {
      return fa2.reduce(function(b4, a3, i4) {
        return M4.concat(b4, f8(i4, a3));
      }, M4.empty);
    };
  };
};
var reduce2 = function(b4, f8) {
  return reduceWithIndex2(b4, function(_3, b5, a3) {
    return f8(b5, a3);
  });
};
var foldMap2 = function(M4) {
  var foldMapWithIndexM = foldMapWithIndex2(M4);
  return function(f8) {
    return foldMapWithIndexM(function(_3, a3) {
      return f8(a3);
    });
  };
};
var reduceWithIndex2 = function(b4, f8) {
  return function(fa2) {
    var len = fa2.length;
    var out = b4;
    for (var i4 = 0; i4 < len; i4++) {
      out = f8(i4, out, fa2[i4]);
    }
    return out;
  };
};
var reduceRight2 = function(b4, f8) {
  return reduceRightWithIndex2(b4, function(_3, a3, b5) {
    return f8(a3, b5);
  });
};
var reduceRightWithIndex2 = function(b4, f8) {
  return function(fa2) {
    return fa2.reduceRight(function(b5, a3, i4) {
      return f8(i4, a3, b5);
    }, b4);
  };
};
var traverse = function(F5) {
  var traverseWithIndexF = traverseWithIndex(F5);
  return function(f8) {
    return traverseWithIndexF(function(_3, a3) {
      return f8(a3);
    });
  };
};
var sequence = function(F5) {
  return function(ta2) {
    return _reduce(ta2, F5.of(zero()), function(fas, fa2) {
      return F5.ap(F5.map(fas, function(as16) {
        return function(a3) {
          return pipe(as16, append4(a3));
        };
      }), fa2);
    });
  };
};
var traverseWithIndex = function(F5) {
  return function(f8) {
    return reduceWithIndex2(F5.of(zero()), function(i4, fbs, a3) {
      return F5.ap(F5.map(fbs, function(bs3) {
        return function(b4) {
          return pipe(bs3, append4(b4));
        };
      }), f8(i4, a3));
    });
  };
};
var URI4 = "ReadonlyArray";
var Functor4 = {
  URI: URI4,
  map: _map4
};
var flap5 = flap(Functor4);
var Pointed = {
  URI: URI4,
  of: of4
};
var Apply3 = {
  URI: URI4,
  map: _map4,
  ap: _ap3
};
var apFirst4 = apFirst(Apply3);
var apSecond4 = apSecond(Apply3);
var Chain3 = {
  URI: URI4,
  map: _map4,
  ap: _ap3,
  chain: flatMap3
};
var chainFirst4 = chainFirst(Chain3);
var Zero = {
  URI: URI4,
  zero
};
var guard3 = guard2(Zero, Pointed);
var Compactable = {
  URI: URI4,
  compact,
  separate
};
var Traversable = {
  URI: URI4,
  map: _map4,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence
};
var _wither = witherDefault(Traversable, Compactable);
var _wilt = wiltDefault(Traversable, Compactable);
var Witherable = {
  URI: URI4,
  map: _map4,
  compact,
  separate,
  filter: _filter,
  filterMap: _filterMap,
  partition: _partition,
  partitionMap: _partitionMap,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence,
  wither: _wither,
  wilt: _wilt
};
var filterE2 = filterE(Witherable);
var FromEither = {
  URI: URI4,
  fromEither
};
var fromEitherK2 = fromEitherK(FromEither);
var empty3 = empty2;
var Do6 = of4(emptyRecord);
var bindTo4 = bindTo(Functor4);
var let_4 = let_(Functor4);
var bind5 = bind2(Chain3);
var apS4 = apS(Apply3);

// node_modules/fp-ts/es6/Array.js
var append5 = append3;
var fromEither2 = function(e2) {
  return isLeft(e2) ? [] : [e2.right];
};
var chainWithIndex4 = function(f8) {
  return function(as16) {
    var out = [];
    for (var i4 = 0; i4 < as16.length; i4++) {
      var bs3 = f8(i4, as16[i4]);
      for (var j3 = 0; j3 < bs3.length; j3++) {
        out.push(bs3[j3]);
      }
    }
    return out;
  };
};
var _map5 = function(fa2, f8) {
  return pipe(fa2, map6(f8));
};
var _ap4 = function(fab, fa2) {
  return pipe(fab, ap5(fa2));
};
var _filter2 = function(fa2, predicate) {
  return pipe(fa2, filter3(predicate));
};
var _filterMap2 = function(fa2, f8) {
  return pipe(fa2, filterMap2(f8));
};
var _partition2 = function(fa2, predicate) {
  return pipe(fa2, partition2(predicate));
};
var _partitionMap2 = function(fa2, f8) {
  return pipe(fa2, partitionMap2(f8));
};
var _reduce2 = function(fa2, b4, f8) {
  return pipe(fa2, reduce3(b4, f8));
};
var _foldMap2 = function(M4) {
  var foldMapM = foldMap3(M4);
  return function(fa2, f8) {
    return pipe(fa2, foldMapM(f8));
  };
};
var _reduceRight2 = function(fa2, b4, f8) {
  return pipe(fa2, reduceRight3(b4, f8));
};
var _traverse2 = function(F5) {
  var traverseF = traverse2(F5);
  return function(ta2, f8) {
    return pipe(ta2, traverseF(f8));
  };
};
var of5 = of3;
var zero2 = function() {
  return [];
};
var map6 = function(f8) {
  return function(fa2) {
    return fa2.map(function(a3) {
      return f8(a3);
    });
  };
};
var ap5 = function(fa2) {
  return flatMap4(function(f8) {
    return pipe(fa2, map6(f8));
  });
};
var flatMap4 = dual(2, function(ma2, f8) {
  return pipe(ma2, chainWithIndex4(function(i4, a3) {
    return f8(a3, i4);
  }));
});
var flatten4 = flatMap4(identity3);
var filterMapWithIndex2 = function(f8) {
  return function(fa2) {
    var out = [];
    for (var i4 = 0; i4 < fa2.length; i4++) {
      var optionB = f8(i4, fa2[i4]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap2 = function(f8) {
  return filterMapWithIndex2(function(_3, a3) {
    return f8(a3);
  });
};
var compact2 = filterMap2(identity3);
var separate2 = function(fa2) {
  var left13 = [];
  var right13 = [];
  for (var _i4 = 0, fa_1 = fa2; _i4 < fa_1.length; _i4++) {
    var e2 = fa_1[_i4];
    if (e2._tag === "Left") {
      left13.push(e2.left);
    } else {
      right13.push(e2.right);
    }
  }
  return separated(left13, right13);
};
var filter3 = function(predicate) {
  return function(as16) {
    return as16.filter(predicate);
  };
};
var partition2 = function(predicate) {
  return partitionWithIndex2(function(_3, a3) {
    return predicate(a3);
  });
};
var partitionWithIndex2 = function(predicateWithIndex) {
  return function(as16) {
    var left13 = [];
    var right13 = [];
    for (var i4 = 0; i4 < as16.length; i4++) {
      var b4 = as16[i4];
      if (predicateWithIndex(i4, b4)) {
        right13.push(b4);
      } else {
        left13.push(b4);
      }
    }
    return separated(left13, right13);
  };
};
var partitionMap2 = function(f8) {
  return partitionMapWithIndex2(function(_3, a3) {
    return f8(a3);
  });
};
var partitionMapWithIndex2 = function(f8) {
  return function(fa2) {
    var left13 = [];
    var right13 = [];
    for (var i4 = 0; i4 < fa2.length; i4++) {
      var e2 = f8(i4, fa2[i4]);
      if (e2._tag === "Left") {
        left13.push(e2.left);
      } else {
        right13.push(e2.right);
      }
    }
    return separated(left13, right13);
  };
};
var extend5 = function(f8) {
  return function(wa2) {
    return wa2.map(function(_3, i4) {
      return f8(wa2.slice(i4));
    });
  };
};
var duplicate4 = extend5(identity3);
var foldMap3 = foldMap2;
var reduce3 = reduce2;
var reduceWithIndex3 = reduceWithIndex2;
var reduceRight3 = reduceRight2;
var traverse2 = function(F5) {
  var traverseWithIndexF = traverseWithIndex2(F5);
  return function(f8) {
    return traverseWithIndexF(function(_3, a3) {
      return f8(a3);
    });
  };
};
var sequence2 = function(F5) {
  return function(ta2) {
    return _reduce2(ta2, F5.of(zero2()), function(fas, fa2) {
      return F5.ap(F5.map(fas, function(as16) {
        return function(a3) {
          return pipe(as16, append5(a3));
        };
      }), fa2);
    });
  };
};
var traverseWithIndex2 = function(F5) {
  return function(f8) {
    return reduceWithIndex3(F5.of(zero2()), function(i4, fbs, a3) {
      return F5.ap(F5.map(fbs, function(bs3) {
        return function(b4) {
          return pipe(bs3, append5(b4));
        };
      }), f8(i4, a3));
    });
  };
};
var URI5 = "Array";
var getSemigroup2 = function() {
  return {
    concat: function(first2, second) {
      return first2.concat(second);
    }
  };
};
var getMonoid2 = function() {
  return {
    concat: getSemigroup2().concat,
    empty: []
  };
};
var Functor5 = {
  URI: URI5,
  map: _map5
};
var flap6 = flap(Functor5);
var Pointed2 = {
  URI: URI5,
  of: of5
};
var Apply4 = {
  URI: URI5,
  map: _map5,
  ap: _ap4
};
var apFirst5 = apFirst(Apply4);
var apSecond5 = apSecond(Apply4);
var Chain4 = {
  URI: URI5,
  map: _map5,
  ap: _ap4,
  chain: flatMap4
};
var chainFirst5 = chainFirst(Chain4);
var Zero2 = {
  URI: URI5,
  zero: zero2
};
var guard4 = guard2(Zero2, Pointed2);
var Compactable2 = {
  URI: URI5,
  compact: compact2,
  separate: separate2
};
var Traversable2 = {
  URI: URI5,
  map: _map5,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2,
  traverse: _traverse2,
  sequence: sequence2
};
var _wither2 = witherDefault(Traversable2, Compactable2);
var _wilt2 = wiltDefault(Traversable2, Compactable2);
var Witherable2 = {
  URI: URI5,
  map: _map5,
  compact: compact2,
  separate: separate2,
  filter: _filter2,
  filterMap: _filterMap2,
  partition: _partition2,
  partitionMap: _partitionMap2,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2,
  traverse: _traverse2,
  sequence: sequence2,
  wither: _wither2,
  wilt: _wilt2
};
var filterE3 = filterE(Witherable2);
var FromEither2 = {
  URI: URI5,
  fromEither: fromEither2
};
var fromEitherK3 = fromEitherK(FromEither2);
var Do7 = of5(emptyRecord);
var bindTo5 = bindTo(Functor5);
var let_5 = let_(Functor5);
var bind6 = bind2(Chain4);
var apS5 = apS(Apply4);

// node_modules/fp-ts/es6/boolean.js
var Eq2 = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var SemigroupAll = {
  concat: function(first2, second) {
    return first2 && second;
  }
};
var SemigroupAny = {
  concat: function(first2, second) {
    return first2 || second;
  }
};
var MonoidAll = {
  concat: SemigroupAll.concat,
  empty: true
};
var MonoidAny = {
  concat: SemigroupAny.concat,
  empty: false
};
var Ord2 = {
  equals: Eq2.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};

// node_modules/fp-ts/es6/Bounded.js
var boundedNumber = {
  equals: ordNumber.equals,
  compare: ordNumber.compare,
  top: Infinity,
  bottom: -Infinity
};

// node_modules/fp-ts/es6/ChainRec.js
var tailRec = function(startWith, f8) {
  var ab = f8(startWith);
  while (ab._tag === "Left") {
    ab = f8(ab.left);
  }
  return ab.right;
};

// node_modules/fp-ts/es6/Predicate.js
var not = function(predicate) {
  return function(a3) {
    return !predicate(a3);
  };
};

// node_modules/fp-ts/es6/Option.js
var none2 = none;
var some2 = some;
function fromPredicate2(predicate) {
  return function(a3) {
    return predicate(a3) ? some2(a3) : none2;
  };
}
var getLeft = function(ma2) {
  return ma2._tag === "Right" ? none2 : some2(ma2.left);
};
var getRight = function(ma2) {
  return ma2._tag === "Left" ? none2 : some2(ma2.right);
};
var _map6 = function(fa2, f8) {
  return pipe(fa2, map7(f8));
};
var _ap5 = function(fab, fa2) {
  return pipe(fab, ap6(fa2));
};
var _reduce3 = function(fa2, b4, f8) {
  return pipe(fa2, reduce4(b4, f8));
};
var _foldMap3 = function(M4) {
  var foldMapM = foldMap4(M4);
  return function(fa2, f8) {
    return pipe(fa2, foldMapM(f8));
  };
};
var _reduceRight3 = function(fa2, b4, f8) {
  return pipe(fa2, reduceRight4(b4, f8));
};
var _traverse3 = function(F5) {
  var traverseF = traverse3(F5);
  return function(ta2, f8) {
    return pipe(ta2, traverseF(f8));
  };
};
var _filter3 = function(fa2, predicate) {
  return pipe(fa2, filter4(predicate));
};
var _filterMap3 = function(fa2, f8) {
  return pipe(fa2, filterMap3(f8));
};
var _partition3 = function(fa2, predicate) {
  return pipe(fa2, partition3(predicate));
};
var _partitionMap3 = function(fa2, f8) {
  return pipe(fa2, partitionMap3(f8));
};
var URI6 = "Option";
var map7 = function(f8) {
  return function(fa2) {
    return isNone2(fa2) ? none2 : some2(f8(fa2.value));
  };
};
var Functor6 = {
  URI: URI6,
  map: _map6
};
var as3 = dual(2, as2(Functor6));
var asUnit2 = asUnit(Functor6);
var of6 = some2;
var Pointed3 = {
  URI: URI6,
  of: of6
};
var ap6 = function(fa2) {
  return function(fab) {
    return isNone2(fab) ? none2 : isNone2(fa2) ? none2 : some2(fab.value(fa2.value));
  };
};
var Apply5 = {
  URI: URI6,
  map: _map6,
  ap: _ap5
};
var Applicative = {
  URI: URI6,
  map: _map6,
  ap: _ap5,
  of: of6
};
var flatMap5 = dual(2, function(ma2, f8) {
  return isNone2(ma2) ? none2 : f8(ma2.value);
});
var Chain5 = {
  URI: URI6,
  map: _map6,
  ap: _ap5,
  chain: flatMap5
};
var reduce4 = function(b4, f8) {
  return function(fa2) {
    return isNone2(fa2) ? b4 : f8(b4, fa2.value);
  };
};
var foldMap4 = function(M4) {
  return function(f8) {
    return function(fa2) {
      return isNone2(fa2) ? M4.empty : f8(fa2.value);
    };
  };
};
var reduceRight4 = function(b4, f8) {
  return function(fa2) {
    return isNone2(fa2) ? b4 : f8(fa2.value, b4);
  };
};
var orElse = dual(2, function(self2, that) {
  return isNone2(self2) ? that() : self2;
});
var zero3 = function() {
  return none2;
};
var Zero3 = {
  URI: URI6,
  zero: zero3
};
var guard5 = guard2(Zero3, Pointed3);
var extend6 = function(f8) {
  return function(wa2) {
    return isNone2(wa2) ? none2 : some2(f8(wa2));
  };
};
var compact3 = flatMap5(identity3);
var defaultSeparated = separated(none2, none2);
var separate3 = function(ma2) {
  return isNone2(ma2) ? defaultSeparated : separated(getLeft(ma2.value), getRight(ma2.value));
};
var Compactable3 = {
  URI: URI6,
  compact: compact3,
  separate: separate3
};
var filter4 = function(predicate) {
  return function(fa2) {
    return isNone2(fa2) ? none2 : predicate(fa2.value) ? fa2 : none2;
  };
};
var filterMap3 = function(f8) {
  return function(fa2) {
    return isNone2(fa2) ? none2 : f8(fa2.value);
  };
};
var partition3 = function(predicate) {
  return function(fa2) {
    return separated(_filter3(fa2, not(predicate)), _filter3(fa2, predicate));
  };
};
var partitionMap3 = function(f8) {
  return flow(map7(f8), separate3);
};
var Filterable = {
  URI: URI6,
  map: _map6,
  compact: compact3,
  separate: separate3,
  filter: _filter3,
  filterMap: _filterMap3,
  partition: _partition3,
  partitionMap: _partitionMap3
};
var traverse3 = function(F5) {
  return function(f8) {
    return function(ta2) {
      return isNone2(ta2) ? F5.of(none2) : F5.map(f8(ta2.value), some2);
    };
  };
};
var sequence3 = function(F5) {
  return function(ta2) {
    return isNone2(ta2) ? F5.of(none2) : F5.map(ta2.value, some2);
  };
};
var Traversable3 = {
  URI: URI6,
  map: _map6,
  reduce: _reduce3,
  foldMap: _foldMap3,
  reduceRight: _reduceRight3,
  traverse: _traverse3,
  sequence: sequence3
};
var _wither3 = witherDefault(Traversable3, Compactable3);
var _wilt3 = wiltDefault(Traversable3, Compactable3);
var fromEither3 = getRight;
var FromEither3 = {
  URI: URI6,
  fromEither: fromEither3
};
var isNone2 = function(fa2) {
  return fa2._tag === "None";
};
var matchW = function(onNone, onSome) {
  return function(ma2) {
    return isNone2(ma2) ? onNone() : onSome(ma2.value);
  };
};
var match = matchW;
var flap7 = flap(Functor6);
var apFirst6 = apFirst(Apply5);
var apSecond6 = apSecond(Apply5);
var tap2 = dual(2, tap(Chain5));
var tapEither2 = dual(2, tapEither(FromEither3, Chain5));
var duplicate5 = extend6(identity3);
var fromEitherK4 = fromEitherK(FromEither3);
var chainEitherK2 = chainEitherK(FromEither3, Chain5);
var fromNullable = function(a3) {
  return a3 == null ? none2 : some2(a3);
};
var toNullable = match(constNull, identity3);
var toUndefined = match(constUndefined, identity3);
var Do8 = of6(emptyRecord);
var bindTo6 = bindTo(Functor6);
var let_6 = let_(Functor6);
var bind7 = bind2(Chain5);
var apS6 = apS(Apply5);
var ApT = of6(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex = function(f8) {
  return function(as16) {
    var o4 = f8(0, head(as16));
    if (isNone2(o4)) {
      return none2;
    }
    var out = [o4.value];
    for (var i4 = 1; i4 < as16.length; i4++) {
      var o_1 = f8(i4, as16[i4]);
      if (isNone2(o_1)) {
        return none2;
      }
      out.push(o_1.value);
    }
    return some2(out);
  };
};
var traverseReadonlyArrayWithIndex = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT;
  };
};
var traverseArray = function(f8) {
  return traverseReadonlyArrayWithIndex(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray = traverseArray(identity3);
var getApplySemigroup2 = getApplySemigroup(Apply5);
var getApplyMonoid = getApplicativeMonoid(Applicative);

// node_modules/fp-ts/es6/Compactable.js
function compact4(F5, G5) {
  return function(fga) {
    return F5.map(fga, G5.compact);
  };
}
function separate4(F5, C4, G5) {
  var _compact = compact4(F5, C4);
  var _map35 = map(F5, G5);
  return function(fge) {
    return separated(_compact(pipe(fge, _map35(getLeft))), _compact(pipe(fge, _map35(getRight))));
  };
}

// node_modules/fp-ts/es6/Const.js
var _map7 = function(fa2, f8) {
  return pipe(fa2, map8(f8));
};
var map8 = function() {
  return unsafeCoerce;
};
var URI7 = "Const";
var Functor7 = {
  URI: URI7,
  map: _map7
};
var flap8 = flap(Functor7);

// node_modules/fp-ts/es6/Date.js
var Ord3 = pipe(
  Ord,
  contramap(function(date) {
    return date.valueOf();
  })
);

// node_modules/fp-ts/es6/Either.js
var Either_exports = {};
__export(Either_exports, {
  Alt: () => Alt,
  ApT: () => ApT2,
  Applicative: () => Applicative2,
  Apply: () => Apply6,
  Bifunctor: () => Bifunctor,
  Chain: () => Chain6,
  ChainRec: () => ChainRec,
  Do: () => Do9,
  Extend: () => Extend,
  Foldable: () => Foldable,
  FromEither: () => FromEither4,
  Functor: () => Functor8,
  Monad: () => Monad,
  MonadThrow: () => MonadThrow,
  Pointed: () => Pointed4,
  Traversable: () => Traversable4,
  URI: () => URI8,
  alt: () => alt,
  altW: () => altW,
  ap: () => ap7,
  apFirst: () => apFirst7,
  apFirstW: () => apFirstW,
  apS: () => apS7,
  apSW: () => apSW,
  apSecond: () => apSecond7,
  apSecondW: () => apSecondW,
  apW: () => apW,
  as: () => as4,
  asUnit: () => asUnit3,
  bimap: () => bimap,
  bind: () => bind8,
  bindTo: () => bindTo7,
  bindW: () => bindW,
  chain: () => chain2,
  chainFirst: () => chainFirst6,
  chainFirstW: () => chainFirstW,
  chainNullableK: () => chainNullableK,
  chainOptionK: () => chainOptionK2,
  chainOptionKW: () => chainOptionKW,
  chainW: () => chainW,
  duplicate: () => duplicate6,
  either: () => either,
  elem: () => elem2,
  exists: () => exists,
  extend: () => extend7,
  filterOrElse: () => filterOrElse2,
  filterOrElseW: () => filterOrElseW,
  flap: () => flap9,
  flatMap: () => flatMap6,
  flatMapNullable: () => flatMapNullable2,
  flatMapOption: () => flatMapOption2,
  flatten: () => flatten5,
  flattenW: () => flattenW,
  fold: () => fold,
  foldMap: () => foldMap5,
  foldW: () => foldW,
  fromNullable: () => fromNullable2,
  fromNullableK: () => fromNullableK,
  fromOption: () => fromOption2,
  fromOptionK: () => fromOptionK2,
  fromPredicate: () => fromPredicate3,
  getAltValidation: () => getAltValidation,
  getApplicativeValidation: () => getApplicativeValidation,
  getApplyMonoid: () => getApplyMonoid2,
  getApplySemigroup: () => getApplySemigroup3,
  getCompactable: () => getCompactable,
  getEq: () => getEq3,
  getFilterable: () => getFilterable,
  getOrElse: () => getOrElse,
  getOrElseW: () => getOrElseW,
  getSemigroup: () => getSemigroup3,
  getShow: () => getShow3,
  getValidation: () => getValidation,
  getValidationMonoid: () => getValidationMonoid,
  getValidationSemigroup: () => getValidationSemigroup,
  getWitherable: () => getWitherable,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left3,
  let: () => let_7,
  liftNullable: () => liftNullable2,
  liftOption: () => liftOption2,
  map: () => map9,
  mapLeft: () => mapLeft,
  match: () => match2,
  matchW: () => matchW2,
  of: () => of7,
  orElse: () => orElse2,
  orElseW: () => orElseW,
  parseJSON: () => parseJSON,
  reduce: () => reduce5,
  reduceRight: () => reduceRight5,
  right: () => right3,
  sequence: () => sequence4,
  sequenceArray: () => sequenceArray2,
  stringifyJSON: () => stringifyJSON,
  swap: () => swap,
  tap: () => tap3,
  throwError: () => throwError,
  toError: () => toError,
  toUnion: () => toUnion,
  traverse: () => traverse4,
  traverseArray: () => traverseArray2,
  traverseArrayWithIndex: () => traverseArrayWithIndex,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex2,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex2,
  tryCatch: () => tryCatch,
  tryCatchK: () => tryCatchK
});
var left3 = left;
var right3 = right;
var flatMap6 = dual(2, function(ma2, f8) {
  return isLeft2(ma2) ? ma2 : f8(ma2.right);
});
var _map8 = function(fa2, f8) {
  return pipe(fa2, map9(f8));
};
var _ap6 = function(fab, fa2) {
  return pipe(fab, ap7(fa2));
};
var _reduce4 = function(fa2, b4, f8) {
  return pipe(fa2, reduce5(b4, f8));
};
var _foldMap4 = function(M4) {
  return function(fa2, f8) {
    var foldMapM = foldMap5(M4);
    return pipe(fa2, foldMapM(f8));
  };
};
var _reduceRight4 = function(fa2, b4, f8) {
  return pipe(fa2, reduceRight5(b4, f8));
};
var _traverse4 = function(F5) {
  var traverseF = traverse4(F5);
  return function(ta2, f8) {
    return pipe(ta2, traverseF(f8));
  };
};
var _bimap = function(fa2, f8, g3) {
  return pipe(fa2, bimap(f8, g3));
};
var _mapLeft = function(fa2, f8) {
  return pipe(fa2, mapLeft(f8));
};
var _alt = function(fa2, that) {
  return pipe(fa2, alt(that));
};
var _extend = function(wa2, f8) {
  return pipe(wa2, extend7(f8));
};
var _chainRec = function(a3, f8) {
  return tailRec(f8(a3), function(e2) {
    return isLeft2(e2) ? right3(left3(e2.left)) : isLeft2(e2.right) ? left3(f8(e2.right.left)) : right3(right3(e2.right.right));
  });
};
var URI8 = "Either";
var getShow3 = function(SE, SA) {
  return {
    show: function(ma2) {
      return isLeft2(ma2) ? "left(".concat(SE.show(ma2.left), ")") : "right(".concat(SA.show(ma2.right), ")");
    }
  };
};
var getEq3 = function(EL, EA) {
  return {
    equals: function(x5, y5) {
      return x5 === y5 || (isLeft2(x5) ? isLeft2(y5) && EL.equals(x5.left, y5.left) : isRight2(y5) && EA.equals(x5.right, y5.right));
    }
  };
};
var getSemigroup3 = function(S4) {
  return {
    concat: function(x5, y5) {
      return isLeft2(y5) ? x5 : isLeft2(x5) ? y5 : right3(S4.concat(x5.right, y5.right));
    }
  };
};
var getCompactable = function(M4) {
  var empty6 = left3(M4.empty);
  return {
    URI: URI8,
    _E: void 0,
    compact: function(ma2) {
      return isLeft2(ma2) ? ma2 : ma2.right._tag === "None" ? empty6 : right3(ma2.right.value);
    },
    separate: function(ma2) {
      return isLeft2(ma2) ? separated(ma2, ma2) : isLeft2(ma2.right) ? separated(right3(ma2.right.left), empty6) : separated(empty6, right3(ma2.right.right));
    }
  };
};
var getFilterable = function(M4) {
  var empty6 = left3(M4.empty);
  var _a21 = getCompactable(M4), compact9 = _a21.compact, separate9 = _a21.separate;
  var filter10 = function(ma2, predicate) {
    return isLeft2(ma2) ? ma2 : predicate(ma2.right) ? ma2 : empty6;
  };
  var partition8 = function(ma2, p4) {
    return isLeft2(ma2) ? separated(ma2, ma2) : p4(ma2.right) ? separated(empty6, right3(ma2.right)) : separated(right3(ma2.right), empty6);
  };
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    compact: compact9,
    separate: separate9,
    filter: filter10,
    filterMap: function(ma2, f8) {
      if (isLeft2(ma2)) {
        return ma2;
      }
      var ob = f8(ma2.right);
      return ob._tag === "None" ? empty6 : right3(ob.value);
    },
    partition: partition8,
    partitionMap: function(ma2, f8) {
      if (isLeft2(ma2)) {
        return separated(ma2, ma2);
      }
      var e2 = f8(ma2.right);
      return isLeft2(e2) ? separated(right3(e2.left), empty6) : separated(empty6, right3(e2.right));
    }
  };
};
var getWitherable = function(M4) {
  var F_ = getFilterable(M4);
  var C4 = getCompactable(M4);
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    compact: F_.compact,
    separate: F_.separate,
    filter: F_.filter,
    filterMap: F_.filterMap,
    partition: F_.partition,
    partitionMap: F_.partitionMap,
    traverse: _traverse4,
    sequence: sequence4,
    reduce: _reduce4,
    foldMap: _foldMap4,
    reduceRight: _reduceRight4,
    wither: witherDefault(Traversable4, C4),
    wilt: wiltDefault(Traversable4, C4)
  };
};
var getApplicativeValidation = function(SE) {
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    ap: function(fab, fa2) {
      return isLeft2(fab) ? isLeft2(fa2) ? left3(SE.concat(fab.left, fa2.left)) : fab : isLeft2(fa2) ? fa2 : right3(fab.right(fa2.right));
    },
    of: of7
  };
};
var getAltValidation = function(SE) {
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    alt: function(me4, that) {
      if (isRight2(me4)) {
        return me4;
      }
      var ea2 = that();
      return isLeft2(ea2) ? left3(SE.concat(me4.left, ea2.left)) : ea2;
    }
  };
};
var map9 = function(f8) {
  return function(fa2) {
    return isLeft2(fa2) ? fa2 : right3(f8(fa2.right));
  };
};
var Functor8 = {
  URI: URI8,
  map: _map8
};
var as4 = dual(2, as2(Functor8));
var asUnit3 = asUnit(Functor8);
var of7 = right3;
var Pointed4 = {
  URI: URI8,
  of: of7
};
var apW = function(fa2) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa2) ? fa2 : right3(fab.right(fa2.right));
  };
};
var ap7 = apW;
var Apply6 = {
  URI: URI8,
  map: _map8,
  ap: _ap6
};
var Applicative2 = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  of: of7
};
var Chain6 = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  chain: flatMap6
};
var Monad = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  of: of7,
  chain: flatMap6
};
var reduce5 = function(b4, f8) {
  return function(fa2) {
    return isLeft2(fa2) ? b4 : f8(b4, fa2.right);
  };
};
var foldMap5 = function(M4) {
  return function(f8) {
    return function(fa2) {
      return isLeft2(fa2) ? M4.empty : f8(fa2.right);
    };
  };
};
var reduceRight5 = function(b4, f8) {
  return function(fa2) {
    return isLeft2(fa2) ? b4 : f8(fa2.right, b4);
  };
};
var Foldable = {
  URI: URI8,
  reduce: _reduce4,
  foldMap: _foldMap4,
  reduceRight: _reduceRight4
};
var traverse4 = function(F5) {
  return function(f8) {
    return function(ta2) {
      return isLeft2(ta2) ? F5.of(left3(ta2.left)) : F5.map(f8(ta2.right), right3);
    };
  };
};
var sequence4 = function(F5) {
  return function(ma2) {
    return isLeft2(ma2) ? F5.of(left3(ma2.left)) : F5.map(ma2.right, right3);
  };
};
var Traversable4 = {
  URI: URI8,
  map: _map8,
  reduce: _reduce4,
  foldMap: _foldMap4,
  reduceRight: _reduceRight4,
  traverse: _traverse4,
  sequence: sequence4
};
var bimap = function(f8, g3) {
  return function(fa2) {
    return isLeft2(fa2) ? left3(f8(fa2.left)) : right3(g3(fa2.right));
  };
};
var mapLeft = function(f8) {
  return function(fa2) {
    return isLeft2(fa2) ? left3(f8(fa2.left)) : fa2;
  };
};
var Bifunctor = {
  URI: URI8,
  bimap: _bimap,
  mapLeft: _mapLeft
};
var altW = function(that) {
  return function(fa2) {
    return isLeft2(fa2) ? that() : fa2;
  };
};
var alt = altW;
var Alt = {
  URI: URI8,
  map: _map8,
  alt: _alt
};
var extend7 = function(f8) {
  return function(wa2) {
    return isLeft2(wa2) ? wa2 : right3(f8(wa2));
  };
};
var Extend = {
  URI: URI8,
  map: _map8,
  extend: _extend
};
var ChainRec = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  chain: flatMap6,
  chainRec: _chainRec
};
var throwError = left3;
var MonadThrow = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  of: of7,
  chain: flatMap6,
  throwError
};
var FromEither4 = {
  URI: URI8,
  fromEither: identity3
};
var fromPredicate3 = fromPredicate(FromEither4);
var fromOption2 = fromOption(FromEither4);
var isLeft2 = isLeft;
var isRight2 = isRight;
var matchW2 = function(onLeft, onRight) {
  return function(ma2) {
    return isLeft2(ma2) ? onLeft(ma2.left) : onRight(ma2.right);
  };
};
var foldW = matchW2;
var match2 = matchW2;
var fold = match2;
var getOrElseW = function(onLeft) {
  return function(ma2) {
    return isLeft2(ma2) ? onLeft(ma2.left) : ma2.right;
  };
};
var getOrElse = getOrElseW;
var flap9 = flap(Functor8);
var apFirst7 = apFirst(Apply6);
var apFirstW = apFirst7;
var apSecond7 = apSecond(Apply6);
var apSecondW = apSecond7;
var tap3 = dual(2, tap(Chain6));
var flattenW = flatMap6(identity3);
var flatten5 = flattenW;
var duplicate6 = extend7(identity3);
var fromOptionK2 = fromOptionK(FromEither4);
var chainOptionK2 = chainOptionK(FromEither4, Chain6);
var chainOptionKW = chainOptionK2;
var _FromEither = {
  fromEither: FromEither4.fromEither
};
var liftNullable2 = liftNullable(_FromEither);
var liftOption2 = liftOption(_FromEither);
var _FlatMap = {
  flatMap: flatMap6
};
var flatMapNullable2 = flatMapNullable(_FromEither, _FlatMap);
var flatMapOption2 = flatMapOption(_FromEither, _FlatMap);
var filterOrElse2 = filterOrElse(FromEither4, Chain6);
var filterOrElseW = filterOrElse2;
var swap = function(ma2) {
  return isLeft2(ma2) ? right3(ma2.left) : left3(ma2.right);
};
var orElseW = function(onLeft) {
  return function(ma2) {
    return isLeft2(ma2) ? onLeft(ma2.left) : ma2;
  };
};
var orElse2 = orElseW;
var fromNullable2 = function(e2) {
  return function(a3) {
    return a3 == null ? left3(e2) : right3(a3);
  };
};
var tryCatch = function(f8, onThrow) {
  try {
    return right3(f8());
  } catch (e2) {
    return left3(onThrow(e2));
  }
};
var tryCatchK = function(f8, onThrow) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return tryCatch(function() {
      return f8.apply(void 0, a3);
    }, onThrow);
  };
};
var fromNullableK = function(e2) {
  var from13 = fromNullable2(e2);
  return function(f8) {
    return flow(f8, from13);
  };
};
var chainNullableK = function(e2) {
  var from13 = fromNullableK(e2);
  return function(f8) {
    return flatMap6(from13(f8));
  };
};
var toUnion = foldW(identity3, identity3);
function toError(e2) {
  try {
    return e2 instanceof Error ? e2 : new Error(String(e2));
  } catch (error) {
    return new Error();
  }
}
function elem2(E4) {
  return function(a3, ma2) {
    if (ma2 === void 0) {
      var elemE_1 = elem2(E4);
      return function(ma3) {
        return elemE_1(a3, ma3);
      };
    }
    return isLeft2(ma2) ? false : E4.equals(a3, ma2.right);
  };
}
var exists = function(predicate) {
  return function(ma2) {
    return isLeft2(ma2) ? false : predicate(ma2.right);
  };
};
var Do9 = of7(emptyRecord);
var bindTo7 = bindTo(Functor8);
var let_7 = let_(Functor8);
var bind8 = bind2(Chain6);
var bindW = bind8;
var apS7 = apS(Apply6);
var apSW = apS7;
var ApT2 = of7(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex2 = function(f8) {
  return function(as16) {
    var e2 = f8(0, head(as16));
    if (isLeft2(e2)) {
      return e2;
    }
    var out = [e2.right];
    for (var i4 = 1; i4 < as16.length; i4++) {
      var e_1 = f8(i4, as16[i4]);
      if (isLeft2(e_1)) {
        return e_1;
      }
      out.push(e_1.right);
    }
    return right3(out);
  };
};
var traverseReadonlyArrayWithIndex2 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex2(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT2;
  };
};
var traverseArrayWithIndex = traverseReadonlyArrayWithIndex2;
var traverseArray2 = function(f8) {
  return traverseReadonlyArrayWithIndex2(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray2 = traverseArray2(identity3);
var chainW = flatMap6;
var chain2 = flatMap6;
var chainFirst6 = tap3;
var chainFirstW = tap3;
function parseJSON(s3, onError) {
  return tryCatch(function() {
    return JSON.parse(s3);
  }, onError);
}
var stringifyJSON = function(u2, onError) {
  return tryCatch(function() {
    var s3 = JSON.stringify(u2);
    if (typeof s3 !== "string") {
      throw new Error("Converting unsupported structure to JSON");
    }
    return s3;
  }, onError);
};
var either = {
  URI: URI8,
  map: _map8,
  of: of7,
  ap: _ap6,
  chain: flatMap6,
  reduce: _reduce4,
  foldMap: _foldMap4,
  reduceRight: _reduceRight4,
  traverse: _traverse4,
  sequence: sequence4,
  bimap: _bimap,
  mapLeft: _mapLeft,
  alt: _alt,
  extend: _extend,
  chainRec: _chainRec,
  throwError
};
var getApplySemigroup3 = getApplySemigroup(Apply6);
var getApplyMonoid2 = getApplicativeMonoid(Applicative2);
var getValidationSemigroup = function(SE, SA) {
  return getApplySemigroup(getApplicativeValidation(SE))(SA);
};
var getValidationMonoid = function(SE, MA) {
  return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
};
function getValidation(SE) {
  var ap26 = getApplicativeValidation(SE).ap;
  var alt10 = getAltValidation(SE).alt;
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    of: of7,
    chain: flatMap6,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce4,
    foldMap: _foldMap4,
    reduceRight: _reduceRight4,
    extend: _extend,
    traverse: _traverse4,
    sequence: sequence4,
    chainRec: _chainRec,
    throwError,
    ap: ap26,
    alt: alt10
  };
}

// node_modules/fp-ts/es6/EitherT.js
function right4(F5) {
  return flow(right3, F5.of);
}
function left4(F5) {
  return flow(left3, F5.of);
}
function rightF(F5) {
  return function(fa2) {
    return F5.map(fa2, right3);
  };
}
function leftF(F5) {
  return function(fe5) {
    return F5.map(fe5, left3);
  };
}
function fromNullable3(F5) {
  return function(e2) {
    return flow(fromNullable2(e2), F5.of);
  };
}
function fromNullableK2(F5) {
  var fromNullableF = fromNullable3(F5);
  return function(e2) {
    var fromNullableFE = fromNullableF(e2);
    return function(f8) {
      return flow(f8, fromNullableFE);
    };
  };
}
function chainNullableK2(M4) {
  var chainM = chain3(M4);
  var fromNullableKM = fromNullableK2(M4);
  return function(e2) {
    var fromNullableKMe = fromNullableKM(e2);
    return function(f8) {
      return chainM(fromNullableKMe(f8));
    };
  };
}
function map10(F5) {
  return map(F5, Functor8);
}
function ap8(F5) {
  return ap(F5, Apply6);
}
function chain3(M4) {
  var flatMapM = flatMap7(M4);
  return function(f8) {
    return function(ma2) {
      return flatMapM(ma2, f8);
    };
  };
}
function flatMap7(M4) {
  return function(ma2, f8) {
    return M4.chain(ma2, function(e2) {
      return isLeft2(e2) ? M4.of(e2) : f8(e2.right);
    });
  };
}
function alt2(M4) {
  return function(second) {
    return function(first2) {
      return M4.chain(first2, function(e2) {
        return isLeft2(e2) ? second() : M4.of(e2);
      });
    };
  };
}
function mapBoth(F5) {
  return function(self2, f8, g3) {
    return F5.map(self2, bimap(f8, g3));
  };
}
function mapError(F5) {
  return function(self2, f8) {
    return F5.map(self2, mapLeft(f8));
  };
}
function match3(F5) {
  return function(onLeft, onRight) {
    return function(ma2) {
      return F5.map(ma2, match2(onLeft, onRight));
    };
  };
}
function matchE(M4) {
  return function(onLeft, onRight) {
    return function(ma2) {
      return M4.chain(ma2, match2(onLeft, onRight));
    };
  };
}
function getOrElse2(M4) {
  return function(onLeft) {
    return function(ma2) {
      return M4.chain(ma2, match2(onLeft, M4.of));
    };
  };
}
function orElse3(M4) {
  return function(onLeft) {
    return function(ma2) {
      return M4.chain(ma2, function(e2) {
        return isLeft2(e2) ? onLeft(e2.left) : M4.of(e2);
      });
    };
  };
}
function tapError(M4) {
  var orElseM = orElse3(M4);
  return function(ma2, onLeft) {
    return pipe(ma2, orElseM(function(e2) {
      return M4.map(onLeft(e2), function(eb) {
        return isLeft2(eb) ? eb : left3(e2);
      });
    }));
  };
}
function orLeft(M4) {
  return function(onLeft) {
    return function(ma2) {
      return M4.chain(ma2, match2(function(e2) {
        return M4.map(onLeft(e2), left3);
      }, function(a3) {
        return M4.of(right3(a3));
      }));
    };
  };
}
function swap2(F5) {
  return function(ma2) {
    return F5.map(ma2, swap);
  };
}
function toUnion2(F5) {
  return function(fa2) {
    return F5.map(fa2, toUnion);
  };
}

// node_modules/fp-ts/es6/Filterable.js
function filter5(F5, G5) {
  return function(predicate) {
    return function(fga) {
      return F5.map(fga, function(ga2) {
        return G5.filter(ga2, predicate);
      });
    };
  };
}
function filterMap4(F5, G5) {
  return function(f8) {
    return function(fga) {
      return F5.map(fga, function(ga2) {
        return G5.filterMap(ga2, f8);
      });
    };
  };
}
function partition4(F5, G5) {
  var _filter6 = filter5(F5, G5);
  return function(predicate) {
    var left13 = _filter6(not(predicate));
    var right13 = _filter6(predicate);
    return function(fgb) {
      return separated(left13(fgb), right13(fgb));
    };
  };
}
function partitionMap4(F5, G5) {
  var _filterMap6 = filterMap4(F5, G5);
  return function(f8) {
    return function(fga) {
      return separated(pipe(fga, _filterMap6(function(a3) {
        return getLeft(f8(a3));
      })), pipe(fga, _filterMap6(function(a3) {
        return getRight(f8(a3));
      })));
    };
  };
}

// node_modules/fp-ts/es6/FromIO.js
function fromIOK(F5) {
  return function(f8) {
    return flow(f8, F5.fromIO);
  };
}
function tapIO(F5, M4) {
  var chainFirstM = tap(M4);
  return function(self2, f8) {
    return chainFirstM(self2, flow(f8, F5.fromIO));
  };
}

// node_modules/fp-ts/es6/Reader.js
var ask = function() {
  return identity3;
};
var _map9 = function(fa2, f8) {
  return pipe(fa2, map11(f8));
};
var _ap7 = function(fab, fa2) {
  return pipe(fab, ap9(fa2));
};
var map11 = function(f8) {
  return function(fa2) {
    return function(r3) {
      return f8(fa2(r3));
    };
  };
};
var apW2 = function(fa2) {
  return function(fab) {
    return function(r3) {
      return fab(r3)(fa2(r3));
    };
  };
};
var ap9 = apW2;
var of8 = constant;
var flatMap8 = dual(2, function(ma2, f8) {
  return function(r3) {
    return f8(ma2(r3))(r3);
  };
});
var flattenW2 = flatMap8(identity3);
var URI9 = "Reader";
var Functor9 = {
  URI: URI9,
  map: _map9
};
var flap10 = flap(Functor9);
var Pointed5 = {
  URI: URI9,
  of: of8
};
var Apply7 = {
  URI: URI9,
  map: _map9,
  ap: _ap7
};
var apFirst8 = apFirst(Apply7);
var apSecond8 = apSecond(Apply7);
var Applicative3 = {
  URI: URI9,
  map: _map9,
  ap: _ap7,
  of: of8
};
var Chain7 = {
  URI: URI9,
  map: _map9,
  ap: _ap7,
  chain: flatMap8
};
var Monad2 = {
  URI: URI9,
  map: _map9,
  of: of8,
  ap: _ap7,
  chain: flatMap8
};
var tap4 = dual(2, tap(Chain7));
var bindTo8 = bindTo(Functor9);
var let_8 = let_(Functor9);
var bind9 = bind2(Chain7);
var Do10 = of8(emptyRecord);
var apS8 = apS(Apply7);
var ApT3 = of8(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex3 = function(f8) {
  return function(as16) {
    return function(r3) {
      var out = [f8(0, head(as16))(r3)];
      for (var i4 = 1; i4 < as16.length; i4++) {
        out.push(f8(i4, as16[i4])(r3));
      }
      return out;
    };
  };
};
var traverseReadonlyArrayWithIndex3 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex3(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT3;
  };
};
var traverseArray3 = function(f8) {
  return traverseReadonlyArrayWithIndex3(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray3 = traverseArray3(identity3);
var getSemigroup4 = getApplySemigroup(Apply7);
var getMonoid3 = getApplicativeMonoid(Applicative3);

// node_modules/fp-ts/es6/FromReader.js
function ask2(F5) {
  return function() {
    return F5.fromReader(ask());
  };
}
function asks(F5) {
  return F5.fromReader;
}
function fromReaderK(F5) {
  return function(f8) {
    return flow(f8, F5.fromReader);
  };
}
function tapReader(F5, M4) {
  var tapM = tap(M4);
  return function(self2, f8) {
    return tapM(self2, flow(f8, F5.fromReader));
  };
}

// node_modules/fp-ts/es6/State.js
var get6 = function() {
  return function(s3) {
    return [s3, s3];
  };
};
var put = function(s3) {
  return function() {
    return [void 0, s3];
  };
};
var modify = function(f8) {
  return function(s3) {
    return [void 0, f8(s3)];
  };
};
var gets = function(f8) {
  return function(s3) {
    return [f8(s3), s3];
  };
};
var _map10 = function(fa2, f8) {
  return pipe(fa2, map12(f8));
};
var _ap8 = function(fab, fa2) {
  return pipe(fab, ap10(fa2));
};
var map12 = function(f8) {
  return function(fa2) {
    return function(s1) {
      var _a21 = fa2(s1), a3 = _a21[0], s22 = _a21[1];
      return [f8(a3), s22];
    };
  };
};
var ap10 = function(fa2) {
  return function(fab) {
    return function(s1) {
      var _a21 = fab(s1), f8 = _a21[0], s22 = _a21[1];
      var _b = fa2(s22), a3 = _b[0], s3 = _b[1];
      return [f8(a3), s3];
    };
  };
};
var of9 = function(a3) {
  return function(s3) {
    return [a3, s3];
  };
};
var flatMap9 = dual(2, function(ma2, f8) {
  return function(s1) {
    var _a21 = ma2(s1), a3 = _a21[0], s22 = _a21[1];
    return f8(a3)(s22);
  };
});
var flatten6 = flatMap9(identity3);
var URI10 = "State";
var Functor10 = {
  URI: URI10,
  map: _map10
};
var flap11 = flap(Functor10);
var Apply8 = {
  URI: URI10,
  map: _map10,
  ap: _ap8
};
var apFirst9 = apFirst(Apply8);
var apSecond9 = apSecond(Apply8);
var Chain8 = {
  URI: URI10,
  map: _map10,
  ap: _ap8,
  chain: flatMap9
};
var tap5 = dual(2, tap(Chain8));
var bindTo9 = bindTo(Functor10);
var let_9 = let_(Functor10);
var bind10 = bind2(Chain8);
var apS9 = apS(Apply8);
var traverseReadonlyNonEmptyArrayWithIndex4 = function(f8) {
  return function(as16) {
    return function(s3) {
      var _a21 = f8(0, head(as16))(s3), b4 = _a21[0], s22 = _a21[1];
      var bs3 = [b4];
      var out = s22;
      for (var i4 = 1; i4 < as16.length; i4++) {
        var _b = f8(i4, as16[i4])(out), b_1 = _b[0], s2_1 = _b[1];
        bs3.push(b_1);
        out = s2_1;
      }
      return [bs3, out];
    };
  };
};
var traverseReadonlyArrayWithIndex4 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex4(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : of9(emptyReadonlyArray);
  };
};
var traverseArray4 = function(f8) {
  return traverseReadonlyArrayWithIndex4(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray4 = traverseArray4(identity3);

// node_modules/fp-ts/es6/FromState.js
function get7(F5) {
  return function() {
    return F5.fromState(get6());
  };
}
function put2(F5) {
  return function(s3) {
    return F5.fromState(put(s3));
  };
}
function modify2(F5) {
  return flow(modify, F5.fromState);
}
function gets2(F5) {
  return flow(gets, F5.fromState);
}
function fromStateK(F5) {
  return function(f8) {
    return flow(f8, F5.fromState);
  };
}
function chainStateK(F5, M4) {
  var fromStateKF = fromStateK(F5);
  return function(f8) {
    return function(ma2) {
      return M4.chain(ma2, fromStateKF(f8));
    };
  };
}

// node_modules/fp-ts/es6/FromTask.js
function fromTaskK(F5) {
  return function(f8) {
    return flow(f8, F5.fromTask);
  };
}
function tapTask(F5, M4) {
  var tapM = tap(M4);
  return function(self2, f8) {
    return tapM(self2, flow(f8, F5.fromTask));
  };
}

// node_modules/fp-ts/es6/FromThese.js
function fromTheseK(F5) {
  return function(f8) {
    return flow(f8, F5.fromThese);
  };
}

// node_modules/fp-ts/es6/Identity.js
var _map11 = function(fa2, f8) {
  return pipe(fa2, map13(f8));
};
var _ap9 = function(fab, fa2) {
  return pipe(fab, ap11(fa2));
};
var map13 = function(f8) {
  return function(fa2) {
    return f8(fa2);
  };
};
var ap11 = function(fa2) {
  return function(fab) {
    return fab(fa2);
  };
};
var of10 = identity3;
var flatMap10 = dual(2, function(ma2, f8) {
  return f8(ma2);
});
var extend8 = function(f8) {
  return function(wa2) {
    return f8(wa2);
  };
};
var duplicate7 = extend8(identity3);
var flatten7 = flatMap10(identity3);
var URI11 = "Identity";
var Functor11 = {
  URI: URI11,
  map: _map11
};
var flap12 = flap(Functor11);
var Apply9 = {
  URI: URI11,
  map: _map11,
  ap: _ap9
};
var apFirst10 = apFirst(Apply9);
var apSecond10 = apSecond(Apply9);
var Chain9 = {
  URI: URI11,
  map: _map11,
  ap: _ap9,
  chain: flatMap10
};
var tap6 = dual(2, tap(Chain9));
var Do11 = of10(emptyRecord);
var bindTo10 = bindTo(Functor11);
var let_10 = let_(Functor11);
var bind11 = bind2(Chain9);
var apS10 = apS(Apply9);

// node_modules/fp-ts/es6/IO.js
var _map12 = function(ma2, f8) {
  return function() {
    return f8(ma2());
  };
};
var _ap10 = function(mab, ma2) {
  return function() {
    return mab()(ma2());
  };
};
var map14 = function(f8) {
  return function(fa2) {
    return _map12(fa2, f8);
  };
};
var of11 = constant;
var flatMap11 = dual(2, function(ma2, f8) {
  return function() {
    return f8(ma2())();
  };
});
var flatten8 = flatMap11(identity3);
var URI12 = "IO";
var Functor12 = {
  URI: URI12,
  map: _map12
};
var as5 = dual(2, as2(Functor12));
var asUnit4 = asUnit(Functor12);
var flap13 = flap(Functor12);
var Pointed6 = {
  URI: URI12,
  of: of11
};
var Apply10 = {
  URI: URI12,
  map: _map12,
  ap: _ap10
};
var apFirst11 = apFirst(Apply10);
var apSecond11 = apSecond(Apply10);
var Applicative4 = {
  URI: URI12,
  map: _map12,
  ap: _ap10,
  of: of11
};
var Chain10 = {
  URI: URI12,
  map: _map12,
  ap: _ap10,
  chain: flatMap11
};
var Monad3 = {
  URI: URI12,
  map: _map12,
  ap: _ap10,
  of: of11,
  chain: flatMap11
};
var tap7 = dual(2, tap(Chain10));
var Do12 = of11(emptyRecord);
var bindTo11 = bindTo(Functor12);
var let_11 = let_(Functor12);
var bind12 = bind2(Chain10);
var apS11 = apS(Apply10);
var ApT4 = of11(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex5 = function(f8) {
  return function(as16) {
    return function() {
      var out = [f8(0, head(as16))()];
      for (var i4 = 1; i4 < as16.length; i4++) {
        out.push(f8(i4, as16[i4])());
      }
      return out;
    };
  };
};
var traverseReadonlyArrayWithIndex5 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex5(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT4;
  };
};
var traverseArray5 = function(f8) {
  return traverseReadonlyArrayWithIndex5(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray5 = traverseArray5(identity3);
var getSemigroup5 = getApplySemigroup(Apply10);
var getMonoid4 = getApplicativeMonoid(Applicative4);

// node_modules/fp-ts/es6/IOEither.js
var left5 = left4(Pointed6);
var right5 = right4(Pointed6);
var rightIO = rightF(Functor12);
var leftIO = leftF(Functor12);
var fromEither4 = of11;
var fromIO = rightIO;
var match4 = match3(Functor12);
var matchE2 = matchE(Monad3);
var getOrElse3 = getOrElse2(Monad3);
var toUnion3 = toUnion2(Functor12);
var orElse4 = orElse3(Monad3);
var tapError2 = dual(2, tapError(Monad3));
var orLeft2 = orLeft(Monad3);
var swap3 = swap2(Functor12);
var _map13 = function(fa2, f8) {
  return pipe(fa2, map15(f8));
};
var _ap11 = function(fab, fa2) {
  return pipe(fab, ap12(fa2));
};
var map15 = map10(Functor12);
var mapBoth2 = dual(3, mapBoth(Functor12));
var mapError2 = dual(2, mapError(Functor12));
var ap12 = ap8(Apply10);
var of12 = right5;
var flatMap12 = dual(2, flatMap7(Monad3));
var flattenW3 = flatMap12(identity3);
var alt3 = alt2(Monad3);
var URI13 = "IOEither";
var Functor13 = {
  URI: URI13,
  map: _map13
};
var as6 = dual(2, as2(Functor13));
var asUnit5 = asUnit(Functor13);
var flap14 = flap(Functor13);
var ApplyPar = {
  URI: URI13,
  map: _map13,
  ap: _ap11
};
var apFirst12 = apFirst(ApplyPar);
var apSecond12 = apSecond(ApplyPar);
var ApplicativePar = {
  URI: URI13,
  map: _map13,
  ap: _ap11,
  of: of12
};
var Chain11 = {
  URI: URI13,
  map: _map13,
  ap: _ap11,
  chain: flatMap12
};
var FromEither5 = {
  URI: URI13,
  fromEither: fromEither4
};
var FromIO = {
  URI: URI13,
  fromIO
};
var tap8 = dual(2, tap(Chain11));
var tapEither3 = dual(2, tapEither(FromEither5, Chain11));
var tapIO2 = dual(2, tapIO(FromIO, Chain11));
var fromIOK2 = fromIOK(FromIO);
var fromOption3 = fromOption(FromEither5);
var fromOptionK3 = fromOptionK(FromEither5);
var chainOptionK3 = chainOptionK(FromEither5, Chain11);
var _FromEither2 = {
  fromEither: FromEither5.fromEither
};
var _FromIO = {
  fromIO
};
var liftNullable3 = liftNullable(_FromEither2);
var liftOption3 = liftOption(_FromEither2);
var _FlatMap2 = {
  flatMap: flatMap12
};
var flatMapNullable3 = flatMapNullable(_FromEither2, _FlatMap2);
var flatMapOption3 = flatMapOption(_FromEither2, _FlatMap2);
var flatMapEither2 = flatMapEither(_FromEither2, _FlatMap2);
var flatMapIO2 = flatMapIO(_FromIO, _FlatMap2);
var fromPredicate4 = fromPredicate(FromEither5);
var filterOrElse3 = filterOrElse(FromEither5, Chain11);
var fromEitherK5 = fromEitherK(FromEither5);
var Do13 = of12(emptyRecord);
var bindTo12 = bindTo(Functor13);
var let_12 = let_(Functor13);
var bind13 = bind2(Chain11);
var apS12 = apS(ApplyPar);
var ApT5 = of12(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex6 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex5(f8), map14(traverseReadonlyNonEmptyArrayWithIndex2(SK)));
};
var traverseReadonlyArrayWithIndex6 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex6(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT5;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f8) {
  return function(as16) {
    return function() {
      var e2 = f8(0, head(as16))();
      if (isLeft(e2)) {
        return e2;
      }
      var out = [e2.right];
      for (var i4 = 1; i4 < as16.length; i4++) {
        var e_1 = f8(i4, as16[i4])();
        if (isLeft(e_1)) {
          return e_1;
        }
        out.push(e_1.right);
      }
      return right(out);
    };
  };
};
var traverseReadonlyArrayWithIndexSeq = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndexSeq(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT5;
  };
};
var traverseArray6 = function(f8) {
  return traverseReadonlyArrayWithIndex6(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray6 = traverseArray6(identity3);
var traverseSeqArray = function(f8) {
  return traverseReadonlyArrayWithIndexSeq(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceSeqArray = traverseSeqArray(identity3);
var getApplySemigroup4 = getApplySemigroup(ApplyPar);
var getApplyMonoid3 = getApplicativeMonoid(ApplicativePar);

// node_modules/fp-ts/es6/OptionT.js
function some3(F5) {
  return flow(some2, F5.of);
}
function zero4(F5) {
  return constant(F5.of(none2));
}
function fromF(F5) {
  return function(ma2) {
    return F5.map(ma2, some2);
  };
}
function fromNullable4(F5) {
  return flow(fromNullable, F5.of);
}
function fromNullableK3(F5) {
  var fromNullableF = fromNullable4(F5);
  return function(f8) {
    return flow(f8, fromNullableF);
  };
}
function chainNullableK3(M4) {
  var chainM = chain4(M4);
  var fromNullableKM = fromNullableK3(M4);
  return function(f8) {
    return chainM(fromNullableKM(f8));
  };
}
function fromOptionK4(F5) {
  return function(f8) {
    return flow(f8, F5.of);
  };
}
function chainOptionK4(M4) {
  var chainM = chain4(M4);
  var fromOptionKM = fromOptionK4(M4);
  return function(f8) {
    return chainM(fromOptionKM(f8));
  };
}
function fromPredicate5(F5) {
  return function(predicate) {
    return function(a3) {
      return F5.of(fromPredicate2(predicate)(a3));
    };
  };
}
function fromEither5(F5) {
  return flow(fromEither3, F5.of);
}
function match5(F5) {
  return function(onNone, onSome) {
    return function(ma2) {
      return F5.map(ma2, match(onNone, onSome));
    };
  };
}
function matchE3(M4) {
  return function(onNone, onSome) {
    return function(ma2) {
      return M4.chain(ma2, match(onNone, onSome));
    };
  };
}
function getOrElse4(M4) {
  return function(onNone) {
    return function(fa2) {
      return M4.chain(fa2, match(onNone, M4.of));
    };
  };
}
function map16(F5) {
  return map(F5, Functor6);
}
function ap13(F5) {
  return ap(F5, Apply5);
}
function chain4(M4) {
  var flatMapM = flatMap13(M4);
  return function(f8) {
    return function(ma2) {
      return flatMapM(ma2, f8);
    };
  };
}
function flatMap13(M4) {
  var zeroM = zero4(M4);
  return function(ma2, f8) {
    return M4.chain(ma2, match(function() {
      return zeroM();
    }, f8));
  };
}
function alt4(M4) {
  var _some = some3(M4);
  return function(second) {
    return function(first2) {
      return M4.chain(first2, match(second, _some));
    };
  };
}

// node_modules/fp-ts/es6/IOOption.js
var some4 = some3(Pointed6);
var fromPredicate6 = fromPredicate5(Pointed6);
var fromEither6 = fromEither5(Pointed6);
var fromIO2 = fromF(Functor12);
var fromIOEither = map14(fromEither3);
var match6 = match5(Functor12);
var matchE4 = matchE3(Chain10);
var getOrElse5 = getOrElse4(Monad3);
var toUndefined2 = map14(toUndefined);
var toNullable2 = map14(toNullable);
var fromNullable5 = fromNullable4(Pointed6);
var fromNullableK4 = fromNullableK3(Pointed6);
var chainNullableK4 = chainNullableK3(Monad3);
var fromOptionK5 = fromOptionK4(Pointed6);
var map17 = map16(Functor12);
var ap14 = ap13(Apply10);
var of13 = some4;
var flatMap14 = dual(2, flatMap13(Monad3));
var flatten9 = flatMap14(identity3);
var alt5 = alt4(Monad3);
var zero5 = zero4(Pointed6);
var none3 = zero5();
var compact5 = compact4(Functor12, Compactable3);
var separate5 = separate4(Functor12, Compactable3, Functor6);
var filter6 = filter5(Functor12, Filterable);
var filterMap5 = filterMap4(Functor12, Filterable);
var partition5 = partition4(Functor12, Filterable);
var partitionMap5 = partitionMap4(Functor12, Filterable);
var _map14 = function(fa2, f8) {
  return pipe(fa2, map17(f8));
};
var _ap12 = function(fab, fa2) {
  return pipe(fab, ap14(fa2));
};
var URI14 = "IOOption";
var Functor14 = {
  URI: URI14,
  map: _map14
};
var as7 = dual(2, as2(Functor14));
var asUnit6 = asUnit(Functor14);
var flap15 = flap(Functor14);
var Pointed7 = {
  URI: URI14,
  of: of13
};
var Apply11 = {
  URI: URI14,
  map: _map14,
  ap: _ap12
};
var apFirst13 = apFirst(Apply11);
var apSecond13 = apSecond(Apply11);
var Chain12 = {
  URI: URI14,
  map: _map14,
  ap: _ap12,
  chain: flatMap14
};
var FromEither6 = {
  URI: URI14,
  fromEither: fromEither6
};
var FromIO2 = {
  URI: URI14,
  fromIO: fromIO2
};
var tap9 = dual(2, tap(Chain12));
var tapEither4 = dual(2, tapEither(FromEither6, Chain12));
var tapIO3 = dual(2, tapIO(FromIO2, Chain12));
var Zero4 = {
  URI: URI14,
  zero: zero5
};
var guard6 = guard2(Zero4, Pointed7);
var _FlatMap3 = {
  flatMap: flatMap14
};
var _FromIO2 = {
  fromIO: FromIO2.fromIO
};
var _FromEither3 = {
  fromEither: fromEither6
};
var flatMapIO3 = flatMapIO(_FromIO2, _FlatMap3);
var flatMapOption4 = dual(2, function(self2, f8) {
  return flatMap14(self2, fromOptionK5(f8));
});
var flatMapEither3 = flatMapEither(_FromEither3, _FlatMap3);
var flatMapNullable4 = dual(2, function(self2, f8) {
  return flatMap14(self2, fromNullableK4(f8));
});
var fromIOK3 = fromIOK(FromIO2);
var fromEitherK6 = fromEitherK(FromEither6);
var Do14 = of13(emptyRecord);
var bindTo13 = bindTo(Functor14);
var let_13 = let_(Functor14);
var bind14 = bind2(Chain12);
var apS13 = apS(Apply11);
var ApT6 = of13(emptyReadonlyArray);

// node_modules/fp-ts/es6/IORef.js
var IORef = (
  /** @class */
  (function() {
    function IORef2(value) {
      var _this = this;
      this.value = value;
      this.read = function() {
        return _this.value;
      };
      this.write = this.write.bind(this);
      this.modify = this.modify.bind(this);
    }
    IORef2.prototype.write = function(a3) {
      var _this = this;
      return function() {
        _this.value = a3;
      };
    };
    IORef2.prototype.modify = function(f8) {
      var _this = this;
      return function() {
        _this.value = f8(_this.value);
      };
    };
    return IORef2;
  })()
);

// node_modules/fp-ts/es6/ReadonlyMap.js
var _mapWithIndex = function(fa2, f8) {
  var m3 = /* @__PURE__ */ new Map();
  var entries = fa2.entries();
  var e2;
  while (!(e2 = entries.next()).done) {
    var _a21 = e2.value, key = _a21[0], a3 = _a21[1];
    m3.set(key, f8(key, a3));
  }
  return m3;
};
var _map15 = function(fa2, f8) {
  return _mapWithIndex(fa2, function(_3, a3) {
    return f8(a3);
  });
};
var URI15 = "ReadonlyMap";
var Functor15 = {
  URI: URI15,
  map: _map15
};
var flap16 = flap(Functor15);

// node_modules/fp-ts/es6/Map.js
var _mapWithIndex2 = function(fa2, f8) {
  var m3 = /* @__PURE__ */ new Map();
  var entries = fa2.entries();
  var e2;
  while (!(e2 = entries.next()).done) {
    var _a21 = e2.value, key = _a21[0], a3 = _a21[1];
    m3.set(key, f8(key, a3));
  }
  return m3;
};
var _map16 = function(fa2, f8) {
  return _mapWithIndex2(fa2, function(_3, a3) {
    return f8(a3);
  });
};
var URI16 = "Map";
var Functor16 = {
  URI: URI16,
  map: _map16
};
var flap17 = flap(Functor16);

// node_modules/fp-ts/es6/Monoid.js
var monoidVoid = {
  concat: semigroupVoid.concat,
  empty: void 0
};
var monoidAll = {
  concat: semigroupAll.concat,
  empty: true
};
var monoidAny = {
  concat: semigroupAny.concat,
  empty: false
};
var monoidString = {
  concat: semigroupString.concat,
  empty: ""
};
var monoidSum = {
  concat: semigroupSum.concat,
  empty: 0
};
var monoidProduct = {
  concat: semigroupProduct.concat,
  empty: 1
};

// node_modules/fp-ts/es6/Ordering.js
var Semigroup = {
  concat: function(x5, y5) {
    return x5 !== 0 ? x5 : y5;
  }
};
var Monoid = {
  concat: Semigroup.concat,
  empty: 0
};

// node_modules/fp-ts/es6/Random.js
var random = function() {
  return Math.random();
};
var randomBool = pipe(random, map14(function(n5) {
  return n5 < 0.5;
}));

// node_modules/fp-ts/es6/ReaderEither.js
var left6 = left4(Pointed5);
var right6 = right4(Pointed5);
var rightReader = rightF(Functor9);
var leftReader = leftF(Functor9);
var fromEither7 = of8;
var fromReader = rightReader;
var match7 = match3(Functor9);
var matchE5 = matchE(Monad2);
var getOrElse6 = getOrElse2(Monad2);
var toUnion4 = toUnion2(Functor9);
var orElse5 = orElse3(Monad2);
var tapError3 = dual(2, tapError(Monad2));
var orLeft3 = orLeft(Monad2);
var swap4 = swap2(Functor9);
var _map17 = function(fa2, f8) {
  return pipe(fa2, map18(f8));
};
var _ap13 = function(fab, fa2) {
  return pipe(fab, ap15(fa2));
};
var map18 = map10(Functor9);
var mapBoth3 = dual(3, mapBoth(Functor9));
var mapError3 = dual(2, mapError(Functor9));
var ap15 = ap8(Apply7);
var of14 = right6;
var flatMap15 = dual(2, flatMap7(Monad2));
var flattenW4 = flatMap15(identity3);
var alt6 = alt2(Monad2);
var URI17 = "ReaderEither";
var Functor17 = {
  URI: URI17,
  map: _map17
};
var as8 = dual(2, as2(Functor17));
var asUnit7 = asUnit(Functor17);
var flap18 = flap(Functor17);
var Apply12 = {
  URI: URI17,
  map: _map17,
  ap: _ap13
};
var apFirst14 = apFirst(Apply12);
var apSecond14 = apSecond(Apply12);
var Applicative5 = {
  URI: URI17,
  map: _map17,
  ap: _ap13,
  of: of14
};
var Chain13 = {
  URI: URI17,
  map: _map17,
  ap: _ap13,
  chain: flatMap15
};
var FromEither7 = {
  URI: URI17,
  fromEither: fromEither7
};
var FromReader = {
  URI: URI17,
  fromReader
};
var tap10 = dual(2, tap(Chain13));
var tapEither5 = dual(2, tapEither(FromEither7, Chain13));
var tapReader2 = dual(2, tapReader(FromReader, Chain13));
var ask3 = ask2(FromReader);
var asks2 = asks(FromReader);
var fromReaderK2 = fromReaderK(FromReader);
var fromOption4 = fromOption(FromEither7);
var fromOptionK6 = fromOptionK(FromEither7);
var chainOptionK5 = chainOptionK(FromEither7, Chain13);
var _FromEither4 = {
  fromEither: FromEither7.fromEither
};
var _FromReader = {
  fromReader: FromReader.fromReader
};
var liftNullable4 = liftNullable(_FromEither4);
var liftOption4 = liftOption(_FromEither4);
var _FlatMap4 = {
  flatMap: flatMap15
};
var flatMapNullable5 = flatMapNullable(_FromEither4, _FlatMap4);
var flatMapOption5 = flatMapOption(_FromEither4, _FlatMap4);
var flatMapEither4 = flatMapEither(_FromEither4, _FlatMap4);
var flatMapReader2 = flatMapReader(_FromReader, _FlatMap4);
var fromPredicate7 = fromPredicate(FromEither7);
var filterOrElse4 = filterOrElse(FromEither7, Chain13);
var fromEitherK7 = fromEitherK(FromEither7);
var Do15 = of14(emptyRecord);
var bindTo14 = bindTo(Functor17);
var let_14 = let_(Functor17);
var bind15 = bind2(Chain13);
var apS14 = apS(Apply12);
var ApT7 = of14(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex7 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f8), map11(traverseReadonlyNonEmptyArrayWithIndex2(SK)));
};
var traverseReadonlyArrayWithIndex7 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex7(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT7;
  };
};
var traverseArray7 = function(f8) {
  return traverseReadonlyArrayWithIndex7(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray7 = traverseArray7(identity3);
var getApplySemigroup5 = getApplySemigroup(Apply12);
var getApplyMonoid4 = getApplicativeMonoid(Applicative5);

// node_modules/fp-ts/es6/ReaderT.js
function of15(F5) {
  return function(a3) {
    return function() {
      return F5.of(a3);
    };
  };
}
function map19(F5) {
  return function(f8) {
    return function(fa2) {
      return function(r3) {
        return F5.map(fa2(r3), f8);
      };
    };
  };
}
function ap16(F5) {
  return function(fa2) {
    return function(fab) {
      return function(r3) {
        return F5.ap(fab(r3), fa2(r3));
      };
    };
  };
}
function flatMap16(M4) {
  return function(ma2, f8) {
    return function(r3) {
      return M4.chain(ma2(r3), function(a3) {
        return f8(a3)(r3);
      });
    };
  };
}
function fromReader2(F5) {
  return function(ma2) {
    return flow(ma2, F5.of);
  };
}

// node_modules/fp-ts/es6/ReaderIO.js
var fromReader3 = fromReader2(Pointed6);
var fromIO3 = of8;
var _map18 = function(fa2, f8) {
  return pipe(fa2, map20(f8));
};
var _ap14 = function(fab, fa2) {
  return pipe(fab, ap17(fa2));
};
var map20 = map19(Functor12);
var ap17 = ap16(Apply10);
var of16 = of15(Pointed6);
var flatMap17 = dual(2, flatMap16(Monad3));
var flattenW5 = flatMap17(identity3);
var URI18 = "ReaderIO";
var Functor18 = {
  URI: URI18,
  map: _map18
};
var as9 = dual(2, as2(Functor18));
var asUnit8 = asUnit(Functor18);
var flap19 = flap(Functor18);
var Apply13 = {
  URI: URI18,
  map: _map18,
  ap: _ap14
};
var apFirst15 = apFirst(Apply13);
var apSecond15 = apSecond(Apply13);
var Chain14 = {
  URI: URI18,
  map: _map18,
  ap: _ap14,
  chain: flatMap17
};
var FromIO3 = {
  URI: URI18,
  fromIO: fromIO3
};
var FromReader2 = {
  URI: URI18,
  fromReader: fromReader3
};
var _FlatMap5 = {
  flatMap: flatMap17
};
var _FromIO3 = {
  fromIO: FromIO3.fromIO
};
var _FromReader2 = {
  fromReader: fromReader3
};
var flatMapIO4 = flatMapIO(_FromIO3, _FlatMap5);
var flatMapReader3 = flatMapReader(_FromReader2, _FlatMap5);
var tap11 = dual(2, tap(Chain14));
var tapIO4 = dual(2, tapIO(FromIO3, Chain14));
var tapReader3 = dual(2, tapReader(FromReader2, Chain14));
var fromIOK4 = fromIOK(FromIO3);
var ask4 = ask2(FromReader2);
var asks3 = asks(FromReader2);
var fromReaderK3 = fromReaderK(FromReader2);
var Do16 = of16(emptyRecord);
var bindTo15 = bindTo(Functor18);
var bind16 = bind2(Chain14);
var apS15 = apS(Apply13);
var ApT8 = of16(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex8 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f8), map11(traverseReadonlyNonEmptyArrayWithIndex5(SK)));
};
var traverseReadonlyArrayWithIndex8 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex8(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT8;
  };
};
var traverseArray8 = function(f8) {
  return traverseReadonlyArrayWithIndex8(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray8 = traverseArray8(identity3);

// node_modules/fp-ts/es6/Task.js
var fromIO4 = function(ma2) {
  return function() {
    return Promise.resolve().then(ma2);
  };
};
var _map19 = function(fa2, f8) {
  return pipe(fa2, map21(f8));
};
var _apPar = function(fab, fa2) {
  return pipe(fab, ap18(fa2));
};
var _apSeq = function(fab, fa2) {
  return flatMap18(fab, function(f8) {
    return pipe(fa2, map21(f8));
  });
};
var map21 = function(f8) {
  return function(fa2) {
    return function() {
      return Promise.resolve().then(fa2).then(f8);
    };
  };
};
var ap18 = function(fa2) {
  return function(fab) {
    return function() {
      return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa2)]).then(function(_a21) {
        var f8 = _a21[0], a3 = _a21[1];
        return f8(a3);
      });
    };
  };
};
var of17 = function(a3) {
  return function() {
    return Promise.resolve(a3);
  };
};
var flatMap18 = dual(2, function(ma2, f8) {
  return function() {
    return Promise.resolve().then(ma2).then(function(a3) {
      return f8(a3)();
    });
  };
});
var flatten10 = flatMap18(identity3);
var URI19 = "Task";
var Functor19 = {
  URI: URI19,
  map: _map19
};
var as10 = dual(2, as2(Functor19));
var asUnit9 = asUnit(Functor19);
var flap20 = flap(Functor19);
var Pointed8 = {
  URI: URI19,
  of: of17
};
var ApplyPar2 = {
  URI: URI19,
  map: _map19,
  ap: _apPar
};
var apFirst16 = apFirst(ApplyPar2);
var apSecond16 = apSecond(ApplyPar2);
var ApplySeq = {
  URI: URI19,
  map: _map19,
  ap: _apSeq
};
var ApplicativeSeq = {
  URI: URI19,
  map: _map19,
  ap: _apSeq,
  of: of17
};
var Chain15 = {
  URI: URI19,
  map: _map19,
  ap: _apPar,
  chain: flatMap18
};
var Monad4 = {
  URI: URI19,
  map: _map19,
  of: of17,
  ap: _apPar,
  chain: flatMap18
};
var FromIO4 = {
  URI: URI19,
  fromIO: fromIO4
};
var _FlatMap6 = {
  flatMap: flatMap18
};
var _FromIO4 = {
  fromIO: FromIO4.fromIO
};
var flatMapIO5 = flatMapIO(_FromIO4, _FlatMap6);
var tap12 = dual(2, tap(Chain15));
var tapIO5 = dual(2, tapIO(FromIO4, Chain15));
var fromIOK5 = fromIOK(FromIO4);
var Do17 = of17(emptyRecord);
var bindTo16 = bindTo(Functor19);
var let_15 = let_(Functor19);
var bind17 = bind2(Chain15);
var apS16 = apS(ApplyPar2);
var ApT9 = of17(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex9 = function(f8) {
  return function(as16) {
    return function() {
      return Promise.all(as16.map(function(a3, i4) {
        return Promise.resolve().then(function() {
          return f8(i4, a3)();
        });
      }));
    };
  };
};
var traverseReadonlyArrayWithIndex9 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex9(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT9;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq2 = function(f8) {
  return function(as16) {
    return function() {
      return tail(as16).reduce(function(acc, a3, i4) {
        return acc.then(function(bs3) {
          return Promise.resolve().then(f8(i4 + 1, a3)).then(function(b4) {
            bs3.push(b4);
            return bs3;
          });
        });
      }, Promise.resolve().then(f8(0, head(as16))).then(singleton));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq2 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndexSeq2(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT9;
  };
};
var traverseArray9 = function(f8) {
  return traverseReadonlyArrayWithIndex9(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray9 = traverseArray9(identity3);
var traverseSeqArray2 = function(f8) {
  return traverseReadonlyArrayWithIndexSeq2(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceSeqArray2 = traverseSeqArray2(identity3);
var getSemigroup6 = getApplySemigroup(ApplySeq);
var getMonoid7 = getApplicativeMonoid(ApplicativeSeq);

// node_modules/fp-ts/es6/ReaderTask.js
var fromReader4 = fromReader2(Pointed8);
var fromTask = of8;
var fromIO5 = flow(fromIO4, fromTask);
var fromReaderIO = map11(fromIO4);
var _map20 = function(fa2, f8) {
  return pipe(fa2, map22(f8));
};
var _apPar2 = function(fab, fa2) {
  return pipe(fab, ap19(fa2));
};
var _apSeq2 = function(fab, fa2) {
  return flatMap19(fab, function(f8) {
    return pipe(fa2, map22(f8));
  });
};
var map22 = map19(Functor19);
var ap19 = ap16(ApplyPar2);
var of18 = of15(Pointed8);
var flatMap19 = dual(2, flatMap16(Monad4));
var flattenW6 = flatMap19(identity3);
var URI20 = "ReaderTask";
var Functor20 = {
  URI: URI20,
  map: _map20
};
var as11 = dual(2, as2(Functor20));
var asUnit10 = asUnit(Functor20);
var flap21 = flap(Functor20);
var Pointed9 = {
  URI: URI20,
  of: of18
};
var ApplyPar3 = {
  URI: URI20,
  map: _map20,
  ap: _apPar2
};
var apFirst17 = apFirst(ApplyPar3);
var apSecond17 = apSecond(ApplyPar3);
var ApplySeq2 = {
  URI: URI20,
  map: _map20,
  ap: _apSeq2
};
var ApplicativeSeq2 = {
  URI: URI20,
  map: _map20,
  ap: _apSeq2,
  of: of18
};
var Chain16 = {
  URI: URI20,
  map: _map20,
  ap: _apPar2,
  chain: flatMap19
};
var Monad5 = {
  URI: URI20,
  map: _map20,
  of: of18,
  ap: _apPar2,
  chain: flatMap19
};
var FromIO5 = {
  URI: URI20,
  fromIO: fromIO5
};
var FromTask = {
  URI: URI20,
  fromIO: fromIO5,
  fromTask
};
var FromReader3 = {
  URI: URI20,
  fromReader: fromReader4
};
var _FlatMap7 = {
  flatMap: flatMap19
};
var _FromIO5 = {
  fromIO: FromIO5.fromIO
};
var _FromTask = {
  fromTask
};
var _FromReader3 = {
  fromReader: fromReader4
};
var flatMapIO6 = flatMapIO(_FromIO5, _FlatMap7);
var flatMapTask2 = flatMapTask(_FromTask, _FlatMap7);
var flatMapReader4 = flatMapReader(_FromReader3, _FlatMap7);
var flatMapReaderIO = dual(2, function(self2, f8) {
  return flatMap19(self2, fromReaderIOK(f8));
});
var tap13 = dual(2, tap(Chain16));
var tapIO6 = dual(2, tapIO(FromIO5, Chain16));
var tapReader4 = dual(2, tapReader(FromReader3, Chain16));
var tapTask2 = dual(2, tapTask(FromTask, Chain16));
var tapReaderIO = dual(2, function(self2, f8) {
  return tap13(self2, fromReaderIOK(f8));
});
var fromIOK6 = fromIOK(FromIO5);
var ask5 = ask2(FromReader3);
var asks4 = asks(FromReader3);
var fromReaderK4 = fromReaderK(FromReader3);
var fromReaderIOK = function(f8) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return fromReaderIO(f8.apply(void 0, a3));
  };
};
var fromTaskK2 = fromTaskK(FromTask);
var Do18 = of18(emptyRecord);
var bindTo17 = bindTo(Functor20);
var let_16 = let_(Functor20);
var bind18 = bind2(Chain16);
var apS17 = apS(ApplyPar3);
var ApT10 = of18(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex10 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f8), map11(traverseReadonlyNonEmptyArrayWithIndex9(SK)));
};
var traverseReadonlyArrayWithIndex10 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex10(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT10;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq3 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f8), map11(traverseReadonlyNonEmptyArrayWithIndexSeq2(SK)));
};
var traverseReadonlyArrayWithIndexSeq3 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndexSeq3(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT10;
  };
};
var traverseArray10 = function(f8) {
  return traverseReadonlyArrayWithIndex10(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray10 = traverseArray10(identity3);
var traverseSeqArray3 = function(f8) {
  return traverseReadonlyArrayWithIndexSeq3(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceSeqArray3 = traverseSeqArray3(identity3);
var getSemigroup7 = getApplySemigroup(ApplySeq2);
var getMonoid8 = getApplicativeMonoid(ApplicativeSeq2);

// node_modules/fp-ts/es6/TaskEither.js
var left7 = left4(Pointed8);
var right7 = right4(Pointed8);
var rightTask = rightF(Functor19);
var leftTask = leftF(Functor19);
var rightIO2 = flow(fromIO4, rightTask);
var leftIO2 = flow(fromIO4, leftTask);
var fromIO6 = rightIO2;
var fromTask2 = rightTask;
var fromEither8 = of17;
var fromIOEither2 = fromIO4;
var fromTaskOption = function(onNone) {
  return map21(fromOption2(onNone));
};
var match8 = match3(Functor19);
var matchE6 = matchE(Monad4);
var getOrElse7 = getOrElse2(Monad4);
var toUnion5 = toUnion2(Functor19);
var fromNullable6 = fromNullable3(Pointed8);
var fromNullableK5 = fromNullableK2(Pointed8);
var chainNullableK5 = chainNullableK2(Monad4);
var orElse6 = orElse3(Monad4);
var tapError4 = dual(2, tapError(Monad4));
var orLeft4 = orLeft(Monad4);
var swap5 = swap2(Functor19);
var fromIOEitherK = function(f8) {
  return flow(f8, fromIOEither2);
};
var _map21 = function(fa2, f8) {
  return pipe(fa2, map23(f8));
};
var _apPar3 = function(fab, fa2) {
  return pipe(fab, ap20(fa2));
};
var _apSeq3 = function(fab, fa2) {
  return flatMap20(fab, function(f8) {
    return pipe(fa2, map23(f8));
  });
};
var map23 = map10(Functor19);
var mapBoth4 = dual(3, mapBoth(Functor19));
var mapError4 = dual(2, mapError(Functor19));
var ap20 = ap8(ApplyPar2);
var flatMap20 = dual(2, flatMap7(Monad4));
var flattenW7 = flatMap20(identity3);
var alt7 = alt2(Monad4);
var of19 = right7;
var URI21 = "TaskEither";
var Functor21 = {
  URI: URI21,
  map: _map21
};
var as12 = dual(2, as2(Functor21));
var asUnit11 = asUnit(Functor21);
var flap22 = flap(Functor21);
var ApplyPar4 = {
  URI: URI21,
  map: _map21,
  ap: _apPar3
};
var apFirst18 = apFirst(ApplyPar4);
var apSecond18 = apSecond(ApplyPar4);
var ApplySeq3 = {
  URI: URI21,
  map: _map21,
  ap: _apSeq3
};
var ApplicativeSeq3 = {
  URI: URI21,
  map: _map21,
  ap: _apSeq3,
  of: of19
};
var Chain17 = {
  URI: URI21,
  map: _map21,
  ap: _apPar3,
  chain: flatMap20
};
var FromEither8 = {
  URI: URI21,
  fromEither: fromEither8
};
var FromIO6 = {
  URI: URI21,
  fromIO: fromIO6
};
var FromTask2 = {
  URI: URI21,
  fromIO: fromIO6,
  fromTask: fromTask2
};
var tap14 = dual(2, tap(Chain17));
var tapEither6 = dual(2, tapEither(FromEither8, Chain17));
var tapIO7 = dual(2, tapIO(FromIO6, Chain17));
var tapTask3 = dual(2, tapTask(FromTask2, Chain17));
var fromOption5 = fromOption(FromEither8);
var fromOptionK7 = fromOptionK(FromEither8);
var chainOptionK6 = chainOptionK(FromEither8, Chain17);
var _FromEither5 = {
  fromEither: FromEither8.fromEither
};
var liftNullable5 = liftNullable(_FromEither5);
var liftOption5 = liftOption(_FromEither5);
var _FlatMap8 = {
  flatMap: flatMap20
};
var _FromIO6 = {
  fromIO: FromIO6.fromIO
};
var _FromTask2 = {
  fromTask: fromTask2
};
var flatMapNullable6 = flatMapNullable(_FromEither5, _FlatMap8);
var flatMapOption6 = flatMapOption(_FromEither5, _FlatMap8);
var flatMapEither5 = flatMapEither(_FromEither5, _FlatMap8);
var flatMapIO7 = flatMapIO(_FromIO6, _FlatMap8);
var flatMapTask3 = flatMapTask(_FromTask2, _FlatMap8);
var flatMapIOEither = dual(2, function(self2, f8) {
  return flatMap20(self2, fromIOEitherK(f8));
});
var flatMapTaskOption = dual(3, function(self2, f8, onNone) {
  return flatMap20(self2, function(a3) {
    return fromTaskOption(function() {
      return onNone(a3);
    })(f8(a3));
  });
});
var fromPredicate8 = fromPredicate(FromEither8);
var filterOrElse5 = filterOrElse(FromEither8, Chain17);
var fromEitherK8 = fromEitherK(FromEither8);
var fromIOK7 = fromIOK(FromIO6);
var fromTaskK3 = fromTaskK(FromTask2);
var Do19 = of19(emptyRecord);
var bindTo18 = bindTo(Functor21);
var let_17 = let_(Functor21);
var bind19 = bind2(Chain17);
var apS18 = apS(ApplyPar4);
var ApT11 = of19(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex11 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex9(f8), map21(traverseReadonlyNonEmptyArrayWithIndex2(SK)));
};
var traverseReadonlyArrayWithIndex11 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex11(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT11;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq4 = function(f8) {
  return function(as16) {
    return function() {
      return tail(as16).reduce(function(acc, a3, i4) {
        return acc.then(function(ebs) {
          return isLeft(ebs) ? acc : f8(i4 + 1, a3)().then(function(eb) {
            if (isLeft(eb)) {
              return eb;
            }
            ebs.right.push(eb.right);
            return ebs;
          });
        });
      }, f8(0, head(as16))().then(map9(singleton)));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq4 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndexSeq4(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT11;
  };
};
var traverseArray11 = function(f8) {
  return traverseReadonlyArrayWithIndex11(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray11 = traverseArray11(identity3);
var traverseSeqArray4 = function(f8) {
  return traverseReadonlyArrayWithIndexSeq4(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceSeqArray4 = traverseSeqArray4(identity3);
var getApplySemigroup6 = getApplySemigroup(ApplySeq3);
var getApplyMonoid5 = getApplicativeMonoid(ApplicativeSeq3);

// node_modules/fp-ts/es6/ReaderTaskEither.js
var fromTaskEither = of8;
var left8 = left4(Pointed9);
var right8 = right4(Pointed9);
var rightTask2 = flow(rightTask, fromTaskEither);
var leftTask2 = flow(leftTask, fromTaskEither);
var rightReader2 = function(ma2) {
  return flow(ma2, right7);
};
var rightReaderTask = rightF(Functor20);
var leftReaderTask = leftF(Functor20);
var rightIO3 = flow(rightIO2, fromTaskEither);
var leftIO3 = flow(leftIO2, fromTaskEither);
var rightReaderIO = function(ma2) {
  return flow(ma2, rightIO2);
};
var fromEither9 = of18;
var fromReader5 = rightReader2;
var fromIO7 = rightIO3;
var fromTask3 = rightTask2;
var fromIOEither3 = flow(fromIOEither2, fromTaskEither);
var fromReaderEither = function(ma2) {
  return flow(ma2, fromEither8);
};
var match9 = match3(Functor20);
var matchE7 = matchE(Chain16);
var getOrElse8 = getOrElse2(Monad5);
var toUnion6 = toUnion2(Functor20);
var fromNullable7 = fromNullable3(Pointed9);
var fromNullableK6 = fromNullableK2(Pointed9);
var chainNullableK6 = chainNullableK2(Monad5);
var orElse7 = orElse3(Monad5);
var tapError5 = dual(2, tapError(Monad5));
var orLeft5 = orLeft(Monad5);
var swap6 = swap2(Functor20);
var fromIOEitherK2 = function(f8) {
  return flow(f8, fromIOEither3);
};
var fromTaskEitherK = function(f8) {
  return flow(f8, fromTaskEither);
};
var fromReaderEitherK = function(f8) {
  return flow(f8, fromReaderEither);
};
var _map22 = function(fa2, f8) {
  return pipe(fa2, map24(f8));
};
var _apPar4 = function(fab, fa2) {
  return pipe(fab, ap21(fa2));
};
var _apSeq4 = function(fab, fa2) {
  return flatMap21(fab, function(f8) {
    return pipe(fa2, map24(f8));
  });
};
var map24 = map10(Functor20);
var mapBoth5 = dual(3, mapBoth(Functor20));
var mapError5 = dual(2, mapError(Functor20));
var ap21 = ap8(ApplyPar3);
var of20 = right8;
var flatMap21 = dual(2, flatMap7(Monad5));
var flattenW8 = flatMap21(identity3);
var alt8 = alt2(Monad5);
var URI22 = "ReaderTaskEither";
var Functor22 = {
  URI: URI22,
  map: _map22
};
var as13 = dual(2, as2(Functor22));
var asUnit12 = asUnit(Functor22);
var flap23 = flap(Functor22);
var Pointed10 = {
  URI: URI22,
  of: of20
};
var ApplyPar5 = {
  URI: URI22,
  map: _map22,
  ap: _apPar4
};
var apFirst19 = apFirst(ApplyPar5);
var apSecond19 = apSecond(ApplyPar5);
var ApplySeq4 = {
  URI: URI22,
  map: _map22,
  ap: _apSeq4
};
var ApplicativeSeq4 = {
  URI: URI22,
  map: _map22,
  ap: _apSeq4,
  of: of20
};
var Chain18 = {
  URI: URI22,
  map: _map22,
  ap: _apPar4,
  chain: flatMap21
};
var Monad6 = {
  URI: URI22,
  map: _map22,
  ap: _apPar4,
  chain: flatMap21,
  of: of20
};
var FromEither9 = {
  URI: URI22,
  fromEither: fromEither9
};
var FromIO7 = {
  URI: URI22,
  fromIO: fromIO7
};
var FromTask3 = {
  URI: URI22,
  fromIO: fromIO7,
  fromTask: fromTask3
};
var FromReader4 = {
  URI: URI22,
  fromReader: fromReader5
};
var tap15 = dual(2, tap(Chain18));
var tapEither7 = dual(2, tapEither(FromEither9, Chain18));
var tapIO8 = dual(2, tapIO(FromIO7, Chain18));
var tapTask4 = dual(2, tapTask(FromTask3, Chain18));
var tapReader5 = dual(2, tapReader(FromReader4, Chain18));
var tapReaderEither = dual(2, function(self2, f8) {
  return tap15(self2, fromReaderEitherK(f8));
});
var tapTaskEither = dual(2, function(self2, f8) {
  return tap15(self2, fromTaskEitherK(f8));
});
var tapReaderTask = dual(2, function(self2, f8) {
  return tap15(self2, fromReaderTaskK(f8));
});
var tapReaderIO2 = dual(2, function(self2, f8) {
  return tap15(self2, fromReaderIOK2(f8));
});
var ask6 = ask2(FromReader4);
var asks5 = asks(FromReader4);
var fromReaderK5 = fromReaderK(FromReader4);
var fromReaderTaskK = function(f8) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return rightReaderTask(f8.apply(void 0, a3));
  };
};
var fromReaderIOK2 = function(f8) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return rightReaderIO(f8.apply(void 0, a3));
  };
};
var fromOption6 = fromOption(FromEither9);
var fromOptionK8 = fromOptionK(FromEither9);
var chainOptionK7 = chainOptionK(FromEither9, Chain18);
var _FromEither6 = {
  fromEither: FromEither9.fromEither
};
var liftNullable6 = liftNullable(_FromEither6);
var liftOption6 = liftOption(_FromEither6);
var _FlatMap9 = {
  flatMap: flatMap21
};
var _FromIO7 = {
  fromIO: fromIO7
};
var _FromTask3 = {
  fromTask: fromTask3
};
var _FromReader4 = {
  fromReader: fromReader5
};
var flatMapNullable7 = flatMapNullable(_FromEither6, _FlatMap9);
var flatMapOption7 = flatMapOption(_FromEither6, _FlatMap9);
var flatMapEither6 = flatMapEither(_FromEither6, _FlatMap9);
var flatMapTaskEither = dual(2, function(self2, f8) {
  return flatMap21(self2, fromTaskEitherK(f8));
});
var flatMapReaderTask = dual(2, function(self2, f8) {
  return flatMap21(self2, fromReaderTaskK(f8));
});
var flatMapIO8 = flatMapIO(_FromIO7, _FlatMap9);
var flatMapTask4 = flatMapTask(_FromTask3, _FlatMap9);
var flatMapReader5 = flatMapReader(_FromReader4, _FlatMap9);
var flatMapReaderIO2 = dual(2, function(self2, f8) {
  return flatMap21(self2, fromReaderIOK2(f8));
});
var flatMapIOEither2 = dual(2, function(self2, f8) {
  return flatMap21(self2, fromIOEitherK2(f8));
});
var flatMapReaderEither = dual(2, function(self2, f8) {
  return flatMap21(self2, fromReaderEitherK(f8));
});
var fromPredicate9 = fromPredicate(FromEither9);
var filterOrElse6 = filterOrElse(FromEither9, Chain18);
var fromEitherK9 = fromEitherK(FromEither9);
var fromIOK8 = fromIOK(FromIO7);
var fromTaskK4 = fromTaskK(FromTask3);
var Do20 = of20(emptyRecord);
var bindTo19 = bindTo(Functor22);
var let_18 = let_(Functor22);
var bind20 = bind2(Chain18);
var apS19 = apS(ApplyPar5);
var ApT12 = of20(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex12 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f8), map11(traverseReadonlyNonEmptyArrayWithIndex11(SK)));
};
var traverseReadonlyArrayWithIndex12 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex12(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT12;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq5 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f8), map11(traverseReadonlyNonEmptyArrayWithIndexSeq4(SK)));
};
var traverseReadonlyArrayWithIndexSeq5 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndexSeq5(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT12;
  };
};
var traverseArray12 = function(f8) {
  return traverseReadonlyArrayWithIndex12(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray12 = traverseArray12(identity3);
var traverseSeqArray5 = function(f8) {
  return traverseReadonlyArrayWithIndexSeq5(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceSeqArray5 = traverseSeqArray5(identity3);
var getApplySemigroup7 = getApplySemigroup(ApplySeq4);
var getApplyMonoid6 = getApplicativeMonoid(ApplicativeSeq4);

// node_modules/fp-ts/es6/string.js
var Eq3 = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var Semigroup2 = {
  concat: function(first2, second) {
    return first2 + second;
  }
};
var empty4 = "";
var Monoid2 = {
  concat: Semigroup2.concat,
  empty: empty4
};
var Ord4 = {
  equals: Eq3.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};

// node_modules/fp-ts/es6/ReadonlyRecord.js
var keys_ = function(O5) {
  return function(r3) {
    return Object.keys(r3).sort(O5.compare);
  };
};
var keys2 = keys_(Ord4);
function collect(O5) {
  if (typeof O5 === "function") {
    return collect(Ord4)(O5);
  }
  var keysO = keys_(O5);
  return function(f8) {
    return function(r3) {
      var out = [];
      for (var _i4 = 0, _a21 = keysO(r3); _i4 < _a21.length; _i4++) {
        var key = _a21[_i4];
        out.push(f8(key, r3[key]));
      }
      return out;
    };
  };
}
var toReadonlyArray = collect(Ord4)(function(k6, a3) {
  return [k6, a3];
});
var empty5 = {};
function mapWithIndex3(f8) {
  return function(r3) {
    var out = {};
    for (var k6 in r3) {
      if (has.call(r3, k6)) {
        out[k6] = f8(k6, r3[k6]);
      }
    }
    return out;
  };
}
function map25(f8) {
  return mapWithIndex3(function(_3, a3) {
    return f8(a3);
  });
}
function reduceWithIndex5() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 2) {
    return reduceWithIndex5(Ord4).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b4, f8) {
    return function(fa2) {
      var out = b4;
      var ks3 = keysO(fa2);
      var len = ks3.length;
      for (var i4 = 0; i4 < len; i4++) {
        var k6 = ks3[i4];
        out = f8(k6, out, fa2[k6]);
      }
      return out;
    };
  };
}
function foldMapWithIndex4(O5) {
  if ("compare" in O5) {
    var keysO_1 = keys_(O5);
    return function(M4) {
      return function(f8) {
        return function(fa2) {
          var out = M4.empty;
          var ks3 = keysO_1(fa2);
          var len = ks3.length;
          for (var i4 = 0; i4 < len; i4++) {
            var k6 = ks3[i4];
            out = M4.concat(out, f8(k6, fa2[k6]));
          }
          return out;
        };
      };
    };
  }
  return foldMapWithIndex4(Ord4)(O5);
}
function reduceRightWithIndex4() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 2) {
    return reduceRightWithIndex4(Ord4).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b4, f8) {
    return function(fa2) {
      var out = b4;
      var ks3 = keysO(fa2);
      var len = ks3.length;
      for (var i4 = len - 1; i4 >= 0; i4--) {
        var k6 = ks3[i4];
        out = f8(k6, fa2[k6], out);
      }
      return out;
    };
  };
}
function sequence5(F5) {
  return _sequence(Ord4)(F5);
}
function partitionMapWithIndex3(f8) {
  return function(r3) {
    var left13 = {};
    var right13 = {};
    for (var k6 in r3) {
      if (has.call(r3, k6)) {
        var e2 = f8(k6, r3[k6]);
        switch (e2._tag) {
          case "Left":
            left13[k6] = e2.left;
            break;
          case "Right":
            right13[k6] = e2.right;
            break;
        }
      }
    }
    return separated(left13, right13);
  };
}
function partitionWithIndex3(predicateWithIndex) {
  return function(r3) {
    var left13 = {};
    var right13 = {};
    for (var k6 in r3) {
      if (has.call(r3, k6)) {
        var a3 = r3[k6];
        if (predicateWithIndex(k6, a3)) {
          right13[k6] = a3;
        } else {
          left13[k6] = a3;
        }
      }
    }
    return separated(left13, right13);
  };
}
function filterMapWithIndex3(f8) {
  return function(r3) {
    var out = {};
    for (var k6 in r3) {
      if (has.call(r3, k6)) {
        var ob = f8(k6, r3[k6]);
        if (isSome(ob)) {
          out[k6] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex(predicateWithIndex) {
  return function(fa2) {
    var out = {};
    var changed = false;
    for (var key in fa2) {
      if (has.call(fa2, key)) {
        var a3 = fa2[key];
        if (predicateWithIndex(key, a3)) {
          out[key] = a3;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa2;
  };
}
var _map23 = function(fa2, f8) {
  return pipe(fa2, map25(f8));
};
var _mapWithIndex3 = function(fa2, f8) {
  return pipe(fa2, mapWithIndex3(f8));
};
var _reduce5 = function(O5) {
  var reduceO = reduce7(O5);
  return function(fa2, b4, f8) {
    return pipe(fa2, reduceO(b4, f8));
  };
};
var _foldMap5 = function(O5) {
  return function(M4) {
    var foldMapM = foldMap7(O5)(M4);
    return function(fa2, f8) {
      return pipe(fa2, foldMapM(f8));
    };
  };
};
var _reduceRight5 = function(O5) {
  var reduceRightO = reduceRight7(O5);
  return function(fa2, b4, f8) {
    return pipe(fa2, reduceRightO(b4, f8));
  };
};
var _filter4 = function(fa2, predicate) {
  return pipe(fa2, filter7(predicate));
};
var _filterMap4 = function(fa2, f8) {
  return pipe(fa2, filterMap6(f8));
};
var _partition4 = function(fa2, predicate) {
  return pipe(fa2, partition6(predicate));
};
var _partitionMap4 = function(fa2, f8) {
  return pipe(fa2, partitionMap6(f8));
};
var _reduceWithIndex = function(O5) {
  var reduceWithIndexO = reduceWithIndex5(O5);
  return function(fa2, b4, f8) {
    return pipe(fa2, reduceWithIndexO(b4, f8));
  };
};
var _foldMapWithIndex = function(O5) {
  var foldMapWithIndexO = foldMapWithIndex4(O5);
  return function(M4) {
    var foldMapWithIndexM = foldMapWithIndexO(M4);
    return function(fa2, f8) {
      return pipe(fa2, foldMapWithIndexM(f8));
    };
  };
};
var _reduceRightWithIndex = function(O5) {
  var reduceRightWithIndexO = reduceRightWithIndex4(O5);
  return function(fa2, b4, f8) {
    return pipe(fa2, reduceRightWithIndexO(b4, f8));
  };
};
var _partitionMapWithIndex = function(fa2, f8) {
  return pipe(fa2, partitionMapWithIndex3(f8));
};
var _partitionWithIndex = function(fa2, predicateWithIndex) {
  return pipe(fa2, partitionWithIndex3(predicateWithIndex));
};
var _filterMapWithIndex = function(fa2, f8) {
  return pipe(fa2, filterMapWithIndex3(f8));
};
var _filterWithIndex = function(fa2, predicateWithIndex) {
  return pipe(fa2, filterWithIndex(predicateWithIndex));
};
var _traverse5 = function(O5) {
  var traverseWithIndexO = _traverseWithIndex(O5);
  return function(F5) {
    var traverseWithIndexOF = traverseWithIndexO(F5);
    return function(ta2, f8) {
      return traverseWithIndexOF(ta2, flow(SK, f8));
    };
  };
};
var _sequence = function(O5) {
  var traverseO = _traverse5(O5);
  return function(F5) {
    var traverseOF = traverseO(F5);
    return function(ta2) {
      return traverseOF(ta2, identity3);
    };
  };
};
var _traverseWithIndex = function(O5) {
  return function(F5) {
    var keysO = keys_(O5);
    return function(ta2, f8) {
      var ks3 = keysO(ta2);
      if (ks3.length === 0) {
        return F5.of(empty5);
      }
      var fr4 = F5.of({});
      var _loop_1 = function(key2) {
        fr4 = F5.ap(F5.map(fr4, function(r3) {
          return function(b4) {
            var _a21;
            return Object.assign({}, r3, (_a21 = {}, _a21[key2] = b4, _a21));
          };
        }), f8(key2, ta2[key2]));
      };
      for (var _i4 = 0, ks_1 = ks3; _i4 < ks_1.length; _i4++) {
        var key = ks_1[_i4];
        _loop_1(key);
      }
      return fr4;
    };
  };
};
var filter7 = function(predicate) {
  return filterWithIndex(function(_3, a3) {
    return predicate(a3);
  });
};
var filterMap6 = function(f8) {
  return filterMapWithIndex3(function(_3, a3) {
    return f8(a3);
  });
};
var partition6 = function(predicate) {
  return partitionWithIndex3(function(_3, a3) {
    return predicate(a3);
  });
};
var partitionMap6 = function(f8) {
  return partitionMapWithIndex3(function(_3, a3) {
    return f8(a3);
  });
};
function reduce7() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 1) {
    var reduceWithIndexO_1 = reduceWithIndex5(args[0]);
    return function(b4, f8) {
      return reduceWithIndexO_1(b4, function(_3, b5, a3) {
        return f8(b5, a3);
      });
    };
  }
  return reduce7(Ord4).apply(void 0, args);
}
function foldMap7(O5) {
  if ("compare" in O5) {
    var foldMapWithIndexO_1 = foldMapWithIndex4(O5);
    return function(M4) {
      var foldMapWithIndexM = foldMapWithIndexO_1(M4);
      return function(f8) {
        return foldMapWithIndexM(function(_3, a3) {
          return f8(a3);
        });
      };
    };
  }
  return foldMap7(Ord4)(O5);
}
function reduceRight7() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 1) {
    var reduceRightWithIndexO_1 = reduceRightWithIndex4(args[0]);
    return function(b4, f8) {
      return reduceRightWithIndexO_1(b4, function(_3, b5, a3) {
        return f8(b5, a3);
      });
    };
  }
  return reduceRight7(Ord4).apply(void 0, args);
}
var compact6 = function(r3) {
  var out = {};
  for (var k6 in r3) {
    if (has.call(r3, k6)) {
      var oa2 = r3[k6];
      if (isSome(oa2)) {
        out[k6] = oa2.value;
      }
    }
  }
  return out;
};
var separate6 = function(r3) {
  var left13 = {};
  var right13 = {};
  for (var k6 in r3) {
    if (has.call(r3, k6)) {
      var e2 = r3[k6];
      if (isLeft(e2)) {
        left13[k6] = e2.left;
      } else {
        right13[k6] = e2.right;
      }
    }
  }
  return separated(left13, right13);
};
var URI23 = "ReadonlyRecord";
var Functor23 = {
  URI: URI23,
  map: _map23
};
var flap24 = flap(Functor23);
var Compactable4 = {
  URI: URI23,
  compact: compact6,
  separate: separate6
};
var Foldable2 = {
  URI: URI23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4)
};
var FoldableWithIndex = {
  URI: URI23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  reduceWithIndex: _reduceWithIndex(Ord4),
  foldMapWithIndex: _foldMapWithIndex(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex(Ord4)
};
var Traversable5 = {
  URI: URI23,
  map: _map23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5
};
var TraversableWithIndex = {
  URI: URI23,
  map: _map23,
  mapWithIndex: _mapWithIndex3,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  reduceWithIndex: _reduceWithIndex(Ord4),
  foldMapWithIndex: _foldMapWithIndex(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5,
  traverseWithIndex: _traverseWithIndex(Ord4)
};
var _wither4 = witherDefault(Traversable5, Compactable4);
var _wilt4 = wiltDefault(Traversable5, Compactable4);
var Witherable3 = {
  URI: URI23,
  map: _map23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5,
  compact: compact6,
  separate: separate6,
  filter: _filter4,
  filterMap: _filterMap4,
  partition: _partition4,
  partitionMap: _partitionMap4,
  wither: _wither4,
  wilt: _wilt4
};
var readonlyRecord = {
  URI: URI23,
  map: _map23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5,
  compact: compact6,
  separate: separate6,
  filter: _filter4,
  filterMap: _filterMap4,
  partition: _partition4,
  partitionMap: _partitionMap4,
  mapWithIndex: _mapWithIndex3,
  reduceWithIndex: _reduceWithIndex(Ord4),
  foldMapWithIndex: _foldMapWithIndex(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex(Ord4),
  filterMapWithIndex: _filterMapWithIndex,
  filterWithIndex: _filterWithIndex,
  partitionMapWithIndex: _partitionMapWithIndex,
  partitionWithIndex: _partitionWithIndex,
  traverseWithIndex: _traverseWithIndex(Ord4),
  wither: _wither4,
  wilt: _wilt4
};

// node_modules/fp-ts/es6/ReadonlyTuple.js
function fst(ea2) {
  return ea2[0];
}
function snd(ea2) {
  return ea2[1];
}
var _map24 = function(fa2, f8) {
  return pipe(fa2, mapFst(f8));
};
var mapFst = function(f8) {
  return function(fa2) {
    return [f8(fst(fa2)), snd(fa2)];
  };
};
var extend9 = function(f8) {
  return function(wa2) {
    return [f8(wa2), snd(wa2)];
  };
};
var duplicate8 = extend9(identity3);
var URI24 = "ReadonlyTuple";
var Functor24 = {
  URI: URI24,
  map: _map24
};
var flap25 = flap(Functor24);

// node_modules/fp-ts/es6/Record.js
var keys_2 = function(O5) {
  return function(r3) {
    return Object.keys(r3).sort(O5.compare);
  };
};
var keys3 = keys_2(Ord4);
function collect2(O5) {
  if (typeof O5 === "function") {
    return collect2(Ord4)(O5);
  }
  var keysO = keys_2(O5);
  return function(f8) {
    return function(r3) {
      var out = [];
      for (var _i4 = 0, _a21 = keysO(r3); _i4 < _a21.length; _i4++) {
        var key = _a21[_i4];
        out.push(f8(key, r3[key]));
      }
      return out;
    };
  };
}
var toArray2 = collect2(Ord4)(function(k6, a3) {
  return [
    k6,
    a3
  ];
});
function sequence6(F5) {
  return sequence5(F5);
}
var _map25 = _map23;
var _mapWithIndex4 = _mapWithIndex3;
var _reduce6 = _reduce5;
var _foldMap6 = _foldMap5;
var _reduceRight6 = _reduceRight5;
var _filter5 = _filter4;
var _filterMap5 = _filterMap4;
var _partition5 = _partition4;
var _partitionMap5 = _partitionMap4;
var _reduceWithIndex2 = _reduceWithIndex;
var _foldMapWithIndex2 = _foldMapWithIndex;
var _reduceRightWithIndex2 = _reduceRightWithIndex;
var _partitionMapWithIndex2 = _partitionMapWithIndex;
var _partitionWithIndex2 = _partitionWithIndex;
var _filterMapWithIndex2 = _filterMapWithIndex;
var _filterWithIndex2 = _filterWithIndex;
var _traverse6 = _traverse5;
var _traverseWithIndex2 = function(O5) {
  return function(F5) {
    var keysO = keys_2(O5);
    return function(ta2, f8) {
      var ks3 = keysO(ta2);
      if (ks3.length === 0) {
        return F5.of({});
      }
      var fr4 = F5.of({});
      var _loop_1 = function(key2) {
        fr4 = F5.ap(F5.map(fr4, function(r3) {
          return function(b4) {
            r3[key2] = b4;
            return r3;
          };
        }), f8(key2, ta2[key2]));
      };
      for (var _i4 = 0, ks_1 = ks3; _i4 < ks_1.length; _i4++) {
        var key = ks_1[_i4];
        _loop_1(key);
      }
      return fr4;
    };
  };
};
var compact7 = compact6;
var separate7 = separate6;
var URI25 = "Record";
var Functor25 = {
  URI: URI25,
  map: _map25
};
var flap26 = flap(Functor25);
var Compactable5 = {
  URI: URI25,
  compact: compact7,
  separate: separate7
};
var Foldable4 = {
  URI: URI25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4)
};
var FoldableWithIndex2 = {
  URI: URI25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  reduceWithIndex: _reduceWithIndex2(Ord4),
  foldMapWithIndex: _foldMapWithIndex2(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex2(Ord4)
};
var Traversable6 = {
  URI: URI25,
  map: _map25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6
};
var TraversableWithIndex2 = {
  URI: URI25,
  map: _map25,
  mapWithIndex: _mapWithIndex4,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  reduceWithIndex: _reduceWithIndex2(Ord4),
  foldMapWithIndex: _foldMapWithIndex2(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex2(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6,
  traverseWithIndex: _traverseWithIndex2(Ord4)
};
var _wither5 = witherDefault(Traversable6, Compactable5);
var _wilt5 = wiltDefault(Traversable6, Compactable5);
var Witherable4 = {
  URI: URI25,
  map: _map25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6,
  compact: compact7,
  separate: separate7,
  filter: _filter5,
  filterMap: _filterMap5,
  partition: _partition5,
  partitionMap: _partitionMap5,
  wither: _wither5,
  wilt: _wilt5
};
var record2 = {
  URI: URI25,
  map: _map25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6,
  compact: compact7,
  separate: separate7,
  filter: _filter5,
  filterMap: _filterMap5,
  partition: _partition5,
  partitionMap: _partitionMap5,
  mapWithIndex: _mapWithIndex4,
  reduceWithIndex: _reduceWithIndex2(Ord4),
  foldMapWithIndex: _foldMapWithIndex2(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex2(Ord4),
  filterMapWithIndex: _filterMapWithIndex2,
  filterWithIndex: _filterWithIndex2,
  partitionMapWithIndex: _partitionMapWithIndex2,
  partitionWithIndex: _partitionWithIndex2,
  traverseWithIndex: _traverseWithIndex2(Ord4),
  wither: _wither5,
  wilt: _wilt5
};

// node_modules/fp-ts/es6/StateT.js
function of21(F5) {
  return function(a3) {
    return function(s3) {
      return F5.of([a3, s3]);
    };
  };
}
function map26(F5) {
  return function(f8) {
    return function(fa2) {
      return function(s3) {
        return F5.map(fa2(s3), function(_a21) {
          var a3 = _a21[0], s1 = _a21[1];
          return [f8(a3), s1];
        });
      };
    };
  };
}
function ap22(M4) {
  return function(fa2) {
    return function(fab) {
      return function(s3) {
        return M4.chain(fab(s3), function(_a21) {
          var f8 = _a21[0], s4 = _a21[1];
          return M4.map(fa2(s4), function(_a22) {
            var a3 = _a22[0], s5 = _a22[1];
            return [f8(a3), s5];
          });
        });
      };
    };
  };
}
function flatMap22(M4) {
  return function(ma2, f8) {
    return function(s3) {
      return M4.chain(ma2(s3), function(_a21) {
        var a3 = _a21[0], s1 = _a21[1];
        return f8(a3)(s1);
      });
    };
  };
}
function fromState(F5) {
  return function(sa2) {
    return function(s3) {
      return F5.of(sa2(s3));
    };
  };
}
function fromF2(F5) {
  return function(ma2) {
    return function(s3) {
      return F5.map(ma2, function(a3) {
        return [a3, s3];
      });
    };
  };
}
function evaluate(F5) {
  return function(s3) {
    return function(ma2) {
      return F5.map(ma2(s3), function(_a21) {
        var a3 = _a21[0];
        return a3;
      });
    };
  };
}
function execute(F5) {
  return function(s3) {
    return function(ma2) {
      return F5.map(ma2(s3), snd);
    };
  };
}

// node_modules/fp-ts/es6/StateReaderTaskEither.js
var left9 = function(e2) {
  return function() {
    return left8(e2);
  };
};
var right9 = of21(Pointed10);
function rightTask3(ma2) {
  return fromReaderTaskEither(rightTask2(ma2));
}
function rightReader3(ma2) {
  return fromReaderTaskEither(rightReader2(ma2));
}
function rightIO4(ma2) {
  return fromReaderTaskEither(rightIO3(ma2));
}
var fromEither10 = match2(function(e2) {
  return left9(e2);
}, right9);
var fromReader6 = rightReader3;
var fromIO8 = rightIO4;
var fromTask4 = rightTask3;
var fromState2 = fromState(Pointed10);
var fromTaskEither2 = function(ma2) {
  return fromReaderTaskEither(fromTaskEither(ma2));
};
var fromIOEither4 = function(ma2) {
  return fromReaderTaskEither(fromIOEither3(ma2));
};
var fromReaderTaskEither = fromF2(Functor22);
var fromIOEitherK3 = function(f8) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return fromIOEither4(f8.apply(void 0, a3));
  };
};
var fromTaskEitherK2 = function(f8) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return fromTaskEither2(f8.apply(void 0, a3));
  };
};
var fromReaderTaskEitherK = function(f8) {
  return function() {
    var a3 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a3[_i4] = arguments[_i4];
    }
    return fromReaderTaskEither(f8.apply(void 0, a3));
  };
};
var _map26 = function(fa2, f8) {
  return pipe(fa2, map27(f8));
};
var _ap15 = function(fab, fa2) {
  return pipe(fab, ap23(fa2));
};
var map27 = map26(Functor22);
var ap23 = ap22(Chain18);
var of22 = right9;
var _FromIO8 = {
  fromIO: fromIO8
};
var _FromTask4 = {
  fromTask: fromTask4
};
var _FromReader5 = {
  fromReader: fromReader6
};
var _FromEither7 = {
  fromEither: fromEither10
};
var flatMap23 = dual(2, flatMap22(Monad6));
var _FlatMap10 = {
  flatMap: flatMap23
};
var flatMapTaskEither2 = dual(2, function(self2, f8) {
  return flatMap23(self2, function(a3) {
    return fromTaskEitherK2(f8)(a3);
  });
});
var flatMapIO9 = flatMapIO(_FromIO8, _FlatMap10);
var flatMapTask5 = flatMapTask(_FromTask4, _FlatMap10);
var flatMapReader6 = flatMapReader(_FromReader5, _FlatMap10);
var flatMapIOEither3 = dual(2, function(self2, f8) {
  return flatMap23(self2, function(a3) {
    return fromIOEitherK3(f8)(a3);
  });
});
var flatMapEither7 = dual(2, flatMapEither(_FromEither7, _FlatMap10));
var flatMapOption8 = flatMapOption(_FromEither7, _FlatMap10);
var flatMapReaderTaskEither = dual(2, function(self2, f8) {
  return flatMap23(self2, function(a3) {
    return fromReaderTaskEitherK(f8)(a3);
  });
});
var flatMapState = dual(2, function(self2, f8) {
  return flatMap23(self2, fromStateK2(f8));
});
var flattenW9 = flatMap23(identity3);
var URI26 = "StateReaderTaskEither";
var Functor26 = {
  URI: URI26,
  map: _map26
};
var as14 = dual(2, as2(Functor26));
var asUnit13 = asUnit(Functor26);
var flap27 = flap(Functor26);
var Apply14 = {
  URI: URI26,
  map: _map26,
  ap: _ap15
};
var apFirst20 = apFirst(Apply14);
var apSecond20 = apSecond(Apply14);
var Chain19 = {
  URI: URI26,
  map: _map26,
  ap: _ap15,
  chain: flatMap23
};
var FromState = {
  URI: URI26,
  fromState: fromState2
};
var get8 = get7(FromState);
var put3 = put2(FromState);
var modify3 = modify2(FromState);
var gets3 = gets2(FromState);
var fromStateK2 = fromStateK(FromState);
var chainStateK2 = chainStateK(FromState, Chain19);
var FromEither10 = {
  URI: URI26,
  fromEither: fromEither10
};
var FromIO8 = {
  URI: URI26,
  fromIO: fromIO8
};
var FromTask4 = {
  URI: URI26,
  fromIO: fromIO8,
  fromTask: fromTask4
};
var FromReader5 = {
  URI: URI26,
  fromReader: fromReader6
};
var tap16 = dual(2, tap(Chain19));
var tapEither8 = dual(2, tapEither(FromEither10, Chain19));
var tapIO9 = dual(2, tapIO(FromIO8, Chain19));
var tapTask5 = dual(2, tapTask(FromTask4, Chain19));
var tapReader6 = dual(2, tapReader(FromReader5, Chain19));
var ask7 = ask2(FromReader5);
var asks6 = asks(FromReader5);
var fromReaderK6 = fromReaderK(FromReader5);
var fromOption7 = fromOption(FromEither10);
var fromOptionK9 = fromOptionK(FromEither10);
var chainOptionK8 = chainOptionK(FromEither10, Chain19);
var fromPredicate10 = fromPredicate(FromEither10);
var filterOrElse7 = filterOrElse(FromEither10, Chain19);
var fromEitherK10 = fromEitherK(FromEither10);
var fromIOK9 = fromIOK(FromIO8);
var fromTaskK5 = fromTaskK(FromTask4);
var evaluate2 = evaluate(Functor22);
var execute2 = execute(Functor22);
var bindTo20 = bindTo(Functor26);
var let_19 = let_(Functor26);
var bind21 = bind2(Chain19);
var apS20 = apS(Apply14);
var traverseReadonlyNonEmptyArrayWithIndex13 = function(f8) {
  return function(as16) {
    return function(s3) {
      return function(r3) {
        return function() {
          return tail(as16).reduce(function(acc, a3, i4) {
            return acc.then(function(ebs) {
              return isLeft(ebs) ? acc : f8(i4 + 1, a3)(ebs.right[1])(r3)().then(function(eb) {
                if (isLeft(eb)) {
                  return eb;
                }
                var _a21 = eb.right, b4 = _a21[0], s4 = _a21[1];
                ebs.right[0].push(b4);
                ebs.right[1] = s4;
                return ebs;
              });
            });
          }, f8(0, head(as16))(s3)(r3)().then(map9(function(_a21) {
            var b4 = _a21[0], s4 = _a21[1];
            return [[b4], s4];
          })));
        };
      };
    };
  };
};
var traverseReadonlyArrayWithIndex13 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex13(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : of22(emptyReadonlyArray);
  };
};
var traverseArray13 = function(f8) {
  return traverseReadonlyArrayWithIndex13(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray13 = traverseArray13(identity3);

// node_modules/fp-ts/es6/Store.js
var _map27 = function(fa2, f8) {
  return pipe(fa2, map28(f8));
};
var extend10 = function(f8) {
  return function(wa2) {
    return {
      peek: function(s3) {
        return f8({ peek: wa2.peek, pos: s3 });
      },
      pos: wa2.pos
    };
  };
};
var duplicate9 = extend10(identity3);
var map28 = function(f8) {
  return function(fa2) {
    return {
      peek: function(s3) {
        return f8(fa2.peek(s3));
      },
      pos: fa2.pos
    };
  };
};
var URI27 = "Store";
var Functor27 = {
  URI: URI27,
  map: _map27
};
var flap28 = flap(Functor27);

// node_modules/fp-ts/es6/TaskOption.js
var some7 = some3(Pointed8);
var fromPredicate11 = fromPredicate5(Pointed8);
var fromEither11 = fromEither5(Pointed8);
var fromIO9 = function(ma2) {
  return fromTask5(fromIO4(ma2));
};
var fromTask5 = fromF(Functor19);
var fromTaskEither3 = map21(fromEither3);
var match10 = match5(Functor19);
var matchE8 = matchE3(Chain15);
var getOrElse9 = getOrElse4(Monad4);
var fromNullable8 = fromNullable4(Pointed8);
var fromNullableK7 = fromNullableK3(Pointed8);
var chainNullableK7 = chainNullableK3(Monad4);
var fromOptionK10 = fromOptionK4(Pointed8);
var chainOptionK9 = chainOptionK4(Monad4);
var map29 = map16(Functor19);
var ap24 = ap13(ApplyPar2);
var of23 = some7;
var _FromIO9 = {
  fromIO: fromIO9
};
var _FromTask5 = {
  fromTask: fromTask5
};
var flatMap24 = dual(2, flatMap13(Monad4));
var _FlatMap11 = {
  flatMap: flatMap24
};
var flatMapIO10 = flatMapIO(_FromIO9, _FlatMap11);
var flatMapTask6 = flatMapTask(_FromTask5, _FlatMap11);
var flatten11 = flatMap24(identity3);
var alt9 = alt4(Monad4);
var zero6 = zero4(Pointed8);
var none4 = zero6();
var compact8 = compact4(Functor19, Compactable3);
var separate8 = separate4(Functor19, Compactable3, Functor6);
var filter8 = filter5(Functor19, Filterable);
var filterMap7 = filterMap4(Functor19, Filterable);
var partition7 = partition4(Functor19, Filterable);
var partitionMap7 = partitionMap4(Functor19, Filterable);
var _map28 = function(fa2, f8) {
  return pipe(fa2, map29(f8));
};
var _ap16 = function(fab, fa2) {
  return pipe(fab, ap24(fa2));
};
var URI28 = "TaskOption";
var Functor28 = {
  URI: URI28,
  map: _map28
};
var as15 = dual(2, as2(Functor28));
var asUnit14 = asUnit(Functor28);
var flap29 = flap(Functor28);
var Pointed11 = {
  URI: URI28,
  of: of23
};
var ApplyPar6 = {
  URI: URI28,
  map: _map28,
  ap: _ap16
};
var apFirst21 = apFirst(ApplyPar6);
var apSecond21 = apSecond(ApplyPar6);
var Chain20 = {
  URI: URI28,
  map: _map28,
  ap: _ap16,
  chain: flatMap24
};
var FromEither11 = {
  URI: URI28,
  fromEither: fromEither11
};
var FromIO9 = {
  URI: URI28,
  fromIO: fromIO9
};
var FromTask5 = {
  URI: URI28,
  fromIO: fromIO9,
  fromTask: fromTask5
};
var tap17 = dual(2, tap(Chain20));
var tapEither9 = dual(2, tapEither(FromEither11, Chain20));
var tapIO10 = dual(2, tapIO(FromIO9, Chain20));
var tapTask6 = dual(2, tapTask(FromTask5, Chain20));
var Zero5 = {
  URI: URI28,
  zero: zero6
};
var guard7 = guard2(Zero5, Pointed11);
var fromIOK10 = fromIOK(FromIO9);
var fromEitherK11 = fromEitherK(FromEither11);
var chainEitherK3 = chainEitherK(FromEither11, Chain20);
var fromTaskK6 = fromTaskK(FromTask5);
var Do21 = of23(emptyRecord);
var bindTo21 = bindTo(Functor28);
var let_20 = let_(Functor28);
var bind22 = bind2(Chain20);
var apS21 = apS(ApplyPar6);
var ApT13 = of23(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex14 = function(f8) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex9(f8), map21(traverseReadonlyNonEmptyArrayWithIndex(SK)));
};
var traverseReadonlyArrayWithIndex14 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndex14(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT13;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq6 = function(f8) {
  return function(as16) {
    return function() {
      return tail(as16).reduce(function(acc, a3, i4) {
        return acc.then(function(obs) {
          return isNone(obs) ? acc : f8(i4 + 1, a3)().then(function(ob) {
            if (isNone(ob)) {
              return ob;
            }
            obs.value.push(ob.value);
            return obs;
          });
        });
      }, f8(0, head(as16))().then(map7(singleton)));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq6 = function(f8) {
  var g3 = traverseReadonlyNonEmptyArrayWithIndexSeq6(f8);
  return function(as16) {
    return isNonEmpty(as16) ? g3(as16) : ApT13;
  };
};
var traverseArray14 = function(f8) {
  return traverseReadonlyArrayWithIndex14(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceArray14 = traverseArray14(identity3);
var traverseSeqArray6 = function(f8) {
  return traverseReadonlyArrayWithIndexSeq6(function(_3, a3) {
    return f8(a3);
  });
};
var sequenceSeqArray6 = traverseSeqArray6(identity3);

// node_modules/fp-ts/es6/These.js
var isLeft3 = function(fa2) {
  return fa2._tag === "Left";
};
var isRight3 = function(fa2) {
  return fa2._tag === "Right";
};
function isBoth(fa2) {
  return fa2._tag === "Both";
}
function left10(left13) {
  return { _tag: "Left", left: left13 };
}
function right10(right13) {
  return { _tag: "Right", right: right13 };
}
function both(left13, right13) {
  return { _tag: "Both", left: left13, right: right13 };
}
var matchW3 = function(onLeft, onRight, onBoth) {
  return function(fa2) {
    switch (fa2._tag) {
      case "Left":
        return onLeft(fa2.left);
      case "Right":
        return onRight(fa2.right);
      case "Both":
        return onBoth(fa2.left, fa2.right);
    }
  };
};
var match11 = matchW3;
var swap7 = match11(right10, left10, function(e2, a3) {
  return both(a3, e2);
});
var _map29 = function(fa2, f8) {
  return pipe(fa2, map30(f8));
};
var bimap3 = function(f8, g3) {
  return function(fa2) {
    return isLeft3(fa2) ? left10(f8(fa2.left)) : isRight3(fa2) ? right10(g3(fa2.right)) : both(f8(fa2.left), g3(fa2.right));
  };
};
var mapLeft3 = function(f8) {
  return function(fa2) {
    return isLeft3(fa2) ? left10(f8(fa2.left)) : isBoth(fa2) ? both(f8(fa2.left), fa2.right) : fa2;
  };
};
var map30 = function(f8) {
  return function(fa2) {
    return isLeft3(fa2) ? fa2 : isRight3(fa2) ? right10(f8(fa2.right)) : both(fa2.left, f8(fa2.right));
  };
};
var of24 = right10;
var URI29 = "These";
var Functor29 = {
  URI: URI29,
  map: _map29
};
var flap30 = flap(Functor29);
var FromEither12 = {
  URI: URI29,
  fromEither: identity3
};
var fromPredicate12 = fromPredicate(FromEither12);
var fromOption8 = fromOption(FromEither12);
var fromOptionK11 = fromOptionK(FromEither12);
var toTuple2 = function(e2, a3) {
  return function(fa2) {
    return isLeft3(fa2) ? [fa2.left, a3()] : isRight3(fa2) ? [e2(), fa2.right] : [fa2.left, fa2.right];
  };
};
var ApT14 = of24(emptyReadonlyArray);

// node_modules/fp-ts/es6/TheseT.js
function right11(F5) {
  return flow(right10, F5.of);
}
function left11(F5) {
  return flow(left10, F5.of);
}
function both2(F5) {
  return flow(both, F5.of);
}
function rightF2(F5) {
  return function(fa2) {
    return F5.map(fa2, right10);
  };
}
function leftF2(F5) {
  return function(fe5) {
    return F5.map(fe5, left10);
  };
}
function map31(F5) {
  return map(F5, Functor29);
}
function bimap4(F5) {
  return function(f8, g3) {
    return function(fea) {
      return F5.map(fea, bimap3(f8, g3));
    };
  };
}
function mapLeft4(F5) {
  return function(f8) {
    return function(fea) {
      return F5.map(fea, mapLeft3(f8));
    };
  };
}
function match12(F5) {
  return function(onLeft, onRight, onBoth) {
    return function(ma2) {
      return F5.map(ma2, match11(onLeft, onRight, onBoth));
    };
  };
}
function matchE9(M4) {
  return function(onLeft, onRight, onBoth) {
    return function(ma2) {
      return M4.chain(ma2, match11(onLeft, onRight, onBoth));
    };
  };
}
function swap8(F5) {
  return function(ma2) {
    return F5.map(ma2, swap7);
  };
}
function toTuple22(F5) {
  return function(e2, a3) {
    return function(fa2) {
      return F5.map(fa2, toTuple2(e2, a3));
    };
  };
}

// node_modules/fp-ts/es6/TaskThese.js
var left12 = left11(Pointed8);
var right12 = right11(Pointed8);
var both3 = both2(Pointed8);
var rightTask4 = rightF2(Functor19);
var leftTask3 = leftF2(Functor19);
var rightIO5 = flow(fromIO4, rightTask4);
var leftIO4 = flow(fromIO4, leftTask3);
var fromEither12 = of17;
var fromThese = of17;
var fromIO10 = rightIO5;
var fromTask6 = rightTask4;
var match13 = match12(Functor19);
var matchE10 = matchE9(Monad4);
var swap9 = swap8(Functor19);
var _map30 = function(fa2, f8) {
  return pipe(fa2, map32(f8));
};
var map32 = map31(Functor19);
var bimap5 = bimap4(Functor19);
var mapLeft5 = mapLeft4(Functor19);
var of25 = right12;
var URI30 = "TaskThese";
var Functor30 = {
  URI: URI30,
  map: _map30
};
var flap31 = flap(Functor30);
var FromEither13 = {
  URI: URI30,
  fromEither: fromEither12
};
var fromOption9 = fromOption(FromEither13);
var fromOptionK12 = fromOptionK(FromEither13);
var fromPredicate13 = fromPredicate(FromEither13);
var FromThese = {
  URI: URI30,
  fromThese
};
var fromTheseK2 = fromTheseK(FromThese);
var FromIO10 = {
  URI: URI30,
  fromIO: fromIO10
};
var fromIOK11 = fromIOK(FromIO10);
var FromTask6 = {
  URI: URI30,
  fromIO: fromIO10,
  fromTask: fromTask6
};
var fromTaskK7 = fromTaskK(FromTask6);
var toTuple23 = toTuple22(Functor19);
var ApT15 = of25(emptyReadonlyArray);

// node_modules/fp-ts/es6/Traced.js
var _map31 = function(fa2, f8) {
  return pipe(fa2, map33(f8));
};
var map33 = function(f8) {
  return function(fa2) {
    return function(p4) {
      return f8(fa2(p4));
    };
  };
};
var URI31 = "Traced";
var Functor31 = {
  URI: URI31,
  map: _map31
};
var flap32 = flap(Functor31);

// node_modules/fp-ts/es6/Tree.js
function make(value, forest) {
  if (forest === void 0) {
    forest = [];
  }
  return {
    value,
    forest
  };
}
var _map32 = function(fa2, f8) {
  return pipe(fa2, map34(f8));
};
var _ap17 = function(fab, fa2) {
  return flatMap25(fab, function(f8) {
    return pipe(fa2, map34(f8));
  });
};
var flatMap25 = dual(2, function(ma2, f8) {
  var _a21 = f8(ma2.value), value = _a21.value, forest = _a21.forest;
  var concat6 = getMonoid2().concat;
  return {
    value,
    forest: concat6(forest, ma2.forest.map(flatMap25(f8)))
  };
});
var extend11 = function(f8) {
  return function(wa2) {
    return {
      value: f8(wa2),
      forest: wa2.forest.map(extend11(f8))
    };
  };
};
var duplicate10 = extend11(identity3);
var flatten12 = flatMap25(identity3);
var map34 = function(f8) {
  return function(fa2) {
    return {
      value: f8(fa2.value),
      forest: fa2.forest.map(map34(f8))
    };
  };
};
var of26 = function(a3) {
  return make(a3);
};
var URI32 = "Tree";
var Functor32 = {
  URI: URI32,
  map: _map32
};
var flap33 = flap(Functor32);
var Apply15 = {
  URI: URI32,
  map: _map32,
  ap: _ap17
};
var apFirst22 = apFirst(Apply15);
var apSecond22 = apSecond(Apply15);
var Chain21 = {
  URI: URI32,
  map: _map32,
  ap: _ap17,
  chain: flatMap25
};
var chainFirst7 = chainFirst(Chain21);
var Do22 = of26(emptyRecord);
var bindTo22 = bindTo(Functor32);
var let_21 = let_(Functor32);
var bind23 = bind2(Chain21);
var apS22 = apS(Apply15);

// node_modules/fp-ts/es6/Tuple.js
var fst2 = fst;
var snd2 = snd;
var _map33 = function(fa2, f8) {
  return pipe(fa2, mapFst2(f8));
};
var mapFst2 = function(f8) {
  return function(fa2) {
    return [f8(fst2(fa2)), snd2(fa2)];
  };
};
var extend12 = function(f8) {
  return function(wa2) {
    return [f8(wa2), snd2(wa2)];
  };
};
var duplicate11 = extend12(identity3);
var URI33 = "Tuple";
var Functor33 = {
  URI: URI33,
  map: _map33
};
var flap34 = flap(Functor33);

// node_modules/fp-ts/es6/void.js
var Semigroup3 = constant2(void 0);
var Monoid3 = {
  concat: Semigroup3.concat,
  empty: void 0
};

// node_modules/fp-ts/es6/Writer.js
var _map34 = function(fa2, f8) {
  return pipe(fa2, map35(f8));
};
var map35 = function(f8) {
  return function(fa2) {
    return function() {
      var _a21 = fa2(), a3 = _a21[0], w4 = _a21[1];
      return [f8(a3), w4];
    };
  };
};
var URI34 = "Writer";
var Functor34 = {
  URI: URI34,
  map: _map34
};
var flap35 = flap(Functor34);

// node_modules/io-ts/es6/index.js
var __extends3 = /* @__PURE__ */ (function() {
  var extendStatics3 = function(d4, b4) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {
      d5.__proto__ = b5;
    } || function(d5, b5) {
      for (var p4 in b5) if (Object.prototype.hasOwnProperty.call(b5, p4)) d5[p4] = b5[p4];
    };
    return extendStatics3(d4, b4);
  };
  return function(d4, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics3(d4, b4);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
})();
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s3, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {
      s3 = arguments[i4];
      for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4))
        t[p4] = s3[p4];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var failures = left3;
var failure = function(value, context, message) {
  return failures([{ value, context, message }]);
};
var success = right3;
var Type = (
  /** @class */
  (function() {
    function Type2(name2, is2, validate9, encode16) {
      this.name = name2;
      this.is = is2;
      this.validate = validate9;
      this.encode = encode16;
      this.decode = this.decode.bind(this);
    }
    Type2.prototype.pipe = function(ab, name2) {
      var _this = this;
      if (name2 === void 0) {
        name2 = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
      }
      return new Type2(name2, ab.is, function(i4, c6) {
        var e2 = _this.validate(i4, c6);
        if (isLeft2(e2)) {
          return e2;
        }
        return ab.validate(e2.right, c6);
      }, this.encode === identity4 && ab.encode === identity4 ? identity4 : function(b4) {
        return _this.encode(ab.encode(b4));
      });
    };
    Type2.prototype.asDecoder = function() {
      return this;
    };
    Type2.prototype.asEncoder = function() {
      return this;
    };
    Type2.prototype.decode = function(i4) {
      return this.validate(i4, [{ key: "", type: this, actual: i4 }]);
    };
    return Type2;
  })()
);
var identity4 = function(a3) {
  return a3;
};
function getFunctionName(f8) {
  return f8.displayName || f8.name || "<function".concat(f8.length, ">");
}
function appendContext(c6, key, decoder, actual) {
  var len = c6.length;
  var r3 = Array(len + 1);
  for (var i4 = 0; i4 < len; i4++) {
    r3[i4] = c6[i4];
  }
  r3[len] = { key, type: decoder, actual };
  return r3;
}
function pushAll(xs4, ys3) {
  var l6 = ys3.length;
  for (var i4 = 0; i4 < l6; i4++) {
    xs4.push(ys3[i4]);
  }
}
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
function getNameFromProps(props) {
  return Object.keys(props).map(function(k6) {
    return "".concat(k6, ": ").concat(props[k6].name);
  }).join(", ");
}
function useIdentity(codecs) {
  for (var i4 = 0; i4 < codecs.length; i4++) {
    if (codecs[i4].encode !== identity4) {
      return false;
    }
  }
  return true;
}
function getInterfaceTypeName(props) {
  return "{ ".concat(getNameFromProps(props), " }");
}
function getPartialTypeName(inner) {
  return "Partial<".concat(inner, ">");
}
function getUnionName(codecs) {
  return "(" + codecs.map(function(type3) {
    return type3.name;
  }).join(" | ") + ")";
}
function mergeAll(base3, us2) {
  var equal = true;
  var primitive = true;
  var baseIsNotADictionary = !UnknownRecord.is(base3);
  for (var _i4 = 0, us_1 = us2; _i4 < us_1.length; _i4++) {
    var u2 = us_1[_i4];
    if (u2 !== base3) {
      equal = false;
    }
    if (UnknownRecord.is(u2)) {
      primitive = false;
    }
  }
  if (equal) {
    return base3;
  } else if (primitive) {
    return us2[us2.length - 1];
  }
  var r3 = {};
  for (var _a21 = 0, us_2 = us2; _a21 < us_2.length; _a21++) {
    var u2 = us_2[_a21];
    for (var k6 in u2) {
      if (!hasOwnProperty3.call(r3, k6) || baseIsNotADictionary || u2[k6] !== base3[k6]) {
        r3[k6] = u2[k6];
      }
    }
  }
  return r3;
}
function isNonEmpty4(as16) {
  return as16.length > 0;
}
var emptyTags = {};
function intersect(a3, b4) {
  var r3 = [];
  for (var _i4 = 0, a_1 = a3; _i4 < a_1.length; _i4++) {
    var v6 = a_1[_i4];
    if (b4.indexOf(v6) !== -1) {
      r3.push(v6);
    }
  }
  return r3;
}
function mergeTags(a3, b4) {
  if (a3 === emptyTags) {
    return b4;
  }
  if (b4 === emptyTags) {
    return a3;
  }
  var r3 = Object.assign({}, a3);
  for (var k6 in b4) {
    if (hasOwnProperty3.call(a3, k6)) {
      var intersection_1 = intersect(a3[k6], b4[k6]);
      if (isNonEmpty4(intersection_1)) {
        r3[k6] = intersection_1;
      } else {
        r3 = emptyTags;
        break;
      }
    } else {
      r3[k6] = b4[k6];
    }
  }
  return r3;
}
function intersectTags(a3, b4) {
  if (a3 === emptyTags || b4 === emptyTags) {
    return emptyTags;
  }
  var r3 = emptyTags;
  for (var k6 in a3) {
    if (hasOwnProperty3.call(b4, k6)) {
      var intersection_2 = intersect(a3[k6], b4[k6]);
      if (intersection_2.length === 0) {
        if (r3 === emptyTags) {
          r3 = {};
        }
        r3[k6] = a3[k6].concat(b4[k6]);
      }
    }
  }
  return r3;
}
function isLiteralC(codec) {
  return codec._tag === "LiteralType";
}
function isTypeC(codec) {
  return codec._tag === "InterfaceType";
}
function isStrictC(codec) {
  return codec._tag === "StrictType";
}
function isExactC(codec) {
  return codec._tag === "ExactType";
}
function isRefinementC(codec) {
  return codec._tag === "RefinementType";
}
function isIntersectionC(codec) {
  return codec._tag === "IntersectionType";
}
function isUnionC(codec) {
  return codec._tag === "UnionType";
}
function isRecursiveC(codec) {
  return codec._tag === "RecursiveType";
}
function isReadonlyC(codec) {
  return codec._tag === "ReadonlyType";
}
var lazyCodecs = [];
function getTags(codec) {
  if (lazyCodecs.indexOf(codec) !== -1) {
    return emptyTags;
  }
  if (isTypeC(codec) || isStrictC(codec)) {
    var index = emptyTags;
    for (var k6 in codec.props) {
      var prop = codec.props[k6];
      if (isLiteralC(prop)) {
        if (index === emptyTags) {
          index = {};
        }
        index[k6] = [prop.value];
      }
    }
    return index;
  } else if (isExactC(codec) || isRefinementC(codec) || isReadonlyC(codec)) {
    return getTags(codec.type);
  } else if (isIntersectionC(codec)) {
    return codec.types.reduce(function(tags2, codec2) {
      return mergeTags(tags2, getTags(codec2));
    }, emptyTags);
  } else if (isUnionC(codec)) {
    return codec.types.slice(1).reduce(function(tags2, codec2) {
      return intersectTags(tags2, getTags(codec2));
    }, getTags(codec.types[0]));
  } else if (isRecursiveC(codec)) {
    lazyCodecs.push(codec);
    var tags = getTags(codec.type);
    lazyCodecs.pop();
    return tags;
  }
  return emptyTags;
}
function getIndex(codecs) {
  var tags = getTags(codecs[0]);
  var keys4 = Object.keys(tags);
  var len = codecs.length;
  var _loop_1 = function(k7) {
    var all5 = tags[k7].slice();
    var index = [tags[k7]];
    for (var i4 = 1; i4 < len; i4++) {
      var codec = codecs[i4];
      var ctags = getTags(codec);
      var values = ctags[k7];
      if (values === void 0) {
        return "continue-keys";
      } else {
        if (values.some(function(v6) {
          return all5.indexOf(v6) !== -1;
        })) {
          return "continue-keys";
        } else {
          all5.push.apply(all5, values);
          index.push(values);
        }
      }
    }
    return { value: [k7, index] };
  };
  keys: for (var _i4 = 0, keys_1 = keys4; _i4 < keys_1.length; _i4++) {
    var k6 = keys_1[_i4];
    var state_1 = _loop_1(k6);
    if (typeof state_1 === "object")
      return state_1.value;
    switch (state_1) {
      case "continue-keys":
        continue keys;
    }
  }
  return void 0;
}
var NullType = (
  /** @class */
  (function(_super) {
    __extends3(NullType2, _super);
    function NullType2() {
      var _this = _super.call(this, "null", function(u2) {
        return u2 === null;
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "NullType";
      return _this;
    }
    return NullType2;
  })(Type)
);
var nullType = new NullType();
var UndefinedType = (
  /** @class */
  (function(_super) {
    __extends3(UndefinedType2, _super);
    function UndefinedType2() {
      var _this = _super.call(this, "undefined", function(u2) {
        return u2 === void 0;
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "UndefinedType";
      return _this;
    }
    return UndefinedType2;
  })(Type)
);
var undefinedType = new UndefinedType();
var VoidType = (
  /** @class */
  (function(_super) {
    __extends3(VoidType2, _super);
    function VoidType2() {
      var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, identity4) || this;
      _this._tag = "VoidType";
      return _this;
    }
    return VoidType2;
  })(Type)
);
var voidType = new VoidType();
var UnknownType = (
  /** @class */
  (function(_super) {
    __extends3(UnknownType2, _super);
    function UnknownType2() {
      var _this = _super.call(this, "unknown", function(_3) {
        return true;
      }, success, identity4) || this;
      _this._tag = "UnknownType";
      return _this;
    }
    return UnknownType2;
  })(Type)
);
var unknown2 = new UnknownType();
var StringType = (
  /** @class */
  (function(_super) {
    __extends3(StringType2, _super);
    function StringType2() {
      var _this = _super.call(this, "string", function(u2) {
        return typeof u2 === "string";
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "StringType";
      return _this;
    }
    return StringType2;
  })(Type)
);
var string3 = new StringType();
var NumberType = (
  /** @class */
  (function(_super) {
    __extends3(NumberType2, _super);
    function NumberType2() {
      var _this = _super.call(this, "number", function(u2) {
        return typeof u2 === "number";
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "NumberType";
      return _this;
    }
    return NumberType2;
  })(Type)
);
var number2 = new NumberType();
var BigIntType = (
  /** @class */
  (function(_super) {
    __extends3(BigIntType2, _super);
    function BigIntType2() {
      var _this = _super.call(
        this,
        "bigint",
        // tslint:disable-next-line: valid-typeof
        function(u2) {
          return typeof u2 === "bigint";
        },
        function(u2, c6) {
          return _this.is(u2) ? success(u2) : failure(u2, c6);
        },
        identity4
      ) || this;
      _this._tag = "BigIntType";
      return _this;
    }
    return BigIntType2;
  })(Type)
);
var bigint = new BigIntType();
var BooleanType = (
  /** @class */
  (function(_super) {
    __extends3(BooleanType2, _super);
    function BooleanType2() {
      var _this = _super.call(this, "boolean", function(u2) {
        return typeof u2 === "boolean";
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "BooleanType";
      return _this;
    }
    return BooleanType2;
  })(Type)
);
var boolean2 = new BooleanType();
var AnyArrayType = (
  /** @class */
  (function(_super) {
    __extends3(AnyArrayType2, _super);
    function AnyArrayType2() {
      var _this = _super.call(this, "UnknownArray", Array.isArray, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "AnyArrayType";
      return _this;
    }
    return AnyArrayType2;
  })(Type)
);
var UnknownArray = new AnyArrayType();
var AnyDictionaryType = (
  /** @class */
  (function(_super) {
    __extends3(AnyDictionaryType2, _super);
    function AnyDictionaryType2() {
      var _this = _super.call(this, "UnknownRecord", function(u2) {
        return u2 !== null && typeof u2 === "object" && !Array.isArray(u2);
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "AnyDictionaryType";
      return _this;
    }
    return AnyDictionaryType2;
  })(Type)
);
var UnknownRecord = new AnyDictionaryType();
var LiteralType = (
  /** @class */
  (function(_super) {
    __extends3(LiteralType2, _super);
    function LiteralType2(name2, is2, validate9, encode16, value) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.value = value;
      _this._tag = "LiteralType";
      return _this;
    }
    return LiteralType2;
  })(Type)
);
function literal2(value, name2) {
  if (name2 === void 0) {
    name2 = JSON.stringify(value);
  }
  var is2 = function(u2) {
    return u2 === value;
  };
  return new LiteralType(name2, is2, function(u2, c6) {
    return is2(u2) ? success(value) : failure(u2, c6);
  }, identity4, value);
}
var KeyofType = (
  /** @class */
  (function(_super) {
    __extends3(KeyofType2, _super);
    function KeyofType2(name2, is2, validate9, encode16, keys4) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.keys = keys4;
      _this._tag = "KeyofType";
      return _this;
    }
    return KeyofType2;
  })(Type)
);
var RefinementType = (
  /** @class */
  (function(_super) {
    __extends3(RefinementType2, _super);
    function RefinementType2(name2, is2, validate9, encode16, type3, predicate) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.type = type3;
      _this.predicate = predicate;
      _this._tag = "RefinementType";
      return _this;
    }
    return RefinementType2;
  })(Type)
);
function brand(codec, predicate, name2) {
  return refinement(codec, predicate, name2);
}
var Int = brand(number2, function(n5) {
  return Number.isInteger(n5);
}, "Int");
var RecursiveType = (
  /** @class */
  (function(_super) {
    __extends3(RecursiveType2, _super);
    function RecursiveType2(name2, is2, validate9, encode16, runDefinition) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.runDefinition = runDefinition;
      _this._tag = "RecursiveType";
      return _this;
    }
    return RecursiveType2;
  })(Type)
);
Object.defineProperty(RecursiveType.prototype, "type", {
  get: function() {
    return this.runDefinition();
  },
  enumerable: true,
  configurable: true
});
var ArrayType = (
  /** @class */
  (function(_super) {
    __extends3(ArrayType2, _super);
    function ArrayType2(name2, is2, validate9, encode16, type3) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.type = type3;
      _this._tag = "ArrayType";
      return _this;
    }
    return ArrayType2;
  })(Type)
);
var InterfaceType = (
  /** @class */
  (function(_super) {
    __extends3(InterfaceType2, _super);
    function InterfaceType2(name2, is2, validate9, encode16, props) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.props = props;
      _this._tag = "InterfaceType";
      return _this;
    }
    return InterfaceType2;
  })(Type)
);
function type2(props, name2) {
  if (name2 === void 0) {
    name2 = getInterfaceTypeName(props);
  }
  var keys4 = Object.keys(props);
  var types = keys4.map(function(key) {
    return props[key];
  });
  var len = keys4.length;
  return new InterfaceType(name2, function(u2) {
    if (UnknownRecord.is(u2)) {
      for (var i4 = 0; i4 < len; i4++) {
        var k6 = keys4[i4];
        var uk = u2[k6];
        if (uk === void 0 && !hasOwnProperty3.call(u2, k6) || !types[i4].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u2, c6) {
    var e2 = UnknownRecord.validate(u2, c6);
    if (isLeft2(e2)) {
      return e2;
    }
    var o4 = e2.right;
    var a3 = o4;
    var errors = [];
    for (var i4 = 0; i4 < len; i4++) {
      var k6 = keys4[i4];
      var ak = a3[k6];
      var type_1 = types[i4];
      var result = type_1.validate(ak, appendContext(c6, k6, type_1, ak));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var vak = result.right;
        if (vak !== ak || vak === void 0 && !hasOwnProperty3.call(a3, k6)) {
          if (a3 === o4) {
            a3 = __assign3({}, o4);
          }
          a3[k6] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a3);
  }, useIdentity(types) ? identity4 : function(a3) {
    var s3 = __assign3({}, a3);
    for (var i4 = 0; i4 < len; i4++) {
      var k6 = keys4[i4];
      var encode16 = types[i4].encode;
      if (encode16 !== identity4) {
        s3[k6] = encode16(a3[k6]);
      }
    }
    return s3;
  }, props);
}
var PartialType = (
  /** @class */
  (function(_super) {
    __extends3(PartialType2, _super);
    function PartialType2(name2, is2, validate9, encode16, props) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.props = props;
      _this._tag = "PartialType";
      return _this;
    }
    return PartialType2;
  })(Type)
);
function partial(props, name2) {
  if (name2 === void 0) {
    name2 = getPartialTypeName(getInterfaceTypeName(props));
  }
  var keys4 = Object.keys(props);
  var types = keys4.map(function(key) {
    return props[key];
  });
  var len = keys4.length;
  return new PartialType(name2, function(u2) {
    if (UnknownRecord.is(u2)) {
      for (var i4 = 0; i4 < len; i4++) {
        var k6 = keys4[i4];
        var uk = u2[k6];
        if (uk !== void 0 && !props[k6].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u2, c6) {
    var e2 = UnknownRecord.validate(u2, c6);
    if (isLeft2(e2)) {
      return e2;
    }
    var o4 = e2.right;
    var a3 = o4;
    var errors = [];
    for (var i4 = 0; i4 < len; i4++) {
      var k6 = keys4[i4];
      var ak = a3[k6];
      var type_2 = props[k6];
      var result = type_2.validate(ak, appendContext(c6, k6, type_2, ak));
      if (isLeft2(result)) {
        if (ak !== void 0) {
          pushAll(errors, result.left);
        }
      } else {
        var vak = result.right;
        if (vak !== ak) {
          if (a3 === o4) {
            a3 = __assign3({}, o4);
          }
          a3[k6] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a3);
  }, useIdentity(types) ? identity4 : function(a3) {
    var s3 = __assign3({}, a3);
    for (var i4 = 0; i4 < len; i4++) {
      var k6 = keys4[i4];
      var ak = a3[k6];
      if (ak !== void 0) {
        s3[k6] = types[i4].encode(ak);
      }
    }
    return s3;
  }, props);
}
var DictionaryType = (
  /** @class */
  (function(_super) {
    __extends3(DictionaryType2, _super);
    function DictionaryType2(name2, is2, validate9, encode16, domain, codomain) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.domain = domain;
      _this.codomain = codomain;
      _this._tag = "DictionaryType";
      return _this;
    }
    return DictionaryType2;
  })(Type)
);
var UnionType = (
  /** @class */
  (function(_super) {
    __extends3(UnionType2, _super);
    function UnionType2(name2, is2, validate9, encode16, types) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.types = types;
      _this._tag = "UnionType";
      return _this;
    }
    return UnionType2;
  })(Type)
);
function union6(codecs, name2) {
  if (name2 === void 0) {
    name2 = getUnionName(codecs);
  }
  var index = getIndex(codecs);
  if (index !== void 0 && codecs.length > 0) {
    var tag_1 = index[0], groups_1 = index[1];
    var len_1 = groups_1.length;
    var find_1 = function(value) {
      for (var i4 = 0; i4 < len_1; i4++) {
        if (groups_1[i4].indexOf(value) !== -1) {
          return i4;
        }
      }
      return void 0;
    };
    return new TaggedUnionType(name2, function(u2) {
      if (UnknownRecord.is(u2)) {
        var i4 = find_1(u2[tag_1]);
        return i4 !== void 0 ? codecs[i4].is(u2) : false;
      }
      return false;
    }, function(u2, c6) {
      var e2 = UnknownRecord.validate(u2, c6);
      if (isLeft2(e2)) {
        return e2;
      }
      var r3 = e2.right;
      var i4 = find_1(r3[tag_1]);
      if (i4 === void 0) {
        return failure(u2, c6);
      }
      var codec = codecs[i4];
      return codec.validate(r3, appendContext(c6, String(i4), codec, r3));
    }, useIdentity(codecs) ? identity4 : function(a3) {
      var i4 = find_1(a3[tag_1]);
      if (i4 === void 0) {
        throw new Error("no codec found to encode value in union codec ".concat(name2));
      } else {
        return codecs[i4].encode(a3);
      }
    }, codecs, tag_1);
  } else {
    return new UnionType(name2, function(u2) {
      return codecs.some(function(type3) {
        return type3.is(u2);
      });
    }, function(u2, c6) {
      var errors = [];
      for (var i4 = 0; i4 < codecs.length; i4++) {
        var codec = codecs[i4];
        var result = codec.validate(u2, appendContext(c6, String(i4), codec, u2));
        if (isLeft2(result)) {
          pushAll(errors, result.left);
        } else {
          return success(result.right);
        }
      }
      return failures(errors);
    }, useIdentity(codecs) ? identity4 : function(a3) {
      for (var _i4 = 0, codecs_1 = codecs; _i4 < codecs_1.length; _i4++) {
        var codec = codecs_1[_i4];
        if (codec.is(a3)) {
          return codec.encode(a3);
        }
      }
      throw new Error("no codec found to encode value in union type ".concat(name2));
    }, codecs);
  }
}
var IntersectionType = (
  /** @class */
  (function(_super) {
    __extends3(IntersectionType2, _super);
    function IntersectionType2(name2, is2, validate9, encode16, types) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.types = types;
      _this._tag = "IntersectionType";
      return _this;
    }
    return IntersectionType2;
  })(Type)
);
function intersection3(codecs, name2) {
  if (name2 === void 0) {
    name2 = "(".concat(codecs.map(function(type3) {
      return type3.name;
    }).join(" & "), ")");
  }
  var len = codecs.length;
  return new IntersectionType(name2, function(u2) {
    return codecs.every(function(type3) {
      return type3.is(u2);
    });
  }, codecs.length === 0 ? success : function(u2, c6) {
    var us2 = [];
    var errors = [];
    for (var i4 = 0; i4 < len; i4++) {
      var codec = codecs[i4];
      var result = codec.validate(u2, appendContext(c6, String(i4), codec, u2));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        us2.push(result.right);
      }
    }
    return errors.length > 0 ? failures(errors) : success(mergeAll(u2, us2));
  }, codecs.length === 0 ? identity4 : function(a3) {
    return mergeAll(a3, codecs.map(function(codec) {
      return codec.encode(a3);
    }));
  }, codecs);
}
var TupleType = (
  /** @class */
  (function(_super) {
    __extends3(TupleType2, _super);
    function TupleType2(name2, is2, validate9, encode16, types) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.types = types;
      _this._tag = "TupleType";
      return _this;
    }
    return TupleType2;
  })(Type)
);
var ReadonlyType = (
  /** @class */
  (function(_super) {
    __extends3(ReadonlyType2, _super);
    function ReadonlyType2(name2, is2, validate9, encode16, type3) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.type = type3;
      _this._tag = "ReadonlyType";
      return _this;
    }
    return ReadonlyType2;
  })(Type)
);
var ReadonlyArrayType = (
  /** @class */
  (function(_super) {
    __extends3(ReadonlyArrayType2, _super);
    function ReadonlyArrayType2(name2, is2, validate9, encode16, type3) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.type = type3;
      _this._tag = "ReadonlyArrayType";
      return _this;
    }
    return ReadonlyArrayType2;
  })(Type)
);
var ExactType = (
  /** @class */
  (function(_super) {
    __extends3(ExactType2, _super);
    function ExactType2(name2, is2, validate9, encode16, type3) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.type = type3;
      _this._tag = "ExactType";
      return _this;
    }
    return ExactType2;
  })(Type)
);
var FunctionType = (
  /** @class */
  (function(_super) {
    __extends3(FunctionType2, _super);
    function FunctionType2() {
      var _this = _super.call(
        this,
        "Function",
        // tslint:disable-next-line:strict-type-predicates
        function(u2) {
          return typeof u2 === "function";
        },
        function(u2, c6) {
          return _this.is(u2) ? success(u2) : failure(u2, c6);
        },
        identity4
      ) || this;
      _this._tag = "FunctionType";
      return _this;
    }
    return FunctionType2;
  })(Type)
);
var Function2 = new FunctionType();
var NeverType = (
  /** @class */
  (function(_super) {
    __extends3(NeverType2, _super);
    function NeverType2() {
      var _this = _super.call(
        this,
        "never",
        function(_3) {
          return false;
        },
        function(u2, c6) {
          return failure(u2, c6);
        },
        /* istanbul ignore next */
        function() {
          throw new Error("cannot encode never");
        }
      ) || this;
      _this._tag = "NeverType";
      return _this;
    }
    return NeverType2;
  })(Type)
);
var never = new NeverType();
var AnyType = (
  /** @class */
  (function(_super) {
    __extends3(AnyType2, _super);
    function AnyType2() {
      var _this = _super.call(this, "any", function(_3) {
        return true;
      }, success, identity4) || this;
      _this._tag = "AnyType";
      return _this;
    }
    return AnyType2;
  })(Type)
);
var any2 = new AnyType();
function refinement(codec, predicate, name2) {
  if (name2 === void 0) {
    name2 = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
  }
  return new RefinementType(name2, function(u2) {
    return codec.is(u2) && predicate(u2);
  }, function(i4, c6) {
    var e2 = codec.validate(i4, c6);
    if (isLeft2(e2)) {
      return e2;
    }
    var a3 = e2.right;
    return predicate(a3) ? success(a3) : failure(a3, c6);
  }, codec.encode, codec, predicate);
}
var Integer = refinement(number2, Number.isInteger, "Integer");
var TaggedUnionType = (
  /** @class */
  (function(_super) {
    __extends3(TaggedUnionType2, _super);
    function TaggedUnionType2(name2, is2, validate9, encode16, codecs, tag) {
      var _this = _super.call(this, name2, is2, validate9, encode16, codecs) || this;
      _this.tag = tag;
      return _this;
    }
    return TaggedUnionType2;
  })(UnionType)
);
var ObjectType = (
  /** @class */
  (function(_super) {
    __extends3(ObjectType2, _super);
    function ObjectType2() {
      var _this = _super.call(this, "object", function(u2) {
        return u2 !== null && typeof u2 === "object";
      }, function(u2, c6) {
        return _this.is(u2) ? success(u2) : failure(u2, c6);
      }, identity4) || this;
      _this._tag = "ObjectType";
      return _this;
    }
    return ObjectType2;
  })(Type)
);
var object = new ObjectType();
var StrictType = (
  /** @class */
  (function(_super) {
    __extends3(StrictType2, _super);
    function StrictType2(name2, is2, validate9, encode16, props) {
      var _this = _super.call(this, name2, is2, validate9, encode16) || this;
      _this.props = props;
      _this._tag = "StrictType";
      return _this;
    }
    return StrictType2;
  })(Type)
);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/hashes/utils.js
function isBytes7(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function anumber4(n5, title = "") {
  if (!Number.isSafeInteger(n5) || n5 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n5}`);
  }
}
function abytes5(value, length2, title = "") {
  const bytes2 = isBytes7(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length2 !== void 0;
  if (!bytes2 || needsLen && len !== length2) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length2}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash2(h5) {
  if (typeof h5 !== "function" || typeof h5.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber4(h5.outputLen);
  anumber4(h5.blockLen);
}
function aexists2(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance2) {
  abytes5(out, void 0, "digestInto() output");
  const min4 = instance2.outputLen;
  if (out.length < min4) {
    throw new Error('"digestInto() output" expected to be of length >=' + min4);
  }
}
function clean2(...arrays) {
  for (let i4 = 0; i4 < arrays.length; i4++) {
    arrays[i4].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE2 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin4 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes3 = Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex5(bytes2) {
  abytes5(bytes2);
  if (hasHexBuiltin4)
    return bytes2.toHex();
  let hex2 = "";
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    hex2 += hexes3[bytes2[i4]];
  }
  return hex2;
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
function hexToBytes5(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin4)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai3 = 0, hi3 = 0; ai3 < al; ai3++, hi3 += 2) {
    const n1 = asciiToBase162(hex2.charCodeAt(hi3));
    const n22 = asciiToBase162(hex2.charCodeAt(hi3 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi3] + hex2[hi3 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi3);
    }
    array2[ai3] = n1 * 16 + n22;
  }
  return array2;
}
function createHasher4(hashCons, info = {}) {
  const hashC = (msg, opts2) => hashCons(opts2).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts2) => hashCons(opts2);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes3(bytesLength = 32) {
  const cr4 = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr4 == null ? void 0 : cr4.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr4.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/regex.js
var regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/validate.js
function validate8(uuid) {
  return typeof uuid === "string" && regex_default2.test(uuid);
}
var validate_default2 = validate8;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  return Uint8Array.of((v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v6 >>> 16 & 255, v6 >>> 8 & 255, v6 & 255, (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v6 / 4294967296 & 255, v6 >>> 24 & 255, v6 >>> 16 & 255, v6 >>> 8 & 255, v6 & 255);
}
var parse_default2 = parse2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex2 = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex2.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify2(arr, offset5 = 0) {
  return (byteToHex2[arr[offset5 + 0]] + byteToHex2[arr[offset5 + 1]] + byteToHex2[arr[offset5 + 2]] + byteToHex2[arr[offset5 + 3]] + "-" + byteToHex2[arr[offset5 + 4]] + byteToHex2[arr[offset5 + 5]] + "-" + byteToHex2[arr[offset5 + 6]] + byteToHex2[arr[offset5 + 7]] + "-" + byteToHex2[arr[offset5 + 8]] + byteToHex2[arr[offset5 + 9]] + "-" + byteToHex2[arr[offset5 + 10]] + byteToHex2[arr[offset5 + 11]] + byteToHex2[arr[offset5 + 12]] + byteToHex2[arr[offset5 + 13]] + byteToHex2[arr[offset5 + 14]] + byteToHex2[arr[offset5 + 15]]).toLowerCase();
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/rng.js
var rnds82 = new Uint8Array(16);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/md5.js
function md53(bytes2) {
  const words = uint8ToUint322(bytes2);
  const md5Bytes = wordsToMd52(words, bytes2.length * 8);
  return uint32ToUint82(md5Bytes);
}
function uint32ToUint82(input) {
  const bytes2 = new Uint8Array(input.length * 4);
  for (let i4 = 0; i4 < input.length * 4; i4++) {
    bytes2[i4] = input[i4 >> 2] >>> i4 % 4 * 8 & 255;
  }
  return bytes2;
}
function getOutputLength2(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd52(x5, len) {
  const xpad = new Uint32Array(getOutputLength2(len)).fill(0);
  xpad.set(x5);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x5 = xpad;
  let a3 = 1732584193;
  let b4 = -271733879;
  let c6 = -1732584194;
  let d4 = 271733878;
  for (let i4 = 0; i4 < x5.length; i4 += 16) {
    const olda = a3;
    const oldb = b4;
    const oldc = c6;
    const oldd = d4;
    a3 = md5ff2(a3, b4, c6, d4, x5[i4], 7, -680876936);
    d4 = md5ff2(d4, a3, b4, c6, x5[i4 + 1], 12, -389564586);
    c6 = md5ff2(c6, d4, a3, b4, x5[i4 + 2], 17, 606105819);
    b4 = md5ff2(b4, c6, d4, a3, x5[i4 + 3], 22, -1044525330);
    a3 = md5ff2(a3, b4, c6, d4, x5[i4 + 4], 7, -176418897);
    d4 = md5ff2(d4, a3, b4, c6, x5[i4 + 5], 12, 1200080426);
    c6 = md5ff2(c6, d4, a3, b4, x5[i4 + 6], 17, -1473231341);
    b4 = md5ff2(b4, c6, d4, a3, x5[i4 + 7], 22, -45705983);
    a3 = md5ff2(a3, b4, c6, d4, x5[i4 + 8], 7, 1770035416);
    d4 = md5ff2(d4, a3, b4, c6, x5[i4 + 9], 12, -1958414417);
    c6 = md5ff2(c6, d4, a3, b4, x5[i4 + 10], 17, -42063);
    b4 = md5ff2(b4, c6, d4, a3, x5[i4 + 11], 22, -1990404162);
    a3 = md5ff2(a3, b4, c6, d4, x5[i4 + 12], 7, 1804603682);
    d4 = md5ff2(d4, a3, b4, c6, x5[i4 + 13], 12, -40341101);
    c6 = md5ff2(c6, d4, a3, b4, x5[i4 + 14], 17, -1502002290);
    b4 = md5ff2(b4, c6, d4, a3, x5[i4 + 15], 22, 1236535329);
    a3 = md5gg2(a3, b4, c6, d4, x5[i4 + 1], 5, -165796510);
    d4 = md5gg2(d4, a3, b4, c6, x5[i4 + 6], 9, -1069501632);
    c6 = md5gg2(c6, d4, a3, b4, x5[i4 + 11], 14, 643717713);
    b4 = md5gg2(b4, c6, d4, a3, x5[i4], 20, -373897302);
    a3 = md5gg2(a3, b4, c6, d4, x5[i4 + 5], 5, -701558691);
    d4 = md5gg2(d4, a3, b4, c6, x5[i4 + 10], 9, 38016083);
    c6 = md5gg2(c6, d4, a3, b4, x5[i4 + 15], 14, -660478335);
    b4 = md5gg2(b4, c6, d4, a3, x5[i4 + 4], 20, -405537848);
    a3 = md5gg2(a3, b4, c6, d4, x5[i4 + 9], 5, 568446438);
    d4 = md5gg2(d4, a3, b4, c6, x5[i4 + 14], 9, -1019803690);
    c6 = md5gg2(c6, d4, a3, b4, x5[i4 + 3], 14, -187363961);
    b4 = md5gg2(b4, c6, d4, a3, x5[i4 + 8], 20, 1163531501);
    a3 = md5gg2(a3, b4, c6, d4, x5[i4 + 13], 5, -1444681467);
    d4 = md5gg2(d4, a3, b4, c6, x5[i4 + 2], 9, -51403784);
    c6 = md5gg2(c6, d4, a3, b4, x5[i4 + 7], 14, 1735328473);
    b4 = md5gg2(b4, c6, d4, a3, x5[i4 + 12], 20, -1926607734);
    a3 = md5hh2(a3, b4, c6, d4, x5[i4 + 5], 4, -378558);
    d4 = md5hh2(d4, a3, b4, c6, x5[i4 + 8], 11, -2022574463);
    c6 = md5hh2(c6, d4, a3, b4, x5[i4 + 11], 16, 1839030562);
    b4 = md5hh2(b4, c6, d4, a3, x5[i4 + 14], 23, -35309556);
    a3 = md5hh2(a3, b4, c6, d4, x5[i4 + 1], 4, -1530992060);
    d4 = md5hh2(d4, a3, b4, c6, x5[i4 + 4], 11, 1272893353);
    c6 = md5hh2(c6, d4, a3, b4, x5[i4 + 7], 16, -155497632);
    b4 = md5hh2(b4, c6, d4, a3, x5[i4 + 10], 23, -1094730640);
    a3 = md5hh2(a3, b4, c6, d4, x5[i4 + 13], 4, 681279174);
    d4 = md5hh2(d4, a3, b4, c6, x5[i4], 11, -358537222);
    c6 = md5hh2(c6, d4, a3, b4, x5[i4 + 3], 16, -722521979);
    b4 = md5hh2(b4, c6, d4, a3, x5[i4 + 6], 23, 76029189);
    a3 = md5hh2(a3, b4, c6, d4, x5[i4 + 9], 4, -640364487);
    d4 = md5hh2(d4, a3, b4, c6, x5[i4 + 12], 11, -421815835);
    c6 = md5hh2(c6, d4, a3, b4, x5[i4 + 15], 16, 530742520);
    b4 = md5hh2(b4, c6, d4, a3, x5[i4 + 2], 23, -995338651);
    a3 = md5ii2(a3, b4, c6, d4, x5[i4], 6, -198630844);
    d4 = md5ii2(d4, a3, b4, c6, x5[i4 + 7], 10, 1126891415);
    c6 = md5ii2(c6, d4, a3, b4, x5[i4 + 14], 15, -1416354905);
    b4 = md5ii2(b4, c6, d4, a3, x5[i4 + 5], 21, -57434055);
    a3 = md5ii2(a3, b4, c6, d4, x5[i4 + 12], 6, 1700485571);
    d4 = md5ii2(d4, a3, b4, c6, x5[i4 + 3], 10, -1894986606);
    c6 = md5ii2(c6, d4, a3, b4, x5[i4 + 10], 15, -1051523);
    b4 = md5ii2(b4, c6, d4, a3, x5[i4 + 1], 21, -2054922799);
    a3 = md5ii2(a3, b4, c6, d4, x5[i4 + 8], 6, 1873313359);
    d4 = md5ii2(d4, a3, b4, c6, x5[i4 + 15], 10, -30611744);
    c6 = md5ii2(c6, d4, a3, b4, x5[i4 + 6], 15, -1560198380);
    b4 = md5ii2(b4, c6, d4, a3, x5[i4 + 13], 21, 1309151649);
    a3 = md5ii2(a3, b4, c6, d4, x5[i4 + 4], 6, -145523070);
    d4 = md5ii2(d4, a3, b4, c6, x5[i4 + 11], 10, -1120210379);
    c6 = md5ii2(c6, d4, a3, b4, x5[i4 + 2], 15, 718787259);
    b4 = md5ii2(b4, c6, d4, a3, x5[i4 + 9], 21, -343485551);
    a3 = safeAdd2(a3, olda);
    b4 = safeAdd2(b4, oldb);
    c6 = safeAdd2(c6, oldc);
    d4 = safeAdd2(d4, oldd);
  }
  return Uint32Array.of(a3, b4, c6, d4);
}
function uint8ToUint322(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output2 = new Uint32Array(getOutputLength2(input.length * 8)).fill(0);
  for (let i4 = 0; i4 < input.length; i4++) {
    output2[i4 >> 2] |= (input[i4] & 255) << i4 % 4 * 8;
  }
  return output2;
}
function safeAdd2(x5, y5) {
  const lsw = (x5 & 65535) + (y5 & 65535);
  const msw = (x5 >> 16) + (y5 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft2(num3, cnt) {
  return num3 << cnt | num3 >>> 32 - cnt;
}
function md5cmn2(q, a3, b4, x5, s3, t) {
  return safeAdd2(bitRotateLeft2(safeAdd2(safeAdd2(a3, q), safeAdd2(x5, t)), s3), b4);
}
function md5ff2(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn2(b4 & c6 | ~b4 & d4, a3, b4, x5, s3, t);
}
function md5gg2(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn2(b4 & d4 | c6 & ~d4, a3, b4, x5, s3, t);
}
function md5hh2(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn2(b4 ^ c6 ^ d4, a3, b4, x5, s3, t);
}
function md5ii2(a3, b4, c6, d4, x5, s3, t) {
  return md5cmn2(c6 ^ (b4 | ~d4), a3, b4, x5, s3, t);
}
var md5_default2 = md53;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes4(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = new Uint8Array(str.length);
  for (let i4 = 0; i4 < str.length; ++i4) {
    bytes2[i4] = str.charCodeAt(i4);
  }
  return bytes2;
}
var DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v352(version11, hash, value, namespace, buf, offset5) {
  const valueBytes = typeof value === "string" ? stringToBytes4(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default2(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default2(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes2 = new Uint8Array(16 + valueBytes.length);
  bytes2.set(namespaceBytes);
  bytes2.set(valueBytes, namespaceBytes.length);
  bytes2 = hash(bytes2);
  bytes2[6] = bytes2[6] & 15 | version11;
  bytes2[8] = bytes2[8] & 63 | 128;
  if (buf) {
    offset5 = offset5 || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset5 + i4] = bytes2[i4];
    }
    return buf;
  }
  return unsafeStringify2(bytes2);
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/v3.js
function v33(value, namespace, buf, offset5) {
  return v352(48, md5_default2, value, namespace, buf, offset5);
}
v33.DNS = DNS2;
v33.URL = URL3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/native.js
var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/sha1.js
function f7(s3, x5, y5, z4) {
  switch (s3) {
    case 0:
      return x5 & y5 ^ ~x5 & z4;
    case 1:
      return x5 ^ y5 ^ z4;
    case 2:
      return x5 & y5 ^ x5 & z4 ^ y5 & z4;
    case 3:
      return x5 ^ y5 ^ z4;
  }
}
function ROTL2(x5, n5) {
  return x5 << n5 | x5 >>> 32 - n5;
}
function sha13(bytes2) {
  const K4 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes2.length + 1);
  newBytes.set(bytes2);
  newBytes[bytes2.length] = 128;
  bytes2 = newBytes;
  const l6 = bytes2.length / 4 + 2;
  const N15 = Math.ceil(l6 / 16);
  const M4 = new Array(N15);
  for (let i4 = 0; i4 < N15; ++i4) {
    const arr = new Uint32Array(16);
    for (let j3 = 0; j3 < 16; ++j3) {
      arr[j3] = bytes2[i4 * 64 + j3 * 4] << 24 | bytes2[i4 * 64 + j3 * 4 + 1] << 16 | bytes2[i4 * 64 + j3 * 4 + 2] << 8 | bytes2[i4 * 64 + j3 * 4 + 3];
    }
    M4[i4] = arr;
  }
  M4[N15 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M4[N15 - 1][14] = Math.floor(M4[N15 - 1][14]);
  M4[N15 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i4 = 0; i4 < N15; ++i4) {
    const W5 = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W5[t] = M4[i4][t];
    }
    for (let t = 16; t < 80; ++t) {
      W5[t] = ROTL2(W5[t - 3] ^ W5[t - 8] ^ W5[t - 14] ^ W5[t - 16], 1);
    }
    let a3 = H2[0];
    let b4 = H2[1];
    let c6 = H2[2];
    let d4 = H2[3];
    let e2 = H2[4];
    for (let t = 0; t < 80; ++t) {
      const s3 = Math.floor(t / 20);
      const T3 = ROTL2(a3, 5) + f7(s3, b4, c6, d4) + e2 + K4[s3] + W5[t] >>> 0;
      e2 = d4;
      d4 = c6;
      c6 = ROTL2(b4, 30) >>> 0;
      b4 = a3;
      a3 = T3;
    }
    H2[0] = H2[0] + a3 >>> 0;
    H2[1] = H2[1] + b4 >>> 0;
    H2[2] = H2[2] + c6 >>> 0;
    H2[3] = H2[3] + d4 >>> 0;
    H2[4] = H2[4] + e2 >>> 0;
  }
  return Uint8Array.of(H2[0] >> 24, H2[0] >> 16, H2[0] >> 8, H2[0], H2[1] >> 24, H2[1] >> 16, H2[1] >> 8, H2[1], H2[2] >> 24, H2[2] >> 16, H2[2] >> 8, H2[2], H2[3] >> 24, H2[3] >> 16, H2[3] >> 8, H2[3], H2[4] >> 24, H2[4] >> 16, H2[4] >> 8, H2[4]);
}
var sha1_default2 = sha13;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/uuid/dist/esm-browser/v5.js
function v52(value, namespace, buf, offset5) {
  return v352(80, sha1_default2, value, namespace, buf, offset5);
}
v52.DNS = DNS2;
v52.URL = URL3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-client/dist/index.js
var ws4 = __toESM(require_browser5());

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/bind.js
function bind24(fn4, thisArg) {
  return function wrap() {
    return fn4.apply(thisArg, arguments);
  };
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/utils.js
var { toString: toString7 } = Object.prototype;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var { iterator: iterator2, toStringTag: toStringTag2 } = Symbol;
var kindOf2 = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString7.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest2 = (type3) => {
  type3 = type3.toLowerCase();
  return (thing) => kindOf2(thing) === type3;
};
var typeOfTest2 = (type3) => (thing) => typeof thing === type3;
var { isArray: isArray2 } = Array;
var isUndefined2 = typeOfTest2("undefined");
function isBuffer2(val) {
  return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && isFunction3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer2 = kindOfTest2("ArrayBuffer");
function isArrayBufferView2(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer2(val.buffer);
  }
  return result;
}
var isString2 = typeOfTest2("string");
var isFunction3 = typeOfTest2("function");
var isNumber2 = typeOfTest2("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean2 = (thing) => thing === true || thing === false;
var isPlainObject2 = (val) => {
  if (kindOf2(val) !== "object") {
    return false;
  }
  const prototype5 = getPrototypeOf2(val);
  return (prototype5 === null || prototype5 === Object.prototype || Object.getPrototypeOf(prototype5) === null) && !(toStringTag2 in val) && !(iterator2 in val);
};
var isDate2 = kindOfTest2("Date");
var isFile2 = kindOfTest2("File");
var isBlob2 = kindOfTest2("Blob");
var isFileList2 = kindOfTest2("FileList");
var isStream2 = (val) => isObject2(val) && isFunction3(val.pipe);
var isFormData2 = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction3(thing.append) && ((kind = kindOf2(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction3(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams2 = kindOfTest2("URLSearchParams");
var [isReadableStream2, isRequest2, isResponse2, isHeaders2] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest2);
var trim4 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach2(obj, fn4, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i4;
  let l6;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (i4 = 0, l6 = obj.length; i4 < l6; i4++) {
      fn4.call(null, obj[i4], i4, obj);
    }
  } else {
    const keys4 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys4.length;
    let key;
    for (i4 = 0; i4 < len; i4++) {
      key = keys4[i4];
      fn4.call(null, obj[key], key, obj);
    }
  }
}
function findKey2(obj, key) {
  key = key.toLowerCase();
  const keys4 = Object.keys(obj);
  let i4 = keys4.length;
  let _key;
  while (i4-- > 0) {
    _key = keys4[i4];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global2 = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined2 = (context) => !isUndefined2(context) && context !== _global2;
function merge2() {
  const { caseless } = isContextDefined2(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey2(result, key) || key;
    if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
      result[targetKey] = merge2(result[targetKey], val);
    } else if (isPlainObject2(val)) {
      result[targetKey] = merge2({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i4 = 0, l6 = arguments.length; i4 < l6; i4++) {
    arguments[i4] && forEach2(arguments[i4], assignValue);
  }
  return result;
}
var extend13 = (a3, b4, thisArg, { allOwnKeys } = {}) => {
  forEach2(b4, (val, key) => {
    if (thisArg && isFunction3(val)) {
      a3[key] = bind24(val, thisArg);
    } else {
      a3[key] = val;
    }
  }, { allOwnKeys });
  return a3;
};
var stripBOM2 = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits2 = (constructor, superConstructor, props, descriptors3) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors3);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject2 = (sourceObj, destObj, filter10, propFilter) => {
  let props;
  let i4;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i4 = props.length;
    while (i4-- > 0) {
      prop = props[i4];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter10 !== false && getPrototypeOf2(sourceObj);
  } while (sourceObj && (!filter10 || filter10(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith2 = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray3 = (thing) => {
  if (!thing) return null;
  if (isArray2(thing)) return thing;
  let i4 = thing.length;
  if (!isNumber2(i4)) return null;
  const arr = new Array(i4);
  while (i4-- > 0) {
    arr[i4] = thing[i4];
  }
  return arr;
};
var isTypedArray2 = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf2(Uint8Array));
var forEachEntry2 = (obj, fn4) => {
  const generator = obj && obj[iterator2];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn4.call(obj, pair[0], pair[1]);
  }
};
var matchAll2 = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm2 = kindOfTest2("HTMLFormElement");
var toCamelCase2 = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m3, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty4 = (({ hasOwnProperty: hasOwnProperty7 }) => (obj, prop) => hasOwnProperty7.call(obj, prop))(Object.prototype);
var isRegExp2 = kindOfTest2("RegExp");
var reduceDescriptors2 = (obj, reducer) => {
  const descriptors3 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach2(descriptors3, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods2 = (obj) => {
  reduceDescriptors2(obj, (descriptor, name2) => {
    if (isFunction3(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction3(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet2 = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber2 = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm2(thing) {
  return !!(thing && isFunction3(thing.append) && thing[toStringTag2] === "FormData" && thing[iterator2]);
}
var toJSONObject2 = (obj) => {
  const stack = new Array(10);
  const visit = (source, i4) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i4] = source;
        const target = isArray2(source) ? [] : {};
        forEach2(source, (value, key) => {
          const reducedValue = visit(value, i4 + 1);
          !isUndefined2(reducedValue) && (target[key] = reducedValue);
        });
        stack[i4] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn2 = kindOfTest2("AsyncFunction");
var isThenable2 = (thing) => thing && (isObject2(thing) || isFunction3(thing)) && isFunction3(thing.then) && isFunction3(thing.catch);
var _setImmediate2 = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global2.addEventListener("message", ({ source, data }) => {
      if (source === _global2 && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global2.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction3(_global2.postMessage)
);
var asap2 = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global2) : typeof process !== "undefined" && process.nextTick || _setImmediate2;
var isIterable2 = (thing) => thing != null && isFunction3(thing[iterator2]);
var utils_default2 = {
  isArray: isArray2,
  isArrayBuffer: isArrayBuffer2,
  isBuffer: isBuffer2,
  isFormData: isFormData2,
  isArrayBufferView: isArrayBufferView2,
  isString: isString2,
  isNumber: isNumber2,
  isBoolean: isBoolean2,
  isObject: isObject2,
  isPlainObject: isPlainObject2,
  isReadableStream: isReadableStream2,
  isRequest: isRequest2,
  isResponse: isResponse2,
  isHeaders: isHeaders2,
  isUndefined: isUndefined2,
  isDate: isDate2,
  isFile: isFile2,
  isBlob: isBlob2,
  isRegExp: isRegExp2,
  isFunction: isFunction3,
  isStream: isStream2,
  isURLSearchParams: isURLSearchParams2,
  isTypedArray: isTypedArray2,
  isFileList: isFileList2,
  forEach: forEach2,
  merge: merge2,
  extend: extend13,
  trim: trim4,
  stripBOM: stripBOM2,
  inherits: inherits2,
  toFlatObject: toFlatObject2,
  kindOf: kindOf2,
  kindOfTest: kindOfTest2,
  endsWith: endsWith2,
  toArray: toArray3,
  forEachEntry: forEachEntry2,
  matchAll: matchAll2,
  isHTMLForm: isHTMLForm2,
  hasOwnProperty: hasOwnProperty4,
  hasOwnProp: hasOwnProperty4,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: reduceDescriptors2,
  freezeMethods: freezeMethods2,
  toObjectSet: toObjectSet2,
  toCamelCase: toCamelCase2,
  noop: noop2,
  toFiniteNumber: toFiniteNumber2,
  findKey: findKey2,
  global: _global2,
  isContextDefined: isContextDefined2,
  isSpecCompliantForm: isSpecCompliantForm2,
  toJSONObject: toJSONObject2,
  isAsyncFn: isAsyncFn2,
  isThenable: isThenable2,
  setImmediate: _setImmediate2,
  asap: asap2,
  isIterable: isIterable2
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/AxiosError.js
function AxiosError3(message, code2, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default2.inherits(AxiosError3, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype3 = AxiosError3.prototype;
var descriptors2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors2[code2] = { value: code2 };
});
Object.defineProperties(AxiosError3, descriptors2);
Object.defineProperty(prototype3, "isAxiosError", { value: true });
AxiosError3.from = (error, code2, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype3);
  utils_default2.toFlatObject(error, axiosError, function filter10(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError3.call(axiosError, error.message, code2, config, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default2 = AxiosError3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/null.js
var null_default2 = null;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/toFormData.js
function isVisitable2(thing) {
  return utils_default2.isPlainObject(thing) || utils_default2.isArray(thing);
}
function removeBrackets2(key) {
  return utils_default2.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey2(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i4) {
    token = removeBrackets2(token);
    return !dots && i4 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray2(arr) {
  return utils_default2.isArray(arr) && !arr.some(isVisitable2);
}
var predicates2 = utils_default2.toFlatObject(utils_default2, {}, null, function filter9(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData3(obj, formData, options) {
  if (!utils_default2.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default2 || FormData)();
  options = utils_default2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default2.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default2.isSpecCompliantForm(formData);
  if (!utils_default2.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue3(value) {
    if (value === null) return "";
    if (utils_default2.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default2.isBlob(value)) {
      throw new AxiosError_default2("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default2.isArrayBuffer(value) || utils_default2.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default2.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default2.isArray(value) && isFlatArray2(value) || (utils_default2.isFileList(value) || utils_default2.endsWith(key, "[]")) && (arr = utils_default2.toArray(value))) {
        key = removeBrackets2(key);
        arr.forEach(function each(el, index) {
          !(utils_default2.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey2([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue3(el)
          );
        });
        return false;
      }
    }
    if (isVisitable2(value)) {
      return true;
    }
    formData.append(renderKey2(path, key, dots), convertValue3(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates2, {
    defaultVisitor,
    convertValue: convertValue3,
    isVisitable: isVisitable2
  });
  function build(value, path) {
    if (utils_default2.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default2.forEach(value, function each(el, key) {
      const result = !(utils_default2.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default2.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default2.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default2 = toFormData3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode14(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match14) {
    return charMap[match14];
  });
}
function AxiosURLSearchParams2(params, options) {
  this._pairs = [];
  params && toFormData_default2(params, this, options);
}
var prototype4 = AxiosURLSearchParams2.prototype;
prototype4.append = function append6(name2, value) {
  this._pairs.push([name2, value]);
};
prototype4.toString = function toString8(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode14);
  } : encode14;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default2 = AxiosURLSearchParams2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/buildURL.js
function encode15(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL2(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode15;
  if (utils_default2.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default2(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager2 = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn4) {
    utils_default2.forEach(this.handlers, function forEachHandler(h5) {
      if (h5 !== null) {
        fn4(h5);
      }
    });
  }
};
var InterceptorManager_default2 = InterceptorManager2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/defaults/transitional.js
var transitional_default2 = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default2 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default2 = typeof FormData !== "undefined" ? FormData : null;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default2 = typeof Blob !== "undefined" ? Blob : null;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/index.js
var browser_default2 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default2,
    FormData: FormData_default2,
    Blob: Blob_default2
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/common/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  hasBrowserEnv: () => hasBrowserEnv2,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv2,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv2,
  navigator: () => _navigator2,
  origin: () => origin2
});
var hasBrowserEnv2 = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator2 = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv2 = hasBrowserEnv2 && (!_navigator2 || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator2.product) < 0);
var hasStandardBrowserWebWorkerEnv2 = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin2 = hasBrowserEnv2 && window.location.href || "http://localhost";

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/index.js
var platform_default2 = {
  ...utils_exports2,
  ...browser_default2
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm2(data, options) {
  return toFormData_default2(data, new platform_default2.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default2.isNode && utils_default2.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath2(name2) {
  return utils_default2.matchAll(/\w+|\[(\w*)]/g, name2).map((match14) => {
    return match14[0] === "[]" ? "" : match14[1] || match14[0];
  });
}
function arrayToObject2(arr) {
  const obj = {};
  const keys4 = Object.keys(arr);
  let i4;
  const len = keys4.length;
  let key;
  for (i4 = 0; i4 < len; i4++) {
    key = keys4[i4];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON2(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    if (name2 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils_default2.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default2.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default2.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils_default2.isArray(target[name2])) {
      target[name2] = arrayToObject2(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default2.isFormData(formData) && utils_default2.isFunction(formData.entries)) {
    const obj = {};
    utils_default2.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath2(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default2 = formDataToJSON2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/defaults/index.js
function stringifySafely2(rawValue, parser, encoder) {
  if (utils_default2.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default2.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults2 = {
  transitional: transitional_default2,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest2(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default2.isObject(data);
    if (isObjectPayload && utils_default2.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData3 = utils_default2.isFormData(data);
    if (isFormData3) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default2(data)) : data;
    }
    if (utils_default2.isArrayBuffer(data) || utils_default2.isBuffer(data) || utils_default2.isStream(data) || utils_default2.isFile(data) || utils_default2.isBlob(data) || utils_default2.isReadableStream(data)) {
      return data;
    }
    if (utils_default2.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default2.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList3;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm2(data, this.formSerializer).toString();
      }
      if ((isFileList3 = utils_default2.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default2(
          isFileList3 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely2(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse2(data) {
    const transitional3 = this.transitional || defaults2.transitional;
    const forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default2.isResponse(data) || utils_default2.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default2.from(e2, AxiosError_default2.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default2.classes.FormData,
    Blob: platform_default2.classes.Blob
  },
  validateStatus: function validateStatus2(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults2.headers[method] = {};
});
var defaults_default2 = defaults2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf2 = utils_default2.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default2 = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i4;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i4 = line.indexOf(":");
    key = line.substring(0, i4).trim().toLowerCase();
    val = line.substring(i4 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf2[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/AxiosHeaders.js
var $internals2 = Symbol("internals");
function normalizeHeader2(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue2(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default2.isArray(value) ? value.map(normalizeValue2) : String(value);
}
function parseTokens2(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match14;
  while (match14 = tokensRE.exec(str)) {
    tokens[match14[1]] = match14[2];
  }
  return tokens;
}
var isValidHeaderName2 = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue2(context, value, header, filter10, isHeaderNameFilter) {
  if (utils_default2.isFunction(filter10)) {
    return filter10.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default2.isString(value)) return;
  if (utils_default2.isString(filter10)) {
    return value.indexOf(filter10) !== -1;
  }
  if (utils_default2.isRegExp(filter10)) {
    return filter10.test(value);
  }
}
function formatHeader2(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w4, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors2(obj, header) {
  const accessorName = utils_default2.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders3 = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader2(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default2.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue2(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default2.isString(header) && (header = header.trim()) && !isValidHeaderName2(header)) {
      setHeaders(parseHeaders_default2(header), valueOrRewrite);
    } else if (utils_default2.isObject(header) && utils_default2.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default2.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default2.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader2(header);
    if (header) {
      const key = utils_default2.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens2(value);
        }
        if (utils_default2.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default2.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader2(header);
    if (header) {
      const key = utils_default2.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue2(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader2(_header);
      if (_header) {
        const key = utils_default2.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue2(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys4 = Object.keys(this);
    let i4 = keys4.length;
    let deleted = false;
    while (i4--) {
      const key = keys4[i4];
      if (!matcher || matchHeaderValue2(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default2.forEach(this, (value, header) => {
      const key = utils_default2.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue2(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader2(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue2(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default2.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default2.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals2] = this[$internals2] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype5 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader2(_header);
      if (!accessors[lHeader]) {
        buildAccessors2(prototype5, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders3.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default2.reduceDescriptors(AxiosHeaders3.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default2.freezeMethods(AxiosHeaders3);
var AxiosHeaders_default2 = AxiosHeaders3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/transformData.js
function transformData2(fns, response) {
  const config = this || defaults_default2;
  const context = response || config;
  const headers = AxiosHeaders_default2.from(context.headers);
  let data = context.data;
  utils_default2.forEach(fns, function transform(fn4) {
    data = fn4.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/cancel/isCancel.js
function isCancel3(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError3(message, config, request2) {
  AxiosError_default2.call(this, message == null ? "canceled" : message, AxiosError_default2.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils_default2.inherits(CanceledError3, AxiosError_default2, {
  __CANCEL__: true
});
var CanceledError_default2 = CanceledError3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/settle.js
function settle2(resolve, reject, response) {
  const validateStatus3 = response.config.validateStatus;
  if (!response.status || !validateStatus3 || validateStatus3(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default2(
      "Request failed with status code " + response.status,
      [AxiosError_default2.ERR_BAD_REQUEST, AxiosError_default2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol2(url) {
  const match14 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match14 && match14[1] || "";
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/speedometer.js
function speedometer2(samplesCount, min4) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head5 = 0;
  let tail4 = 0;
  let firstSampleTS;
  min4 = min4 !== void 0 ? min4 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail4];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head5] = chunkLength;
    timestamps[head5] = now;
    let i4 = tail4;
    let bytesCount = 0;
    while (i4 !== head5) {
      bytesCount += bytes2[i4++];
      i4 = i4 % samplesCount;
    }
    head5 = (head5 + 1) % samplesCount;
    if (head5 === tail4) {
      tail4 = (tail4 + 1) % samplesCount;
    }
    if (now - firstSampleTS < min4) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default2 = speedometer2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/throttle.js
function throttle2(fn4, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn4.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default2 = throttle2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer2 = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default2(50, 250);
  return throttle_default2((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange3 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange3 ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator2 = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator2 = (fn4) => (...args) => utils_default2.asap(() => fn4(...args));

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default2 = platform_default2.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin3, isMSIE) => (url) => {
  url = new URL(url, platform_default2.origin);
  return origin3.protocol === url.protocol && origin3.host === url.host && (isMSIE || origin3.port === url.port);
})(
  new URL(platform_default2.origin),
  platform_default2.navigator && /(msie|trident)/i.test(platform_default2.navigator.userAgent)
) : () => true;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/cookies.js
var cookies_default2 = platform_default2.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils_default2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default2.isString(path) && cookie.push("path=" + path);
      utils_default2.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match14 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match14 ? decodeURIComponent(match14[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL2(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath2(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL2(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/mergeConfig.js
var headersToObject2 = (thing) => thing instanceof AxiosHeaders_default2 ? { ...thing } : thing;
function mergeConfig3(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default2.isPlainObject(target) && utils_default2.isPlainObject(source)) {
      return utils_default2.merge.call({ caseless }, target, source);
    } else if (utils_default2.isPlainObject(source)) {
      return utils_default2.merge({}, source);
    } else if (utils_default2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a3, b4, prop, caseless) {
    if (!utils_default2.isUndefined(b4)) {
      return getMergedValue(a3, b4, prop, caseless);
    } else if (!utils_default2.isUndefined(a3)) {
      return getMergedValue(void 0, a3, prop, caseless);
    }
  }
  function valueFromConfig2(a3, b4) {
    if (!utils_default2.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    }
  }
  function defaultToConfig2(a3, b4) {
    if (!utils_default2.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    } else if (!utils_default2.isUndefined(a3)) {
      return getMergedValue(void 0, a3);
    }
  }
  function mergeDirectKeys(a3, b4, prop) {
    if (prop in config2) {
      return getMergedValue(a3, b4);
    } else if (prop in config1) {
      return getMergedValue(void 0, a3);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a3, b4, prop) => mergeDeepProperties(headersToObject2(a3), headersToObject2(b4), prop, true)
  };
  utils_default2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default2.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default2 = (config) => {
  const newConfig = mergeConfig3({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default2.from(headers);
  newConfig.url = buildURL2(buildFullPath2(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default2.isFormData(data)) {
    if (platform_default2.hasStandardBrowserEnv || platform_default2.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type3, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type3 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default2.hasStandardBrowserEnv) {
    withXSRFToken && utils_default2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default2(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default2.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported2 = typeof XMLHttpRequest !== "undefined";
var xhr_default2 = isXHRAdapterSupported2 && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default2(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default2.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default2.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle2(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default2("Request aborted", AxiosError_default2.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default2("Network Error", AxiosError_default2.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional3 = _config.transitional || transitional_default2;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default2(
        timeoutErrorMessage,
        transitional3.clarifyTimeoutError ? AxiosError_default2.ETIMEDOUT : AxiosError_default2.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default2.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer2(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer2(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default2(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol2(_config.url);
    if (protocol && platform_default2.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default2("Unsupported protocol " + protocol + ":", AxiosError_default2.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/composeSignals.js
var composeSignals2 = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default2 ? err : new CanceledError_default2(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default2(`timeout ${timeout} of ms exceeded`, AxiosError_default2.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default2.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default2 = composeSignals2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/trackStream.js
var streamChunk2 = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes2 = async function* (iterable, chunkSize) {
  for await (const chunk of readStream2(iterable)) {
    yield* streamChunk2(chunk, chunkSize);
  }
};
var readStream2 = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream2 = (stream, chunkSize, onProgress, onFinish) => {
  const iterator4 = readBytes2(stream, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator4.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator4.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test2 = (fn4, ...args) => {
  try {
    return !!fn4(...args);
  } catch (e2) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test2(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default2.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE2 = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test2(() => utils_default2.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type3) => {
    !resolvers[type3] && (resolvers[type3] = utils_default2.isFunction(res[type3]) ? (res2) => res2[type3]() : (_3, config) => {
      throw new AxiosError_default2(`Response type '${type3}' is not supported`, AxiosError_default2.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default2.isBlob(body)) {
    return body.size;
  }
  if (utils_default2.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default2.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default2.isArrayBufferView(body) || utils_default2.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default2.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default2.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length2 = utils_default2.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default2(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default2([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default2.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator2(
          requestContentLength,
          progressEventReducer2(asyncDecorator2(onUploadProgress))
        );
        data = trackStream2(_request.body, DEFAULT_CHUNK_SIZE2, onProgress, flush);
      }
    }
    if (!utils_default2.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default2.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator2(
        responseContentLength,
        progressEventReducer2(asyncDecorator2(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream2(response.body, DEFAULT_CHUNK_SIZE2, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default2.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle2(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default2.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default2("Network Error", AxiosError_default2.ERR_NETWORK, config, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default2.from(err, err && err.code, config, request2);
  }
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/adapters/adapters.js
var knownAdapters2 = {
  http: null_default2,
  xhr: xhr_default2,
  fetch: fetch_default
};
utils_default2.forEach(knownAdapters2, (fn4, value) => {
  if (fn4) {
    try {
      Object.defineProperty(fn4, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn4, "adapterName", { value });
  }
});
var renderReason2 = (reason) => `- ${reason}`;
var isResolvedHandle2 = (adapter2) => utils_default2.isFunction(adapter2) || adapter2 === null || adapter2 === false;
var adapters_default2 = {
  getAdapter: (adapters) => {
    adapters = utils_default2.isArray(adapters) ? adapters : [adapters];
    const { length: length2 } = adapters;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i4 = 0; i4 < length2; i4++) {
      nameOrAdapter = adapters[i4];
      let id;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle2(nameOrAdapter)) {
        adapter2 = knownAdapters2[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError_default2(`Unknown adapter '${id}'`);
        }
      }
      if (adapter2) {
        break;
      }
      rejectedReasons[id || "#" + i4] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s3 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason2).join("\n") : " " + renderReason2(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default2(
        `There is no suitable adapter to dispatch the request ` + s3,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters2
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested2(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default2(null, config);
  }
}
function dispatchRequest2(config) {
  throwIfCancellationRequested2(config);
  config.headers = AxiosHeaders_default2.from(config.headers);
  config.data = transformData2.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default2.getAdapter(config.adapter || defaults_default2.adapter);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested2(config);
    response.data = transformData2.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default2.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel3(reason)) {
      throwIfCancellationRequested2(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default2.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/env/data.js
var VERSION4 = "1.9.0";

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/validator.js
var validators3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type3, i4) => {
  validators3[type3] = function validator(thing) {
    return typeof thing === type3 || "a" + (i4 < 1 ? "n " : " ") + type3;
  };
});
var deprecatedWarnings2 = {};
validators3.transitional = function transitional2(validator, version11, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION4 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts2) => {
    if (validator === false) {
      throw new AxiosError_default2(
        formatMessage(opt, " has been removed" + (version11 ? " in " + version11 : "")),
        AxiosError_default2.ERR_DEPRECATED
      );
    }
    if (version11 && !deprecatedWarnings2[opt]) {
      deprecatedWarnings2[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version11 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts2) : true;
  };
};
validators3.spelling = function spelling2(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions2(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default2("options must be an object", AxiosError_default2.ERR_BAD_OPTION_VALUE);
  }
  const keys4 = Object.keys(options);
  let i4 = keys4.length;
  while (i4-- > 0) {
    const opt = keys4[i4];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default2("option " + opt + " must be " + result, AxiosError_default2.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default2("Unknown option " + opt, AxiosError_default2.ERR_BAD_OPTION);
    }
  }
}
var validator_default2 = {
  assertOptions: assertOptions2,
  validators: validators3
};

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/Axios.js
var validators4 = validator_default2.validators;
var Axios3 = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default2(),
      response: new InterceptorManager_default2()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig3(this.defaults, config);
    const { transitional: transitional3, paramsSerializer, headers } = config;
    if (transitional3 !== void 0) {
      validator_default2.assertOptions(transitional3, {
        silentJSONParsing: validators4.transitional(validators4.boolean),
        forcedJSONParsing: validators4.transitional(validators4.boolean),
        clarifyTimeoutError: validators4.transitional(validators4.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default2.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default2.assertOptions(paramsSerializer, {
          encode: validators4.function,
          serialize: validators4.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default2.assertOptions(config, {
      baseUrl: validators4.spelling("baseURL"),
      withXsrfToken: validators4.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default2.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default2.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i4 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain6 = [dispatchRequest2.bind(this), void 0];
      chain6.unshift.apply(chain6, requestInterceptorChain);
      chain6.push.apply(chain6, responseInterceptorChain);
      len = chain6.length;
      promise = Promise.resolve(config);
      while (i4 < len) {
        promise = promise.then(chain6[i4++], chain6[i4++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i4 = 0;
    while (i4 < len) {
      const onFulfilled = requestInterceptorChain[i4++];
      const onRejected = requestInterceptorChain[i4++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest2.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i4 = 0;
    len = responseInterceptorChain.length;
    while (i4 < len) {
      promise = promise.then(responseInterceptorChain[i4++], responseInterceptorChain[i4++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig3(this.defaults, config);
    const fullPath = buildFullPath2(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL2(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios3.prototype[method] = function(url, config) {
    return this.request(mergeConfig3(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig3(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios3.prototype[method] = generateHTTPMethod();
  Axios3.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default2 = Axios3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken3 = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i4 = token._listeners.length;
      while (i4-- > 0) {
        token._listeners[i4](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default2(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c6) {
      cancel = c6;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default2 = CancelToken3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/spread.js
function spread3(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError3(payload) {
  return utils_default2.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode3 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode3).forEach(([key, value]) => {
  HttpStatusCode3[value] = key;
});
var HttpStatusCode_default2 = HttpStatusCode3;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/axios.js
function createInstance2(defaultConfig) {
  const context = new Axios_default2(defaultConfig);
  const instance2 = bind24(Axios_default2.prototype.request, context);
  utils_default2.extend(instance2, Axios_default2.prototype, context, { allOwnKeys: true });
  utils_default2.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create6(instanceConfig) {
    return createInstance2(mergeConfig3(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios2 = createInstance2(defaults_default2);
axios2.Axios = Axios_default2;
axios2.CanceledError = CanceledError_default2;
axios2.CancelToken = CancelToken_default2;
axios2.isCancel = isCancel3;
axios2.VERSION = VERSION4;
axios2.toFormData = toFormData_default2;
axios2.AxiosError = AxiosError_default2;
axios2.Cancel = axios2.CanceledError;
axios2.all = function all3(promises) {
  return Promise.all(promises);
};
axios2.spread = spread3;
axios2.isAxiosError = isAxiosError3;
axios2.mergeConfig = mergeConfig3;
axios2.AxiosHeaders = AxiosHeaders_default2;
axios2.formToJSON = (thing) => formDataToJSON_default2(utils_default2.isHTMLForm(thing) ? new FormData(thing) : thing);
axios2.getAdapter = adapters_default2.getAdapter;
axios2.HttpStatusCode = HttpStatusCode_default2;
axios2.default = axios2;
var axios_default2 = axios2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/index.js
var {
  Axios: Axios4,
  AxiosError: AxiosError4,
  CanceledError: CanceledError4,
  isCancel: isCancel4,
  CancelToken: CancelToken4,
  VERSION: VERSION5,
  all: all4,
  Cancel: Cancel2,
  isAxiosError: isAxiosError4,
  spread: spread4,
  toFormData: toFormData4,
  AxiosHeaders: AxiosHeaders4,
  HttpStatusCode: HttpStatusCode4,
  formToJSON: formToJSON2,
  getAdapter: getAdapter3,
  mergeConfig: mergeConfig4
} = axios_default2;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/core/index.esm.js
var ENVIRONMENT_ENUM = (function(ENVIRONMENT_ENUM4) {
  ENVIRONMENT_ENUM4["development"] = "development";
  ENVIRONMENT_ENUM4["preprod"] = "preprod";
  ENVIRONMENT_ENUM4["production"] = "production";
  return ENVIRONMENT_ENUM4;
})({});
var WalletOperation = (function(WalletOperation4) {
  WalletOperation4["REACH_THRESHOLD"] = "REACH_THRESHOLD";
  WalletOperation4["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
  WalletOperation4["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  WalletOperation4["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  WalletOperation4["REFRESH"] = "REFRESH";
  WalletOperation4["RESHARE"] = "RESHARE";
  WalletOperation4["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
  WalletOperation4["NO_OPERATION"] = "NO_OPERATION";
  return WalletOperation4;
})({});
var BackupLocation = (function(BackupLocation4) {
  BackupLocation4["DYNAMIC"] = "dynamic";
  BackupLocation4["GOOGLE_DRIVE"] = "googleDrive";
  BackupLocation4["ICLOUD"] = "iCloud";
  BackupLocation4["USER"] = "user";
  BackupLocation4["EXTERNAL"] = "external";
  BackupLocation4["DELEGATED"] = "delegated";
  return BackupLocation4;
})({});
var SigningAlgorithm = (function(SigningAlgorithm4) {
  SigningAlgorithm4["ECDSA"] = "ECDSA";
  SigningAlgorithm4["ED25519"] = "ED25519";
  SigningAlgorithm4["BIP340"] = "BIP340";
  return SigningAlgorithm4;
})({});
var BITCOIN_DERIVATION_PATHS = {
  LEGACY: [
    44,
    0,
    0,
    0,
    0
  ],
  // m/49'/0'/0'/0/0  - SegWit (P2SH-P2WPKH)
  NATIVE_SEGWIT: [
    84,
    0,
    0,
    0,
    0
  ],
  // m/44'/0'/0'/0/0  - Legacy (P2PKH)
  SEGWIT: [
    49,
    0,
    0,
    0,
    0
  ]
};
var MPC_CHAIN_CONFIG = {
  EVM: {
    // Uses secp256k1 ECDSA
    derivationPath: [
      44,
      60,
      0,
      0,
      0
    ],
    signingAlgorithm: "ECDSA"
  },
  SVM: {
    // Uses Ed25519
    derivationPath: [
      44,
      501,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  BTC: {
    // Uses secp256k1 BIP340
    derivationPath: BITCOIN_DERIVATION_PATHS.NATIVE_SEGWIT,
    signingAlgorithm: "BIP340"
  },
  COSMOS: {
    // Uses Ed25519
    derivationPath: [
      44,
      118,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  FLOW: {
    // Uses Ed25519
    derivationPath: [
      44,
      539,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  SUI: {
    // Uses Ed25519
    derivationPath: [
      44,
      784,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  }
};
var ThresholdSignatureScheme = (function(ThresholdSignatureScheme4) {
  ThresholdSignatureScheme4["TWO_OF_TWO"] = "TWO_OF_TWO";
  ThresholdSignatureScheme4["TWO_OF_THREE"] = "TWO_OF_THREE";
  ThresholdSignatureScheme4["THREE_OF_FIVE"] = "THREE_OF_FIVE";
  return ThresholdSignatureScheme4;
})({});
var CreateRoomPartiesOptions = (function(CreateRoomPartiesOptions4) {
  CreateRoomPartiesOptions4["THRESHOLD"] = "threshold";
  CreateRoomPartiesOptions4["FULL"] = "full";
  return CreateRoomPartiesOptions4;
})({});
var URL_PATTERNS = {
  [ENVIRONMENT_ENUM.development]: /^http:\/\/localhost:\d+$/,
  [ENVIRONMENT_ENUM.preprod]: /dynamic-preprod/,
  [ENVIRONMENT_ENUM.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
var AuthMode = (function(AuthMode4) {
  AuthMode4["HEADER"] = "header";
  AuthMode4["COOKIE"] = "cookie";
  return AuthMode4;
})({});
var SuccessEventType = (function(SuccessEventType4) {
  SuccessEventType4["KeygenComplete"] = "keygen_complete";
  SuccessEventType4["RoomCreated"] = "room_created";
  SuccessEventType4["CeremonyComplete"] = "ceremony_complete";
  return SuccessEventType4;
})({});

// node_modules/@noble/post-quantum/node_modules/@noble/hashes/_u64.js
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
function fromBig2(n5, le5 = false) {
  if (le5)
    return { h: Number(n5 & U32_MASK642), l: Number(n5 >> _32n2 & U32_MASK642) };
  return { h: Number(n5 >> _32n2 & U32_MASK642) | 0, l: Number(n5 & U32_MASK642) | 0 };
}
function split2(lst, le5 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i4 = 0; i4 < len; i4++) {
    const { h: h5, l: l6 } = fromBig2(lst[i4], le5);
    [Ah[i4], Al[i4]] = [h5, l6];
  }
  return [Ah, Al];
}
var rotlSH2 = (h5, l6, s3) => h5 << s3 | l6 >>> 32 - s3;
var rotlSL2 = (h5, l6, s3) => l6 << s3 | h5 >>> 32 - s3;
var rotlBH2 = (h5, l6, s3) => l6 << s3 - 32 | h5 >>> 64 - s3;
var rotlBL2 = (h5, l6, s3) => h5 << s3 - 32 | l6 >>> 64 - s3;

// node_modules/@noble/post-quantum/node_modules/@noble/hashes/utils.js
function isBytes8(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function anumber5(n5, title = "") {
  if (!Number.isSafeInteger(n5) || n5 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n5}`);
  }
}
function abytes6(value, length2, title = "") {
  const bytes2 = isBytes8(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length2 !== void 0;
  if (!bytes2 || needsLen && len !== length2) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length2}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function aexists3(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput3(out, instance2) {
  abytes6(out, void 0, "digestInto() output");
  const min4 = instance2.outputLen;
  if (out.length < min4) {
    throw new Error('"digestInto() output" expected to be of length >=' + min4);
  }
}
function u326(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean3(...arrays) {
  for (let i4 = 0; i4 < arrays.length; i4++) {
    arrays[i4].fill(0);
  }
}
var isLE3 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap2(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap322(arr) {
  for (let i4 = 0; i4 < arr.length; i4++) {
    arr[i4] = byteSwap2(arr[i4]);
  }
  return arr;
}
var swap32IfBE = isLE3 ? (u2) => u2 : byteSwap322;
var hasHexBuiltin5 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes4 = Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function createHasher5(hashCons, info = {}) {
  const hashC = (msg, opts2) => hashCons(opts2).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts2) => hashCons(opts2);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes4(bytesLength = 32) {
  const cr4 = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr4 == null ? void 0 : cr4.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr4.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist2 = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/@noble/post-quantum/node_modules/@noble/hashes/sha3.js
var _0n17 = BigInt(0);
var _1n17 = BigInt(1);
var _2n13 = BigInt(2);
var _7n2 = BigInt(7);
var _256n2 = BigInt(256);
var _0x71n2 = BigInt(113);
var SHA3_PI2 = [];
var SHA3_ROTL2 = [];
var _SHA3_IOTA2 = [];
for (let round = 0, R3 = _1n17, x5 = 1, y5 = 0; round < 24; round++) {
  [x5, y5] = [y5, (2 * x5 + 3 * y5) % 5];
  SHA3_PI2.push(2 * (5 * y5 + x5));
  SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n17;
  for (let j3 = 0; j3 < 7; j3++) {
    R3 = (R3 << _1n17 ^ (R3 >> _7n2) * _0x71n2) % _256n2;
    if (R3 & _2n13)
      t ^= _1n17 << (_1n17 << BigInt(j3)) - _1n17;
  }
  _SHA3_IOTA2.push(t);
}
var IOTAS = split2(_SHA3_IOTA2, true);
var SHA3_IOTA_H2 = IOTAS[0];
var SHA3_IOTA_L2 = IOTAS[1];
var rotlH2 = (h5, l6, s3) => s3 > 32 ? rotlBH2(h5, l6, s3) : rotlSH2(h5, l6, s3);
var rotlL2 = (h5, l6, s3) => s3 > 32 ? rotlBL2(h5, l6, s3) : rotlSL2(h5, l6, s3);
function keccakP2(s3, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x5 = 0; x5 < 10; x5++)
      B3[x5] = s3[x5] ^ s3[x5 + 10] ^ s3[x5 + 20] ^ s3[x5 + 30] ^ s3[x5 + 40];
    for (let x5 = 0; x5 < 10; x5 += 2) {
      const idx1 = (x5 + 8) % 10;
      const idx0 = (x5 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y5 = 0; y5 < 50; y5 += 10) {
        s3[x5 + y5] ^= Th;
        s3[x5 + y5 + 1] ^= Tl;
      }
    }
    let curH = s3[2];
    let curL = s3[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL2[t];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI = SHA3_PI2[t];
      curH = s3[PI];
      curL = s3[PI + 1];
      s3[PI] = Th;
      s3[PI + 1] = Tl;
    }
    for (let y5 = 0; y5 < 50; y5 += 10) {
      for (let x5 = 0; x5 < 10; x5++)
        B3[x5] = s3[y5 + x5];
      for (let x5 = 0; x5 < 10; x5++)
        s3[y5 + x5] ^= ~B3[(x5 + 2) % 10] & B3[(x5 + 4) % 10];
    }
    s3[0] ^= SHA3_IOTA_H2[round];
    s3[1] ^= SHA3_IOTA_L2[round];
  }
  clean3(B3);
}
var Keccak2 = class _Keccak {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    __publicField(this, "state");
    __publicField(this, "pos", 0);
    __publicField(this, "posOut", 0);
    __publicField(this, "finished", false);
    __publicField(this, "state32");
    __publicField(this, "destroyed", false);
    __publicField(this, "blockLen");
    __publicField(this, "suffix");
    __publicField(this, "outputLen");
    __publicField(this, "enableXOF", false);
    __publicField(this, "rounds");
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber5(outputLen, "outputLen");
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u326(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP2(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists3(this);
    abytes6(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i4 = 0; i4 < take; i4++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists3(this, false);
    abytes6(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber5(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput3(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean3(this.state);
  }
  _cloneInto(to5) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to5 || (to5 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to5.state32.set(this.state32);
    to5.pos = this.pos;
    to5.posOut = this.posOut;
    to5.finished = this.finished;
    to5.rounds = rounds;
    to5.suffix = suffix;
    to5.outputLen = outputLen;
    to5.enableXOF = enableXOF;
    to5.destroyed = this.destroyed;
    return to5;
  }
};
var genKeccak = (suffix, blockLen, outputLen, info = {}) => createHasher5(() => new Keccak2(blockLen, suffix, outputLen), info);
var sha3_2242 = genKeccak(
  6,
  144,
  28,
  oidNist2(7)
);
var sha3_2562 = genKeccak(
  6,
  136,
  32,
  oidNist2(8)
);
var sha3_3842 = genKeccak(
  6,
  104,
  48,
  oidNist2(9)
);
var sha3_5122 = genKeccak(
  6,
  72,
  64,
  oidNist2(10)
);
var keccak_2242 = genKeccak(1, 144, 28);
var keccak_2563 = genKeccak(1, 136, 32);
var keccak_3842 = genKeccak(1, 104, 48);
var keccak_5122 = genKeccak(1, 72, 64);
var genShake2 = (suffix, blockLen, outputLen, info = {}) => createHasher5((opts2 = {}) => new Keccak2(blockLen, suffix, opts2.dkLen === void 0 ? outputLen : opts2.dkLen, true), info);
var shake1282 = genShake2(31, 168, 16, oidNist2(11));
var shake2562 = genShake2(31, 136, 32, oidNist2(12));
var shake128_32 = genShake2(31, 168, 32, oidNist2(11));
var shake256_64 = genShake2(31, 136, 64, oidNist2(12));

// node_modules/@noble/post-quantum/node_modules/@noble/curves/abstract/fft.js
function checkU32(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0 || n5 > 4294967295)
    throw new Error("wrong u32 integer:" + n5);
  return n5;
}
function isPowerOfTwo(x5) {
  checkU32(x5);
  return (x5 & x5 - 1) === 0 && x5 !== 0;
}
function reverseBits(n5, bits) {
  checkU32(n5);
  let reversed = 0;
  for (let i4 = 0; i4 < bits; i4++, n5 >>>= 1)
    reversed = reversed << 1 | n5 & 1;
  return reversed;
}
function log2(n5) {
  checkU32(n5);
  return 31 - Math.clz32(n5);
}
function bitReversalInplace(values) {
  const n5 = values.length;
  if (n5 < 2 || !isPowerOfTwo(n5))
    throw new Error("n must be a power of 2 and greater than 1. Got " + n5);
  const bits = log2(n5);
  for (let i4 = 0; i4 < n5; i4++) {
    const j3 = reverseBits(i4, bits);
    if (i4 < j3) {
      const tmp = values[i4];
      values[i4] = values[j3];
      values[j3] = tmp;
    }
  }
  return values;
}
var _1n18 = BigInt(1);
var FFTCore = (F5, coreOpts) => {
  const { N: N15, roots, dit, invertButterflies = false, skipStages = 0, brp = true } = coreOpts;
  const bits = log2(N15);
  if (!isPowerOfTwo(N15))
    throw new Error("FFT: Polynomial size should be power of two");
  const isDit = dit !== invertButterflies;
  isDit;
  return (values) => {
    if (values.length !== N15)
      throw new Error("FFT: wrong Polynomial length");
    if (dit && brp)
      bitReversalInplace(values);
    for (let i4 = 0, g3 = 1; i4 < bits - skipStages; i4++) {
      const s3 = dit ? i4 + 1 + skipStages : bits - i4;
      const m3 = 1 << s3;
      const m22 = m3 >> 1;
      const stride = N15 >> s3;
      for (let k6 = 0; k6 < N15; k6 += m3) {
        for (let j3 = 0, grp = g3++; j3 < m22; j3++) {
          const rootPos = invertButterflies ? dit ? N15 - grp : grp : j3 * stride;
          const i0 = k6 + j3;
          const i1 = k6 + j3 + m22;
          const omega = roots[rootPos];
          const b4 = values[i1];
          const a3 = values[i0];
          if (isDit) {
            const t = F5.mul(b4, omega);
            values[i0] = F5.add(a3, t);
            values[i1] = F5.sub(a3, t);
          } else if (invertButterflies) {
            values[i0] = F5.add(b4, a3);
            values[i1] = F5.mul(F5.sub(b4, a3), omega);
          } else {
            values[i0] = F5.add(a3, b4);
            values[i1] = F5.mul(F5.sub(a3, b4), omega);
          }
        }
      }
    }
    if (!dit && brp)
      bitReversalInplace(values);
    return values;
  };
};

// node_modules/@noble/post-quantum/utils.js
var randomBytes5 = randomBytes4;
function equalBytes3(a3, b4) {
  if (a3.length !== b4.length)
    return false;
  let diff = 0;
  for (let i4 = 0; i4 < a3.length; i4++)
    diff |= a3[i4] ^ b4[i4];
  return diff === 0;
}
function copyBytes(bytes2) {
  return Uint8Array.from(bytes2);
}
function splitCoder(label, ...lengths) {
  const getLength = (c6) => typeof c6 === "number" ? c6 : c6.bytesLen;
  const bytesLen = lengths.reduce((sum, a3) => sum + getLength(a3), 0);
  return {
    bytesLen,
    encode: (bufs) => {
      const res = new Uint8Array(bytesLen);
      for (let i4 = 0, pos = 0; i4 < lengths.length; i4++) {
        const c6 = lengths[i4];
        const l6 = getLength(c6);
        const b4 = typeof c6 === "number" ? bufs[i4] : c6.encode(bufs[i4]);
        abytes6(b4, l6, label);
        res.set(b4, pos);
        if (typeof c6 !== "number")
          b4.fill(0);
        pos += l6;
      }
      return res;
    },
    decode: (buf) => {
      abytes6(buf, bytesLen, label);
      const res = [];
      for (const c6 of lengths) {
        const l6 = getLength(c6);
        const b4 = buf.subarray(0, l6);
        res.push(typeof c6 === "number" ? b4 : c6.decode(b4));
        buf = buf.subarray(l6);
      }
      return res;
    }
  };
}
function vecCoder(c6, vecLen) {
  const bytesLen = vecLen * c6.bytesLen;
  return {
    bytesLen,
    encode: (u2) => {
      if (u2.length !== vecLen)
        throw new Error(`vecCoder.encode: wrong length=${u2.length}. Expected: ${vecLen}`);
      const res = new Uint8Array(bytesLen);
      for (let i4 = 0, pos = 0; i4 < u2.length; i4++) {
        const b4 = c6.encode(u2[i4]);
        res.set(b4, pos);
        b4.fill(0);
        pos += b4.length;
      }
      return res;
    },
    decode: (a3) => {
      abytes6(a3, bytesLen);
      const r3 = [];
      for (let i4 = 0; i4 < a3.length; i4 += c6.bytesLen)
        r3.push(c6.decode(a3.subarray(i4, i4 + c6.bytesLen)));
      return r3;
    }
  };
}
function cleanBytes(...list) {
  for (const t of list) {
    if (Array.isArray(t))
      for (const b4 of t)
        b4.fill(0);
    else
      t.fill(0);
  }
}
function getMask(bits) {
  return (1 << bits) - 1;
}
var EMPTY = Uint8Array.of();
var oidNistP = Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2]);

// node_modules/@noble/post-quantum/_crystals.js
var genCrystals = (opts2) => {
  const { newPoly, N: N15, Q: Q6, F: F5, ROOT_OF_UNITY: ROOT_OF_UNITY2, brvBits, isKyber } = opts2;
  const mod4 = (a3, modulo = Q6) => {
    const result = a3 % modulo | 0;
    return (result >= 0 ? result | 0 : modulo + result | 0) | 0;
  };
  const smod = (a3, modulo = Q6) => {
    const r3 = mod4(a3, modulo) | 0;
    return (r3 > modulo >> 1 ? r3 - modulo | 0 : r3) | 0;
  };
  function getZettas() {
    const out = newPoly(N15);
    for (let i4 = 0; i4 < N15; i4++) {
      const b4 = reverseBits(i4, brvBits);
      const p4 = BigInt(ROOT_OF_UNITY2) ** BigInt(b4) % BigInt(Q6);
      out[i4] = Number(p4) | 0;
    }
    return out;
  }
  const nttZetas2 = getZettas();
  const field = {
    add: (a3, b4) => mod4((a3 | 0) + (b4 | 0)) | 0,
    sub: (a3, b4) => mod4((a3 | 0) - (b4 | 0)) | 0,
    mul: (a3, b4) => mod4((a3 | 0) * (b4 | 0)) | 0,
    inv: (_a21) => {
      throw new Error("not implemented");
    }
  };
  const nttOpts = {
    N: N15,
    roots: nttZetas2,
    invertButterflies: true,
    skipStages: isKyber ? 1 : 0,
    brp: false
  };
  const dif = FFTCore(field, { dit: false, ...nttOpts });
  const dit = FFTCore(field, { dit: true, ...nttOpts });
  const NTT2 = {
    encode: (r3) => {
      return dif(r3);
    },
    decode: (r3) => {
      dit(r3);
      for (let i4 = 0; i4 < r3.length; i4++)
        r3[i4] = mod4(F5 * r3[i4]);
      return r3;
    }
  };
  const bitsCoder2 = (d4, c6) => {
    const mask = getMask(d4);
    const bytesLen = d4 * (N15 / 8);
    return {
      bytesLen,
      encode: (poly) => {
        const r3 = new Uint8Array(bytesLen);
        for (let i4 = 0, buf = 0, bufLen = 0, pos = 0; i4 < poly.length; i4++) {
          buf |= (c6.encode(poly[i4]) & mask) << bufLen;
          bufLen += d4;
          for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
            r3[pos++] = buf & getMask(bufLen);
        }
        return r3;
      },
      decode: (bytes2) => {
        const r3 = newPoly(N15);
        for (let i4 = 0, buf = 0, bufLen = 0, pos = 0; i4 < bytes2.length; i4++) {
          buf |= bytes2[i4] << bufLen;
          bufLen += 8;
          for (; bufLen >= d4; bufLen -= d4, buf >>= d4)
            r3[pos++] = c6.decode(buf & mask);
        }
        return r3;
      }
    };
  };
  return { mod: mod4, smod, nttZetas: nttZetas2, NTT: NTT2, bitsCoder: bitsCoder2 };
};
var createXofShake = (shake) => (seed, blockLen) => {
  if (!blockLen)
    blockLen = shake.blockLen;
  const _seed = new Uint8Array(seed.length + 2);
  _seed.set(seed);
  const seedLen = seed.length;
  const buf = new Uint8Array(blockLen);
  let h5 = shake.create({});
  let calls = 0;
  let xofs = 0;
  return {
    stats: () => ({ calls, xofs }),
    get: (x5, y5) => {
      _seed[seedLen + 0] = x5;
      _seed[seedLen + 1] = y5;
      h5.destroy();
      h5 = shake.create({}).update(_seed);
      calls++;
      return () => {
        xofs++;
        return h5.xofInto(buf);
      };
    },
    clean: () => {
      h5.destroy();
      cleanBytes(buf, _seed);
    }
  };
};
var XOF128 = createXofShake(shake1282);
var XOF256 = createXofShake(shake2562);

// node_modules/@noble/post-quantum/ml-kem.js
var N14 = 256;
var Q5 = 3329;
var F4 = 3303;
var ROOT_OF_UNITY = 17;
var { mod: mod3, nttZetas, NTT, bitsCoder } = genCrystals({
  N: N14,
  Q: Q5,
  F: F4,
  ROOT_OF_UNITY,
  newPoly: (n5) => new Uint16Array(n5),
  brvBits: 7,
  isKyber: true
});
var PARAMS = {
  512: { N: N14, Q: Q5, K: 2, ETA1: 3, ETA2: 2, du: 10, dv: 4, RBGstrength: 128 },
  768: { N: N14, Q: Q5, K: 3, ETA1: 2, ETA2: 2, du: 10, dv: 4, RBGstrength: 192 },
  1024: { N: N14, Q: Q5, K: 4, ETA1: 2, ETA2: 2, du: 11, dv: 5, RBGstrength: 256 }
};
var compress = (d4) => {
  if (d4 >= 12)
    return { encode: (i4) => i4, decode: (i4) => i4 };
  const a3 = 2 ** (d4 - 1);
  return {
    // const compress = (i: number) => round((2 ** d / Q) * i) % 2 ** d;
    encode: (i4) => ((i4 << d4) + Q5 / 2) / Q5,
    // const decompress = (i: number) => round((Q / 2 ** d) * i);
    decode: (i4) => i4 * Q5 + a3 >>> d4
  };
};
var polyCoder = (d4) => bitsCoder(d4, compress(d4));
function polyAdd(a3, b4) {
  for (let i4 = 0; i4 < N14; i4++)
    a3[i4] = mod3(a3[i4] + b4[i4]);
}
function polySub(a3, b4) {
  for (let i4 = 0; i4 < N14; i4++)
    a3[i4] = mod3(a3[i4] - b4[i4]);
}
function BaseCaseMultiply(a0, a1, b0, b1, zeta) {
  const c0 = mod3(a1 * b1 * zeta + a0 * b0);
  const c1 = mod3(a0 * b1 + a1 * b0);
  return { c0, c1 };
}
function MultiplyNTTs(f8, g3) {
  for (let i4 = 0; i4 < N14 / 2; i4++) {
    let z4 = nttZetas[64 + (i4 >> 1)];
    if (i4 & 1)
      z4 = -z4;
    const { c0, c1 } = BaseCaseMultiply(f8[2 * i4 + 0], f8[2 * i4 + 1], g3[2 * i4 + 0], g3[2 * i4 + 1], z4);
    f8[2 * i4 + 0] = c0;
    f8[2 * i4 + 1] = c1;
  }
  return f8;
}
function SampleNTT(xof) {
  const r3 = new Uint16Array(N14);
  for (let j3 = 0; j3 < N14; ) {
    const b4 = xof();
    if (b4.length % 3)
      throw new Error("SampleNTT: unaligned block");
    for (let i4 = 0; j3 < N14 && i4 + 3 <= b4.length; i4 += 3) {
      const d1 = (b4[i4 + 0] >> 0 | b4[i4 + 1] << 8) & 4095;
      const d22 = (b4[i4 + 1] >> 4 | b4[i4 + 2] << 4) & 4095;
      if (d1 < Q5)
        r3[j3++] = d1;
      if (j3 < N14 && d22 < Q5)
        r3[j3++] = d22;
    }
  }
  return r3;
}
function sampleCBD(PRF, seed, nonce, eta) {
  const buf = PRF(eta * N14 / 4, seed, nonce);
  const r3 = new Uint16Array(N14);
  const b32 = u326(buf);
  let len = 0;
  for (let i4 = 0, p4 = 0, bb = 0, t0 = 0; i4 < b32.length; i4++) {
    let b4 = b32[i4];
    for (let j3 = 0; j3 < 32; j3++) {
      bb += b4 & 1;
      b4 >>= 1;
      len += 1;
      if (len === eta) {
        t0 = bb;
        bb = 0;
      } else if (len === 2 * eta) {
        r3[p4++] = mod3(t0 - bb);
        bb = 0;
        len = 0;
      }
    }
  }
  if (len)
    throw new Error(`sampleCBD: leftover bits: ${len}`);
  return r3;
}
var genKPKE = (opts2) => {
  const { K: K4, PRF, XOF, HASH512, ETA1, ETA2, du, dv } = opts2;
  const poly1 = polyCoder(1);
  const polyV = polyCoder(dv);
  const polyU = polyCoder(du);
  const publicCoder = splitCoder("publicKey", vecCoder(polyCoder(12), K4), 32);
  const secretCoder = vecCoder(polyCoder(12), K4);
  const cipherCoder = splitCoder("ciphertext", vecCoder(polyU, K4), polyV);
  const seedCoder = splitCoder("seed", 32, 32);
  return {
    secretCoder,
    lengths: {
      secretKey: secretCoder.bytesLen,
      publicKey: publicCoder.bytesLen,
      cipherText: cipherCoder.bytesLen
    },
    keygen: (seed) => {
      abytes6(seed, 32, "seed");
      const seedDst = new Uint8Array(33);
      seedDst.set(seed);
      seedDst[32] = K4;
      const seedHash = HASH512(seedDst);
      const [rho, sigma] = seedCoder.decode(seedHash);
      const sHat = [];
      const tHat = [];
      for (let i4 = 0; i4 < K4; i4++)
        sHat.push(NTT.encode(sampleCBD(PRF, sigma, i4, ETA1)));
      const x5 = XOF(rho);
      for (let i4 = 0; i4 < K4; i4++) {
        const e2 = NTT.encode(sampleCBD(PRF, sigma, K4 + i4, ETA1));
        for (let j3 = 0; j3 < K4; j3++) {
          const aji = SampleNTT(x5.get(j3, i4));
          polyAdd(e2, MultiplyNTTs(aji, sHat[j3]));
        }
        tHat.push(e2);
      }
      x5.clean();
      const res = {
        publicKey: publicCoder.encode([tHat, rho]),
        secretKey: secretCoder.encode(sHat)
      };
      cleanBytes(rho, sigma, sHat, tHat, seedDst, seedHash);
      return res;
    },
    encrypt: (publicKey5, msg, seed) => {
      const [tHat, rho] = publicCoder.decode(publicKey5);
      const rHat = [];
      for (let i4 = 0; i4 < K4; i4++)
        rHat.push(NTT.encode(sampleCBD(PRF, seed, i4, ETA1)));
      const x5 = XOF(rho);
      const tmp2 = new Uint16Array(N14);
      const u2 = [];
      for (let i4 = 0; i4 < K4; i4++) {
        const e1 = sampleCBD(PRF, seed, K4 + i4, ETA2);
        const tmp = new Uint16Array(N14);
        for (let j3 = 0; j3 < K4; j3++) {
          const aij = SampleNTT(x5.get(i4, j3));
          polyAdd(tmp, MultiplyNTTs(aij, rHat[j3]));
        }
        polyAdd(e1, NTT.decode(tmp));
        u2.push(e1);
        polyAdd(tmp2, MultiplyNTTs(tHat[i4], rHat[i4]));
        cleanBytes(tmp);
      }
      x5.clean();
      const e2 = sampleCBD(PRF, seed, 2 * K4, ETA2);
      polyAdd(e2, NTT.decode(tmp2));
      const v6 = poly1.decode(msg);
      polyAdd(v6, e2);
      cleanBytes(tHat, rHat, tmp2, e2);
      return cipherCoder.encode([u2, v6]);
    },
    decrypt: (cipherText, privateKey) => {
      const [u2, v6] = cipherCoder.decode(cipherText);
      const sk = secretCoder.decode(privateKey);
      const tmp = new Uint16Array(N14);
      for (let i4 = 0; i4 < K4; i4++)
        polyAdd(tmp, MultiplyNTTs(sk[i4], NTT.encode(u2[i4])));
      polySub(v6, NTT.decode(tmp));
      cleanBytes(tmp, sk, u2);
      return poly1.encode(v6);
    }
  };
};
function createKyber(opts2) {
  const KPKE = genKPKE(opts2);
  const { HASH256, HASH512, KDF } = opts2;
  const { secretCoder: KPKESecretCoder, lengths } = KPKE;
  const secretCoder = splitCoder("secretKey", lengths.secretKey, lengths.publicKey, 32, 32);
  const msgLen = 32;
  const seedLen = 64;
  return {
    info: { type: "ml-kem" },
    lengths: {
      ...lengths,
      seed: 64,
      msg: msgLen,
      msgRand: msgLen,
      secretKey: secretCoder.bytesLen
    },
    keygen: (seed = randomBytes5(seedLen)) => {
      abytes6(seed, seedLen, "seed");
      const { publicKey: publicKey5, secretKey: sk } = KPKE.keygen(seed.subarray(0, 32));
      const publicKeyHash = HASH256(publicKey5);
      const secretKey = secretCoder.encode([sk, publicKey5, publicKeyHash, seed.subarray(32)]);
      cleanBytes(sk, publicKeyHash);
      return { publicKey: publicKey5, secretKey };
    },
    getPublicKey: (secretKey) => {
      const [_sk, publicKey5, _publicKeyHash, _z] = secretCoder.decode(secretKey);
      return Uint8Array.from(publicKey5);
    },
    encapsulate: (publicKey5, msg = randomBytes5(msgLen)) => {
      abytes6(publicKey5, lengths.publicKey, "publicKey");
      abytes6(msg, msgLen, "message");
      const eke = publicKey5.subarray(0, 384 * opts2.K);
      const ek = KPKESecretCoder.encode(KPKESecretCoder.decode(copyBytes(eke)));
      if (!equalBytes3(ek, eke)) {
        cleanBytes(ek);
        throw new Error("ML-KEM.encapsulate: wrong publicKey modulus");
      }
      cleanBytes(ek);
      const kr4 = HASH512.create().update(msg).update(HASH256(publicKey5)).digest();
      const cipherText = KPKE.encrypt(publicKey5, msg, kr4.subarray(32, 64));
      cleanBytes(kr4.subarray(32));
      return { cipherText, sharedSecret: kr4.subarray(0, 32) };
    },
    decapsulate: (cipherText, secretKey) => {
      abytes6(secretKey, secretCoder.bytesLen, "secretKey");
      abytes6(cipherText, lengths.cipherText, "cipherText");
      const k768 = secretCoder.bytesLen - 96;
      const start = k768 + 32;
      const test3 = HASH256(secretKey.subarray(k768 / 2, start));
      if (!equalBytes3(test3, secretKey.subarray(start, start + 32)))
        throw new Error("invalid secretKey: hash check failed");
      const [sk, publicKey5, publicKeyHash, z4] = secretCoder.decode(secretKey);
      const msg = KPKE.decrypt(cipherText, sk);
      const kr4 = HASH512.create().update(msg).update(publicKeyHash).digest();
      const Khat = kr4.subarray(0, 32);
      const cipherText2 = KPKE.encrypt(publicKey5, msg, kr4.subarray(32, 64));
      const isValid = equalBytes3(cipherText, cipherText2);
      const Kbar = KDF.create({ dkLen: 32 }).update(z4).update(cipherText).digest();
      cleanBytes(msg, cipherText2, !isValid ? Khat : Kbar);
      return isValid ? Khat : Kbar;
    }
  };
}
function shakePRF(dkLen, key, nonce) {
  return shake2562.create({ dkLen }).update(key).update(new Uint8Array([nonce])).digest();
}
var opts = {
  HASH256: sha3_2562,
  HASH512: sha3_5122,
  KDF: shake2562,
  XOF: XOF128,
  PRF: shakePRF
};
var ml_kem512 = createKyber({
  ...opts,
  ...PARAMS[512]
});
var ml_kem768 = createKyber({
  ...opts,
  ...PARAMS[768]
});
var ml_kem1024 = createKyber({
  ...opts,
  ...PARAMS[1024]
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/hashes/hmac.js
var _HMAC = class {
  constructor(hash, key) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    ahash2(hash);
    abytes5(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i4 = 0; i4 < pad3.length; i4++)
      pad3[i4] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash.create();
    for (let i4 = 0; i4 < pad3.length; i4++)
      pad3[i4] ^= 54 ^ 92;
    this.oHash.update(pad3);
    clean2(pad3);
  }
  update(buf) {
    aexists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes5(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to5) {
    to5 || (to5 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to5 = to5;
    to5.finished = finished;
    to5.destroyed = destroyed;
    to5.blockLen = blockLen;
    to5.outputLen = outputLen;
    to5.oHash = oHash._cloneInto(to5.oHash);
    to5.iHash = iHash._cloneInto(to5.iHash);
    return to5;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac3 = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
hmac3.create = (hash, key) => new _HMAC(hash, key);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/hashes/hkdf.js
function extract5(hash, ikm, salt) {
  ahash2(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac3(hash, salt, ikm);
}
var HKDF_COUNTER = Uint8Array.of(0);
var EMPTY_BUFFER = Uint8Array.of();
function expand(hash, prk, info, length2 = 32) {
  ahash2(hash);
  anumber4(length2, "length");
  const olen = hash.outputLen;
  if (length2 > 255 * olen)
    throw new Error("Length must be <= 255*HashLen");
  const blocks = Math.ceil(length2 / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  else
    abytes5(info, void 0, "info");
  const okm = new Uint8Array(blocks * olen);
  const HMAC2 = hmac3.create(hash, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T3 = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T3).update(info).update(HKDF_COUNTER).digestInto(T3);
    okm.set(T3, olen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  clean2(T3, HKDF_COUNTER);
  return okm.slice(0, length2);
}
var hkdf = (hash, ikm, salt, info, length2) => expand(hash, extract5(hash, ikm, salt), info, length2);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/hashes/_md.js
function Chi3(a3, b4, c6) {
  return a3 & b4 ^ ~a3 & c6;
}
function Maj3(a3, b4, c6) {
  return a3 & b4 ^ a3 & c6 ^ b4 & c6;
}
var HashMD3 = class {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    aexists2(this);
    abytes5(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE6 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean2(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos; i4 < blockLen; i4++)
      buffer[i4] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0; i4 < outLen; i4++)
      oview.setUint32(4 * i4, state[i4], isLE6);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to5) {
    to5 || (to5 = new this.constructor());
    to5.set(...this.get());
    const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
    to5.destroyed = destroyed;
    to5.finished = finished;
    to5.length = length2;
    to5.pos = pos;
    if (length2 % blockLen)
      to5.buffer.set(buffer);
    return to5;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV2 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/hashes/_u64.js
var U32_MASK643 = BigInt(2 ** 32 - 1);
var _32n3 = BigInt(32);
function fromBig3(n5, le5 = false) {
  if (le5)
    return { h: Number(n5 & U32_MASK643), l: Number(n5 >> _32n3 & U32_MASK643) };
  return { h: Number(n5 >> _32n3 & U32_MASK643) | 0, l: Number(n5 & U32_MASK643) | 0 };
}
function split3(lst, le5 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i4 = 0; i4 < len; i4++) {
    const { h: h5, l: l6 } = fromBig3(lst[i4], le5);
    [Ah[i4], Al[i4]] = [h5, l6];
  }
  return [Ah, Al];
}
var shrSH2 = (h5, _l, s3) => h5 >>> s3;
var shrSL2 = (h5, l6, s3) => h5 << 32 - s3 | l6 >>> s3;
var rotrSH2 = (h5, l6, s3) => h5 >>> s3 | l6 << 32 - s3;
var rotrSL2 = (h5, l6, s3) => h5 << 32 - s3 | l6 >>> s3;
var rotrBH2 = (h5, l6, s3) => h5 << 64 - s3 | l6 >>> s3 - 32;
var rotrBL2 = (h5, l6, s3) => h5 >>> s3 - 32 | l6 << 64 - s3;
function add2(Ah, Al, Bh, Bl) {
  const l6 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l6 / 2 ** 32 | 0) | 0, l: l6 | 0 };
}
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/hashes/sha2.js
var SHA256_K2 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2_32B = class extends HashMD3 {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4, E: E4, F: F5, G: G5, H: H2 } = this;
    return [A4, B3, C4, D4, E4, F5, G5, H2];
  }
  // prettier-ignore
  set(A4, B3, C4, D4, E4, F5, G5, H2) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
    this.E = E4 | 0;
    this.F = F5 | 0;
    this.G = G5 | 0;
    this.H = H2 | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4)
      SHA256_W2[i4] = view.getUint32(offset5, false);
    for (let i4 = 16; i4 < 64; i4++) {
      const W15 = SHA256_W2[i4 - 15];
      const W22 = SHA256_W2[i4 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W22, 17) ^ rotr2(W22, 19) ^ W22 >>> 10;
      SHA256_W2[i4] = s1 + SHA256_W2[i4 - 7] + s0 + SHA256_W2[i4 - 16] | 0;
    }
    let { A: A4, B: B3, C: C4, D: D4, E: E4, F: F5, G: G5, H: H2 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      const sigma1 = rotr2(E4, 6) ^ rotr2(E4, 11) ^ rotr2(E4, 25);
      const T1 = H2 + sigma1 + Chi3(E4, F5, G5) + SHA256_K2[i4] + SHA256_W2[i4] | 0;
      const sigma0 = rotr2(A4, 2) ^ rotr2(A4, 13) ^ rotr2(A4, 22);
      const T22 = sigma0 + Maj3(A4, B3, C4) | 0;
      H2 = G5;
      G5 = F5;
      F5 = E4;
      E4 = D4 + T1 | 0;
      D4 = C4;
      C4 = B3;
      B3 = A4;
      A4 = T1 + T22 | 0;
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    E4 = E4 + this.E | 0;
    F5 = F5 + this.F | 0;
    G5 = G5 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A4, B3, C4, D4, E4, F5, G5, H2);
  }
  roundClean() {
    clean2(SHA256_W2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean2(this.buffer);
  }
};
var _SHA256 = class extends SHA2_32B {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV2[0] | 0);
    __publicField(this, "B", SHA256_IV2[1] | 0);
    __publicField(this, "C", SHA256_IV2[2] | 0);
    __publicField(this, "D", SHA256_IV2[3] | 0);
    __publicField(this, "E", SHA256_IV2[4] | 0);
    __publicField(this, "F", SHA256_IV2[5] | 0);
    __publicField(this, "G", SHA256_IV2[6] | 0);
    __publicField(this, "H", SHA256_IV2[7] | 0);
  }
};
var _SHA224 = class extends SHA2_32B {
  constructor() {
    super(28);
    __publicField(this, "A", SHA224_IV[0] | 0);
    __publicField(this, "B", SHA224_IV[1] | 0);
    __publicField(this, "C", SHA224_IV[2] | 0);
    __publicField(this, "D", SHA224_IV[3] | 0);
    __publicField(this, "E", SHA224_IV[4] | 0);
    __publicField(this, "F", SHA224_IV[5] | 0);
    __publicField(this, "G", SHA224_IV[6] | 0);
    __publicField(this, "H", SHA224_IV[7] | 0);
  }
};
var K512 = (() => split3([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
var SHA512_Kh2 = (() => K512[0])();
var SHA512_Kl2 = (() => K512[1])();
var SHA512_W_H2 = new Uint32Array(80);
var SHA512_W_L2 = new Uint32Array(80);
var SHA2_64B = class extends HashMD3 {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4) {
      SHA512_W_H2[i4] = view.getUint32(offset5);
      SHA512_W_L2[i4] = view.getUint32(offset5 += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H2[i4 - 15] | 0;
      const W15l = SHA512_W_L2[i4 - 15] | 0;
      const s0h = rotrSH2(W15h, W15l, 1) ^ rotrSH2(W15h, W15l, 8) ^ shrSH2(W15h, W15l, 7);
      const s0l = rotrSL2(W15h, W15l, 1) ^ rotrSL2(W15h, W15l, 8) ^ shrSL2(W15h, W15l, 7);
      const W2h = SHA512_W_H2[i4 - 2] | 0;
      const W2l = SHA512_W_L2[i4 - 2] | 0;
      const s1h = rotrSH2(W2h, W2l, 19) ^ rotrBH2(W2h, W2l, 61) ^ shrSH2(W2h, W2l, 6);
      const s1l = rotrSL2(W2h, W2l, 19) ^ rotrBL2(W2h, W2l, 61) ^ shrSL2(W2h, W2l, 6);
      const SUMl = add4L2(s0l, s1l, SHA512_W_L2[i4 - 7], SHA512_W_L2[i4 - 16]);
      const SUMh = add4H2(SUMl, s0h, s1h, SHA512_W_H2[i4 - 7], SHA512_W_H2[i4 - 16]);
      SHA512_W_H2[i4] = SUMh | 0;
      SHA512_W_L2[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = rotrSH2(Eh, El, 14) ^ rotrSH2(Eh, El, 18) ^ rotrBH2(Eh, El, 41);
      const sigma1l = rotrSL2(Eh, El, 14) ^ rotrSL2(Eh, El, 18) ^ rotrBL2(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L2(Hl, sigma1l, CHIl, SHA512_Kl2[i4], SHA512_W_L2[i4]);
      const T1h = add5H2(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i4], SHA512_W_H2[i4]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH2(Ah, Al, 28) ^ rotrBH2(Ah, Al, 34) ^ rotrBH2(Ah, Al, 39);
      const sigma0l = rotrSL2(Ah, Al, 28) ^ rotrBL2(Ah, Al, 34) ^ rotrBL2(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add2(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L2(T1l, sigma0l, MAJl);
      Ah = add3H2(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add2(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add2(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add2(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add2(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add2(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add2(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add2(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add2(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean2(SHA512_W_H2, SHA512_W_L2);
  }
  destroy() {
    clean2(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _SHA512 = class extends SHA2_64B {
  constructor() {
    super(64);
    __publicField(this, "Ah", SHA512_IV[0] | 0);
    __publicField(this, "Al", SHA512_IV[1] | 0);
    __publicField(this, "Bh", SHA512_IV[2] | 0);
    __publicField(this, "Bl", SHA512_IV[3] | 0);
    __publicField(this, "Ch", SHA512_IV[4] | 0);
    __publicField(this, "Cl", SHA512_IV[5] | 0);
    __publicField(this, "Dh", SHA512_IV[6] | 0);
    __publicField(this, "Dl", SHA512_IV[7] | 0);
    __publicField(this, "Eh", SHA512_IV[8] | 0);
    __publicField(this, "El", SHA512_IV[9] | 0);
    __publicField(this, "Fh", SHA512_IV[10] | 0);
    __publicField(this, "Fl", SHA512_IV[11] | 0);
    __publicField(this, "Gh", SHA512_IV[12] | 0);
    __publicField(this, "Gl", SHA512_IV[13] | 0);
    __publicField(this, "Hh", SHA512_IV[14] | 0);
    __publicField(this, "Hl", SHA512_IV[15] | 0);
  }
};
var _SHA384 = class extends SHA2_64B {
  constructor() {
    super(48);
    __publicField(this, "Ah", SHA384_IV[0] | 0);
    __publicField(this, "Al", SHA384_IV[1] | 0);
    __publicField(this, "Bh", SHA384_IV[2] | 0);
    __publicField(this, "Bl", SHA384_IV[3] | 0);
    __publicField(this, "Ch", SHA384_IV[4] | 0);
    __publicField(this, "Cl", SHA384_IV[5] | 0);
    __publicField(this, "Dh", SHA384_IV[6] | 0);
    __publicField(this, "Dl", SHA384_IV[7] | 0);
    __publicField(this, "Eh", SHA384_IV[8] | 0);
    __publicField(this, "El", SHA384_IV[9] | 0);
    __publicField(this, "Fh", SHA384_IV[10] | 0);
    __publicField(this, "Fl", SHA384_IV[11] | 0);
    __publicField(this, "Gh", SHA384_IV[12] | 0);
    __publicField(this, "Gl", SHA384_IV[13] | 0);
    __publicField(this, "Hh", SHA384_IV[14] | 0);
    __publicField(this, "Hl", SHA384_IV[15] | 0);
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var _SHA512_224 = class extends SHA2_64B {
  constructor() {
    super(28);
    __publicField(this, "Ah", T224_IV[0] | 0);
    __publicField(this, "Al", T224_IV[1] | 0);
    __publicField(this, "Bh", T224_IV[2] | 0);
    __publicField(this, "Bl", T224_IV[3] | 0);
    __publicField(this, "Ch", T224_IV[4] | 0);
    __publicField(this, "Cl", T224_IV[5] | 0);
    __publicField(this, "Dh", T224_IV[6] | 0);
    __publicField(this, "Dl", T224_IV[7] | 0);
    __publicField(this, "Eh", T224_IV[8] | 0);
    __publicField(this, "El", T224_IV[9] | 0);
    __publicField(this, "Fh", T224_IV[10] | 0);
    __publicField(this, "Fl", T224_IV[11] | 0);
    __publicField(this, "Gh", T224_IV[12] | 0);
    __publicField(this, "Gl", T224_IV[13] | 0);
    __publicField(this, "Hh", T224_IV[14] | 0);
    __publicField(this, "Hl", T224_IV[15] | 0);
  }
};
var _SHA512_256 = class extends SHA2_64B {
  constructor() {
    super(32);
    __publicField(this, "Ah", T256_IV[0] | 0);
    __publicField(this, "Al", T256_IV[1] | 0);
    __publicField(this, "Bh", T256_IV[2] | 0);
    __publicField(this, "Bl", T256_IV[3] | 0);
    __publicField(this, "Ch", T256_IV[4] | 0);
    __publicField(this, "Cl", T256_IV[5] | 0);
    __publicField(this, "Dh", T256_IV[6] | 0);
    __publicField(this, "Dl", T256_IV[7] | 0);
    __publicField(this, "Eh", T256_IV[8] | 0);
    __publicField(this, "El", T256_IV[9] | 0);
    __publicField(this, "Fh", T256_IV[10] | 0);
    __publicField(this, "Fl", T256_IV[11] | 0);
    __publicField(this, "Gh", T256_IV[12] | 0);
    __publicField(this, "Gl", T256_IV[13] | 0);
    __publicField(this, "Hh", T256_IV[14] | 0);
    __publicField(this, "Hl", T256_IV[15] | 0);
  }
};
var sha2567 = createHasher4(
  () => new _SHA256(),
  oidNist(1)
);
var sha2242 = createHasher4(
  () => new _SHA224(),
  oidNist(4)
);
var sha5124 = createHasher4(
  () => new _SHA512(),
  oidNist(3)
);
var sha3842 = createHasher4(
  () => new _SHA384(),
  oidNist(2)
);
var sha512_2562 = createHasher4(
  () => new _SHA512_256(),
  oidNist(6)
);
var sha512_2242 = createHasher4(
  () => new _SHA512_224(),
  oidNist(5)
);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/ciphers/esm/utils.js
var u85 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
var u327 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes9(a3) {
  return a3 instanceof Uint8Array || a3 != null && typeof a3 === "object" && a3.constructor.name === "Uint8Array";
}
var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE4)
  throw new Error("Non little-endian hardware is not supported");
var hexes5 = Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes4(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  else if (isBytes9(data))
    data = data.slice();
  else
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function ensureBytes3(b4, len) {
  if (!isBytes9(b4))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b4.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function equalBytes4(a3, b4) {
  if (a3.length !== b4.length)
    return false;
  let diff = 0;
  for (let i4 = 0; i4 < a3.length; i4++)
    diff |= a3[i4] ^ b4[i4];
  return diff === 0;
}
var wrapCipher = (params, c6) => {
  Object.assign(c6, params);
  return c6;
};
function setBigUint642(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE6);
  const _32n5 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n5 & _u32_max);
  const wl = Number(value & _u32_max);
  const h5 = isLE6 ? 4 : 0;
  const l6 = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h5, wh, isLE6);
  view.setUint32(byteOffset + l6, wl, isLE6);
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/ciphers/esm/_assert.js
function isBytes10(a3) {
  return a3 != null && typeof a3 === "object" && (a3 instanceof Uint8Array || a3.constructor.name === "Uint8Array");
}
function bytes(b4, ...lengths) {
  if (!isBytes10(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b4.length}`);
}
function exists2(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance2) {
  bytes(out);
  const min4 = instance2.outputLen;
  if (out.length < min4) {
    throw new Error(`digestInto() expects output buffer of length at least ${min4}`);
  }
}

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = new Uint8Array(16);
var ZEROS32 = u327(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s22, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s22 << 31 | s3 >>> 1,
    s2: s1 << 31 | s22 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n5) => (n5 >>> 0 & 255) << 24 | (n5 >>> 8 & 255) << 16 | (n5 >>> 16 & 255) << 8 | n5 >>> 24 & 255 | 0;
function _toGHASHKey(k6) {
  k6.reverse();
  const hiBit = k6[15] & 1;
  let carry = 0;
  for (let i4 = 0; i4 < k6.length; i4++) {
    const t = k6[i4];
    k6[i4] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k6[0] ^= -hiBit & 225;
  return k6;
}
var estimateWindow = (bytes2) => {
  if (bytes2 > 64 * 1024)
    return 8;
  if (bytes2 > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes4(key);
    ensureBytes3(key, 16);
    const kView = createView3(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k22 = kView.getUint32(8, false);
    let k32 = kView.getUint32(12, false);
    const doubles = [];
    for (let i4 = 0; i4 < 128; i4++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k22), s3: swapLE(k32) });
      ({ s0: k0, s1: k1, s2: k22, s3: k32 } = mul2(k0, k1, k22, k32));
    }
    const W5 = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W5))
      throw new Error(`ghash: wrong window size=${W5}, should be 2, 4 or 8`);
    this.W = W5;
    const bits = 128;
    const windows = bits / W5;
    const windowSize = this.windowSize = 2 ** W5;
    const items = [];
    for (let w4 = 0; w4 < windows; w4++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s22 = 0, s3 = 0;
        for (let j3 = 0; j3 < W5; j3++) {
          const bit = byte >>> W5 - j3 - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d22, s3: d32 } = doubles[W5 * w4 + j3];
          s0 ^= d0, s1 ^= d1, s22 ^= d22, s3 ^= d32;
        }
        items.push({ s0, s1, s2: s22, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s22, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s22 ^= this.s2, s3 ^= this.s3;
    const { W: W5, t, windowSize } = this;
    let o0 = 0, o1 = 0, o22 = 0, o32 = 0;
    const mask = (1 << W5) - 1;
    let w4 = 0;
    for (const num3 of [s0, s1, s22, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num3 >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W5 - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W5 * bitPos & mask;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w4 * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o22 ^= e2, o32 ^= e3;
          w4 += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o22;
    this.s3 = o32;
  }
  update(data) {
    data = toBytes4(data);
    exists2(this);
    const b32 = u327(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left13 = data.length % BLOCK_SIZE;
    for (let i4 = 0; i4 < blocks; i4++) {
      this._updateBlock(b32[i4 * 4 + 0], b32[i4 * 4 + 1], b32[i4 * 4 + 2], b32[i4 * 4 + 3]);
    }
    if (left13) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      ZEROS32.fill(0);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    exists2(this);
    output(out, this);
    this.finished = true;
    const { s0, s1, s2: s22, s3 } = this;
    const o32 = u327(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s22;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes4(key);
    const ghKey = _toGHASHKey(key.slice());
    super(ghKey, expectedLength);
    ghKey.fill(0);
  }
  update(data) {
    data = toBytes4(data);
    exists2(this);
    const b32 = u327(data);
    const left13 = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i4 = 0; i4 < blocks; i4++) {
      this._updateBlock(swapLE(b32[i4 * 4 + 3]), swapLE(b32[i4 * 4 + 2]), swapLE(b32[i4 * 4 + 1]), swapLE(b32[i4 * 4 + 0]));
    }
    if (left13) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      ZEROS32.fill(0);
    }
    return this;
  }
  digestInto(out) {
    exists2(this);
    output(out, this);
    this.finished = true;
    const { s0, s1, s2: s22, s3 } = this;
    const o32 = u327(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s22;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes4(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n5) {
  return n5 << 1 ^ POLY2 & -(n5 >> 7);
}
function mul(a3, b4) {
  let res = 0;
  for (; b4 > 0; b4 >>= 1) {
    res ^= a3 & -(b4 & 1);
    a3 = mul22(a3);
  }
  return res;
}
var _sbox = (() => {
  let t = new Uint8Array(256);
  for (let i4 = 0, x5 = 1; i4 < 256; i4++, x5 ^= mul22(x5))
    t[i4] = x5;
  const sbox = new Uint8Array(256);
  sbox[0] = 99;
  for (let i4 = 0; i4 < 255; i4++) {
    let x5 = t[255 - i4];
    x5 |= x5 << 8;
    sbox[t[i4]] = (x5 ^ x5 >> 4 ^ x5 >> 5 ^ x5 >> 6 ^ x5 >> 7 ^ 99) & 255;
  }
  return sbox;
})();
var _inv_sbox = _sbox.map((_3, j3) => _sbox.indexOf(j3));
var rotr32_8 = (n5) => n5 << 24 | n5 >>> 8;
var rotl32_8 = (n5) => n5 << 8 | n5 >>> 24;
function genTtable(sbox, fn4) {
  if (sbox.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_3, j3) => fn4(sbox[j3]));
  const T1 = T0.map(rotl32_8);
  const T22 = T1.map(rotl32_8);
  const T3 = T22.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox2 = new Uint16Array(256 * 256);
  for (let i4 = 0; i4 < 256; i4++) {
    for (let j3 = 0; j3 < 256; j3++) {
      const idx = i4 * 256 + j3;
      T01[idx] = T0[i4] ^ T1[j3];
      T23[idx] = T22[i4] ^ T3[j3];
      sbox2[idx] = sbox[i4] << 8 | sbox[j3];
    }
  }
  return { sbox, sbox2, T0, T1, T2: T22, T3, T01, T23 };
}
var TABLE_ENC = genTtable(_sbox, (s3) => mul(s3, 3) << 24 | s3 << 16 | s3 << 8 | mul(s3, 2));
var TABLE_DEC = genTtable(_inv_sbox, (s3) => mul(s3, 11) << 24 | mul(s3, 13) << 16 | mul(s3, 9) << 8 | mul(s3, 14));
var POWX = (() => {
  const p4 = new Uint8Array(16);
  for (let i4 = 0, x5 = 1; i4 < 16; i4++, x5 = mul22(x5))
    p4[i4] = x5;
  return p4;
})();
function expandKeyLE(key) {
  ensureBytes3(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
  const { sbox2 } = TABLE_ENC;
  const k32 = u327(key);
  const Nk = k32.length;
  const subByte = (n5) => applySbox(sbox2, n5, n5, n5, n5);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i4 = Nk; i4 < xk.length; i4++) {
    let t = xk[i4 - 1];
    if (i4 % Nk === 0)
      t = subByte(rotr32_8(t)) ^ POWX[i4 / Nk - 1];
    else if (Nk > 6 && i4 % Nk === 4)
      t = subByte(t);
    xk[i4] = xk[i4 - Nk] ^ t;
  }
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = TABLE_ENC;
  const { T0, T1, T2: T22, T3 } = TABLE_DEC;
  for (let i4 = 0; i4 < Nk; i4 += 4) {
    for (let j3 = 0; j3 < 4; j3++)
      xk[i4 + j3] = encKey[Nk - i4 - 4 + j3];
  }
  encKey.fill(0);
  for (let i4 = 4; i4 < Nk - 4; i4++) {
    const x5 = xk[i4];
    const w4 = applySbox(sbox2, x5, x5, x5, x5);
    xk[i4] = T0[w4 & 255] ^ T1[w4 >>> 8 & 255] ^ T22[w4 >>> 16 & 255] ^ T3[w4 >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s22, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s22 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s22, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s22 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt(xk, s0, s1, s22, s3) {
  const { sbox2, T01, T23 } = TABLE_ENC;
  let k6 = 0;
  s0 ^= xk[k6++], s1 ^= xk[k6++], s22 ^= xk[k6++], s3 ^= xk[k6++];
  const rounds = xk.length / 4 - 2;
  for (let i4 = 0; i4 < rounds; i4++) {
    const t02 = xk[k6++] ^ apply0123(T01, T23, s0, s1, s22, s3);
    const t12 = xk[k6++] ^ apply0123(T01, T23, s1, s22, s3, s0);
    const t22 = xk[k6++] ^ apply0123(T01, T23, s22, s3, s0, s1);
    const t32 = xk[k6++] ^ apply0123(T01, T23, s3, s0, s1, s22);
    s0 = t02, s1 = t12, s22 = t22, s3 = t32;
  }
  const t0 = xk[k6++] ^ applySbox(sbox2, s0, s1, s22, s3);
  const t1 = xk[k6++] ^ applySbox(sbox2, s1, s22, s3, s0);
  const t2 = xk[k6++] ^ applySbox(sbox2, s22, s3, s0, s1);
  const t3 = xk[k6++] ^ applySbox(sbox2, s3, s0, s1, s22);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt(xk, s0, s1, s22, s3) {
  const { sbox2, T01, T23 } = TABLE_DEC;
  let k6 = 0;
  s0 ^= xk[k6++], s1 ^= xk[k6++], s22 ^= xk[k6++], s3 ^= xk[k6++];
  const rounds = xk.length / 4 - 2;
  for (let i4 = 0; i4 < rounds; i4++) {
    const t02 = xk[k6++] ^ apply0123(T01, T23, s0, s3, s22, s1);
    const t12 = xk[k6++] ^ apply0123(T01, T23, s1, s0, s3, s22);
    const t22 = xk[k6++] ^ apply0123(T01, T23, s22, s1, s0, s3);
    const t32 = xk[k6++] ^ apply0123(T01, T23, s3, s22, s1, s0);
    s0 = t02, s1 = t12, s22 = t22, s3 = t32;
  }
  const t0 = xk[k6++] ^ applySbox(sbox2, s0, s3, s22, s1);
  const t1 = xk[k6++] ^ applySbox(sbox2, s1, s0, s3, s22);
  const t2 = xk[k6++] ^ applySbox(sbox2, s22, s1, s0, s3);
  const t3 = xk[k6++] ^ applySbox(sbox2, s3, s22, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function getDst(len, dst) {
  if (!dst)
    return new Uint8Array(len);
  ensureBytes3(dst);
  if (dst.length < len)
    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
  return dst;
}
function ctrCounter(xk, nonce, src2, dst) {
  ensureBytes3(nonce, BLOCK_SIZE2);
  ensureBytes3(src2);
  const srcLen = src2.length;
  dst = getDst(srcLen, dst);
  const ctr3 = nonce;
  const c32 = u327(ctr3);
  let { s0, s1, s2: s22, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u327(src2);
  const dst32 = u327(dst);
  for (let i4 = 0; i4 + 4 <= src32.length; i4 += 4) {
    dst32[i4 + 0] = src32[i4 + 0] ^ s0;
    dst32[i4 + 1] = src32[i4 + 1] ^ s1;
    dst32[i4 + 2] = src32[i4 + 2] ^ s22;
    dst32[i4 + 3] = src32[i4 + 3] ^ s3;
    let carry = 1;
    for (let i5 = ctr3.length - 1; i5 >= 0; i5--) {
      carry = carry + (ctr3[i5] & 255) | 0;
      ctr3[i5] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2: s22, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s22, s3]);
    const buf = u85(b32);
    for (let i4 = start, pos = 0; i4 < srcLen; i4++, pos++)
      dst[i4] = src2[i4] ^ buf[pos];
  }
  return dst;
}
function ctr32(xk, isLE6, nonce, src2, dst) {
  ensureBytes3(nonce, BLOCK_SIZE2);
  ensureBytes3(src2);
  dst = getDst(src2.length, dst);
  const ctr3 = nonce;
  const c32 = u327(ctr3);
  const view = createView3(ctr3);
  const src32 = u327(src2);
  const dst32 = u327(dst);
  const ctrPos = isLE6 ? 0 : 12;
  const srcLen = src2.length;
  let ctrNum = view.getUint32(ctrPos, isLE6);
  let { s0, s1, s2: s22, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i4 = 0; i4 + 4 <= src32.length; i4 += 4) {
    dst32[i4 + 0] = src32[i4 + 0] ^ s0;
    dst32[i4 + 1] = src32[i4 + 1] ^ s1;
    dst32[i4 + 2] = src32[i4 + 2] ^ s22;
    dst32[i4 + 3] = src32[i4 + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE6);
    ({ s0, s1, s2: s22, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s22, s3]);
    const buf = u85(b32);
    for (let i4 = start, pos = 0; i4 < srcLen; i4++, pos++)
      dst[i4] = src2[i4] ^ buf[pos];
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce) {
  ensureBytes3(key);
  ensureBytes3(nonce, BLOCK_SIZE2);
  function processCtr(buf, dst) {
    const xk = expandKeyLE(key);
    const n5 = nonce.slice();
    const out = ctrCounter(xk, n5, buf, dst);
    xk.fill(0);
    n5.fill(0);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  ensureBytes3(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  const b4 = u327(plaintext);
  if (pcks5) {
    let left13 = BLOCK_SIZE2 - remaining;
    if (!left13)
      left13 = BLOCK_SIZE2;
    outLen = outLen + left13;
  }
  const out = getDst(outLen, dst);
  const o4 = u327(out);
  return { b: b4, o: o4, out };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
  const out = data.subarray(0, -lastByte);
  for (let i4 = 0; i4 < lastByte; i4++)
    if (data[len - i4 - 1] !== lastByte)
      throw new Error(`aes/pcks5: wrong padding`);
  return out;
}
function padPCKS(left13) {
  const tmp = new Uint8Array(16);
  const tmp32 = u327(tmp);
  tmp.set(left13);
  const paddingByte = BLOCK_SIZE2 - left13.length;
  for (let i4 = BLOCK_SIZE2 - paddingByte; i4 < BLOCK_SIZE2; i4++)
    tmp[i4] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function ecb2(key, opts2 = {}) {
  ensureBytes3(key);
  const pcks5 = !opts2.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      ensureBytes3(plaintext);
      const { b: b4, o: o4, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i4 = 0;
      for (; i4 + 4 <= b4.length; ) {
        const { s0, s1, s2: s22, s3 } = encrypt(xk, b4[i4 + 0], b4[i4 + 1], b4[i4 + 2], b4[i4 + 3]);
        o4[i4++] = s0, o4[i4++] = s1, o4[i4++] = s22, o4[i4++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i4 * 4));
        const { s0, s1, s2: s22, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o4[i4++] = s0, o4[i4++] = s1, o4[i4++] = s22, o4[i4++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const out = getDst(ciphertext.length, dst);
      const b4 = u327(ciphertext);
      const o4 = u327(out);
      for (let i4 = 0; i4 + 4 <= b4.length; ) {
        const { s0, s1, s2: s22, s3 } = decrypt(xk, b4[i4 + 0], b4[i4 + 1], b4[i4 + 2], b4[i4 + 3]);
        o4[i4++] = s0, o4[i4++] = s1, o4[i4++] = s22, o4[i4++] = s3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts2 = {}) {
  ensureBytes3(key);
  ensureBytes3(iv, 16);
  const pcks5 = !opts2.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      const xk = expandKeyLE(key);
      const { b: b4, o: o4, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const n32 = u327(iv);
      let s0 = n32[0], s1 = n32[1], s22 = n32[2], s3 = n32[3];
      let i4 = 0;
      for (; i4 + 4 <= b4.length; ) {
        s0 ^= b4[i4 + 0], s1 ^= b4[i4 + 1], s22 ^= b4[i4 + 2], s3 ^= b4[i4 + 3];
        ({ s0, s1, s2: s22, s3 } = encrypt(xk, s0, s1, s22, s3));
        o4[i4++] = s0, o4[i4++] = s1, o4[i4++] = s22, o4[i4++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i4 * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s22 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2: s22, s3 } = encrypt(xk, s0, s1, s22, s3));
        o4[i4++] = s0, o4[i4++] = s1, o4[i4++] = s22, o4[i4++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const n32 = u327(iv);
      const out = getDst(ciphertext.length, dst);
      const b4 = u327(ciphertext);
      const o4 = u327(out);
      let s0 = n32[0], s1 = n32[1], s22 = n32[2], s3 = n32[3];
      for (let i4 = 0; i4 + 4 <= b4.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s22, ps3 = s3;
        s0 = b4[i4 + 0], s1 = b4[i4 + 1], s22 = b4[i4 + 2], s3 = b4[i4 + 3];
        const { s0: o0, s1: o1, s2: o22, s3: o32 } = decrypt(xk, s0, s1, s22, s3);
        o4[i4++] = o0 ^ ps0, o4[i4++] = o1 ^ ps1, o4[i4++] = o22 ^ ps2, o4[i4++] = o32 ^ ps3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
function computeTag(fn4, isLE6, key, data, AAD) {
  const h5 = fn4.create(key, data.length + ((AAD == null ? void 0 : AAD.length) || 0));
  if (AAD)
    h5.update(AAD);
  h5.update(data);
  const num3 = new Uint8Array(16);
  const view = createView3(num3);
  if (AAD)
    setBigUint642(view, 0, BigInt(AAD.length * 8), isLE6);
  setBigUint642(view, 8, BigInt(data.length * 8), isLE6);
  h5.update(num3);
  return h5.digest();
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce, AAD) {
  ensureBytes3(nonce);
  if (nonce.length === 0)
    throw new Error("aes/gcm: empty nonce");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag = computeTag(ghash, false, authKey, data, AAD);
    for (let i4 = 0; i4 < tagMask.length; i4++)
      tag[i4] ^= tagMask[i4];
    return tag;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter, counter, authKey);
    if (nonce.length === 12) {
      counter.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView3(nonceLen);
      setBigUint642(view, 8, BigInt(nonce.length * 8), false);
      ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);
    }
    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
    return { xk, authKey, counter, tagMask };
  }
  return {
    encrypt: (plaintext) => {
      ensureBytes3(plaintext);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      ctr32(xk, false, counter, plaintext, out);
      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      out.set(tag, plaintext.length);
      xk.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      ensureBytes3(ciphertext);
      if (ciphertext.length < tagLength)
        throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = _computeTag(authKey, tagMask, data);
      if (!equalBytes4(tag, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter, data);
      authKey.fill(0);
      tagMask.fill(0);
      xk.fill(0);
      return out;
    }
  };
});
var limit = (name2, min4, max4) => (value) => {
  if (!Number.isSafeInteger(value) || min4 > value || value > max4)
    throw new Error(`${name2}: invalid value=${value}, must be [${min4}..${max4}]`);
};
var siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  ensureBytes3(nonce);
  NONCE_LIMIT(nonce.length);
  if (AAD) {
    ensureBytes3(AAD);
    AAD_LIMIT(AAD.length);
  }
  function deriveKeys() {
    const len = key.length;
    if (len !== 16 && len !== 24 && len !== 32)
      throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(len);
    const authKey = new Uint8Array(16);
    const n32 = u327(nonce);
    let s0 = 0, s1 = n32[0], s22 = n32[1], s3 = n32[2];
    let counter = 0;
    for (const derivedKey of [authKey, encKey].map(u327)) {
      const d32 = u327(derivedKey);
      for (let i4 = 0; i4 < d32.length; i4 += 2) {
        const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s22, s3);
        d32[i4 + 0] = o0;
        d32[i4 + 1] = o1;
        s0 = ++counter;
      }
    }
    xk.fill(0);
    return { authKey, encKey: expandKeyLE(encKey) };
  }
  function _computeTag(encKey, authKey, data) {
    const tag = computeTag(polyval, true, authKey, data, AAD);
    for (let i4 = 0; i4 < 12; i4++)
      tag[i4] ^= nonce[i4];
    tag[15] &= 127;
    const t32 = u327(tag);
    let s0 = t32[0], s1 = t32[1], s22 = t32[2], s3 = t32[3];
    ({ s0, s1, s2: s22, s3 } = encrypt(encKey, s0, s1, s22, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s22, t32[3] = s3;
    return tag;
  }
  function processSiv(encKey, tag, input) {
    let block = tag.slice();
    block[15] |= 128;
    return ctr32(encKey, true, block, input);
  }
  return {
    encrypt: (plaintext) => {
      ensureBytes3(plaintext);
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag = _computeTag(encKey, authKey, plaintext);
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag, plaintext.length);
      out.set(processSiv(encKey, tag, plaintext));
      encKey.fill(0);
      authKey.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      ensureBytes3(ciphertext);
      CIPHER_LIMIT(ciphertext.length);
      const tag = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      encKey.fill(0);
      authKey.fill(0);
      if (!equalBytes4(tag, expectedTag))
        throw new Error("invalid polyval tag");
      return plaintext;
    }
  };
});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-shared/dist/index.js
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var WebSocketErrorType = (function(WebSocketErrorType22) {
  WebSocketErrorType22["INVALID_MESSAGE"] = "INVALID_MESSAGE";
  WebSocketErrorType22["HANDLER_NOT_FOUND"] = "HANDLER_NOT_FOUND";
  WebSocketErrorType22["HANDLER_ERROR"] = "HANDLER_ERROR";
  WebSocketErrorType22["CONNECTION_ERROR"] = "CONNECTION_ERROR";
  WebSocketErrorType22["VALIDATION_ERROR"] = "VALIDATION_ERROR";
  return WebSocketErrorType22;
})({});
var _a3;
var BaseMessage = (_a3 = class {
  constructor(data) {
    __publicField(this, "data");
    this.data = data;
  }
  getData() {
    return this.data;
  }
}, __name(_a3, "BaseMessage"), _a3);
var Uint8ArrayCodec = new Type(
  "Uint8Array",
  (u2) => u2 instanceof Uint8Array,
  (u2, c6) => {
    if (typeof u2 !== "string") {
      return failure(u2, c6, "Expected a hex string for Uint8Array");
    }
    try {
      const cleanHex = u2.startsWith("0x") ? u2.slice(2) : u2;
      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {
        return failure(u2, c6, "Invalid hex string format");
      }
      const decoded = hexToBytes5(cleanHex);
      return success(decoded);
    } catch (e2) {
      return failure(u2, c6, `Invalid hex string: ${e2}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a3) => bytesToHex5(a3)
);
var Uint32ArrayCodec = new Type(
  "Uint32Array",
  (u2) => u2 instanceof Uint32Array,
  (u2, c6) => {
    if (typeof u2 !== "string") {
      return failure(u2, c6, "Expected a hex string for Uint32Array");
    }
    try {
      const cleanHex = u2.startsWith("0x") ? u2.slice(2) : u2;
      if (cleanHex.length === 0) {
        return failure(u2, c6, "Empty hex string not allowed for Uint32Array");
      }
      if (cleanHex.length % 8 !== 0) {
        return failure(u2, c6, "Invalid hex string format for Uint32Array (must be multiple of 8 hex characters)");
      }
      const uint8Array = hexToBytes5(cleanHex);
      const uint32Array = new Uint32Array(uint8Array.buffer);
      return success(uint32Array);
    } catch (e2) {
      return failure(u2, c6, `Invalid hex string: ${e2}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a3) => {
    const uint8Array = new Uint8Array(a3.buffer);
    return bytesToHex5(uint8Array);
  }
);
var EncryptedKeyshareCodec = type2({
  salt: Uint8ArrayCodec,
  encryptedPayload: Uint8ArrayCodec
});
function buildMessageSchema(messageType, version11, additionalFields = {}, ...additionalSchemas) {
  const schema = type2({
    type: literal2(messageType),
    version: literal2(version11),
    ...additionalFields
  });
  if (additionalSchemas.length === 0) {
    return schema;
  }
  if (additionalSchemas.length === 1) {
    return intersection3([
      schema,
      additionalSchemas[0]
    ]);
  }
  let result = intersection3([
    schema,
    additionalSchemas[0]
  ]);
  for (let i4 = 1; i4 < additionalSchemas.length; i4++) {
    result = intersection3([
      result,
      additionalSchemas[i4]
    ]);
  }
  return result;
}
__name(buildMessageSchema, "buildMessageSchema");
function createComplexEncoder(messageType, version11, fieldTransforms = {}) {
  return (data) => {
    const encoded = {
      type: messageType,
      version: version11
    };
    for (const [key, value] of Object.entries(data)) {
      if (value !== void 0) {
        encoded[key] = fieldTransforms[key] ? fieldTransforms[key](value) : value;
      }
    }
    return encoded;
  };
}
__name(createComplexEncoder, "createComplexEncoder");
function createStandardDecoder(fieldExtractor) {
  return (decoded) => fieldExtractor(decoded);
}
__name(createStandardDecoder, "createStandardDecoder");
function createStandardMessage(config) {
  var _a21;
  let StandardMessageClass = (_a21 = class extends BaseMessage {
    constructor(data) {
      super(data);
      __publicField(this, "type", config.messageType);
      __publicField(this, "version", config.version);
    }
    encode() {
      return config.encodeData(this.data, this.type, this.version);
    }
    static decode(wireData) {
      const result = config.schema.decode(wireData);
      if (Either_exports.isLeft(result)) {
        return result;
      }
      const decoded = result.right;
      return {
        _tag: "Right",
        right: new _a21(config.decodeData(decoded))
      };
    }
  }, __name(_a21, "StandardMessageClass"), __publicField(_a21, "MESSAGE_TYPE", config.messageType), __publicField(_a21, "MESSAGE_VERSION", config.version), __publicField(_a21, "schema", config.schema), _a21);
  return StandardMessageClass;
}
__name(createStandardMessage, "createStandardMessage");
function createSimpleMessage(config) {
  return createStandardMessage({
    messageType: config.messageType,
    version: config.version,
    schema: config.schema,
    encodeData: __name((data) => ({
      type: config.messageType,
      version: config.version,
      ...data
    }), "encodeData"),
    decodeData: __name((decoded) => {
      const { type: type7, version: version11, ...data } = decoded;
      return data;
    }, "decodeData")
  });
}
__name(createSimpleMessage, "createSimpleMessage");
var HandshakeRequestSchema = buildMessageSchema("handshake", 1, {
  challenge: Uint8ArrayCodec,
  nonce: Uint8ArrayCodec
});
var HandshakeV1RequestMessage = createStandardMessage({
  messageType: "handshake",
  version: 1,
  schema: HandshakeRequestSchema,
  encodeData: __name((data) => HandshakeRequestSchema.encode({
    type: "handshake",
    version: 1,
    challenge: data.challenge,
    nonce: data.nonce
  }), "encodeData"),
  decodeData: createStandardDecoder((decoded) => ({
    challenge: decoded.challenge,
    nonce: decoded.nonce
  }))
});
var HandshakeResponseSchema = buildMessageSchema("handshake_response", 1, {
  encapsulatedSharedSecret: string3,
  attestationDoc: string3,
  connectionId: string3
});
var HandshakeV1ResponseMessage = createSimpleMessage({
  messageType: "handshake_response",
  version: 1,
  schema: HandshakeResponseSchema
});
var _a4;
var BaseSigningAlgorithm = (_a4 = class {
}, __name(_a4, "BaseSigningAlgorithm"), _a4);
var _a5;
var Ed25519SigningAlgorithm = (_a5 = class extends BaseSigningAlgorithm {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "ed25519");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type2({
        signingAlgo: literal2("ed25519")
      }),
      partial({
        derivationPath: Uint32ArrayCodec
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: new Uint8Array(32)
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name(_a5, "Ed25519SigningAlgorithm"), _a5);
var _a6;
var BIP340SigningAlgorithm = (_a6 = class extends BaseSigningAlgorithm {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "bip340");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type2({
        signingAlgo: literal2("bip340")
      }),
      partial({
        derivationPath: Uint32ArrayCodec,
        tweak: Uint8ArrayCodec
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: new Uint8Array(32)
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name(_a6, "BIP340SigningAlgorithm"), _a6);
var _a7;
var EcdsaSigningAlgorithm = (_a7 = class extends BaseSigningAlgorithm {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "ecdsa");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type2({
        signingAlgo: literal2("ecdsa")
      }),
      partial({
        hashAlgo: union6([
          literal2("sha256"),
          literal2("sha256d"),
          literal2("keccak256")
        ]),
        derivationPath: Uint32ArrayCodec
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: {
        pubKeyAsHex: __name(() => "0x" + "00".repeat(33), "pubKeyAsHex"),
        serializeCompressed: __name(() => new Uint8Array(33), "serializeCompressed"),
        serializeUncompressed: __name(() => new Uint8Array(65), "serializeUncompressed")
      }
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name(_a7, "EcdsaSigningAlgorithm"), _a7);
var SIGNING_ALGORITHM_CLASSES = {
  ed25519: Ed25519SigningAlgorithm,
  bip340: BIP340SigningAlgorithm,
  ecdsa: EcdsaSigningAlgorithm
};
var ALL_SIGNING_ALGORITHM_NAMES = Object.keys(SIGNING_ALGORITHM_CLASSES);
var SIGNING_ALGORITHM_INSTANCES = {
  ed25519: new SIGNING_ALGORITHM_CLASSES.ed25519(),
  bip340: new SIGNING_ALGORITHM_CLASSES.bip340(),
  ecdsa: new SIGNING_ALGORITHM_CLASSES.ecdsa()
};
var ALL_SIGNING_ALGORITHM_SCHEMA = (() => {
  const schemas = Object.values(SIGNING_ALGORITHM_INSTANCES).map((instance2) => instance2.schema);
  if (schemas.length === 0) {
    throw new Error("No signing algorithms defined");
  }
  if (schemas.length === 1) {
    return schemas[0];
  }
  return union6([
    schemas[0],
    schemas[1],
    ...schemas.slice(2)
  ]);
})();
function isValidSigningAlgorithm(name2) {
  return name2 in SIGNING_ALGORITHM_CLASSES;
}
__name(isValidSigningAlgorithm, "isValidSigningAlgorithm");
function createKeygenResultFromSecretShare(algorithmName, secretShare) {
  const algorithm = SIGNING_ALGORITHM_INSTANCES[algorithmName];
  if (!algorithm) {
    throw new Error(`Unknown signing algorithm: ${algorithmName}`);
  }
  return algorithm.createKeygenResultFromSecretShare(secretShare);
}
__name(createKeygenResultFromSecretShare, "createKeygenResultFromSecretShare");
var ALGORITHMS = {
  [SigningAlgorithm.ECDSA]: {
    name: "ecdsa",
    dynamicEnum: SigningAlgorithm.ECDSA,
    className: "Ecdsa",
    requiresHashAlgo: true,
    supportsDerivationPath: true,
    supportsTweak: false,
    supportedHashAlgos: [
      "sha256",
      "sha256d",
      "keccak256"
    ]
  },
  [SigningAlgorithm.ED25519]: {
    name: "ed25519",
    dynamicEnum: SigningAlgorithm.ED25519,
    className: "Ed25519",
    requiresHashAlgo: false,
    supportsDerivationPath: true,
    supportsTweak: false,
    supportedHashAlgos: []
  },
  [SigningAlgorithm.BIP340]: {
    name: "bip340",
    dynamicEnum: SigningAlgorithm.BIP340,
    className: "BIP340",
    requiresHashAlgo: false,
    supportsDerivationPath: true,
    supportsTweak: true,
    supportedHashAlgos: []
  }
};
function toDynamicSigningAlgorithm(algorithmName) {
  const algorithmConfig = Object.values(ALGORITHMS).find((config) => config.name === algorithmName);
  if (!algorithmConfig) {
    throw new Error(`Unknown algorithm: ${algorithmName}`);
  }
  return algorithmConfig.dynamicEnum;
}
__name(toDynamicSigningAlgorithm, "toDynamicSigningAlgorithm");
function fromDynamicSigningAlgorithm(dynamicAlgorithm) {
  const algorithmConfig = ALGORITHMS[dynamicAlgorithm];
  if (!algorithmConfig) {
    throw new Error(`Unknown Dynamic SDK algorithm: ${dynamicAlgorithm}`);
  }
  return algorithmConfig.name;
}
__name(fromDynamicSigningAlgorithm, "fromDynamicSigningAlgorithm");
var SignatureAlgoSchema = ALL_SIGNING_ALGORITHM_SCHEMA;
var DomainCodec = new Type("DomainCodec", (u2) => typeof u2 === "string", (u2, c6) => {
  if (typeof u2 !== "string") {
    return failure(u2, c6, "Value must be a string");
  }
  const domainPattern = /^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(?::\d{1,5})?$/;
  if (!domainPattern.test(u2)) {
    return failure(u2, c6, "Invalid domain format");
  }
  return success(u2);
}, identity4);
var Uint8ArrayOrHexCodec = new Type(
  "Uint8ArrayOrHex",
  (u2) => u2 instanceof Uint8Array,
  (u2, c6) => {
    if (u2 instanceof Uint8Array) {
      return success(u2);
    }
    if (typeof u2 !== "string") {
      return failure(u2, c6, "Expected a hex string or Uint8Array");
    }
    try {
      const cleanHex = u2.startsWith("0x") ? u2.slice(2) : u2;
      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {
        return failure(u2, c6, "Invalid hex string format");
      }
      const decoded = hexToBytes5(cleanHex);
      return success(decoded);
    } catch (e2) {
      return failure(u2, c6, `Invalid hex string: ${e2}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a3) => {
    if (typeof a3 === "string") {
      return a3;
    }
    return bytesToHex5(a3);
  }
);
var SignMessageRequestSchema = buildMessageSchema("signMessage", 1, {
  relayDomain: DomainCodec,
  keyshare: EncryptedKeyshareCodec,
  message: Uint8ArrayOrHexCodec,
  roomUuid: string3
}, SignatureAlgoSchema);
var SignMessageV1RequestMessage = createStandardMessage({
  messageType: "signMessage",
  version: 1,
  schema: SignMessageRequestSchema,
  encodeData: createComplexEncoder("signMessage", 1, {
    signingAlgo: __name((value) => fromDynamicSigningAlgorithm(value), "signingAlgo"),
    derivationPath: __name((value) => Uint32ArrayCodec.encode(value), "derivationPath"),
    tweak: __name((value) => Uint8ArrayCodec.encode(value), "tweak"),
    keyshare: __name((value) => EncryptedKeyshareCodec.encode(value), "keyshare"),
    message: __name((value) => Uint8ArrayOrHexCodec.encode(value), "message")
  }),
  decodeData: createStandardDecoder((decoded) => ({
    relayDomain: decoded.relayDomain,
    signingAlgo: decoded.signingAlgo,
    hashAlgo: decoded.hashAlgo,
    derivationPath: decoded.derivationPath,
    tweak: decoded.tweak,
    keyshare: decoded.keyshare,
    message: decoded.message,
    roomUuid: decoded.roomUuid
  }))
});
var WebSocketErrorTypeCodec = string3;
var WebSocketErrorCodec = type2({
  type: WebSocketErrorTypeCodec,
  message: string3,
  details: union6([
    unknown2,
    undefinedType
  ])
});
var SignMessageResponseSchema = buildMessageSchema("signMessage_response", 1, {
  signature: union6([
    Uint8ArrayOrHexCodec,
    undefinedType
  ]),
  error: union6([
    WebSocketErrorCodec,
    undefinedType
  ])
});
var SignMessageV1ResponseMessage = createStandardMessage({
  messageType: "signMessage_response",
  version: 1,
  schema: SignMessageResponseSchema,
  encodeData: createComplexEncoder("signMessage_response", 1, {
    signature: __name((value) => Uint8ArrayOrHexCodec.encode(value), "signature")
  }),
  decodeData: createStandardDecoder((decoded) => ({
    signature: decoded.signature,
    error: decoded.error
  }))
});
var ConnectionAckRequestSchema = buildMessageSchema("connection_ack", 1, {
  connectionId: union6([
    string3,
    undefinedType
  ])
});
var ConnectionAckV1RequestMessage = createSimpleMessage({
  messageType: "connection_ack",
  version: 1,
  schema: ConnectionAckRequestSchema
});
var ConnectionAckResponseSchema = buildMessageSchema("connection_ack_response", 1, {
  status: literal2("acknowledged"),
  timestamp: string3
});
var ConnectionAckV1ResponseMessage = createSimpleMessage({
  messageType: "connection_ack_response",
  version: 1,
  schema: ConnectionAckResponseSchema
});
var ALL_MESSAGE_CLASSES = {
  "handshake@1": HandshakeV1RequestMessage,
  "handshake_response@1": HandshakeV1ResponseMessage,
  "signMessage@1": SignMessageV1RequestMessage,
  "signMessage_response@1": SignMessageV1ResponseMessage,
  "connection_ack@1": ConnectionAckV1RequestMessage,
  "connection_ack_response@1": ConnectionAckV1ResponseMessage
};
var ALL_MESSAGE_KEYS = Object.keys(ALL_MESSAGE_CLASSES);
function getMessageClass(type7, version11) {
  const key = `${type7}@${version11}`;
  const MessageClass = ALL_MESSAGE_CLASSES[key];
  if (!MessageClass) {
    throw new Error(`Unknown message type: ${type7} version ${version11}`);
  }
  return MessageClass;
}
__name(getMessageClass, "getMessageClass");
function isValidMessageType(type7, version11) {
  const key = `${type7}@${version11}`;
  return key in ALL_MESSAGE_CLASSES;
}
__name(isValidMessageType, "isValidMessageType");
function getAllSupportedMessages() {
  return ALL_MESSAGE_KEYS.map((key) => {
    const [type7, versionStr] = key.split("@");
    return {
      type: type7,
      version: parseInt(versionStr, 10)
    };
  });
}
__name(getAllSupportedMessages, "getAllSupportedMessages");
function parseMessageKey(key) {
  const [type7, versionStr] = key.split("@");
  return {
    type: type7,
    version: parseInt(versionStr, 10)
  };
}
__name(parseMessageKey, "parseMessageKey");
var _a8;
var MessageRegistry = (_a8 = class {
  constructor() {
  }
  static getInstance() {
    if (!_a8.instance) {
      _a8.instance = new _a8();
    }
    return _a8.instance;
  }
  /**
  * Get a message class by type and version (derived from single source)
  */
  getMessageClass(type7, version11) {
    try {
      return getMessageClass(type7, version11);
    } catch {
      return void 0;
    }
  }
  /**
  * Create a message instance from wire data (using derived message classes)
  */
  decode(wireData) {
    if (!wireData || typeof wireData !== "object") {
      return {
        _tag: "Left",
        left: "Invalid wire data: must be an object"
      };
    }
    const { type: type7, version: version11 } = wireData;
    if (!type7 || !version11) {
      return {
        _tag: "Left",
        left: "Invalid wire data: missing type or version"
      };
    }
    const MessageClass = this.getMessageClass(type7, version11);
    if (!MessageClass) {
      return {
        _tag: "Left",
        left: `Unknown message type: ${type7}@${version11}`
      };
    }
    const result = MessageClass.decode(wireData);
    if (Either_exports.isLeft(result)) {
      return {
        _tag: "Left",
        left: `Decode error: ${result.left.map((e2) => e2.message).join(", ")}`
      };
    }
    return {
      _tag: "Right",
      right: result.right
    };
  }
  /**
  * Encode a message to wire format
  */
  encode(message) {
    return message.encode();
  }
  /**
  * Get all registered message types (derived from single source)
  */
  getRegisteredTypes() {
    return getAllSupportedMessages().map(({ type: type7, version: version11 }) => `${type7}@${version11}`);
  }
}, __name(_a8, "MessageRegistry"), __publicField(_a8, "instance"), _a8);
var messageRegistry = MessageRegistry.getInstance();
function assertDefined(value, message) {
  if (value === null || value === void 0) {
    throw new Error(message ?? "Value must be defined");
  }
}
__name(assertDefined, "assertDefined");
function assertNotNull(value, message) {
  if (value === null) {
    throw new Error(message ?? "Value must not be null");
  }
}
__name(assertNotNull, "assertNotNull");
function getDefined(value, message) {
  assertDefined(value, message);
  return value;
}
__name(getDefined, "getDefined");
var generateMlKem768Keypair = __name(() => {
  try {
    const keys4 = ml_kem768.keygen();
    assertNotNull(keys4.publicKey, "Encapsulation key must be defined");
    assertNotNull(keys4.secretKey, "Decapsulation key must be defined");
    return {
      encapsulationKey: keys4.publicKey,
      decapsulationKey: keys4.secretKey
    };
  } catch (error) {
    throw new Error(`Failed to generate ML-KEM-768 keypair: ${error instanceof Error ? error.message : String(error)}`);
  }
}, "generateMlKem768Keypair");
var encapsulateMlKem768 = __name((encapsulationKey) => {
  return ml_kem768.encapsulate(encapsulationKey);
}, "encapsulateMlKem768");
var decapsulateMlKem768 = __name((decapsulationKey, cipherText) => {
  return ml_kem768.decapsulate(cipherText, decapsulationKey);
}, "decapsulateMlKem768");
var AES_256_GCM_KEY_SIZE = 32;
function deriveAESKey(sharedSecret, salt, info) {
  const infoBytes = new TextEncoder().encode(info);
  return hkdf(sha2567, sharedSecret, salt, infoBytes, AES_256_GCM_KEY_SIZE);
}
__name(deriveAESKey, "deriveAESKey");
function createKeyDerivationInfo(purpose, connectionId, version11 = 1) {
  return `forward-mpc-${purpose}-v${version11}-${connectionId}`;
}
__name(createKeyDerivationInfo, "createKeyDerivationInfo");
async function encryptKeyshare(keyshare, sharedSecret, connectionId, signingAlgorithm) {
  const salt = randomBytes3(32);
  const keyshareInfo = createKeyDerivationInfo("keyshare", connectionId);
  const aesKey = deriveAESKey(sharedSecret, salt, keyshareInfo);
  const keyshareData = {
    keyshare,
    signingAlgorithm,
    timestamp: Date.now(),
    nonce: bytesToHex5(randomBytes3(16))
  };
  const nonce = randomBytes3(12);
  const aes256Gcm = gcm(aesKey, nonce);
  const plaintext = new TextEncoder().encode(JSON.stringify(keyshareData));
  const ciphertext = aes256Gcm.encrypt(plaintext);
  const encryptedPayload = new Uint8Array(nonce.length + ciphertext.length);
  encryptedPayload.set(nonce, 0);
  encryptedPayload.set(ciphertext, nonce.length);
  aesKey.fill(0);
  return {
    salt,
    encryptedPayload
  };
}
__name(encryptKeyshare, "encryptKeyshare");
var _a9;
var SigningAlgorithmRegistry = (_a9 = class {
  /**
  * Get algorithm instance (derived from single source of truth)
  */
  get(name2) {
    const algorithm = SIGNING_ALGORITHM_INSTANCES[name2];
    if (!algorithm) {
      throw new Error(`Unknown signing algorithm: ${name2}`);
    }
    return algorithm;
  }
  /**
  * Type-safe check if algorithm exists
  */
  has(name2) {
    return isValidSigningAlgorithm(name2);
  }
  /**
  * Get all algorithm names (derived from classes)
  */
  getAllNames() {
    return ALL_SIGNING_ALGORITHM_NAMES;
  }
  /**
  * Get all algorithm instances (derived from classes)
  */
  getAllInstances() {
    return SIGNING_ALGORITHM_INSTANCES;
  }
}, __name(_a9, "SigningAlgorithmRegistry"), _a9);
var signingAlgorithmRegistry = new SigningAlgorithmRegistry();

// node_modules/@evervault/wasm-attestation-bindings/index.js
var wasm;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset5 = 0;
  for (; offset5 < len; offset5++) {
    const code2 = arg.charCodeAt(offset5);
    if (code2 > 127) break;
    mem[ptr + offset5] = code2;
  }
  if (offset5 !== len) {
    if (offset5 !== 0) {
      arg = arg.slice(offset5);
    }
    ptr = realloc(ptr, len, len = offset5 + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset5, ptr + len);
    const ret = encodeString(arg, view);
    offset5 += ret.written;
    ptr = realloc(ptr, len, offset5, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset5;
  return ptr;
}
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function isLikeNone(x5) {
  return x5 === void 0 || x5 === null;
}
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_3.set(idx, obj);
  return idx;
}
function passArrayJsValueToWasm0(array2, malloc) {
  const ptr = malloc(array2.length * 4, 4) >>> 0;
  for (let i4 = 0; i4 < array2.length; i4++) {
    const add4 = addToExternrefTable0(array2[i4]);
    getDataViewMemory0().setUint32(ptr + 4 * i4, add4, true);
  }
  WASM_VECTOR_LEN = array2.length;
  return ptr;
}
function validateAttestationDocPcrs(attestation_doc, expected_pcrs_list) {
  const ptr0 = passStringToWasm0(attestation_doc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passArrayJsValueToWasm0(expected_pcrs_list, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.validateAttestationDocPcrs(ptr0, len0, ptr1, len1);
  return ret !== 0;
}
function takeFromExternrefTable0(idx) {
  const value = wasm.__wbindgen_export_3.get(idx);
  wasm.__externref_table_dealloc(idx);
  return value;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function getUserData(attestation_doc) {
  const ptr0 = passStringToWasm0(attestation_doc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getUserData(ptr0, len0);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  let v22;
  if (ret[0] !== 0) {
    v22 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  }
  return v22;
}
function getNonce(attestation_doc) {
  const ptr0 = passStringToWasm0(attestation_doc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getNonce(ptr0, len0);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  let v22;
  if (ret[0] !== 0) {
    v22 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  }
  return v22;
}
var PCRsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_pcrs_free(ptr >>> 0, 1));
var PCRs = class _PCRs {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_PCRs.prototype);
    obj.__wbg_ptr = ptr;
    PCRsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  static __unwrap(jsValue) {
    if (!(jsValue instanceof _PCRs)) {
      return 0;
    }
    return jsValue.__destroy_into_raw();
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PCRsFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_pcrs_free(ptr, 0);
  }
  /**
   * @returns {string | undefined}
   */
  get hashAlgorithm() {
    const ret = wasm.__wbg_get_pcrs_hashAlgorithm(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set hashAlgorithm(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_hashAlgorithm(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr0() {
    const ret = wasm.__wbg_get_pcrs_pcr0(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr0(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr0(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr1() {
    const ret = wasm.__wbg_get_pcrs_pcr1(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr1(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr1(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr2() {
    const ret = wasm.__wbg_get_pcrs_pcr2(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr2(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr2(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr8() {
    const ret = wasm.__wbg_get_pcrs_pcr8(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr8(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr8(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @param {string | null} [pcr_0]
   * @param {string | null} [pcr_1]
   * @param {string | null} [pcr_2]
   * @param {string | null} [pcr_8]
   * @param {string | null} [hash_algorithm]
   */
  constructor(pcr_0, pcr_1, pcr_2, pcr_8, hash_algorithm) {
    var ptr0 = isLikeNone(pcr_0) ? 0 : passStringToWasm0(pcr_0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = isLikeNone(pcr_1) ? 0 : passStringToWasm0(pcr_1, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(pcr_2) ? 0 : passStringToWasm0(pcr_2, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(pcr_8) ? 0 : passStringToWasm0(pcr_8, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    var ptr4 = isLikeNone(hash_algorithm) ? 0 : passStringToWasm0(hash_algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len4 = WASM_VECTOR_LEN;
    const ret = wasm.pcrs_new(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);
    this.__wbg_ptr = ret >>> 0;
    PCRsFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * Helper to create an empty PCR container, to support setting the PCRs explicitly
   * ```js
   * const pcrs = PCRs.empty();
   * pcrs.pcr0 = "...";
   * pcrs.pcr8 = "...";
   * ```
   * @returns {PCRs}
   */
  static empty() {
    const ret = wasm.pcrs_empty();
    return _PCRs.__wrap(ret);
  }
};
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e2) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e2);
        } else {
          throw e2;
        }
      }
    }
    const bytes2 = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance2 = await WebAssembly.instantiate(module, imports);
    if (instance2 instanceof WebAssembly.Instance) {
      return { instance: instance2, module };
    } else {
      return instance2;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_error_40b1c155aa56d80b = function(arg0, arg1) {
    console.error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    const ret = new Error();
    return ret;
  };
  imports.wbg.__wbg_now_b8ba7a2a6289a15e = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_pcrs_unwrap = function(arg0) {
    const ret = PCRs.__unwrap(arg0);
    return ret;
  };
  imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
    const ret = arg1.stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_export_3;
    const offset5 = table.grow(4);
    table.set(0, void 0);
    table.set(offset5 + 0, void 0);
    table.set(offset5 + 1, null);
    table.set(offset5 + 2, true);
    table.set(offset5 + 3, false);
    ;
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_init_memory(imports, memory2) {
}
function __wbg_finalize_init(instance2, module) {
  wasm = instance2.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("index_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  __wbg_init_memory(imports);
  const { instance: instance2, module } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance2, module);
}
var wasm_attestation_bindings_default = __wbg_init;

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/forward-mpc-client/dist/index.js
var __defProp2 = Object.defineProperty;
var __name2 = (target, value) => __defProp2(target, "name", { value, configurable: true });
var ATTESTATION_CONSTANTS = {
  // Maximum age of attestation document in milliseconds
  MAX_ATTESTATION_AGE: 5 * 60 * 1e3
};
var _a10;
var NitroAttestationVerifier = (_a10 = class {
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "wasmInitialized", false);
    this.config = {
      strictCertValidation: true,
      maxAge: ATTESTATION_CONSTANTS.MAX_ATTESTATION_AGE,
      ...config
    };
  }
  /**
  * Initialize WASM module if not already initialized
  */
  async ensureWasmInitialized() {
    if (!this.wasmInitialized) {
      try {
        await wasm_attestation_bindings_default();
        this.wasmInitialized = true;
      } catch (error) {
        throw new Error(`Failed to initialize WASM module: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  /**
  * Verify an attestation document using Evervault WASM bindings
  * Accepts base64-encoded attestation document directly
  *
  * @param attestationDocBase64 - Base64-encoded attestation document
  * @param expectedChallenge - Expected challenge (ciphertext hash)
  * @param expectedNonce - Expected nonce (REQUIRED for security)
  */
  async verify(attestationDocBase64, expectedChallenge, expectedNonce) {
    try {
      await this.ensureWasmInitialized();
      const expectedPcrs = PCRs.empty();
      expectedPcrs.pcr8 = this.config.expectedPcr8;
      const isValid = validateAttestationDocPcrs(attestationDocBase64, [
        expectedPcrs
      ]);
      if (!isValid) {
        return {
          valid: false,
          errors: [
            "Attestation document PCR verification failed"
          ],
          timestamp: Date.now()
        };
      }
      if (expectedChallenge) {
        try {
          const userData = getUserData(attestationDocBase64);
          if (!userData) {
            return {
              valid: false,
              errors: [
                "No user data found in attestation document"
              ],
              timestamp: Date.now()
            };
          }
          const userDataString = new TextDecoder("utf-8").decode(userData);
          if (!userDataString.includes(expectedChallenge)) {
            return {
              valid: false,
              errors: [
                "Ciphertext hash verification failed - challenge not found in attestation user data"
              ],
              timestamp: Date.now()
            };
          }
        } catch (error) {
          return {
            valid: false,
            errors: [
              `Failed to extract or verify ciphertext hash: ${error instanceof Error ? error.message : String(error)}`
            ],
            timestamp: Date.now()
          };
        }
      }
      try {
        const extractedNonceRaw = getNonce(attestationDocBase64);
        if (!extractedNonceRaw) {
          return {
            valid: false,
            errors: [
              "No nonce found in attestation document"
            ],
            timestamp: Date.now()
          };
        }
        let extractedNonce;
        try {
          const nonceString = new TextDecoder().decode(extractedNonceRaw);
          if (typeof atob !== "undefined") {
            const binaryString = atob(nonceString);
            extractedNonce = new Uint8Array(binaryString.length);
            for (let i4 = 0; i4 < binaryString.length; i4++) {
              extractedNonce[i4] = binaryString.charCodeAt(i4);
            }
          } else {
            const decodedBuffer = Buffer.from(nonceString, "base64");
            extractedNonce = new Uint8Array(decodedBuffer);
          }
        } catch (decodeError) {
          return {
            valid: false,
            errors: [
              `Failed to decode nonce from base64: ${decodeError instanceof Error ? decodeError.message : String(decodeError)}`
            ],
            timestamp: Date.now()
          };
        }
        if (extractedNonce.length !== expectedNonce.length) {
          return {
            valid: false,
            errors: [
              `Nonce length mismatch: expected ${expectedNonce.length} bytes, got ${extractedNonce.length} bytes`
            ],
            timestamp: Date.now()
          };
        }
        for (let i4 = 0; i4 < expectedNonce.length; i4++) {
          if (extractedNonce[i4] !== expectedNonce[i4]) {
            return {
              valid: false,
              errors: [
                "Nonce verification failed - nonce mismatch"
              ],
              timestamp: Date.now()
            };
          }
        }
      } catch (error) {
        return {
          valid: false,
          errors: [
            `Failed to extract or verify nonce: ${error instanceof Error ? error.message : String(error)}`
          ],
          timestamp: Date.now()
        };
      }
      return {
        valid: true,
        errors: [],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        valid: false,
        errors: [
          `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`
        ],
        timestamp: Date.now()
      };
    }
  }
}, __name2(_a10, "NitroAttestationVerifier"), _a10);
var isWindow = typeof globalThis !== "undefined" && typeof globalThis.window !== "undefined";
var WebSocketImpl = isWindow ? globalThis.WebSocket : ws4.WebSocket;
var _a11;
var ForwardMPCClient = (_a11 = class extends import_index.default {
  constructor(url, options = {}) {
    super();
    __publicField(this, "ws", null);
    __publicField(this, "url");
    __publicField(this, "options");
    __publicField(this, "attestationVerifier", null);
    __publicField(this, "isConnected", false);
    __publicField(this, "messageId", 0);
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "sharedSecret", null);
    __publicField(this, "decapsulationKey", null);
    __publicField(this, "connectionId");
    __publicField(this, "handshakeNonce", null);
    __publicField(this, "attestationPromise", null);
    this.url = url;
    this.connectionId = "";
    this.options = {
      reconnectAttempts: options.reconnectAttempts ?? 3,
      reconnectInterval: options.reconnectInterval ?? 1e3,
      connectionTimeout: options.connectionTimeout ?? 1e4,
      heartbeatInterval: options.heartbeatInterval ?? 3e4,
      attestationConfig: options.attestationConfig,
      attestationVerifier: options.attestationVerifier,
      bypassAttestation: options.bypassAttestation ?? false
    };
    if (options.attestationVerifier) {
      this.attestationVerifier = options.attestationVerifier;
    } else if (this.options.attestationConfig) {
      this.attestationVerifier = new NitroAttestationVerifier(this.options.attestationConfig);
    }
  }
  async connect() {
    return new Promise((resolve, reject) => {
      if (this.isConnected) {
        resolve();
        return;
      }
      const timeout = setTimeout(() => {
        reject(new Error("Connection timeout"));
      }, this.options.connectionTimeout);
      this.ws = new WebSocketImpl(this.url);
      if (isWindow) {
        this.ws.onopen = () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        };
        this.ws.onerror = (_error) => {
          clearTimeout(timeout);
          this.emit("error", new Error("WebSocket error"));
          reject(new Error("WebSocket error"));
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onclose = () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        };
      } else {
        this.ws.on("open", () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        });
        this.ws.on("error", (error) => {
          clearTimeout(timeout);
          this.emit("error", error);
          reject(error);
        });
        this.ws.on("message", (data) => {
          this.handleMessage(data.toString());
        });
        this.ws.on("close", () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        });
      }
    });
  }
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.cleanup();
  }
  cleanup() {
    for (const [, request2] of this.pendingRequests) {
      clearTimeout(request2.timeout);
      request2.reject(new Error("Connection closed"));
    }
    this.pendingRequests.clear();
    if (this.sharedSecret) {
      this.sharedSecret.fill(0);
      this.sharedSecret = null;
    }
    if (this.decapsulationKey) {
      this.decapsulationKey.fill(0);
      this.decapsulationKey = null;
    }
    if (this.handshakeNonce) {
      this.handshakeNonce.fill(0);
      this.handshakeNonce = null;
    }
    this.connectionId = "";
    this.attestationPromise = null;
  }
  /**
  * Ensures the WebSocket connection is active and handshake is completed.
  * Automatically connects and performs handshake if needed.
  * @returns Object containing the shared secret and connection ID
  * @throws Error if connection or handshake fails
  */
  async ensureWsConnection() {
    if (!this.isConnected || !this.ws) {
      await this.connect();
    }
    if (!this.sharedSecret || !this.connectionId) {
      await this.handshake();
    }
    if (this.attestationVerifier && !this.options.bypassAttestation && !this.attestationPromise) {
      throw new Error("Attestation verifier configured but attestation was not performed");
    }
    if (this.attestationPromise) {
      try {
        await this.attestationPromise;
      } catch (error) {
        this.disconnect();
        throw error;
      }
    }
    if (!this.sharedSecret || !this.connectionId) {
      throw new Error("Failed to establish connection and handshake");
    }
    return {
      sharedSecret: this.sharedSecret,
      connectionId: this.connectionId
    };
  }
  handleMessage(data) {
    try {
      const parsed = JSON.parse(data);
      const requestId = parsed.requestId;
      if (requestId) {
        delete parsed.requestId;
      }
      const message = this.deserializeMessage(JSON.stringify(parsed));
      if (requestId && this.pendingRequests.has(requestId)) {
        const request2 = this.pendingRequests.get(requestId);
        this.pendingRequests.delete(requestId);
        clearTimeout(request2.timeout);
        if (message.type === "error") {
          const errorMsg = message;
          request2.reject(new Error(errorMsg.error.message));
        } else if (message.type.endsWith("_response")) {
          const responseData = message.getData ? message.getData() : message;
          if (responseData.error) {
            request2.reject(new Error(responseData.error.message));
          } else {
            request2.resolve(message);
          }
        } else {
          request2.resolve(message);
        }
        return;
      }
      this.emit("message", message);
    } catch (error) {
      this.emit("error", new Error(`Failed to parse message: ${error}`));
    }
  }
  sendRequest(message) {
    return new Promise((resolve, reject) => {
      if (!this.isConnected || !this.ws) {
        reject(new Error("Not connected"));
        return;
      }
      const requestId = `req_${++this.messageId}_${Date.now()}`;
      const messageWithId = message;
      messageWithId.requestId = requestId;
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error("Request timeout"));
      }, 3e4);
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        timeout
      });
      try {
        const serializedMessage = this.serializeMessage(messageWithId);
        this.ws.send(serializedMessage);
      } catch (error) {
        this.pendingRequests.delete(requestId);
        clearTimeout(timeout);
        reject(error);
      }
    });
  }
  serializeMessage(message) {
    try {
      if (message && typeof message.encode === "function") {
        const encoded = message.encode();
        if (message.requestId) {
          encoded.requestId = message.requestId;
        }
        return JSON.stringify(encoded);
      }
      return JSON.stringify(message);
    } catch (error) {
      throw new Error(`Failed to serialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  deserializeMessage(data) {
    try {
      const parsed = JSON.parse(data);
      if (!messageRegistry) {
        throw new Error("messageRegistry is undefined");
      }
      if (typeof messageRegistry.decode !== "function") {
        throw new Error("messageRegistry.decode is not a function");
      }
      const result = messageRegistry.decode(parsed);
      if (Either_exports.isLeft(result)) {
        return parsed;
      }
      return result.right;
    } catch (error) {
      throw new Error(`Failed to deserialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async handshake() {
    const { encapsulationKey, decapsulationKey } = generateMlKem768Keypair();
    this.decapsulationKey = decapsulationKey;
    const nonceBytes = randomBytes3(32);
    this.handshakeNonce = nonceBytes;
    const request2 = new HandshakeV1RequestMessage({
      challenge: encapsulationKey,
      nonce: nonceBytes
    });
    const response = await this.sendRequest(request2);
    const responseData = response.getData();
    if (responseData.encapsulatedSharedSecret && responseData.connectionId && this.decapsulationKey) {
      this.connectionId = responseData.connectionId;
      const cipherText = hexToBytes5(responseData.encapsulatedSharedSecret);
      this.sharedSecret = decapsulateMlKem768(this.decapsulationKey, cipherText);
    }
    if (this.attestationVerifier && responseData.attestationDoc && responseData.encapsulatedSharedSecret && !this.options.bypassAttestation) {
      const cipherText = hexToBytes5(responseData.encapsulatedSharedSecret);
      this.attestationPromise = this.verifyAttestationDocument(responseData.attestationDoc, cipherText);
    }
    return response;
  }
  async signMessage(params) {
    const { sharedSecret, connectionId } = await this.ensureWsConnection();
    let messageToSign;
    if (typeof params.message === "string") {
      const cleanHex = params.message.startsWith("0x") ? params.message.slice(2) : params.message;
      messageToSign = hexToBytes5(cleanHex);
    } else {
      messageToSign = params.message;
    }
    const encryptedKeyshare = await encryptKeyshare(params.keyshare, sharedSecret, connectionId, params.signingAlgo);
    const request2 = new SignMessageV1RequestMessage({
      relayDomain: params.relayDomain,
      signingAlgo: params.signingAlgo,
      hashAlgo: params.hashAlgo,
      derivationPath: params.derivationPath,
      tweak: params.tweak,
      keyshare: encryptedKeyshare,
      message: messageToSign,
      roomUuid: params.roomUuid
    });
    return this.sendRequest(request2);
  }
  get connected() {
    return this.isConnected;
  }
  /**
  * Generate a unique connection ID
  */
  /**
  * Verify attestation document from handshake response
  * Uses base64-encoded attestation document directly
  */
  async verifyAttestationDocument(attestationDocBase64, cipherText) {
    if (!this.attestationVerifier) {
      return;
    }
    try {
      const challengeHash = sha2567(cipherText);
      const expectedChallenge = Array.from(challengeHash).map((b4) => b4.toString(16).padStart(2, "0")).join("");
      if (!this.handshakeNonce) {
        throw new Error("Nonce not found - handshake may not have completed properly");
      }
      const result = await this.attestationVerifier.verify(attestationDocBase64, expectedChallenge, this.handshakeNonce);
      if (!result.valid) {
        const errorMsg = `Attestation verification failed: ${result.errors.join(", ")}`;
        this.emit("error", new Error(errorMsg));
        throw new Error(errorMsg);
      }
      this.emit("message", {
        type: "attestation-verified",
        timestamp: Date.now(),
        data: result
      });
    } catch (error) {
      const errorMsg = `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`;
      this.emit("error", new Error(errorMsg));
      throw new Error(errorMsg);
    }
  }
}, __name2(_a11, "ForwardMPCClient"), _a11);

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/core/index.esm.js
var import_http_errors = __toESM(require_http_errors());
var ENVIRONMENT_ENUM2 = (function(ENVIRONMENT_ENUM4) {
  ENVIRONMENT_ENUM4["development"] = "development";
  ENVIRONMENT_ENUM4["preprod"] = "preprod";
  ENVIRONMENT_ENUM4["production"] = "production";
  return ENVIRONMENT_ENUM4;
})({});
var WalletOperation2 = (function(WalletOperation4) {
  WalletOperation4["REACH_THRESHOLD"] = "REACH_THRESHOLD";
  WalletOperation4["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
  WalletOperation4["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  WalletOperation4["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  WalletOperation4["REFRESH"] = "REFRESH";
  WalletOperation4["RESHARE"] = "RESHARE";
  WalletOperation4["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
  WalletOperation4["NO_OPERATION"] = "NO_OPERATION";
  return WalletOperation4;
})({});
var BackupLocation2 = (function(BackupLocation4) {
  BackupLocation4["DYNAMIC"] = "dynamic";
  BackupLocation4["GOOGLE_DRIVE"] = "googleDrive";
  BackupLocation4["ICLOUD"] = "iCloud";
  BackupLocation4["USER"] = "user";
  BackupLocation4["EXTERNAL"] = "external";
  BackupLocation4["DELEGATED"] = "delegated";
  return BackupLocation4;
})({});
var SigningAlgorithm2 = (function(SigningAlgorithm4) {
  SigningAlgorithm4["ECDSA"] = "ECDSA";
  SigningAlgorithm4["ED25519"] = "ED25519";
  SigningAlgorithm4["BIP340"] = "BIP340";
  return SigningAlgorithm4;
})({});
var BITCOIN_DERIVATION_PATHS2 = {
  LEGACY: [
    44,
    0,
    0,
    0,
    0
  ],
  // m/49'/0'/0'/0/0  - SegWit (P2SH-P2WPKH)
  NATIVE_SEGWIT: [
    84,
    0,
    0,
    0,
    0
  ],
  // m/44'/0'/0'/0/0  - Legacy (P2PKH)
  SEGWIT: [
    49,
    0,
    0,
    0,
    0
  ]
};
var MPC_CHAIN_CONFIG2 = {
  EVM: {
    // Uses secp256k1 ECDSA
    derivationPath: [
      44,
      60,
      0,
      0,
      0
    ],
    signingAlgorithm: "ECDSA"
  },
  SVM: {
    // Uses Ed25519
    derivationPath: [
      44,
      501,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  BTC: {
    // Uses secp256k1 BIP340
    derivationPath: BITCOIN_DERIVATION_PATHS2.NATIVE_SEGWIT,
    signingAlgorithm: "BIP340"
  },
  COSMOS: {
    // Uses Ed25519
    derivationPath: [
      44,
      118,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  FLOW: {
    // Uses Ed25519
    derivationPath: [
      44,
      539,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  SUI: {
    // Uses Ed25519
    derivationPath: [
      44,
      784,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  }
};
var ThresholdSignatureScheme2 = (function(ThresholdSignatureScheme4) {
  ThresholdSignatureScheme4["TWO_OF_TWO"] = "TWO_OF_TWO";
  ThresholdSignatureScheme4["TWO_OF_THREE"] = "TWO_OF_THREE";
  ThresholdSignatureScheme4["THREE_OF_FIVE"] = "THREE_OF_FIVE";
  return ThresholdSignatureScheme4;
})({});
var CreateRoomPartiesOptions2 = (function(CreateRoomPartiesOptions4) {
  CreateRoomPartiesOptions4["THRESHOLD"] = "threshold";
  CreateRoomPartiesOptions4["FULL"] = "full";
  return CreateRoomPartiesOptions4;
})({});
var URL_PATTERNS2 = {
  [ENVIRONMENT_ENUM2.development]: /^http:\/\/localhost:\d+$/,
  [ENVIRONMENT_ENUM2.preprod]: /dynamic-preprod/,
  [ENVIRONMENT_ENUM2.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
var AuthMode2 = (function(AuthMode4) {
  AuthMode4["HEADER"] = "header";
  AuthMode4["COOKIE"] = "cookie";
  return AuthMode4;
})({});
var SuccessEventType2 = (function(SuccessEventType4) {
  SuccessEventType4["KeygenComplete"] = "keygen_complete";
  SuccessEventType4["RoomCreated"] = "room_created";
  SuccessEventType4["CeremonyComplete"] = "ceremony_complete";
  return SuccessEventType4;
})({});

// node_modules/@dynamic-labs-wallet/forward-mpc-shared/dist/index.js
var __defProp3 = Object.defineProperty;
var __name3 = (target, value) => __defProp3(target, "name", { value, configurable: true });
var WebSocketErrorType2 = (function(WebSocketErrorType22) {
  WebSocketErrorType22["INVALID_MESSAGE"] = "INVALID_MESSAGE";
  WebSocketErrorType22["HANDLER_NOT_FOUND"] = "HANDLER_NOT_FOUND";
  WebSocketErrorType22["HANDLER_ERROR"] = "HANDLER_ERROR";
  WebSocketErrorType22["CONNECTION_ERROR"] = "CONNECTION_ERROR";
  WebSocketErrorType22["VALIDATION_ERROR"] = "VALIDATION_ERROR";
  return WebSocketErrorType22;
})({});
var _a12;
var BaseMessage2 = (_a12 = class {
  constructor(data) {
    __publicField(this, "data");
    this.data = data;
  }
  getData() {
    return this.data;
  }
}, __name3(_a12, "BaseMessage"), _a12);
var Uint8ArrayCodec2 = new Type(
  "Uint8Array",
  (u2) => u2 instanceof Uint8Array,
  (u2, c6) => {
    if (typeof u2 !== "string") {
      return failure(u2, c6, "Expected a hex string for Uint8Array");
    }
    try {
      const cleanHex = u2.startsWith("0x") ? u2.slice(2) : u2;
      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {
        return failure(u2, c6, "Invalid hex string format");
      }
      const decoded = hexToBytes5(cleanHex);
      return success(decoded);
    } catch (e2) {
      return failure(u2, c6, `Invalid hex string: ${e2}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a3) => bytesToHex5(a3)
);
var Uint32ArrayCodec2 = new Type(
  "Uint32Array",
  (u2) => u2 instanceof Uint32Array,
  (u2, c6) => {
    if (typeof u2 !== "string") {
      return failure(u2, c6, "Expected a hex string for Uint32Array");
    }
    try {
      const cleanHex = u2.startsWith("0x") ? u2.slice(2) : u2;
      if (cleanHex.length === 0) {
        return failure(u2, c6, "Empty hex string not allowed for Uint32Array");
      }
      if (cleanHex.length % 8 !== 0) {
        return failure(u2, c6, "Invalid hex string format for Uint32Array (must be multiple of 8 hex characters)");
      }
      const uint8Array = hexToBytes5(cleanHex);
      const uint32Array = new Uint32Array(uint8Array.buffer);
      return success(uint32Array);
    } catch (e2) {
      return failure(u2, c6, `Invalid hex string: ${e2}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a3) => {
    const uint8Array = new Uint8Array(a3.buffer);
    return bytesToHex5(uint8Array);
  }
);
var EncryptedKeyshareCodec2 = type2({
  salt: Uint8ArrayCodec2,
  encryptedPayload: Uint8ArrayCodec2
});
var TraceContextSchema = partial({
  traceId: string3,
  startTime: number2
});
var TraceContextCodec = union6([
  TraceContextSchema,
  undefinedType
]);
var OptionalStringCodec = union6([
  string3,
  undefinedType
]);
function buildMessageSchema2(messageType, version11, additionalFields = {}, ...additionalSchemas) {
  const schema = type2({
    type: literal2(messageType),
    version: literal2(version11),
    ...additionalFields
  });
  if (additionalSchemas.length === 0) {
    return schema;
  }
  if (additionalSchemas.length === 1) {
    return intersection3([
      schema,
      additionalSchemas[0]
    ]);
  }
  let result = intersection3([
    schema,
    additionalSchemas[0]
  ]);
  for (let i4 = 1; i4 < additionalSchemas.length; i4++) {
    result = intersection3([
      result,
      additionalSchemas[i4]
    ]);
  }
  return result;
}
__name3(buildMessageSchema2, "buildMessageSchema");
function createComplexEncoder2(messageType, version11, fieldTransforms = {}) {
  return (data) => {
    const encoded = {
      type: messageType,
      version: version11
    };
    for (const [key, value] of Object.entries(data)) {
      if (value !== void 0) {
        encoded[key] = fieldTransforms[key] ? fieldTransforms[key](value) : value;
      }
    }
    return encoded;
  };
}
__name3(createComplexEncoder2, "createComplexEncoder");
function createStandardDecoder2(fieldExtractor) {
  return (decoded) => fieldExtractor(decoded);
}
__name3(createStandardDecoder2, "createStandardDecoder");
function createStandardMessage2(config) {
  var _a21;
  let StandardMessageClass = (_a21 = class extends BaseMessage2 {
    constructor(data) {
      super(data);
      __publicField(this, "type", config.messageType);
      __publicField(this, "version", config.version);
    }
    encode() {
      return config.encodeData(this.data, this.type, this.version);
    }
    static decode(wireData) {
      const result = config.schema.decode(wireData);
      if (Either_exports.isLeft(result)) {
        return result;
      }
      const decoded = result.right;
      return {
        _tag: "Right",
        right: new _a21(config.decodeData(decoded))
      };
    }
  }, __name3(_a21, "StandardMessageClass"), __publicField(_a21, "MESSAGE_TYPE", config.messageType), __publicField(_a21, "MESSAGE_VERSION", config.version), __publicField(_a21, "schema", config.schema), _a21);
  return StandardMessageClass;
}
__name3(createStandardMessage2, "createStandardMessage");
function createSimpleMessage2(config) {
  return createStandardMessage2({
    messageType: config.messageType,
    version: config.version,
    schema: config.schema,
    encodeData: __name3((data) => ({
      type: config.messageType,
      version: config.version,
      ...data
    }), "encodeData"),
    decodeData: __name3((decoded) => {
      const { type: type7, version: version11, ...data } = decoded;
      return data;
    }, "decodeData")
  });
}
__name3(createSimpleMessage2, "createSimpleMessage");
var HandshakeRequestSchema2 = buildMessageSchema2("handshake", 1, {
  challenge: Uint8ArrayCodec2,
  nonce: Uint8ArrayCodec2,
  traceContext: TraceContextCodec
});
var HandshakeV1RequestMessage2 = createStandardMessage2({
  messageType: "handshake",
  version: 1,
  schema: HandshakeRequestSchema2,
  encodeData: __name3((data) => HandshakeRequestSchema2.encode({
    type: "handshake",
    version: 1,
    challenge: data.challenge,
    nonce: data.nonce,
    traceContext: data.traceContext
  }), "encodeData"),
  decodeData: createStandardDecoder2((decoded) => ({
    challenge: decoded.challenge,
    nonce: decoded.nonce,
    traceContext: decoded.traceContext
  }))
});
var HandshakeResponseSchema2 = buildMessageSchema2("handshake_response", 1, {
  encapsulatedSharedSecret: string3,
  attestationDoc: string3,
  connectionId: string3
});
var HandshakeV1ResponseMessage2 = createSimpleMessage2({
  messageType: "handshake_response",
  version: 1,
  schema: HandshakeResponseSchema2
});
var _a13;
var BaseSigningAlgorithm2 = (_a13 = class {
}, __name3(_a13, "BaseSigningAlgorithm"), _a13);
var _a14;
var Ed25519SigningAlgorithm2 = (_a14 = class extends BaseSigningAlgorithm2 {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "ed25519");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type2({
        signingAlgo: literal2("ed25519")
      }),
      partial({
        derivationPath: Uint32ArrayCodec2
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: new Uint8Array(32)
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name3(_a14, "Ed25519SigningAlgorithm"), _a14);
var _a15;
var BIP340SigningAlgorithm2 = (_a15 = class extends BaseSigningAlgorithm2 {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "bip340");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type2({
        signingAlgo: literal2("bip340")
      }),
      partial({
        derivationPath: Uint32ArrayCodec2,
        tweak: Uint8ArrayCodec2
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: new Uint8Array(32)
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name3(_a15, "BIP340SigningAlgorithm"), _a15);
var _a16;
var EcdsaSigningAlgorithm2 = (_a16 = class extends BaseSigningAlgorithm2 {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "ecdsa");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type2({
        signingAlgo: literal2("ecdsa")
      }),
      partial({
        hashAlgo: union6([
          literal2("sha256"),
          literal2("sha256d"),
          literal2("keccak256")
        ]),
        derivationPath: Uint32ArrayCodec2
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: {
        pubKeyAsHex: __name3(() => "0x" + "00".repeat(33), "pubKeyAsHex"),
        serializeCompressed: __name3(() => new Uint8Array(33), "serializeCompressed"),
        serializeUncompressed: __name3(() => new Uint8Array(65), "serializeUncompressed")
      }
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name3(_a16, "EcdsaSigningAlgorithm"), _a16);
var SIGNING_ALGORITHM_CLASSES2 = {
  ed25519: Ed25519SigningAlgorithm2,
  bip340: BIP340SigningAlgorithm2,
  ecdsa: EcdsaSigningAlgorithm2
};
var ALL_SIGNING_ALGORITHM_NAMES2 = Object.keys(SIGNING_ALGORITHM_CLASSES2);
var SIGNING_ALGORITHM_INSTANCES2 = {
  ed25519: new SIGNING_ALGORITHM_CLASSES2.ed25519(),
  bip340: new SIGNING_ALGORITHM_CLASSES2.bip340(),
  ecdsa: new SIGNING_ALGORITHM_CLASSES2.ecdsa()
};
var ALL_SIGNING_ALGORITHM_SCHEMA2 = (() => {
  const schemas = Object.values(SIGNING_ALGORITHM_INSTANCES2).map((instance2) => instance2.schema);
  if (schemas.length === 0) {
    throw new Error("No signing algorithms defined");
  }
  if (schemas.length === 1) {
    return schemas[0];
  }
  return union6([
    schemas[0],
    schemas[1],
    ...schemas.slice(2)
  ]);
})();
function isValidSigningAlgorithm2(name2) {
  return name2 in SIGNING_ALGORITHM_CLASSES2;
}
__name3(isValidSigningAlgorithm2, "isValidSigningAlgorithm");
function createKeygenResultFromSecretShare2(algorithmName, secretShare) {
  const algorithm = SIGNING_ALGORITHM_INSTANCES2[algorithmName];
  if (!algorithm) {
    throw new Error(`Unknown signing algorithm: ${algorithmName}`);
  }
  return algorithm.createKeygenResultFromSecretShare(secretShare);
}
__name3(createKeygenResultFromSecretShare2, "createKeygenResultFromSecretShare");
var ALGORITHMS2 = {
  [SigningAlgorithm2.ECDSA]: {
    name: "ecdsa",
    dynamicEnum: SigningAlgorithm2.ECDSA,
    className: "Ecdsa",
    requiresHashAlgo: true,
    supportsDerivationPath: true,
    supportsTweak: false,
    supportedHashAlgos: [
      "sha256",
      "sha256d",
      "keccak256"
    ]
  },
  [SigningAlgorithm2.ED25519]: {
    name: "ed25519",
    dynamicEnum: SigningAlgorithm2.ED25519,
    className: "Ed25519",
    requiresHashAlgo: false,
    supportsDerivationPath: true,
    supportsTweak: false,
    supportedHashAlgos: []
  },
  [SigningAlgorithm2.BIP340]: {
    name: "bip340",
    dynamicEnum: SigningAlgorithm2.BIP340,
    className: "BIP340",
    requiresHashAlgo: false,
    supportsDerivationPath: true,
    supportsTweak: true,
    supportedHashAlgos: []
  }
};
function toDynamicSigningAlgorithm2(algorithmName) {
  const algorithmConfig = Object.values(ALGORITHMS2).find((config) => config.name === algorithmName);
  if (!algorithmConfig) {
    throw new Error(`Unknown algorithm: ${algorithmName}`);
  }
  return algorithmConfig.dynamicEnum;
}
__name3(toDynamicSigningAlgorithm2, "toDynamicSigningAlgorithm");
function fromDynamicSigningAlgorithm2(dynamicAlgorithm) {
  const algorithmConfig = ALGORITHMS2[dynamicAlgorithm];
  if (!algorithmConfig) {
    throw new Error(`Unknown Dynamic SDK algorithm: ${dynamicAlgorithm}`);
  }
  return algorithmConfig.name;
}
__name3(fromDynamicSigningAlgorithm2, "fromDynamicSigningAlgorithm");
var SignatureAlgoSchema2 = ALL_SIGNING_ALGORITHM_SCHEMA2;
var DomainCodec2 = new Type("DomainCodec", (u2) => typeof u2 === "string", (u2, c6) => {
  if (typeof u2 !== "string") {
    return failure(u2, c6, "Value must be a string");
  }
  const domainPattern = /^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(?::\d{1,5})?$/;
  if (!domainPattern.test(u2)) {
    return failure(u2, c6, "Invalid domain format");
  }
  return success(u2);
}, identity4);
var Uint8ArrayOrHexCodec2 = new Type(
  "Uint8ArrayOrHex",
  (u2) => u2 instanceof Uint8Array,
  (u2, c6) => {
    if (u2 instanceof Uint8Array) {
      return success(u2);
    }
    if (typeof u2 !== "string") {
      return failure(u2, c6, "Expected a hex string or Uint8Array");
    }
    try {
      const cleanHex = u2.startsWith("0x") ? u2.slice(2) : u2;
      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {
        return failure(u2, c6, "Invalid hex string format");
      }
      const decoded = hexToBytes5(cleanHex);
      return success(decoded);
    } catch (e2) {
      return failure(u2, c6, `Invalid hex string: ${e2}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a3) => {
    if (typeof a3 === "string") {
      return a3;
    }
    return bytesToHex5(a3);
  }
);
var SignMessageRequestSchema2 = buildMessageSchema2("signMessage", 1, {
  relayDomain: DomainCodec2,
  keyshare: EncryptedKeyshareCodec2,
  message: Uint8ArrayOrHexCodec2,
  roomUuid: string3,
  userId: OptionalStringCodec,
  environmentId: OptionalStringCodec,
  traceContext: TraceContextCodec
}, SignatureAlgoSchema2);
var SignMessageV1RequestMessage2 = createStandardMessage2({
  messageType: "signMessage",
  version: 1,
  schema: SignMessageRequestSchema2,
  encodeData: createComplexEncoder2("signMessage", 1, {
    signingAlgo: __name3((value) => fromDynamicSigningAlgorithm2(value), "signingAlgo"),
    derivationPath: __name3((value) => Uint32ArrayCodec2.encode(value), "derivationPath"),
    tweak: __name3((value) => Uint8ArrayCodec2.encode(value), "tweak"),
    keyshare: __name3((value) => EncryptedKeyshareCodec2.encode(value), "keyshare"),
    message: __name3((value) => Uint8ArrayOrHexCodec2.encode(value), "message")
  }),
  decodeData: createStandardDecoder2((decoded) => ({
    relayDomain: decoded.relayDomain,
    signingAlgo: decoded.signingAlgo,
    hashAlgo: decoded.hashAlgo,
    derivationPath: decoded.derivationPath,
    tweak: decoded.tweak,
    keyshare: decoded.keyshare,
    message: decoded.message,
    roomUuid: decoded.roomUuid,
    userId: decoded.userId,
    environmentId: decoded.environmentId,
    traceContext: decoded.traceContext
  }))
});
var WebSocketErrorTypeCodec2 = string3;
var WebSocketErrorCodec2 = type2({
  type: WebSocketErrorTypeCodec2,
  message: string3,
  details: union6([
    unknown2,
    undefinedType
  ])
});
var SignMessageResponseSchema2 = buildMessageSchema2("signMessage_response", 1, {
  signature: union6([
    Uint8ArrayOrHexCodec2,
    undefinedType
  ]),
  error: union6([
    WebSocketErrorCodec2,
    undefinedType
  ])
});
var SignMessageV1ResponseMessage2 = createStandardMessage2({
  messageType: "signMessage_response",
  version: 1,
  schema: SignMessageResponseSchema2,
  encodeData: createComplexEncoder2("signMessage_response", 1, {
    signature: __name3((value) => Uint8ArrayOrHexCodec2.encode(value), "signature")
  }),
  decodeData: createStandardDecoder2((decoded) => ({
    signature: decoded.signature,
    error: decoded.error
  }))
});
var ConnectionAckRequestSchema2 = buildMessageSchema2("connection_ack", 1, {
  connectionId: union6([
    string3,
    undefinedType
  ])
});
var ConnectionAckV1RequestMessage2 = createSimpleMessage2({
  messageType: "connection_ack",
  version: 1,
  schema: ConnectionAckRequestSchema2
});
var ConnectionAckResponseSchema2 = buildMessageSchema2("connection_ack_response", 1, {
  status: literal2("acknowledged"),
  timestamp: string3
});
var ConnectionAckV1ResponseMessage2 = createSimpleMessage2({
  messageType: "connection_ack_response",
  version: 1,
  schema: ConnectionAckResponseSchema2
});
var ALL_MESSAGE_CLASSES2 = {
  "handshake@1": HandshakeV1RequestMessage2,
  "handshake_response@1": HandshakeV1ResponseMessage2,
  "signMessage@1": SignMessageV1RequestMessage2,
  "signMessage_response@1": SignMessageV1ResponseMessage2,
  "connection_ack@1": ConnectionAckV1RequestMessage2,
  "connection_ack_response@1": ConnectionAckV1ResponseMessage2
};
var ALL_MESSAGE_KEYS2 = Object.keys(ALL_MESSAGE_CLASSES2);
function getMessageClass2(type7, version11) {
  const key = `${type7}@${version11}`;
  const MessageClass = ALL_MESSAGE_CLASSES2[key];
  if (!MessageClass) {
    throw new Error(`Unknown message type: ${type7} version ${version11}`);
  }
  return MessageClass;
}
__name3(getMessageClass2, "getMessageClass");
function isValidMessageType2(type7, version11) {
  const key = `${type7}@${version11}`;
  return key in ALL_MESSAGE_CLASSES2;
}
__name3(isValidMessageType2, "isValidMessageType");
function getAllSupportedMessages2() {
  return ALL_MESSAGE_KEYS2.map((key) => {
    const [type7, versionStr] = key.split("@");
    return {
      type: type7,
      version: parseInt(versionStr, 10)
    };
  });
}
__name3(getAllSupportedMessages2, "getAllSupportedMessages");
function parseMessageKey2(key) {
  const [type7, versionStr] = key.split("@");
  return {
    type: type7,
    version: parseInt(versionStr, 10)
  };
}
__name3(parseMessageKey2, "parseMessageKey");
var _a17;
var MessageRegistry2 = (_a17 = class {
  constructor() {
  }
  static getInstance() {
    if (!_a17.instance) {
      _a17.instance = new _a17();
    }
    return _a17.instance;
  }
  /**
  * Get a message class by type and version (derived from single source)
  */
  getMessageClass(type7, version11) {
    try {
      return getMessageClass2(type7, version11);
    } catch {
      return void 0;
    }
  }
  /**
  * Create a message instance from wire data (using derived message classes)
  */
  decode(wireData) {
    if (!wireData || typeof wireData !== "object") {
      return {
        _tag: "Left",
        left: "Invalid wire data: must be an object"
      };
    }
    const { type: type7, version: version11 } = wireData;
    if (!type7 || !version11) {
      return {
        _tag: "Left",
        left: "Invalid wire data: missing type or version"
      };
    }
    const MessageClass = this.getMessageClass(type7, version11);
    if (!MessageClass) {
      return {
        _tag: "Left",
        left: `Unknown message type: ${type7}@${version11}`
      };
    }
    const result = MessageClass.decode(wireData);
    if (Either_exports.isLeft(result)) {
      return {
        _tag: "Left",
        left: `Decode error: ${result.left.map((e2) => e2.message).join(", ")}`
      };
    }
    return {
      _tag: "Right",
      right: result.right
    };
  }
  /**
  * Encode a message to wire format
  */
  encode(message) {
    return message.encode();
  }
  /**
  * Get all registered message types (derived from single source)
  */
  getRegisteredTypes() {
    return getAllSupportedMessages2().map(({ type: type7, version: version11 }) => `${type7}@${version11}`);
  }
}, __name3(_a17, "MessageRegistry"), __publicField(_a17, "instance"), _a17);
var messageRegistry2 = MessageRegistry2.getInstance();
function assertDefined2(value, message) {
  if (value === null || value === void 0) {
    throw new Error(message ?? "Value must be defined");
  }
}
__name3(assertDefined2, "assertDefined");
function assertNotNull2(value, message) {
  if (value === null) {
    throw new Error(message ?? "Value must not be null");
  }
}
__name3(assertNotNull2, "assertNotNull");
function getDefined2(value, message) {
  assertDefined2(value, message);
  return value;
}
__name3(getDefined2, "getDefined");
var generateMlKem768Keypair2 = __name3(() => {
  try {
    const keys4 = ml_kem768.keygen();
    assertNotNull2(keys4.publicKey, "Encapsulation key must be defined");
    assertNotNull2(keys4.secretKey, "Decapsulation key must be defined");
    return {
      encapsulationKey: keys4.publicKey,
      decapsulationKey: keys4.secretKey
    };
  } catch (error) {
    throw new Error(`Failed to generate ML-KEM-768 keypair: ${error instanceof Error ? error.message : String(error)}`);
  }
}, "generateMlKem768Keypair");
var encapsulateMlKem7682 = __name3((encapsulationKey) => {
  return ml_kem768.encapsulate(encapsulationKey);
}, "encapsulateMlKem768");
var decapsulateMlKem7682 = __name3((decapsulationKey, cipherText) => {
  return ml_kem768.decapsulate(cipherText, decapsulationKey);
}, "decapsulateMlKem768");
var AES_256_GCM_KEY_SIZE2 = 32;
function deriveAESKey2(sharedSecret, salt, info) {
  const infoBytes = new TextEncoder().encode(info);
  return hkdf(sha2567, sharedSecret, salt, infoBytes, AES_256_GCM_KEY_SIZE2);
}
__name3(deriveAESKey2, "deriveAESKey");
function createKeyDerivationInfo2(purpose, connectionId, version11 = 1) {
  return `forward-mpc-${purpose}-v${version11}-${connectionId}`;
}
__name3(createKeyDerivationInfo2, "createKeyDerivationInfo");
async function encryptKeyshare2(keyshare, sharedSecret, connectionId, signingAlgorithm) {
  const salt = randomBytes3(32);
  const keyshareInfo = createKeyDerivationInfo2("keyshare", connectionId);
  const aesKey = deriveAESKey2(sharedSecret, salt, keyshareInfo);
  const keyshareData = {
    keyshare,
    signingAlgorithm,
    timestamp: Date.now(),
    nonce: bytesToHex5(randomBytes3(16))
  };
  const nonce = randomBytes3(12);
  const aes256Gcm = gcm(aesKey, nonce);
  const plaintext = new TextEncoder().encode(JSON.stringify(keyshareData));
  const ciphertext = aes256Gcm.encrypt(plaintext);
  const encryptedPayload = new Uint8Array(nonce.length + ciphertext.length);
  encryptedPayload.set(nonce, 0);
  encryptedPayload.set(ciphertext, nonce.length);
  aesKey.fill(0);
  return {
    salt,
    encryptedPayload
  };
}
__name3(encryptKeyshare2, "encryptKeyshare");
var _a18;
var SigningAlgorithmRegistry2 = (_a18 = class {
  /**
  * Get algorithm instance (derived from single source of truth)
  */
  get(name2) {
    const algorithm = SIGNING_ALGORITHM_INSTANCES2[name2];
    if (!algorithm) {
      throw new Error(`Unknown signing algorithm: ${name2}`);
    }
    return algorithm;
  }
  /**
  * Type-safe check if algorithm exists
  */
  has(name2) {
    return isValidSigningAlgorithm2(name2);
  }
  /**
  * Get all algorithm names (derived from classes)
  */
  getAllNames() {
    return ALL_SIGNING_ALGORITHM_NAMES2;
  }
  /**
  * Get all algorithm instances (derived from classes)
  */
  getAllInstances() {
    return SIGNING_ALGORITHM_INSTANCES2;
  }
}, __name3(_a18, "SigningAlgorithmRegistry"), _a18);
var signingAlgorithmRegistry2 = new SigningAlgorithmRegistry2();

// node_modules/@dynamic-labs-wallet/forward-mpc-client/node_modules/@noble/hashes/utils.js
function isBytes11(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes7(value, length2, title = "") {
  const bytes2 = isBytes11(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length2 !== void 0;
  if (!bytes2 || needsLen && len !== length2) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length2}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function aexists4(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput4(out, instance2) {
  abytes7(out, void 0, "digestInto() output");
  const min4 = instance2.outputLen;
  if (out.length < min4) {
    throw new Error('"digestInto() output" expected to be of length >=' + min4);
  }
}
function clean4(...arrays) {
  for (let i4 = 0; i4 < arrays.length; i4++) {
    arrays[i4].fill(0);
  }
}
function createView4(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE5 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin6 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes6 = Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
var asciis3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase163(ch) {
  if (ch >= asciis3._0 && ch <= asciis3._9)
    return ch - asciis3._0;
  if (ch >= asciis3.A && ch <= asciis3.F)
    return ch - (asciis3.A - 10);
  if (ch >= asciis3.a && ch <= asciis3.f)
    return ch - (asciis3.a - 10);
  return;
}
function hexToBytes6(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin6)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai3 = 0, hi3 = 0; ai3 < al; ai3++, hi3 += 2) {
    const n1 = asciiToBase163(hex2.charCodeAt(hi3));
    const n22 = asciiToBase163(hex2.charCodeAt(hi3 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi3] + hex2[hi3 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi3);
    }
    array2[ai3] = n1 * 16 + n22;
  }
  return array2;
}
function createHasher6(hashCons, info = {}) {
  const hashC = (msg, opts2) => hashCons(opts2).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts2) => hashCons(opts2);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes6(bytesLength = 32) {
  const cr4 = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr4 == null ? void 0 : cr4.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr4.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist3 = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/@dynamic-labs-wallet/forward-mpc-client/node_modules/@noble/hashes/_md.js
function Chi4(a3, b4, c6) {
  return a3 & b4 ^ ~a3 & c6;
}
function Maj4(a3, b4, c6) {
  return a3 & b4 ^ a3 & c6 ^ b4 & c6;
}
var HashMD4 = class {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView4(this.buffer);
  }
  update(data) {
    aexists4(this);
    abytes7(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView4(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists4(this);
    aoutput4(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE6 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean4(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos; i4 < blockLen; i4++)
      buffer[i4] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView4(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0; i4 < outLen; i4++)
      oview.setUint32(4 * i4, state[i4], isLE6);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to5) {
    to5 || (to5 = new this.constructor());
    to5.set(...this.get());
    const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
    to5.destroyed = destroyed;
    to5.finished = finished;
    to5.length = length2;
    to5.pos = pos;
    if (length2 % blockLen)
      to5.buffer.set(buffer);
    return to5;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV3 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV2 = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV2 = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV2 = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@dynamic-labs-wallet/forward-mpc-client/node_modules/@noble/hashes/_u64.js
var U32_MASK644 = BigInt(2 ** 32 - 1);
var _32n4 = BigInt(32);
function fromBig4(n5, le5 = false) {
  if (le5)
    return { h: Number(n5 & U32_MASK644), l: Number(n5 >> _32n4 & U32_MASK644) };
  return { h: Number(n5 >> _32n4 & U32_MASK644) | 0, l: Number(n5 & U32_MASK644) | 0 };
}
function split4(lst, le5 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i4 = 0; i4 < len; i4++) {
    const { h: h5, l: l6 } = fromBig4(lst[i4], le5);
    [Ah[i4], Al[i4]] = [h5, l6];
  }
  return [Ah, Al];
}
var shrSH3 = (h5, _l, s3) => h5 >>> s3;
var shrSL3 = (h5, l6, s3) => h5 << 32 - s3 | l6 >>> s3;
var rotrSH3 = (h5, l6, s3) => h5 >>> s3 | l6 << 32 - s3;
var rotrSL3 = (h5, l6, s3) => h5 << 32 - s3 | l6 >>> s3;
var rotrBH3 = (h5, l6, s3) => h5 << 64 - s3 | l6 >>> s3 - 32;
var rotrBL3 = (h5, l6, s3) => h5 >>> s3 - 32 | l6 << 64 - s3;
function add3(Ah, Al, Bh, Bl) {
  const l6 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l6 / 2 ** 32 | 0) | 0, l: l6 | 0 };
}
var add3L3 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H3 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L3 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H3 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L3 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H3 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@dynamic-labs-wallet/forward-mpc-client/node_modules/@noble/hashes/sha2.js
var SHA256_K3 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W3 = new Uint32Array(64);
var SHA2_32B2 = class extends HashMD4 {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4, E: E4, F: F5, G: G5, H: H2 } = this;
    return [A4, B3, C4, D4, E4, F5, G5, H2];
  }
  // prettier-ignore
  set(A4, B3, C4, D4, E4, F5, G5, H2) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
    this.E = E4 | 0;
    this.F = F5 | 0;
    this.G = G5 | 0;
    this.H = H2 | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4)
      SHA256_W3[i4] = view.getUint32(offset5, false);
    for (let i4 = 16; i4 < 64; i4++) {
      const W15 = SHA256_W3[i4 - 15];
      const W22 = SHA256_W3[i4 - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W22, 17) ^ rotr3(W22, 19) ^ W22 >>> 10;
      SHA256_W3[i4] = s1 + SHA256_W3[i4 - 7] + s0 + SHA256_W3[i4 - 16] | 0;
    }
    let { A: A4, B: B3, C: C4, D: D4, E: E4, F: F5, G: G5, H: H2 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      const sigma1 = rotr3(E4, 6) ^ rotr3(E4, 11) ^ rotr3(E4, 25);
      const T1 = H2 + sigma1 + Chi4(E4, F5, G5) + SHA256_K3[i4] + SHA256_W3[i4] | 0;
      const sigma0 = rotr3(A4, 2) ^ rotr3(A4, 13) ^ rotr3(A4, 22);
      const T22 = sigma0 + Maj4(A4, B3, C4) | 0;
      H2 = G5;
      G5 = F5;
      F5 = E4;
      E4 = D4 + T1 | 0;
      D4 = C4;
      C4 = B3;
      B3 = A4;
      A4 = T1 + T22 | 0;
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    E4 = E4 + this.E | 0;
    F5 = F5 + this.F | 0;
    G5 = G5 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A4, B3, C4, D4, E4, F5, G5, H2);
  }
  roundClean() {
    clean4(SHA256_W3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean4(this.buffer);
  }
};
var _SHA2562 = class extends SHA2_32B2 {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV3[0] | 0);
    __publicField(this, "B", SHA256_IV3[1] | 0);
    __publicField(this, "C", SHA256_IV3[2] | 0);
    __publicField(this, "D", SHA256_IV3[3] | 0);
    __publicField(this, "E", SHA256_IV3[4] | 0);
    __publicField(this, "F", SHA256_IV3[5] | 0);
    __publicField(this, "G", SHA256_IV3[6] | 0);
    __publicField(this, "H", SHA256_IV3[7] | 0);
  }
};
var _SHA2242 = class extends SHA2_32B2 {
  constructor() {
    super(28);
    __publicField(this, "A", SHA224_IV2[0] | 0);
    __publicField(this, "B", SHA224_IV2[1] | 0);
    __publicField(this, "C", SHA224_IV2[2] | 0);
    __publicField(this, "D", SHA224_IV2[3] | 0);
    __publicField(this, "E", SHA224_IV2[4] | 0);
    __publicField(this, "F", SHA224_IV2[5] | 0);
    __publicField(this, "G", SHA224_IV2[6] | 0);
    __publicField(this, "H", SHA224_IV2[7] | 0);
  }
};
var K5122 = (() => split4([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
var SHA512_Kh3 = (() => K5122[0])();
var SHA512_Kl3 = (() => K5122[1])();
var SHA512_W_H3 = new Uint32Array(80);
var SHA512_W_L3 = new Uint32Array(80);
var SHA2_64B2 = class extends HashMD4 {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset5) {
    for (let i4 = 0; i4 < 16; i4++, offset5 += 4) {
      SHA512_W_H3[i4] = view.getUint32(offset5);
      SHA512_W_L3[i4] = view.getUint32(offset5 += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H3[i4 - 15] | 0;
      const W15l = SHA512_W_L3[i4 - 15] | 0;
      const s0h = rotrSH3(W15h, W15l, 1) ^ rotrSH3(W15h, W15l, 8) ^ shrSH3(W15h, W15l, 7);
      const s0l = rotrSL3(W15h, W15l, 1) ^ rotrSL3(W15h, W15l, 8) ^ shrSL3(W15h, W15l, 7);
      const W2h = SHA512_W_H3[i4 - 2] | 0;
      const W2l = SHA512_W_L3[i4 - 2] | 0;
      const s1h = rotrSH3(W2h, W2l, 19) ^ rotrBH3(W2h, W2l, 61) ^ shrSH3(W2h, W2l, 6);
      const s1l = rotrSL3(W2h, W2l, 19) ^ rotrBL3(W2h, W2l, 61) ^ shrSL3(W2h, W2l, 6);
      const SUMl = add4L3(s0l, s1l, SHA512_W_L3[i4 - 7], SHA512_W_L3[i4 - 16]);
      const SUMh = add4H3(SUMl, s0h, s1h, SHA512_W_H3[i4 - 7], SHA512_W_H3[i4 - 16]);
      SHA512_W_H3[i4] = SUMh | 0;
      SHA512_W_L3[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = rotrSH3(Eh, El, 14) ^ rotrSH3(Eh, El, 18) ^ rotrBH3(Eh, El, 41);
      const sigma1l = rotrSL3(Eh, El, 14) ^ rotrSL3(Eh, El, 18) ^ rotrBL3(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L3(Hl, sigma1l, CHIl, SHA512_Kl3[i4], SHA512_W_L3[i4]);
      const T1h = add5H3(T1ll, Hh, sigma1h, CHIh, SHA512_Kh3[i4], SHA512_W_H3[i4]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH3(Ah, Al, 28) ^ rotrBH3(Ah, Al, 34) ^ rotrBH3(Ah, Al, 39);
      const sigma0l = rotrSL3(Ah, Al, 28) ^ rotrBL3(Ah, Al, 34) ^ rotrBL3(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add3(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L3(T1l, sigma0l, MAJl);
      Ah = add3H3(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add3(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add3(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add3(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add3(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add3(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add3(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add3(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add3(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean4(SHA512_W_H3, SHA512_W_L3);
  }
  destroy() {
    clean4(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _SHA5122 = class extends SHA2_64B2 {
  constructor() {
    super(64);
    __publicField(this, "Ah", SHA512_IV2[0] | 0);
    __publicField(this, "Al", SHA512_IV2[1] | 0);
    __publicField(this, "Bh", SHA512_IV2[2] | 0);
    __publicField(this, "Bl", SHA512_IV2[3] | 0);
    __publicField(this, "Ch", SHA512_IV2[4] | 0);
    __publicField(this, "Cl", SHA512_IV2[5] | 0);
    __publicField(this, "Dh", SHA512_IV2[6] | 0);
    __publicField(this, "Dl", SHA512_IV2[7] | 0);
    __publicField(this, "Eh", SHA512_IV2[8] | 0);
    __publicField(this, "El", SHA512_IV2[9] | 0);
    __publicField(this, "Fh", SHA512_IV2[10] | 0);
    __publicField(this, "Fl", SHA512_IV2[11] | 0);
    __publicField(this, "Gh", SHA512_IV2[12] | 0);
    __publicField(this, "Gl", SHA512_IV2[13] | 0);
    __publicField(this, "Hh", SHA512_IV2[14] | 0);
    __publicField(this, "Hl", SHA512_IV2[15] | 0);
  }
};
var _SHA3842 = class extends SHA2_64B2 {
  constructor() {
    super(48);
    __publicField(this, "Ah", SHA384_IV2[0] | 0);
    __publicField(this, "Al", SHA384_IV2[1] | 0);
    __publicField(this, "Bh", SHA384_IV2[2] | 0);
    __publicField(this, "Bl", SHA384_IV2[3] | 0);
    __publicField(this, "Ch", SHA384_IV2[4] | 0);
    __publicField(this, "Cl", SHA384_IV2[5] | 0);
    __publicField(this, "Dh", SHA384_IV2[6] | 0);
    __publicField(this, "Dl", SHA384_IV2[7] | 0);
    __publicField(this, "Eh", SHA384_IV2[8] | 0);
    __publicField(this, "El", SHA384_IV2[9] | 0);
    __publicField(this, "Fh", SHA384_IV2[10] | 0);
    __publicField(this, "Fl", SHA384_IV2[11] | 0);
    __publicField(this, "Gh", SHA384_IV2[12] | 0);
    __publicField(this, "Gl", SHA384_IV2[13] | 0);
    __publicField(this, "Hh", SHA384_IV2[14] | 0);
    __publicField(this, "Hl", SHA384_IV2[15] | 0);
  }
};
var T224_IV2 = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV2 = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var _SHA512_2242 = class extends SHA2_64B2 {
  constructor() {
    super(28);
    __publicField(this, "Ah", T224_IV2[0] | 0);
    __publicField(this, "Al", T224_IV2[1] | 0);
    __publicField(this, "Bh", T224_IV2[2] | 0);
    __publicField(this, "Bl", T224_IV2[3] | 0);
    __publicField(this, "Ch", T224_IV2[4] | 0);
    __publicField(this, "Cl", T224_IV2[5] | 0);
    __publicField(this, "Dh", T224_IV2[6] | 0);
    __publicField(this, "Dl", T224_IV2[7] | 0);
    __publicField(this, "Eh", T224_IV2[8] | 0);
    __publicField(this, "El", T224_IV2[9] | 0);
    __publicField(this, "Fh", T224_IV2[10] | 0);
    __publicField(this, "Fl", T224_IV2[11] | 0);
    __publicField(this, "Gh", T224_IV2[12] | 0);
    __publicField(this, "Gl", T224_IV2[13] | 0);
    __publicField(this, "Hh", T224_IV2[14] | 0);
    __publicField(this, "Hl", T224_IV2[15] | 0);
  }
};
var _SHA512_2562 = class extends SHA2_64B2 {
  constructor() {
    super(32);
    __publicField(this, "Ah", T256_IV2[0] | 0);
    __publicField(this, "Al", T256_IV2[1] | 0);
    __publicField(this, "Bh", T256_IV2[2] | 0);
    __publicField(this, "Bl", T256_IV2[3] | 0);
    __publicField(this, "Ch", T256_IV2[4] | 0);
    __publicField(this, "Cl", T256_IV2[5] | 0);
    __publicField(this, "Dh", T256_IV2[6] | 0);
    __publicField(this, "Dl", T256_IV2[7] | 0);
    __publicField(this, "Eh", T256_IV2[8] | 0);
    __publicField(this, "El", T256_IV2[9] | 0);
    __publicField(this, "Fh", T256_IV2[10] | 0);
    __publicField(this, "Fl", T256_IV2[11] | 0);
    __publicField(this, "Gh", T256_IV2[12] | 0);
    __publicField(this, "Gl", T256_IV2[13] | 0);
    __publicField(this, "Hh", T256_IV2[14] | 0);
    __publicField(this, "Hl", T256_IV2[15] | 0);
  }
};
var sha2568 = createHasher6(
  () => new _SHA2562(),
  oidNist3(1)
);
var sha2243 = createHasher6(
  () => new _SHA2242(),
  oidNist3(4)
);
var sha5125 = createHasher6(
  () => new _SHA5122(),
  oidNist3(3)
);
var sha3843 = createHasher6(
  () => new _SHA3842(),
  oidNist3(2)
);
var sha512_2563 = createHasher6(
  () => new _SHA512_2562(),
  oidNist3(6)
);
var sha512_2243 = createHasher6(
  () => new _SHA512_2242(),
  oidNist3(5)
);

// node_modules/@dynamic-labs-wallet/forward-mpc-client/dist/index.js
var __defProp4 = Object.defineProperty;
var __name4 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var ATTESTATION_CONSTANTS2 = {
  // Maximum age of attestation document in milliseconds
  MAX_ATTESTATION_AGE: 5 * 60 * 1e3
};
var _a19;
var NitroAttestationVerifier2 = (_a19 = class {
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "wasmInitialized", false);
    this.config = {
      strictCertValidation: true,
      maxAge: ATTESTATION_CONSTANTS2.MAX_ATTESTATION_AGE,
      ...config
    };
  }
  /**
  * Initialize WASM module if not already initialized
  */
  async ensureWasmInitialized() {
    if (!this.wasmInitialized) {
      try {
        await wasm_attestation_bindings_default();
        this.wasmInitialized = true;
      } catch (error) {
        throw new Error(`Failed to initialize WASM module: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  /**
  * Verify an attestation document using Evervault WASM bindings
  * Accepts base64-encoded attestation document directly
  *
  * @param attestationDocBase64 - Base64-encoded attestation document
  * @param expectedChallenge - Expected challenge (ciphertext hash)
  * @param expectedNonce - Expected nonce (REQUIRED for security)
  */
  async verify(attestationDocBase64, expectedChallenge, expectedNonce) {
    try {
      await this.ensureWasmInitialized();
      const expectedPcrs = PCRs.empty();
      expectedPcrs.pcr8 = this.config.expectedPcr8;
      const isValid = validateAttestationDocPcrs(attestationDocBase64, [
        expectedPcrs
      ]);
      if (!isValid) {
        return {
          valid: false,
          errors: [
            "Attestation document PCR verification failed"
          ],
          timestamp: Date.now()
        };
      }
      if (expectedChallenge) {
        try {
          const userData = getUserData(attestationDocBase64);
          if (!userData) {
            return {
              valid: false,
              errors: [
                "No user data found in attestation document"
              ],
              timestamp: Date.now()
            };
          }
          const userDataString = new TextDecoder("utf-8").decode(userData);
          if (!userDataString.includes(expectedChallenge)) {
            return {
              valid: false,
              errors: [
                "Ciphertext hash verification failed - challenge not found in attestation user data"
              ],
              timestamp: Date.now()
            };
          }
        } catch (error) {
          return {
            valid: false,
            errors: [
              `Failed to extract or verify ciphertext hash: ${error instanceof Error ? error.message : String(error)}`
            ],
            timestamp: Date.now()
          };
        }
      }
      try {
        const extractedNonceRaw = getNonce(attestationDocBase64);
        if (!extractedNonceRaw) {
          return {
            valid: false,
            errors: [
              "No nonce found in attestation document"
            ],
            timestamp: Date.now()
          };
        }
        let extractedNonce;
        try {
          const nonceString = new TextDecoder().decode(extractedNonceRaw);
          if (typeof atob !== "undefined") {
            const binaryString = atob(nonceString);
            extractedNonce = new Uint8Array(binaryString.length);
            for (let i4 = 0; i4 < binaryString.length; i4++) {
              extractedNonce[i4] = binaryString.charCodeAt(i4);
            }
          } else {
            const decodedBuffer = Buffer.from(nonceString, "base64");
            extractedNonce = new Uint8Array(decodedBuffer);
          }
        } catch (decodeError) {
          return {
            valid: false,
            errors: [
              `Failed to decode nonce from base64: ${decodeError instanceof Error ? decodeError.message : String(decodeError)}`
            ],
            timestamp: Date.now()
          };
        }
        if (extractedNonce.length !== expectedNonce.length) {
          return {
            valid: false,
            errors: [
              `Nonce length mismatch: expected ${expectedNonce.length} bytes, got ${extractedNonce.length} bytes`
            ],
            timestamp: Date.now()
          };
        }
        for (let i4 = 0; i4 < expectedNonce.length; i4++) {
          if (extractedNonce[i4] !== expectedNonce[i4]) {
            return {
              valid: false,
              errors: [
                "Nonce verification failed - nonce mismatch"
              ],
              timestamp: Date.now()
            };
          }
        }
      } catch (error) {
        return {
          valid: false,
          errors: [
            `Failed to extract or verify nonce: ${error instanceof Error ? error.message : String(error)}`
          ],
          timestamp: Date.now()
        };
      }
      return {
        valid: true,
        errors: [],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        valid: false,
        errors: [
          `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`
        ],
        timestamp: Date.now()
      };
    }
  }
}, __name4(_a19, "NitroAttestationVerifier"), _a19);
var isWindow2 = typeof globalThis !== "undefined" && typeof globalThis.window !== "undefined";
var WebSocketImpl2 = isWindow2 ? globalThis.WebSocket : ws5.WebSocket;
var _a20;
var ForwardMPCClient2 = (_a20 = class extends import_index.default {
  constructor(url, options = {}) {
    super();
    __publicField(this, "ws", null);
    __publicField(this, "url");
    __publicField(this, "options");
    __publicField(this, "attestationVerifier", null);
    __publicField(this, "isConnected", false);
    __publicField(this, "messageId", 0);
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "sharedSecret", null);
    __publicField(this, "decapsulationKey", null);
    __publicField(this, "connectionId");
    __publicField(this, "handshakeNonce", null);
    __publicField(this, "attestationPromise", null);
    this.url = url;
    this.connectionId = "";
    this.options = {
      reconnectAttempts: options.reconnectAttempts ?? 3,
      reconnectInterval: options.reconnectInterval ?? 1e3,
      connectionTimeout: options.connectionTimeout ?? 1e4,
      heartbeatInterval: options.heartbeatInterval ?? 3e4,
      attestationConfig: options.attestationConfig,
      attestationVerifier: options.attestationVerifier,
      bypassAttestation: options.bypassAttestation ?? false
    };
    if (options.attestationVerifier) {
      this.attestationVerifier = options.attestationVerifier;
    } else if (this.options.attestationConfig) {
      this.attestationVerifier = new NitroAttestationVerifier2(this.options.attestationConfig);
    }
  }
  async connect() {
    return new Promise((resolve, reject) => {
      if (this.isConnected) {
        resolve();
        return;
      }
      const timeout = setTimeout(() => {
        reject(new Error("Connection timeout"));
      }, this.options.connectionTimeout);
      this.ws = new WebSocketImpl2(this.url);
      if (isWindow2) {
        this.ws.onopen = () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        };
        this.ws.onerror = (_error) => {
          clearTimeout(timeout);
          this.emit("error", new Error("WebSocket error"));
          reject(new Error("WebSocket error"));
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onclose = () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        };
      } else {
        this.ws.on("open", () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        });
        this.ws.on("error", (error) => {
          clearTimeout(timeout);
          this.emit("error", error);
          reject(error);
        });
        this.ws.on("message", (data) => {
          this.handleMessage(data.toString());
        });
        this.ws.on("close", () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        });
      }
    });
  }
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.cleanup();
  }
  cleanup() {
    for (const [, request2] of this.pendingRequests) {
      clearTimeout(request2.timeout);
      request2.reject(new Error("Connection closed"));
    }
    this.pendingRequests.clear();
    if (this.sharedSecret) {
      this.sharedSecret.fill(0);
      this.sharedSecret = null;
    }
    if (this.decapsulationKey) {
      this.decapsulationKey.fill(0);
      this.decapsulationKey = null;
    }
    if (this.handshakeNonce) {
      this.handshakeNonce.fill(0);
      this.handshakeNonce = null;
    }
    this.connectionId = "";
    this.attestationPromise = null;
  }
  /**
  * Ensures the WebSocket connection is active and handshake is completed.
  * Automatically connects and performs handshake if needed.
  * @returns Object containing the shared secret and connection ID
  * @throws Error if connection or handshake fails
  */
  async ensureWsConnection() {
    if (!this.isConnected || !this.ws) {
      await this.connect();
    }
    if (!this.sharedSecret || !this.connectionId) {
      await this.handshake();
    }
    if (this.attestationVerifier && !this.options.bypassAttestation && !this.attestationPromise) {
      throw new Error("Attestation verifier configured but attestation was not performed");
    }
    if (this.attestationPromise) {
      try {
        await this.attestationPromise;
      } catch (error) {
        this.disconnect();
        throw error;
      }
    }
    if (!this.sharedSecret || !this.connectionId) {
      throw new Error("Failed to establish connection and handshake");
    }
    return {
      sharedSecret: this.sharedSecret,
      connectionId: this.connectionId
    };
  }
  handleMessage(data) {
    try {
      const parsed = JSON.parse(data);
      const requestId = parsed.requestId;
      if (requestId) {
        delete parsed.requestId;
      }
      const message = this.deserializeMessage(JSON.stringify(parsed));
      if (requestId && this.pendingRequests.has(requestId)) {
        const request2 = this.pendingRequests.get(requestId);
        this.pendingRequests.delete(requestId);
        clearTimeout(request2.timeout);
        if (message.type === "error") {
          const errorMsg = message;
          request2.reject(new Error(errorMsg.error.message));
        } else if (message.type.endsWith("_response")) {
          const responseData = message.getData ? message.getData() : message;
          if (responseData.error) {
            request2.reject(new Error(responseData.error.message));
          } else {
            request2.resolve(message);
          }
        } else {
          request2.resolve(message);
        }
        return;
      }
      this.emit("message", message);
    } catch (error) {
      this.emit("error", new Error(`Failed to parse message: ${error}`));
    }
  }
  sendRequest(message) {
    return new Promise((resolve, reject) => {
      if (!this.isConnected || !this.ws) {
        reject(new Error("Not connected"));
        return;
      }
      const requestId = `req_${++this.messageId}_${Date.now()}`;
      const messageWithId = message;
      messageWithId.requestId = requestId;
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error("Request timeout"));
      }, 3e4);
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        timeout
      });
      try {
        const serializedMessage = this.serializeMessage(messageWithId);
        this.ws.send(serializedMessage);
      } catch (error) {
        this.pendingRequests.delete(requestId);
        clearTimeout(timeout);
        reject(error);
      }
    });
  }
  serializeMessage(message) {
    try {
      if (message && typeof message.encode === "function") {
        const encoded = message.encode();
        if (message.requestId) {
          encoded.requestId = message.requestId;
        }
        return JSON.stringify(encoded);
      }
      return JSON.stringify(message);
    } catch (error) {
      throw new Error(`Failed to serialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  deserializeMessage(data) {
    try {
      const parsed = JSON.parse(data);
      if (!messageRegistry2) {
        throw new Error("messageRegistry is undefined");
      }
      if (typeof messageRegistry2.decode !== "function") {
        throw new Error("messageRegistry.decode is not a function");
      }
      const result = messageRegistry2.decode(parsed);
      if (Either_exports.isLeft(result)) {
        return parsed;
      }
      return result.right;
    } catch (error) {
      throw new Error(`Failed to deserialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async handshake(traceContext) {
    const { encapsulationKey, decapsulationKey } = generateMlKem768Keypair2();
    this.decapsulationKey = decapsulationKey;
    const nonceBytes = randomBytes6(32);
    this.handshakeNonce = nonceBytes;
    const request2 = new HandshakeV1RequestMessage2({
      challenge: encapsulationKey,
      nonce: nonceBytes,
      traceContext
    });
    const response = await this.sendRequest(request2);
    const responseData = response.getData();
    if (responseData.encapsulatedSharedSecret && responseData.connectionId && this.decapsulationKey) {
      this.connectionId = responseData.connectionId;
      const cipherText = hexToBytes6(responseData.encapsulatedSharedSecret);
      this.sharedSecret = decapsulateMlKem7682(this.decapsulationKey, cipherText);
    }
    if (this.attestationVerifier && responseData.attestationDoc && responseData.encapsulatedSharedSecret && !this.options.bypassAttestation) {
      const cipherText = hexToBytes6(responseData.encapsulatedSharedSecret);
      this.attestationPromise = this.verifyAttestationDocument(responseData.attestationDoc, cipherText);
    }
    return response;
  }
  async signMessage(params) {
    const { sharedSecret, connectionId } = await this.ensureWsConnection();
    let messageToSign;
    if (typeof params.message === "string") {
      const cleanHex = params.message.startsWith("0x") ? params.message.slice(2) : params.message;
      messageToSign = hexToBytes6(cleanHex);
    } else {
      messageToSign = params.message;
    }
    const encryptedKeyshare = await encryptKeyshare2(params.keyshare, sharedSecret, connectionId, params.signingAlgo);
    const request2 = new SignMessageV1RequestMessage2({
      relayDomain: params.relayDomain,
      signingAlgo: params.signingAlgo,
      hashAlgo: params.hashAlgo,
      derivationPath: params.derivationPath,
      tweak: params.tweak,
      keyshare: encryptedKeyshare,
      message: messageToSign,
      roomUuid: params.roomUuid,
      traceContext: params.traceContext,
      userId: params.userId,
      environmentId: params.environmentId
    });
    return this.sendRequest(request2);
  }
  get connected() {
    return this.isConnected;
  }
  /**
  * Generate a unique connection ID
  */
  /**
  * Verify attestation document from handshake response
  * Uses base64-encoded attestation document directly
  */
  async verifyAttestationDocument(attestationDocBase64, cipherText) {
    if (!this.attestationVerifier) {
      return;
    }
    try {
      const challengeHash = sha2568(cipherText);
      const expectedChallenge = Array.from(challengeHash).map((b4) => b4.toString(16).padStart(2, "0")).join("");
      if (!this.handshakeNonce) {
        throw new Error("Nonce not found - handshake may not have completed properly");
      }
      const result = await this.attestationVerifier.verify(attestationDocBase64, expectedChallenge, this.handshakeNonce);
      if (!result.valid) {
        const errorMsg = `Attestation verification failed: ${result.errors.join(", ")}`;
        this.emit("error", new Error(errorMsg));
        throw new Error(errorMsg);
      }
      this.emit("message", {
        type: "attestation-verified",
        timestamp: Date.now(),
        data: result
      });
    } catch (error) {
      const errorMsg = `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`;
      this.emit("error", new Error(errorMsg));
      throw new Error(errorMsg);
    }
  }
}, __name4(_a20, "ForwardMPCClient"), _a20);

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/core/index.esm.js
var import_http_errors2 = __toESM(require_http_errors2());
var ENVIRONMENT_ENUM3 = (function(ENVIRONMENT_ENUM4) {
  ENVIRONMENT_ENUM4["development"] = "development";
  ENVIRONMENT_ENUM4["preprod"] = "preprod";
  ENVIRONMENT_ENUM4["production"] = "production";
  return ENVIRONMENT_ENUM4;
})({});
var WalletOperation3 = (function(WalletOperation4) {
  WalletOperation4["REACH_THRESHOLD"] = "REACH_THRESHOLD";
  WalletOperation4["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
  WalletOperation4["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  WalletOperation4["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  WalletOperation4["REFRESH"] = "REFRESH";
  WalletOperation4["RESHARE"] = "RESHARE";
  WalletOperation4["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
  WalletOperation4["NO_OPERATION"] = "NO_OPERATION";
  return WalletOperation4;
})({});
var BackupLocation3 = (function(BackupLocation4) {
  BackupLocation4["DYNAMIC"] = "dynamic";
  BackupLocation4["GOOGLE_DRIVE"] = "googleDrive";
  BackupLocation4["ICLOUD"] = "iCloud";
  BackupLocation4["USER"] = "user";
  BackupLocation4["EXTERNAL"] = "external";
  BackupLocation4["DELEGATED"] = "delegated";
  return BackupLocation4;
})({});
var IFRAME_DOMAIN_MAP = {
  development: "http://localhost:4200",
  preprod: "https://app.dynamic-preprod.xyz",
  production: "https://app.dynamicauth.com"
};
var SigningAlgorithm3 = (function(SigningAlgorithm4) {
  SigningAlgorithm4["ECDSA"] = "ECDSA";
  SigningAlgorithm4["ED25519"] = "ED25519";
  SigningAlgorithm4["BIP340"] = "BIP340";
  return SigningAlgorithm4;
})({});
var BITCOIN_DERIVATION_PATHS3 = {
  NATIVE_SEGWIT: [
    84,
    0,
    0,
    0,
    0
  ],
  TAPROOT: [
    86,
    0,
    0,
    0,
    0
  ]
};
var BITCOIN_ADDRESS_TYPE_CONFIG = {
  taproot: {
    derivationPath: BITCOIN_DERIVATION_PATHS3.TAPROOT,
    signingAlgorithm: "BIP340"
  },
  native_segwit: {
    derivationPath: BITCOIN_DERIVATION_PATHS3.NATIVE_SEGWIT,
    signingAlgorithm: "ECDSA"
  }
};
var ThresholdSignatureScheme3 = (function(ThresholdSignatureScheme4) {
  ThresholdSignatureScheme4["TWO_OF_TWO"] = "TWO_OF_TWO";
  ThresholdSignatureScheme4["TWO_OF_THREE"] = "TWO_OF_THREE";
  ThresholdSignatureScheme4["THREE_OF_FIVE"] = "THREE_OF_FIVE";
  return ThresholdSignatureScheme4;
})({});
var CreateRoomPartiesOptions3 = (function(CreateRoomPartiesOptions4) {
  CreateRoomPartiesOptions4["THRESHOLD"] = "threshold";
  CreateRoomPartiesOptions4["FULL"] = "full";
  return CreateRoomPartiesOptions4;
})({});
var URL_PATTERNS3 = {
  [ENVIRONMENT_ENUM3.development]: /^http:\/\/localhost:\d+$/,
  [ENVIRONMENT_ENUM3.preprod]: /-preprod/,
  [ENVIRONMENT_ENUM3.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
function getEnvironmentFromUrl(url) {
  if (!url) {
    return ENVIRONMENT_ENUM3.production;
  }
  if (URL_PATTERNS3[ENVIRONMENT_ENUM3.development].test(url)) {
    return ENVIRONMENT_ENUM3.development;
  }
  if (URL_PATTERNS3[ENVIRONMENT_ENUM3.preprod].test(url)) {
    return ENVIRONMENT_ENUM3.preprod;
  }
  return ENVIRONMENT_ENUM3.production;
}
var AuthMode3 = (function(AuthMode4) {
  AuthMode4["HEADER"] = "header";
  AuthMode4["COOKIE"] = "cookie";
  return AuthMode4;
})({});
var BitcoinAddressType = (function(BitcoinAddressType2) {
  BitcoinAddressType2["TAPROOT"] = "taproot";
  BitcoinAddressType2["NATIVE_SEGWIT"] = "native_segwit";
  return BitcoinAddressType2;
})({});
var BitcoinNetwork = (function(BitcoinNetwork2) {
  BitcoinNetwork2["MAINNET"] = "mainnet";
  BitcoinNetwork2["TESTNET"] = "testnet";
  return BitcoinNetwork2;
})({});
var SuccessEventType3 = (function(SuccessEventType4) {
  SuccessEventType4["KeygenComplete"] = "keygen_complete";
  SuccessEventType4["RoomCreated"] = "room_created";
  SuccessEventType4["CeremonyComplete"] = "ceremony_complete";
  return SuccessEventType4;
})({});

// node_modules/@dynamic-labs/message-transport/package.js
var version10 = "4.57.1";

// node_modules/@dynamic-labs/message-transport/src/messageTransport/messageTransport.js
var createMessageTransport = () => {
  const listeners2 = /* @__PURE__ */ new Set();
  return {
    emit: (message) => listeners2.forEach((callback) => callback(message)),
    off: (callback) => listeners2.delete(callback),
    on: (callback) => listeners2.add(callback)
  };
};

// node_modules/@dynamic-labs/message-transport/src/messageTransport/decorators/applyDefaultMessageOrigin/applyDefaultMessageOrigin.js
var applyDefaultMessageOrigin = ({ defaultOrigin, messageTransport }) => Object.assign(Object.assign({}, messageTransport), { defaultOrigin, emit: (message) => {
  var _a21;
  messageTransport.emit(Object.assign(Object.assign({}, message), { origin: (_a21 = message.origin) !== null && _a21 !== void 0 ? _a21 : defaultOrigin }));
} });

// node_modules/@dynamic-labs/message-transport/node_modules/eventemitter3/index.mjs
var import_index4 = __toESM(require_eventemitter32(), 1);

// node_modules/@dynamic-labs/message-transport/src/messageTransport/decorators/applyRecoveryManager/applyRecoveryManager.js
var hasRecoveryManager = (messageTransport) => "recoveryManager" in messageTransport;

// node_modules/@dynamic-labs/message-transport/_virtual/_tslib.js
function __rest4(s3, e2) {
  var t = {};
  for (var p4 in s3) if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
    t[p4] = s3[p4];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s3); i4 < p4.length; i4++) {
      if (e2.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i4]))
        t[p4[i4]] = s3[p4[i4]];
    }
  return t;
}
function __awaiter11(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/message-transport/src/debug/debug.js
var globalDebugEnabled = false;
var isGlobalDebugEnabled = () => globalDebugEnabled;

// node_modules/@dynamic-labs/message-transport/src/utils/isSerializedError/isSerializedError.js
var isSerializedError = (serializedError) => {
  if (typeof serializedError !== "object" || serializedError === null) {
    return false;
  }
  const { message, stack } = serializedError;
  return typeof message === "string" && typeof stack === "string";
};

// node_modules/@dynamic-labs/message-transport/src/utils/logger.js
var logger5 = new Logger("message-transport");

// node_modules/@dynamic-labs/message-transport/src/utils/parseErrorFromTransport/parseErrorFromTransport.js
var parseErrorFromTransport = (serializedError) => {
  const { message, name: name2, stack } = serializedError, otherProps = __rest4(serializedError, ["message", "name", "stack"]);
  let error;
  if (message) {
    try {
      const data = JSON.parse(message);
      if (Array.isArray(data))
        return data;
    } catch (_a21) {
    }
  }
  switch (name2) {
    case "TypeError":
      error = new TypeError(message);
      break;
    case "ReferenceError":
      error = new ReferenceError(message);
      break;
    case "SyntaxError":
      error = new SyntaxError(message);
      break;
    case "RangeError":
      error = new RangeError(message);
      break;
    case "EvalError":
      error = new EvalError(message);
      break;
    case "URIError":
      error = new URIError(message);
      break;
    default:
      error = new Error(message);
      error.name = name2 || "Error";
  }
  if (stack) {
    error.stack = [message, stack].join("\n");
  }
  Object.assign(error, otherProps);
  return error;
};

// node_modules/@dynamic-labs/message-transport/src/utils/serializeErrorForTransport/serializeErrorForTransport.js
var serializeErrorForTransport = (err) => {
  if (err instanceof Error) {
    return convertError(err);
  } else if (Array.isArray(err)) {
    return { message: JSON.stringify(err) };
  } else if (typeof err === "object" && err !== null) {
    const errorMessage = serializeObjectToMessage(err);
    return convertError(Object.assign({ message: errorMessage, name: "Error", stack: "" }, err));
  }
  return { message: String(err) };
};
var convertError = (err) => Object.assign({
  // @ts-expect-error message is a standard property of Error
  message: err.message,
  // @ts-expect-error name is a standard property of Error
  name: err.name,
  stack: err.stack
}, err);
var serializeObjectToMessage = (obj) => {
  try {
    const data = JSON.stringify(obj);
    return data;
  } catch (_a21) {
    return String(obj);
  }
};

// node_modules/@dynamic-labs/message-transport/src/requestChannel/utils/utils.js
var getResolveMessageType = (type3) => `${type3}__resolve`;
var getRejectMessageType = (type3) => `${type3}__reject`;
var getAckMessageType = (type3) => `${type3}__ack`;
var createNoHandlerError = (type3) => {
  const message = `No handlers were registered for message of type ${type3}`;
  logger5.error(message);
  return new RequestChannelNotHandledError(message);
};
var TIMEOUT_DURATION = 5e3;

// node_modules/@dynamic-labs/message-transport/src/requestChannel/createRequestChannelMessageSender/createRequestChannelMessageSender.js
var createRequestChannelMessageSender = ({ requestType, messageSessionId, timeoutMap, onReceiveAck, messageTransport, onTimeout, params, debugOverride, disableAckForOutgoingMessage = false }) => {
  let messageTimedOut = false;
  const ackMessageType = getAckMessageType(requestType);
  const isDebugEnabled = () => debugOverride !== null && debugOverride !== void 0 ? debugOverride : isGlobalDebugEnabled();
  const outgoingMessage = {
    args: params,
    doNotAck: disableAckForOutgoingMessage,
    messageSessionId,
    type: requestType
  };
  const getTimestamp = () => (/* @__PURE__ */ new Date()).toISOString();
  const handleAckMessage = ({ messageSessionId: incomingSessionId, type: incomingType, doNotAck: incomingDoNotAck }) => {
    if (incomingSessionId !== messageSessionId || incomingType !== ackMessageType || incomingDoNotAck) {
      return;
    }
    if (isDebugEnabled()) {
      logger5.debug(`[messageSender ${requestType} ${getTimestamp()}]  received ack message (messageSessionId: ${messageSessionId}). Message timeout ID: ${timeoutMap[messageSessionId]}. Content of timeoutMap: ${JSON.stringify(timeoutMap)}`);
    }
    clearTimeout(timeoutMap[messageSessionId]);
    delete timeoutMap[messageSessionId];
    onReceiveAck === null || onReceiveAck === void 0 ? void 0 : onReceiveAck();
    if (messageTimedOut) {
      if (isDebugEnabled()) {
        logger5.debug(`[messageSender ${requestType} ${getTimestamp()}]  identified a false negative for message time out. Message: ${requestType} with session id ${messageSessionId}`);
      }
      logger5.instrument(`Identified a false negative for message time out. Message: ${requestType} with session id ${messageSessionId}. Params: ${JSON.stringify(params)}`);
    }
  };
  const sendMessage = () => {
    if (disableAckForOutgoingMessage) {
      messageTransport.emit(outgoingMessage);
      return;
    }
    const startTimer = () => {
      const timeoutTimer = setTimeout(() => {
        if (hasRecoveryManager(messageTransport) && messageTransport.recoveryManager.canRetryMessageSessionId(messageSessionId)) {
          if (isDebugEnabled()) {
            logger5.debug(`[messageSender ${requestType} ${getTimestamp()}]  timed out, triggering recovery (messageSessionId: ${messageSessionId})`);
          }
          messageTransport.recoveryManager.triggerRecovery(messageSessionId);
          if (isDebugEnabled()) {
            logger5.debug(`[messageSender ${requestType} ${getTimestamp()}]  attempting to send message again (messageSessionId: ${messageSessionId})`);
          }
          sendMessage();
        } else {
          onTimeout();
          messageTimedOut = true;
        }
      }, TIMEOUT_DURATION);
      if (isDebugEnabled()) {
        logger5.debug(`[messageSender ${requestType} ${getTimestamp()}]  setting timeout timer (messageSessionId: ${messageSessionId}). Timeout ID: ${timeoutTimer}. Content of timeoutMap: ${JSON.stringify(timeoutMap)}`);
      }
      timeoutMap[messageSessionId] = timeoutTimer;
    };
    if ("isBlocked" in messageTransport && messageTransport.isBlocked()) {
      messageTransport.emit(outgoingMessage, { onEmit: startTimer });
      return;
    }
    startTimer();
    messageTransport.emit(outgoingMessage);
  };
  return { handleAckMessage, sendMessage };
};

// node_modules/@dynamic-labs/message-transport/src/requestChannel/requestChannel.js
var createRequestChannel = (messageTransport, { debugOverride, disableAcknowledgement } = {}) => {
  let uniqueIdCounter = 0;
  const idPrefix = Math.random().toString();
  const getUniqueId = () => `${idPrefix}-${uniqueIdCounter++}`;
  const timeoutMap = {};
  const isDebugEnabled = () => debugOverride !== null && debugOverride !== void 0 ? debugOverride : isGlobalDebugEnabled();
  const getTimestamp = () => (/* @__PURE__ */ new Date()).toISOString();
  return {
    emit: (requestType, ...params) => new Promise((resolve, reject) => {
      const messageSessionId = getUniqueId();
      const { handleAckMessage, sendMessage } = createRequestChannelMessageSender({
        debugOverride,
        disableAckForOutgoingMessage: disableAcknowledgement,
        messageSessionId,
        messageTransport,
        onReceiveAck: () => {
          cleanupMessageHandler();
          resolve();
        },
        onTimeout: () => {
          reject(createNoHandlerError(requestType));
          cleanupMessageHandler();
        },
        params,
        requestType,
        timeoutMap
      });
      const cleanupMessageHandler = () => messageTransport.off(handleAckMessage);
      if (disableAcknowledgement) {
        resolve();
      } else {
        messageTransport.on(handleAckMessage);
      }
      sendMessage();
    }),
    handle: (requestType, handler) => {
      const messageHandler = (_a21) => __awaiter11(void 0, [_a21], void 0, function* ({ args, messageSessionId, type: incomingType, doNotAck = false }) {
        if (requestType !== incomingType)
          return;
        if (!doNotAck) {
          messageTransport.emit({
            args: [],
            messageSessionId,
            type: getAckMessageType(requestType)
          });
        }
        const result = handler(...args);
        if (!(result instanceof Promise))
          return;
        try {
          const response = yield result;
          messageTransport.emit({
            args: [response],
            messageSessionId,
            type: getResolveMessageType(requestType)
          });
        } catch (error) {
          messageTransport.emit({
            args: [serializeErrorForTransport(error)],
            messageSessionId,
            type: getRejectMessageType(requestType)
          });
        }
      });
      messageTransport.on(messageHandler);
      return () => {
        messageTransport.off(messageHandler);
      };
    },
    request: (requestType, ...params) => new Promise((resolve, reject) => {
      const messageSessionId = getUniqueId();
      const resolveMessageType = getResolveMessageType(requestType);
      const rejectMessageType = getRejectMessageType(requestType);
      const { handleAckMessage, sendMessage } = createRequestChannelMessageSender({
        debugOverride,
        disableAckForOutgoingMessage: disableAcknowledgement,
        messageSessionId,
        messageTransport,
        onTimeout: () => {
          reject(createNoHandlerError(requestType));
          cleanupMessageHandler();
        },
        params,
        requestType,
        timeoutMap
      });
      const handleMessage = (message) => {
        if (message.messageSessionId !== messageSessionId)
          return;
        if (isDebugEnabled()) {
          logger5.debug(`[request ${requestType} ${getTimestamp()}]  received response message (messageSessionId: ${messageSessionId})`);
        }
        const { args: [result], type: incomingType } = message;
        if (incomingType === resolveMessageType) {
          cleanupMessageHandler();
          resolve(result);
          if (isDebugEnabled()) {
            logger5.debug(`[request ${requestType} ${getTimestamp()}]  resolved message (messageSessionId: ${messageSessionId})`);
          }
          return;
        }
        if (incomingType === rejectMessageType) {
          cleanupMessageHandler();
          if (isSerializedError(result)) {
            reject(parseErrorFromTransport(result));
          } else {
            reject(result);
          }
          if (isDebugEnabled()) {
            logger5.debug(`[request ${requestType} ${getTimestamp()}]  rejected message (messageSessionId: ${messageSessionId})`);
          }
          return;
        }
        handleAckMessage(message);
      };
      const cleanupMessageHandler = () => messageTransport.off(handleMessage);
      messageTransport.on(handleMessage);
      sendMessage();
    })
  };
};

// node_modules/@dynamic-labs/message-transport/src/utils/parseMessageTransportData/parseMessageTransportData.js
var parseMessageTransportData = (parsedData) => {
  if (!parsedData || typeof parsedData !== "object") {
    return void 0;
  }
  const message = {
    args: parsedData.args,
    doNotAck: parsedData.doNotAck,
    messageSessionId: parsedData.messageSessionId,
    origin: parsedData.origin,
    transportStamps: parsedData.transportStamps,
    type: parsedData.type
  };
  if (!Array.isArray(message.args) || typeof message.messageSessionId !== "string" || typeof message.origin !== "string" || typeof message.type !== "string") {
    return void 0;
  }
  return message;
};

// node_modules/@vue/shared/dist/shared.esm-bundler.js
function makeMap(str) {
  const map36 = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map36[key] = 1;
  return (val) => val in map36;
}
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var extend14 = Object.assign;
var hasOwnProperty5 = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty5.call(val, key);
var isArray3 = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString3 = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject3 = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key) => isString3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var isBuiltInDirective = makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
var cacheStringFunction = (fn4) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn4(str));
  });
};
var camelizeRE = /-\w/g;
var camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c6) => c6.slice(1).toUpperCase());
  }
);
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction(
  (str) => {
    const s3 = str ? `on${capitalize(str)}` : ``;
    return s3;
  }
);
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
var isGloballyAllowed = makeMap(GLOBALS_ALLOWED);
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isHTMLTag = makeMap(HTML_TAGS);
var isSVGTag = makeMap(SVG_TAGS);
var isMathMLTag = makeMap(MATH_TAGS);
var isVoidTag = makeMap(VOID_TAGS);
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
var isBooleanAttr = makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
var isKnownHtmlAttr = makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
var isKnownSvgAttr = makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
var isKnownMathMLAttr = makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
var activeSub;
var batchDepth = 0;
var batchedSub;
var batchedComputed;
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e2 = batchedComputed;
    batchedComputed = void 0;
    while (e2) {
      const next = e2.next;
      e2.next = void 0;
      e2.flags &= -9;
      e2 = next;
    }
  }
  let error;
  while (batchedSub) {
    let e2 = batchedSub;
    batchedSub = void 0;
    while (e2) {
      const next = e2.next;
      e2.next = void 0;
      e2.flags &= -9;
      if (e2.flags & 1) {
        try {
          ;
          e2.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e2 = next;
    }
  }
  if (error) throw error;
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last5 = trackStack.pop();
  shouldTrack = last5 === void 0 ? true : last5;
}
var globalVersion = 0;
var Link = class {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
var Dep = class {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
    if (true) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if (activeSub.onTrack) {
      activeSub.onTrack(
        extend14(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (true) {
        for (let head5 = this.subsHead; head5; head5 = head5.nextSub) {
          if (head5.sub.onTrigger && !(head5.sub.flags & 8)) {
            head5.sub.onTrigger(
              extend14(
                {
                  effect: head5.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
};
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l6 = computed.deps; l6; l6 = l6.nextDep) {
        addSub(l6);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if (link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
var targetMap = /* @__PURE__ */ new WeakMap();
var ITERATE_KEY = Symbol(
  true ? "Object iterate" : ""
);
var MAP_KEY_ITERATE_KEY = Symbol(
  true ? "Map keys iterate" : ""
);
var ARRAY_ITERATE_KEY = Symbol(
  true ? "Array iterate" : ""
);
function track(target, type3, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (true) {
      dep.track({
        target,
        type: type3,
        key
      });
    } else {
      dep.track();
    }
  }
}
function trigger(target, type3, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (true) {
        dep.trigger({
          target,
          type: type3,
          key,
          newValue,
          oldValue,
          oldTarget
        });
      } else {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type3 === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray3(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type3) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array2) {
  const raw = toRaw(array2);
  if (raw === array2) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array2) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item) {
  if (isReadonly(target)) {
    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
  }
  return toReactive(item);
}
var arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator3(this, Symbol.iterator, (item) => toWrapped(this, item));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x5) => isArray3(x5) ? reactiveReadArray(x5) : x5)
    );
  },
  entries() {
    return iterator3(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn4, thisArg) {
    return apply(this, "every", fn4, thisArg, void 0, arguments);
  },
  filter(fn4, thisArg) {
    return apply(
      this,
      "filter",
      fn4,
      thisArg,
      (v6) => v6.map((item) => toWrapped(this, item)),
      arguments
    );
  },
  find(fn4, thisArg) {
    return apply(
      this,
      "find",
      fn4,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findIndex(fn4, thisArg) {
    return apply(this, "findIndex", fn4, thisArg, void 0, arguments);
  },
  findLast(fn4, thisArg) {
    return apply(
      this,
      "findLast",
      fn4,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findLastIndex(fn4, thisArg) {
    return apply(this, "findLastIndex", fn4, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn4, thisArg) {
    return apply(this, "forEach", fn4, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn4, thisArg) {
    return apply(this, "map", fn4, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn4, ...args) {
    return reduce10(this, "reduce", fn4, args);
  },
  reduceRight(fn4, ...args) {
    return reduce10(this, "reduceRight", fn4, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn4, thisArg) {
    return apply(this, "some", fn4, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator3(this, "values", (item) => toWrapped(this, item));
  }
};
function iterator3(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
var arrayProto = Array.prototype;
function apply(self2, method, fn4, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn4;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn4.call(this, toWrapped(self2, item), index, self2);
      };
    } else if (fn4.length > 2) {
      wrappedFn = function(item, index) {
        return fn4.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce10(self2, method, fn4, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn4;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn4.call(this, acc, toWrapped(self2, item), index, self2);
      };
    } else if (fn4.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn4.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
var isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty6(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
var BaseReactiveHandler = class {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray3(target);
    if (!isReadonly2) {
      let fn4;
      if (targetIsArray && (fn4 = arrayInstrumentations[key])) {
        return fn4;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty6;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject3(value) ? readonly2(value) : value;
    }
    if (isObject3(res)) {
      return isReadonly2 ? readonly2(res) : reactive(res);
    }
    return res;
  }
};
var MutableReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = isArray3(target) && isIntegerKey(key);
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          if (true) {
            warn(
              `Set operation on key "${String(key)}" failed: target is readonly.`,
              target[key]
            );
          }
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray3(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
};
var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (true) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
};
var mutableHandlers = new MutableReactiveHandler();
var readonlyHandlers = new ReadonlyReactiveHandler();
var shallowReactiveHandlers = new MutableReactiveHandler(true);
var shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
var toShallow = (value) => value;
var getProto = (v6) => Reflect.getPrototypeOf(v6);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return extend14(
      // inheriting all iterator properties
      Object.create(innerIterator),
      {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        }
      }
    );
  };
}
function createReadonlyMethod(type3) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
        `${capitalize(type3)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type3 === "delete" ? false : type3 === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly3, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly3) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has3 } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly3 ? toReadonly : toReactive;
      if (has3.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has3.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly3 && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly3) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly3 ? toReadonly : toReactive;
      !readonly3 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend14(
    instrumentations,
    readonly3 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has: has3, get: get9 } = getProto(target);
        let hadKey = has3.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has3.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has3, key);
        }
        const oldValue = get9.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has: has3, get: get9 } = getProto(target);
        let hadKey = has3.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has3.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has3, key);
        }
        const oldValue = get9 ? get9.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly3, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has3, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has3.call(target, rawKey)) {
    const type3 = toRawType(target);
    warn(
      `Reactive ${type3} contains both the raw and reactive versions of the same object${type3 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function readonly2(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject3(target)) {
    if (true) {
      warn(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
var toReactive = (value) => isObject3(value) ? reactive(value) : value;
var toReadonly = (value) => isObject3(value) ? readonly2(value) : value;
function isRef(r3) {
  return r3 ? r3["__v_isRef"] === true : false;
}

// node_modules/@dynamic-labs/message-transport/src/index.js
assertPackageVersion("@dynamic-labs/message-transport", version10);

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/browser-wallet-client/index.esm.js
function _extends() {
  _extends = Object.assign || function assign(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var iframeMessageHandler = class {
  // Handle error response from iframe message handler
  handleIframeMessageResponseError(response) {
    if (typeof response === "object" && response !== null && "error" in response) {
      throw new Error(String(response.error));
    }
  }
  async getWallets(request2) {
    const response = await this.requestChannel.request("getWallets", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async getWallet(request2) {
    const response = await this.requestChannel.request("getWallet", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async createWalletAccount(request2) {
    const response = await this.requestChannel.request("createWalletAccount", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async requiresPasswordForOperation(request2) {
    const response = await this.requestChannel.request("requiresPasswordForOperation", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signMessage(request2) {
    const response = await this.requestChannel.request("signMessage", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signRawMessage(request2) {
    const response = await this.requestChannel.request("signRawMessage", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signTransaction(request2) {
    const response = await this.requestChannel.request("signTransaction", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async isPasswordEncrypted(request2) {
    const response = await this.requestChannel.request("isPasswordEncrypted", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async backupKeySharesToGoogleDrive(request2) {
    const response = await this.requestChannel.request("backupKeySharesToGoogleDrive", request2);
    this.handleIframeMessageResponseError(response);
  }
  async backupKeySharesToICloud(request2) {
    const response = await this.requestChannel.request("backupKeySharesToICloud", request2);
    this.handleIframeMessageResponseError(response);
  }
  async displayICloudSignIn(chainName) {
    await this.requestChannel.request("displayICloudSignIn", {
      chainName
    });
  }
  async hideICloudSignIn() {
    await this.requestChannel.request("hideICloudSignIn");
  }
  async isICloudAuthenticated(chainName) {
    return this.requestChannel.request("isICloudAuthenticated", {
      chainName
    });
  }
  async delegateKeyShares(request2) {
    const response = await this.requestChannel.request("delegateKeyShares", request2);
    this.handleIframeMessageResponseError(response);
  }
  async revokeDelegation(request2) {
    const response = await this.requestChannel.request("revokeDelegation", request2);
    this.handleIframeMessageResponseError(response);
  }
  async exportClientKeysharesFromGoogleDrive(request2) {
    const response = await this.requestChannel.request("exportClientKeysharesFromGoogleDrive", request2);
    this.handleIframeMessageResponseError(response);
  }
  async refreshWalletAccountShares(request2) {
    const response = await this.requestChannel.request("refreshWalletAccountShares", request2);
    this.handleIframeMessageResponseError(response);
  }
  async reshare(request2) {
    const response = await this.requestChannel.request("reshare", request2);
    this.handleIframeMessageResponseError(response);
  }
  async exportPrivateKey(request2) {
    const response = await this.requestChannel.request("exportPrivateKey", request2);
    this.handleIframeMessageResponseError(response);
  }
  async verifyPassword(request2) {
    const response = await this.requestChannel.request("verifyPassword", request2);
    this.handleIframeMessageResponseError(response);
  }
  async updatePassword(request2) {
    const response = await this.requestChannel.request("updatePassword", request2);
    this.handleIframeMessageResponseError(response);
  }
  async importPrivateKey(request2) {
    const response = await this.requestChannel.request("importPrivateKey", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async sendAuthToken(token, authMode, traceContext) {
    return this.requestChannel.request("sendAuthToken", token, authMode, traceContext);
  }
  async exportClientKeyshares(request2) {
    const response = await this.requestChannel.request("exportClientKeyshares", request2);
    this.handleIframeMessageResponseError(response);
  }
  async offlineExportPrivateKey(request2) {
    const response = await this.requestChannel.request("offlineExportPrivateKey", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signTypedData(request2) {
    const response = await this.requestChannel.request("signTypedData", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async cleanup() {
    return this.requestChannel.request("cleanup");
  }
  constructor(messageTransport) {
    this.requestChannel = createRequestChannel(messageTransport);
  }
};
var logger6 = new Logger("DynamicWaasWalletClient");
var setupMessageTransportBridge = (messageTransport, iframe, iframeOrigin) => {
  if (!(iframe == null ? void 0 : iframe.contentWindow)) {
    throw new Error("Iframe or contentWindow not available");
  }
  const logger8 = new Logger("debug");
  messageTransport.on((message) => {
    if (message.origin === "host") {
      var _iframe_contentWindow;
      iframe == null ? void 0 : (_iframe_contentWindow = iframe.contentWindow) == null ? void 0 : _iframe_contentWindow.postMessage(message, iframeOrigin);
    }
  });
  const handleIncomingMessage = (message) => {
    const { data } = message;
    if (!data) return;
    if ((data == null ? void 0 : data.origin) !== "webview") {
      return;
    }
    if (typeof data !== "object") {
      return;
    }
    try {
      const message2 = parseMessageTransportData(data);
      messageTransport.emit(message2);
    } catch (error) {
      if (!(error instanceof SyntaxError)) {
        logger8.error("Error handling incoming message:", error);
      }
    }
  };
  document.addEventListener("message", handleIncomingMessage);
  window.addEventListener("message", handleIncomingMessage);
};
var IframeManager = class _IframeManager {
  // Simply load the iframe from localhost
  async initialize() {
    await this.doInitializeIframeCommunication();
  }
  /**
  * this is called on class construction time
  * @returns {Promise<void>} that resolves when the iframe is loaded and the message transport and iframe storage are initialized
  */
  initializeIframeCommunication() {
    var _IframeManager2;
    var _iframeLoadPromise;
    (_iframeLoadPromise = (_IframeManager2 = _IframeManager).iframeLoadPromise) != null ? _iframeLoadPromise : _IframeManager2.iframeLoadPromise = this.doInitializeIframeCommunication();
    return _IframeManager.iframeLoadPromise;
  }
  /**
  * initialize the iframe communication by awaiting the iframe load promise
  * and initializing the message transport and iframe storage after iframe is successfully loaded
  */
  async doInitializeIframeCommunication() {
    try {
      await this.loadIframe();
    } catch (error) {
      this.logger.error("Error initializing iframe:", error);
      throw error;
    }
  }
  /**
  * initialize the message transport after iframe is successfully loaded
  */
  async initializeMessageTransport() {
    if (this.messageTransport && this.iframeMessageHandler) {
      this.logger.debug("Skipping initializeMessageTransport: transport and message handler already initialized");
      return;
    }
    await this.initializeIframeCommunication();
    const transport = applyDefaultMessageOrigin({
      defaultOrigin: "host",
      messageTransport: createMessageTransport()
    });
    this.messageTransport = transport;
    if (!this.iframe) {
      throw new Error("Iframe not available");
    }
    setupMessageTransportBridge(this.messageTransport, this.iframe, this.iframeDomain);
    this.iframeMessageHandler = new iframeMessageHandler(this.messageTransport);
    if (this.secureStorage) {
      this.setupSecureStorageHandlers();
    }
    await this.initAuthToken();
    if (this.secureStorage && this.iframeMessageHandler) {
      await this.notifySecureStorageAvailable();
    }
  }
  /**
  * Sets up message handlers for secureStorage operations from iframe
  */
  setupSecureStorageHandlers() {
    if (!this.messageTransport) {
      return;
    }
    this.iframeRequestChannel = createRequestChannel(this.messageTransport);
    this.iframeRequestChannel.handle("getClientKeyShare", this.handleGetClientKeyShare.bind(this));
    this.iframeRequestChannel.handle("setClientKeyShare", this.handleSetClientKeyShare.bind(this));
  }
  /**
  * Handler for getClientKeyShare requests from iframe
  */
  async handleGetClientKeyShare(request2) {
    if (!this.secureStorage) {
      throw new Error("Secure storage not available");
    }
    const keyShares = await this.secureStorage.getClientKeyShare(request2.chainName, request2.accountAddress);
    return {
      keyShares
    };
  }
  /**
  * Handler for setClientKeyShare requests from iframe
  */
  async handleSetClientKeyShare(request2) {
    if (!this.secureStorage) {
      throw new Error("Secure storage not available");
    }
    await this.secureStorage.setClientKeyShare(request2.chainName, request2.accountAddress, request2.keyShares);
  }
  /**
  * Notifies the iframe that secureStorage is available.
  * Uses optional chaining since sendSecureStorageConfig may not exist in older iframe versions.
  */
  async notifySecureStorageAvailable() {
    if (!this.iframeMessageHandler) {
      return;
    }
    await (this.iframeMessageHandler.sendSecureStorageConfig == null ? void 0 : this.iframeMessageHandler.sendSecureStorageConfig.call(this.iframeMessageHandler));
  }
  /**
  * securely exchange the auth token with iframe securely
  */
  async initAuthToken() {
    if (!this.iframeMessageHandler) {
      throw new Error("Iframe message handler not initialized");
    }
    try {
      await this.iframeMessageHandler.sendAuthToken(this.authToken, this.authMode);
    } catch (error) {
      throw new Error("Failed to establish secure token exchange: " + error);
    }
  }
  /**
  * Reset the shared iframe and iframe load promise, and iframe instance count
  */
  async resetSharedIframe() {
    _IframeManager.sharedIframe = null;
    _IframeManager.iframeInstanceCount = 0;
    _IframeManager.iframeLoadPromise = null;
    this.iframe = null;
    this.iframeMessageHandler = null;
    this.messageTransport = null;
    _IframeManager.iframeLoadTimeout = Math.min(_IframeManager.iframeLoadTimeout * 2, 6e4);
  }
  async loadIframe() {
    if (_IframeManager.sharedIframe) {
      this.assignExistingIframe();
      return Promise.resolve();
    }
    if (_IframeManager.iframeLoadPromise) {
      return _IframeManager.iframeLoadPromise.then(() => {
        this.assignExistingIframe();
      });
    }
    _IframeManager.iframeLoadPromise = this.createIframeLoadPromise();
    return _IframeManager.iframeLoadPromise;
  }
  assignExistingIframe() {
    this.iframe = _IframeManager.sharedIframe;
    _IframeManager.iframeInstanceCount++;
  }
  createIframeLoadPromise() {
    return new Promise((resolve, reject) => {
      const attemptLoad = () => {
        _IframeManager.iframeLoadAttempts++;
        this.logger.debug(`Loading iframe for waas wallet client... (attempt ${_IframeManager.iframeLoadAttempts}/${_IframeManager.maxRetryAttempts + 1})`, this.getIframeContext());
        const iframe = document.createElement("iframe");
        let messageListener = null;
        const context = _extends({}, this.getIframeContext(), {
          attempt: _IframeManager.iframeLoadAttempts
        });
        const iframeTimeoutId = setTimeout(() => {
          if (iframe.onerror) {
            iframe.onerror("Iframe load timeout");
          }
        }, _IframeManager.iframeLoadTimeout);
        messageListener = this.createMessageListener(iframe, iframeTimeoutId, resolve);
        window.addEventListener("message", messageListener);
        this.configureIframe(iframe);
        this.setIframeSource(iframe);
        this.logger.debug("Creating iframe with src:", iframe.src);
        document.body.appendChild(iframe);
        this.setupIframeEventHandlersWithRetry(iframe, messageListener, iframeTimeoutId, reject, attemptLoad, context);
      };
      attemptLoad();
    });
  }
  setupIframeEventHandlersWithRetry(iframe, messageListener, iframeTimeoutId, reject, attemptLoad, context) {
    iframe.onload = () => {
      this.logger.debug("Iframe onload fired, waiting for ready message...");
    };
    iframe.onerror = (error) => {
      if (messageListener) {
        window.removeEventListener("message", messageListener);
      }
      clearTimeout(iframeTimeoutId);
      if (_IframeManager.iframeLoadAttempts <= _IframeManager.maxRetryAttempts) {
        const errorMsg = error instanceof Error ? error.message : "Unknown error occurred.";
        this.logger.warn(`(loadIframe) Iframe failed to load on attempt ${_IframeManager.iframeLoadAttempts}, retrying... context: ${JSON.stringify(context)}, error: ${errorMsg}`);
        if (iframe.parentNode) {
          iframe.parentNode.removeChild(iframe);
        }
        setTimeout(() => {
          attemptLoad();
        }, 1e3);
      } else {
        this.logger.error("Iframe failed to load after all retry attempts: ", error);
        this.resetSharedIframe();
        _IframeManager.iframeLoadAttempts = 0;
        reject(new Error(`Failed to load iframe after all retry attempts... context: ${JSON.stringify(context)}`));
      }
    };
  }
  getIframeContext() {
    var _this_sdkVersion;
    return {
      iframeDomain: this.iframeDomain,
      environmentId: this.environmentId,
      sdkVersion: (_this_sdkVersion = this.sdkVersion) != null ? _this_sdkVersion : "",
      instanceId: this.instanceId,
      chainName: this.chainName,
      iframeLoadTimeout: _IframeManager.iframeLoadTimeout
    };
  }
  createMessageListener(iframe, iframeTimeoutId, resolve) {
    const messageListener = (event) => {
      if (event.source === iframe.contentWindow && event.data === `iframe-ready-${this.instanceId}`) {
        window.removeEventListener("message", messageListener);
        clearTimeout(iframeTimeoutId);
        _IframeManager.sharedIframe = iframe;
        this.iframe = iframe;
        _IframeManager.iframeInstanceCount++;
        _IframeManager.iframeLoadAttempts = 0;
        resolve();
        this.logger.debug("Iframe loaded successfully...", this.getIframeContext());
      }
    };
    return messageListener;
  }
  configureIframe(iframe) {
    iframe.style.display = "none";
    iframe.setAttribute("title", "Dynamic Wallet Iframe");
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-downloads");
    iframe.setAttribute("referrerpolicy", "origin");
    iframe.style.position = "fixed";
    iframe.style.top = "0";
    iframe.style.left = "0";
    iframe.style.width = "0";
    iframe.style.height = "0";
    iframe.style.border = "none";
    iframe.style.pointerEvents = "none";
  }
  setIframeSource(iframe) {
    var _this_instanceId, _this_sdkVersion, _this_baseClientKeysharesRelayApiUrl;
    const params = new URLSearchParams({
      instanceId: (_this_instanceId = this.instanceId) != null ? _this_instanceId : "",
      hostOrigin: window.location.origin,
      environmentId: this.environmentId,
      baseApiUrl: this.baseApiUrl,
      baseMPCRelayApiUrl: this.baseMPCRelayApiUrl,
      sdkVersion: (_this_sdkVersion = this.sdkVersion) != null ? _this_sdkVersion : "",
      debug: String(this.debug),
      baseClientKeysharesRelayApiUrl: (_this_baseClientKeysharesRelayApiUrl = this.baseClientKeysharesRelayApiUrl) != null ? _this_baseClientKeysharesRelayApiUrl : ""
    });
    iframe.src = `${this.iframeDomain}/waas-v1/${this.environmentId}?${params.toString()}`;
  }
  /**
  * Load an iframe for a specific container
  * @param {HTMLElement} container - The container to which the iframe will be attached
  * @returns {Promise<HTMLIFrameElement>} that resolves when the iframe is loaded
  */
  loadIframeForContainer(container) {
    return new Promise((resolve, reject) => {
      var _this_sdkVersion;
      const context = {
        iframeDomain: this.iframeDomain,
        environmentId: this.environmentId,
        sdkVersion: (_this_sdkVersion = this.sdkVersion) != null ? _this_sdkVersion : "",
        instanceId: this.instanceId,
        chainName: this.chainName,
        iframeLoadTimeout: _IframeManager.iframeLoadTimeout
      };
      this.logger.debug(`Loading iframe for container...`, context);
      const iframe = document.createElement("iframe");
      let messageListener = null;
      const iframeTimeoutId = setTimeout(() => {
        if (messageListener) {
          window.removeEventListener("message", messageListener);
        }
        this.logger.error(`(loadIframeForContainer) Iframe load timeout due to no handshake message from iframe, this could be network issues, incorrect iframe domain, or CORS errors that prevents iframe from being loaded or sending handshake message, context: ${JSON.stringify(context)}`);
        reject(new Error(`(loadIframeForContainer) Iframe load timeout due to no handshake message from iframe, this could be network issues, incorrect iframe domain, or CORS errors that prevents iframe from being loaded or sending handshake message, context: ${JSON.stringify(context)}`));
      }, _IframeManager.iframeLoadTimeout);
      iframe.style.display = "block";
      iframe.style.width = "100%";
      iframe.style.height = "100%";
      iframe.setAttribute("title", "Dynamic Wallet Storage");
      iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox");
      iframe.setAttribute("referrerpolicy", "origin");
      var _this_instanceId, _this_sdkVersion1, _this_baseClientKeysharesRelayApiUrl;
      const params = new URLSearchParams({
        instanceId: (_this_instanceId = this.instanceId) != null ? _this_instanceId : "",
        hostOrigin: window.location.origin,
        environmentId: this.environmentId,
        baseApiUrl: this.baseApiUrl,
        baseMPCRelayApiUrl: this.baseMPCRelayApiUrl,
        sdkVersion: (_this_sdkVersion1 = this.sdkVersion) != null ? _this_sdkVersion1 : "",
        debug: String(this.debug),
        baseClientKeysharesRelayApiUrl: (_this_baseClientKeysharesRelayApiUrl = this.baseClientKeysharesRelayApiUrl) != null ? _this_baseClientKeysharesRelayApiUrl : ""
      });
      iframe.src = `${this.iframeDomain}/waas-v1/${this.environmentId}?${params.toString()}`;
      this.logger.debug("Creating iframe with src:", iframe.src);
      container.appendChild(iframe);
      iframe.onload = () => {
        this.logger.debug("Iframe onload fired, waiting for ready message...");
      };
      iframe.onerror = (error) => {
        if (messageListener) {
          window.removeEventListener("message", messageListener);
        }
        clearTimeout(iframeTimeoutId);
        this.logger.error("Iframe failed to load due to errors: ", error);
        reject(new Error("Failed to load iframe due to unknown load errors, this is likely a browser or network issue."));
      };
      messageListener = (event) => {
        if (event.source === iframe.contentWindow && event.data === `iframe-ready-${this.instanceId}`) {
          if (messageListener) {
            window.removeEventListener("message", messageListener);
          }
          clearTimeout(iframeTimeoutId);
          _IframeManager.sharedIframe = iframe;
          this.iframe = iframe;
          _IframeManager.iframeInstanceCount++;
          resolve(iframe);
          var _this_sdkVersion2;
          this.logger.debug("Iframe loaded successfully...", {
            iframeDomain: this.iframeDomain,
            environmentId: this.environmentId,
            sdkVersion: (_this_sdkVersion2 = this.sdkVersion) != null ? _this_sdkVersion2 : "",
            instanceId: this.instanceId,
            chainName: this.chainName
          });
        }
      };
      window.addEventListener("message", messageListener);
    });
  }
  /**
  * Initializes the iframe display for a specific container.
  *
  * @param {HTMLElement} container - The container to which the iframe will be attached.
  * @returns:
  *   iframe: HTMLIFrameElement;
  *   iframeDisplay: IframeDisplayChannelAdapter;
  *   cleanup: () => void;
  */
  async initializeIframeDisplayForContainer({ container }) {
    try {
      const iframe = await this.loadIframeForContainer(container);
      const transport = applyDefaultMessageOrigin({
        defaultOrigin: "host",
        messageTransport: createMessageTransport()
      });
      setupMessageTransportBridge(transport, iframe, this.iframeDomain);
      const iframeDisplay = new iframeMessageHandler(transport);
      var _this_authMode;
      await iframeDisplay.sendAuthToken(this.authToken, (_this_authMode = this.authMode) != null ? _this_authMode : AuthMode3.HEADER);
      return {
        iframe,
        iframeDisplay,
        cleanup: () => {
          container.removeChild(iframe);
        }
      };
    } catch (error) {
      this.logger.error("Error initializing iframe:", error);
      throw error;
    }
  }
  async cleanup() {
    await this.initializeMessageTransport();
    if (!this.iframeMessageHandler) {
      throw new Error("Iframe message handler not initialized");
    }
    await this.iframeMessageHandler.cleanup();
    if (this.iframe) {
      _IframeManager.iframeInstanceCount--;
      if (_IframeManager.sharedIframe && _IframeManager.iframeInstanceCount === 0) {
        document.body.removeChild(_IframeManager.sharedIframe);
        _IframeManager.sharedIframe = null;
        _IframeManager.iframeLoadPromise = null;
      }
      this.iframe = null;
    }
  }
  constructor({ environmentId, baseApiUrl, baseMPCRelayApiUrl, chainName, sdkVersion, authMode = AuthMode3.HEADER, authToken, debug, baseClientKeysharesRelayApiUrl }, internalOptions) {
    this.logger = logger6;
    this.instanceId = null;
    this.iframeDomain = null;
    this.messageTransport = null;
    this.iframeMessageHandler = null;
    this.iframe = null;
    this.environmentId = environmentId;
    this.authToken = authToken;
    this.authMode = authMode;
    this.baseApiUrl = baseApiUrl;
    this.baseMPCRelayApiUrl = baseMPCRelayApiUrl;
    this.chainName = chainName;
    this.sdkVersion = sdkVersion;
    this.baseClientKeysharesRelayApiUrl = baseClientKeysharesRelayApiUrl;
    if (internalOptions == null ? void 0 : internalOptions.secureStorage) {
      this.secureStorage = internalOptions.secureStorage;
    }
    const environment = getEnvironmentFromUrl(baseApiUrl);
    this.iframeDomain = IFRAME_DOMAIN_MAP[environment];
    if (this.authMode === AuthMode3.COOKIE) {
      this.iframeDomain = this.baseApiUrl;
    }
    this.instanceId = v4_default();
    this.debug = Boolean(debug);
    this.logger.setLogLevel(this.debug ? "DEBUG" : "INFO");
  }
};
IframeManager.iframeLoadPromise = null;
IframeManager.iframeLoadTimeout = 1e4;
IframeManager.iframeLoadAttempts = 0;
IframeManager.maxRetryAttempts = 1;
IframeManager.sharedIframe = null;
IframeManager.iframeInstanceCount = 0;
var DynamicWalletClient = class extends IframeManager {
  async withHandler(operation) {
    await this.initializeMessageTransport();
    if (!this.iframeMessageHandler) {
      throw new Error("Iframe message handler not initialized");
    }
    return operation(this.iframeMessageHandler);
  }
  async getWallets() {
    return this.withHandler((handler) => handler.getWallets({
      chainName: this.chainName
    }));
  }
  async getWallet({ accountAddress, walletOperation = WalletOperation3.NO_OPERATION, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.getWallet({
      chainName: this.chainName,
      accountAddress,
      walletOperation,
      signedSessionId,
      authToken
    }));
  }
  async createWalletAccount({ thresholdSignatureScheme, password = void 0, signedSessionId, authToken, traceContext, bitcoinConfig }) {
    return this.withHandler((handler) => handler.createWalletAccount({
      chainName: this.chainName,
      thresholdSignatureScheme,
      password,
      signedSessionId,
      authToken,
      traceContext,
      bitcoinConfig
    }));
  }
  async requiresPasswordForOperation({ accountAddress, walletOperation = WalletOperation3.REACH_THRESHOLD, authToken }) {
    return this.withHandler((handler) => handler.requiresPasswordForOperation({
      chainName: this.chainName,
      accountAddress,
      walletOperation,
      authToken
    }));
  }
  async isPasswordEncrypted({ accountAddress, authToken }) {
    return this.withHandler((handler) => handler.isPasswordEncrypted({
      chainName: this.chainName,
      accountAddress,
      authToken
    }));
  }
  async signMessage({ message, accountAddress, password = void 0, signedSessionId, authToken, mfaToken, context, traceContext, bitcoinConfig }) {
    const contextString = JSON.stringify(context, (_key, value) => typeof value === "bigint" ? value.toString() : value);
    return this.withHandler((handler) => handler.signMessage({
      chainName: this.chainName,
      message,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      context: contextString,
      traceContext,
      bitcoinConfig
    }));
  }
  async signRawMessage({ message, accountAddress, password = void 0, signedSessionId, authToken, mfaToken, context, traceContext, bitcoinConfig }) {
    return this.withHandler((handler) => handler.signRawMessage({
      chainName: this.chainName,
      message,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      context,
      traceContext,
      bitcoinConfig
    }));
  }
  /**
  * Signs a transaction and returns the signature, @transaction is a string of the serialized transaction
  * EVM:
  *   transaction = serializeTransaction()
  * SOL:
  *   const messageBytes = transaction.serializeMessage();
  *   const messageToSign = Buffer.from(messageBytes).toString("hex");
  * SUI:
  *  const txBytes = await txb.build({ client });
  *  const txString = Buffer.from(txBytes).toString("hex");
  */
  async signTransaction({ senderAddress, transaction, password = void 0, signedSessionId, authToken, mfaToken, chainId, traceContext, bitcoinConfig }) {
    return this.withHandler((handler) => handler.signTransaction({
      chainName: this.chainName,
      senderAddress,
      transaction,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      chainId,
      traceContext,
      bitcoinConfig
    }));
  }
  async signTypedData({ accountAddress, typedData, password = void 0, signedSessionId, authToken, mfaToken, traceContext }) {
    return this.withHandler((handler) => handler.signTypedData({
      chainName: this.chainName,
      accountAddress,
      typedData: JSON.stringify(typedData),
      password,
      signedSessionId,
      authToken,
      mfaToken,
      traceContext
    }));
  }
  async backupKeySharesToGoogleDrive({ accountAddress, password = void 0, signedSessionId, authToken, traceContext }) {
    return this.withHandler((handler) => handler.backupKeySharesToGoogleDrive({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      traceContext
    }));
  }
  async backupKeySharesToICloud({ accountAddress, password = void 0, signedSessionId, authToken, traceContext }) {
    return this.withHandler((handler) => handler.backupKeySharesToICloud({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      traceContext
    }));
  }
  async displayICloudSignIn({ displayContainer }) {
    const { iframeDisplay } = await this.initializeIframeDisplayForContainer({
      container: displayContainer
    });
    if (!iframeDisplay) {
      throw new Error("Failed to initialize iframe handler with display functionality");
    }
    return iframeDisplay.displayICloudSignIn(this.chainName);
  }
  async hideICloudSignIn() {
    return this.withHandler((handler) => handler.hideICloudSignIn());
  }
  async isICloudAuthenticated() {
    return this.withHandler((handler) => handler.isICloudAuthenticated(this.chainName));
  }
  async delegateKeyShares({ accountAddress, password, signedSessionId, authToken, mfaToken, traceContext }) {
    return this.withHandler((handler) => handler.delegateKeyShares({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      traceContext
    }));
  }
  async revokeDelegation({ accountAddress, password, signedSessionId, authToken, mfaToken, traceContext }) {
    return this.withHandler((handler) => handler.revokeDelegation({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      traceContext
    }));
  }
  async exportClientKeysharesFromGoogleDrive({ accountAddress, password, signedSessionId, authToken, traceContext }) {
    return this.withHandler((handler) => handler.exportClientKeysharesFromGoogleDrive({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      traceContext
    }));
  }
  async refreshWalletAccountShares({ accountAddress, password, signedSessionId, authToken, mfaToken, traceContext }) {
    return this.withHandler((handler) => handler.refreshWalletAccountShares({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      traceContext
    }));
  }
  async reshare({ accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, password, signedSessionId, authToken, mfaToken, traceContext }) {
    return this.withHandler((handler) => handler.reshare({
      chainName: this.chainName,
      accountAddress,
      oldThresholdSignatureScheme,
      newThresholdSignatureScheme,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      traceContext
    }));
  }
  async exportPrivateKey({ accountAddress, displayContainer, password, signedSessionId, authToken, mfaToken, traceContext, bitcoinConfig }) {
    const { iframeDisplay } = await this.initializeIframeDisplayForContainer({
      container: displayContainer
    });
    if (!iframeDisplay) {
      throw new Error("Failed to initialize iframe handler with display functionality");
    }
    return iframeDisplay.exportPrivateKey({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      traceContext,
      bitcoinConfig
    });
  }
  async verifyPassword({ accountAddress, password, walletOperation = WalletOperation3.NO_OPERATION, signedSessionId, authToken, traceContext }) {
    return this.withHandler((handler) => handler.verifyPassword({
      chainName: this.chainName,
      accountAddress,
      password,
      walletOperation,
      signedSessionId,
      authToken,
      traceContext
    }));
  }
  async updatePassword({ accountAddress, existingPassword, newPassword, signedSessionId, authToken, traceContext }) {
    return this.withHandler((handler) => handler.updatePassword({
      chainName: this.chainName,
      accountAddress,
      existingPassword,
      newPassword,
      signedSessionId,
      authToken,
      traceContext
    }));
  }
  async importPrivateKey({ privateKey, thresholdSignatureScheme, signedSessionId, authToken, publicAddressCheck, addressType, traceContext, legacyWalletId }) {
    return this.withHandler((handler) => handler.importPrivateKey({
      chainName: this.chainName,
      privateKey,
      thresholdSignatureScheme,
      signedSessionId,
      authToken,
      publicAddressCheck,
      addressType,
      traceContext,
      legacyWalletId
    }));
  }
  async exportClientKeyshares({ accountAddress, password, signedSessionId, authToken, traceContext }) {
    return this.withHandler((handler) => handler.exportClientKeyshares({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      traceContext
    }));
  }
  /**
  * keyShares is stringified list of EcdsaKeygenResult[] and Ed25519KeygenResult[]
  */
  async offlineExportPrivateKey({ keyShares, derivationPath, traceContext }) {
    const args = {
      chainName: this.chainName,
      keyShares,
      derivationPath
    };
    const serializedArgs = JSON.stringify(args);
    const argsBuffer = new TextEncoder().encode(serializedArgs);
    const base64Args = Buffer.from(argsBuffer).toString("base64");
    return this.withHandler((handler) => handler.offlineExportPrivateKey({
      chainName: this.chainName,
      base64Args,
      traceContext
    }));
  }
  constructor({ environmentId, authToken, baseApiUrl, baseMPCRelayApiUrl, baseClientKeysharesRelayApiUrl, chainName, sdkVersion, debug, authMode = AuthMode3.HEADER }, internalOptions) {
    super({
      environmentId,
      authToken,
      baseApiUrl,
      baseMPCRelayApiUrl,
      baseClientKeysharesRelayApiUrl,
      chainName,
      sdkVersion,
      debug,
      authMode
    }, internalOptions);
  }
};

// node_modules/@dynamic-labs/waas/utils/constants.js
var DEFAULT_BASE_API_URL = "https://app.dynamicauth.com";
var DEFAULT_BASE_MPC_RELAY_API_URL = "https://relay.dynamicauth.com";

// node_modules/@dynamic-labs/waas/utils/instrumentation.js
var InstrumentationTimer = class {
  constructor(startTime) {
    this.startTime = startTime || Date.now();
    this.stepStartTime = this.startTime;
  }
  getElapsed() {
    return Date.now() - this.startTime;
  }
  startStep() {
    this.stepStartTime = Date.now();
  }
  getStepElapsed() {
    return Date.now() - this.stepStartTime;
  }
  resetStep() {
    this.startStep();
  }
  setStartTime(startTime) {
    this.startTime = startTime;
  }
  setStepStartTime(stepStartTime) {
    this.stepStartTime = stepStartTime;
  }
};

// node_modules/@dynamic-labs/waas/src/DynamicWaasMixin.js
var WaasExportHandler = class {
  constructor() {
    this.iframeStamper = null;
  }
  setIframeStamper(iframe) {
    this.iframeStamper = iframe;
  }
  clear() {
    if (this.iframeStamper) {
      this.iframeStamper.remove();
      this.iframeStamper = null;
    }
  }
};
var withDynamicWaas = (BaseClass) => {
  class DynamicWaasMixin extends BaseClass {
    setGetAuthTokenFunction(getAuthToken) {
      this.getAuthToken = getAuthToken;
    }
    setWaasAuthMode(authMode) {
      this.authMode = authMode;
    }
    setGetMfaTokenFunction(getMfaToken) {
      this.getMfaToken = getMfaToken;
    }
    setEnvironmentId(environmentId) {
      this.environmentId = environmentId;
    }
    setBaseApiUrl(baseApiUrl) {
      this.baseApiUrl = baseApiUrl;
    }
    setBaseClientKeysharesRelayApiUrl(baseClientKeysharesRelayApiUrl) {
      this.baseClientKeysharesRelayApiUrl = baseClientKeysharesRelayApiUrl;
    }
    setRelayUrl(relayUrl) {
      this.relayUrl = relayUrl;
    }
    setGetSignedSessionIdFunction(getSignedSessionId) {
      this.getSignedSessionId = getSignedSessionId;
    }
    delegateKeyShares(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new Error("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new Error("Signed session ID is required");
        }
        const authToken = (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this);
        if (!authToken) {
          throw new Error("Auth token is required");
        }
        return walletClient.delegateKeyShares({
          accountAddress,
          authToken,
          password,
          signedSessionId
        });
      });
    }
    constructor(...args) {
      super(...args);
      this.name = "Dynamic Waas";
      this.overrideKey = "dynamicwaas";
      this.isEmbeddedWallet = true;
      this.authMode = "header";
      this.__exportHandler = new WaasExportHandler();
      const { connectedChain } = this;
      const chainNameMap = {
        BTC: "BTC",
        EVM: "EVM",
        SOL: "SVM",
        SUI: "SUI",
        TON: "TON"
      };
      const chainName = chainNameMap[connectedChain];
      if (!chainName) {
        throw new DynamicError(`Unsupported chain: ${connectedChain}`);
      }
      this.chainName = chainName;
    }
    createDynamicWaasClient(traceContext) {
      return __awaiter10(this, void 0, void 0, function* () {
        var _a21;
        const authToken = (_a21 = this.getAuthToken) === null || _a21 === void 0 ? void 0 : _a21.call(this);
        if (!authToken && this.authMode === "header") {
          throw new DynamicError("Auth token is required in non-cookie auth mode");
        }
        if (!this.environmentId) {
          throw new DynamicError("Environment ID is required");
        }
        const client = new DynamicWalletClient({
          authMode: this.authMode || "header",
          authToken: authToken || "",
          baseApiUrl: this.baseApiUrl || DEFAULT_BASE_API_URL,
          baseClientKeysharesRelayApiUrl: this.baseClientKeysharesRelayApiUrl,
          baseMPCRelayApiUrl: this.relayUrl || DEFAULT_BASE_MPC_RELAY_API_URL,
          chainName: this.chainName,
          environmentId: this.environmentId,
          sdkVersion: version9
        });
        this.instrumentAsync({
          context: traceContext,
          fn: () => __awaiter10(this, void 0, void 0, function* () {
            return client.initialize();
          }),
          operation: "createDynamicWaasClient",
          resource: "initialize"
        });
        return client;
      });
    }
    getWaasWalletClient(traceContext) {
      return __awaiter10(this, void 0, void 0, function* () {
        if (!this.dynamicWaasClient) {
          this.dynamicWaasClient = yield this.createDynamicWaasClient(traceContext);
        }
        return this.dynamicWaasClient;
      });
    }
    // Common methods that are identical across all connectors
    createWalletAccount() {
      return __awaiter10(this, arguments, void 0, function* ({ thresholdSignatureScheme = "TWO_OF_TWO", password, bitcoinConfig } = {}) {
        var _a21, _b;
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_a21 = this.getSignedSessionId) === null || _a21 === void 0 ? void 0 : _a21.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const createdWallet = yield walletClient.createWalletAccount({
          authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
          bitcoinConfig,
          password,
          signedSessionId,
          thresholdSignatureScheme
        });
        return createdWallet;
      });
    }
    importPrivateKey(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ privateKey, thresholdSignatureScheme = "TWO_OF_TWO", publicAddressCheck, addressType, legacyWalletId }) {
        var _b, _c3;
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        yield walletClient.importPrivateKey({
          addressType,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          legacyWalletId,
          privateKey,
          publicAddressCheck,
          signedSessionId,
          thresholdSignatureScheme
        });
      });
    }
    exportPrivateKey() {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, displayContainer, password } = {}) {
        var _a21, _b, _c3;
        const walletClient = yield this.getWaasWalletClient();
        const targetAccountAddress = accountAddress || (yield this.getActiveAccountAddress());
        if (!targetAccountAddress) {
          throw new DynamicError("Account address is required");
        }
        if (!displayContainer) {
          throw new DynamicError("Missing display container for export private key");
        }
        const signedSessionId = yield (_a21 = this.getSignedSessionId) === null || _a21 === void 0 ? void 0 : _a21.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        this.__exportHandler.setIframeStamper(displayContainer);
        const mfaToken = yield (_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
          mfaAction: MFAAction.WalletWaasExport
        });
        yield walletClient.exportPrivateKey({
          accountAddress: targetAccountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          displayContainer,
          mfaToken,
          password,
          signedSessionId
        });
      });
    }
    getExportHandler() {
      return this.__exportHandler;
    }
    exportClientKeyshares(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        yield walletClient.exportClientKeyshares({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    backupKeySharesToGoogleDrive(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.backupKeySharesToGoogleDrive({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    exportClientKeysharesFromGoogleDrive(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.exportClientKeysharesFromGoogleDrive({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    backupKeySharesToICloud(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.backupKeySharesToICloud({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    displayICloudSignIn(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ displayContainer }) {
        const walletClient = yield this.getWaasWalletClient();
        return walletClient.displayICloudSignIn({
          displayContainer
        });
      });
    }
    hideICloudSignIn() {
      return __awaiter10(this, void 0, void 0, function* () {
        const walletClient = yield this.getWaasWalletClient();
        return walletClient.hideICloudSignIn();
      });
    }
    isICloudAuthenticated() {
      return __awaiter10(this, void 0, void 0, function* () {
        const walletClient = yield this.getWaasWalletClient();
        return walletClient.isICloudAuthenticated();
      });
    }
    refreshWalletAccountShares(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3, _d;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const mfaToken = yield (_c3 = this.getMfaToken) === null || _c3 === void 0 ? void 0 : _c3.call(this, {
          mfaAction: MFAAction.WalletWaasRefresh
        });
        return walletClient.refreshWalletAccountShares({
          accountAddress,
          authToken: (_d = this.getAuthToken) === null || _d === void 0 ? void 0 : _d.call(this),
          mfaToken,
          password,
          signedSessionId
        });
      });
    }
    reshareWalletAccountShares(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, thresholdSignatureScheme, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const wallets2 = yield walletClient.getWallets();
        const wallet = wallets2.find((w4) => w4.accountAddress === accountAddress);
        if (!wallet) {
          throw new DynamicError("Wallet not found");
        }
        const oldThresholdSignatureScheme = wallet.thresholdSignatureScheme;
        return walletClient.reshare({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          newThresholdSignatureScheme: thresholdSignatureScheme,
          oldThresholdSignatureScheme,
          password,
          signedSessionId
        });
      });
    }
    revokeDelegation(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.revokeDelegation({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    updatePassword(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, existingPassword, newPassword }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.updatePassword({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          existingPassword,
          newPassword,
          signedSessionId
        });
      });
    }
    signRawMessage(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ accountAddress, message, password }) {
        var _b, _c3, _d;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        if (message.length !== 64) {
          throw new DynamicError("Message must be 64 characters long");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const mfaToken = yield (_c3 = this.getMfaToken) === null || _c3 === void 0 ? void 0 : _c3.call(this, {
          mfaAction: MFAAction.WalletWaasSign
        });
        return walletClient.signRawMessage({
          accountAddress,
          authToken: (_d = this.getAuthToken) === null || _d === void 0 ? void 0 : _d.call(this),
          message,
          mfaToken,
          password,
          signedSessionId
        });
      });
    }
    endSession() {
      return __awaiter10(this, void 0, void 0, function* () {
        const waasClient = yield this.getWaasWalletClient();
        if (!waasClient) {
          return;
        }
        yield waasClient.cleanup();
        this.dynamicWaasClient = void 0;
      });
    }
    /**
     * Get connected accounts by fetching wallets from Waas client.
     */
    getConnectedAccounts() {
      return __awaiter10(this, void 0, void 0, function* () {
        try {
          const walletClient = yield this.getWaasWalletClient();
          const wallets2 = yield walletClient.getWallets();
          const addresses = wallets2.map((w4) => w4 === null || w4 === void 0 ? void 0 : w4.accountAddress).filter((a3) => typeof a3 === "string");
          return addresses;
        } catch (error) {
          this.logger.debug("[getConnectedAccounts] Failed to fetch wallets from Waas client", {
            error
          });
          return [];
        }
      });
    }
    generateTraceId() {
      const bytes2 = new Uint8Array(16);
      crypto.getRandomValues(bytes2);
      return Array.from(bytes2).map((byte) => byte.toString(16).padStart(2, "0")).join("");
    }
    /**
     * Helper method to instrument with automatic properties inclusion
     */
    instrument(message, context) {
      const defaultContext = {
        accountAddress: context.accountAddress || this.activeAccountAddress,
        environmentId: context.environmentId || this.environmentId,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        traceId: context.traceId || this.generateTraceId()
      };
      this.logger.debug(message, Object.assign(Object.assign({}, defaultContext), context));
      this.logger.instrument(message, Object.assign(Object.assign({}, defaultContext), context));
    }
    instrumentAsync(_a21) {
      return __awaiter10(this, arguments, void 0, function* ({ operation, resource, fn: fn4, context }) {
        const timing = new InstrumentationTimer(context === null || context === void 0 ? void 0 : context.startTime);
        if (context === null || context === void 0 ? void 0 : context.stepStartTime) {
          timing.setStepStartTime(context.stepStartTime);
        } else {
          timing.startStep();
        }
        this.instrument(`[${operation}] ${resource} - start`, Object.assign({ key: `${resource}-start`, operation, stepTime: timing.getStepElapsed(), time: timing.getElapsed() }, context));
        try {
          const result = yield fn4(timing);
          this.instrument(`[${operation}] ${resource} - completed`, Object.assign({ key: `${resource}-completed`, operation, stepTime: timing.getStepElapsed(), time: timing.getElapsed() }, context));
          return result;
        } catch (error) {
          this.instrument(`[${operation}] ${resource} - failed`, Object.assign(Object.assign({ key: `${resource}-failed`, operation, stepTime: timing.getStepElapsed(), time: timing.getElapsed() }, context), { error }));
          throw error;
        }
      });
    }
  }
  return DynamicWaasMixin;
};

// node_modules/@dynamic-labs/waas/src/index.js
assertPackageVersion("@dynamic-labs/waas", version9);

// node_modules/@dynamic-labs/waas-svm/utils/logger.js
var logger7 = new Logger("@dynamic-labs/waas-svm");

// node_modules/@dynamic-labs/waas-svm/src/signer/DynamicWaasSVMSigner.js
var import_bs588 = __toESM(require_bs586(), 1);

// node_modules/@dynamic-labs/waas-svm/node_modules/eventemitter3/index.mjs
var import_index5 = __toESM(require_eventemitter33(), 1);
var eventemitter3_default3 = import_index5.default;

// node_modules/@dynamic-labs/waas-svm/src/signer/DynamicWaasSVMSigner.js
var DynamicWaasSVMSigner = class extends eventemitter3_default3 {
  constructor({ walletConnector }) {
    super();
    this.isConnected = true;
    this.providers = [this];
    this.isBraveWallet = false;
    this.isGlow = false;
    this.isPhantom = false;
    this.isSolflare = false;
    this.isExodus = false;
    this.isBackpack = false;
    this.isMagicEden = false;
    this.walletConnector = walletConnector;
    this.accountAddress = this.walletConnector.activeAccountAddress;
    this.publicKey = this.accountAddress ? new PublicKey5(this.accountAddress) : void 0;
  }
  signMessage(encodedMessage) {
    return __awaiter9(this, void 0, void 0, function* () {
      const messageString = Buffer.from(encodedMessage).toString();
      const signedMessage = yield this.walletConnector.signMessage(messageString);
      const signatureBytes = import_bs588.default.decode(signedMessage);
      return { signature: signatureBytes };
    });
  }
  signTransaction(transaction) {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.walletConnector.signTransaction(transaction);
    });
  }
  signAllTransactions(transactions) {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.walletConnector.signAllTransactions(transactions);
    });
  }
  signAndSendTransaction(transaction, options) {
    return __awaiter9(this, void 0, void 0, function* () {
      const signature4 = yield this.walletConnector.signAndSendTransaction(transaction, options);
      return { signature: signature4 };
    });
  }
  connect(_args) {
    return __awaiter9(this, void 0, void 0, function* () {
      return { address: this.accountAddress, publicKey: this.publicKey };
    });
  }
  disconnect() {
    return __awaiter9(this, void 0, void 0, function* () {
      return;
    });
  }
};

// node_modules/@dynamic-labs/waas-svm/src/connector/DynamicWaasSVMConnector.js
var DynamicWaasSVMConnector = class extends withDynamicWaas(SolanaWalletConnector) {
  connect() {
    throw new Error("Method not implemented.");
  }
  constructor(props) {
    super(props);
    this.name = "Dynamic Waas";
    this.overrideKey = "dynamicwaas";
    this.isEmbeddedWallet = true;
    this.logger = logger7;
    this.walletUiUtils = props.walletUiUtils;
  }
  /**
   * Override setEnvironmentId to ensure it's set on the global logger
   */
  setEnvironmentId(environmentId) {
    super.setEnvironmentId(environmentId);
    Logger.setEnvironmentId(environmentId);
  }
  setActiveAccountAddress(accountAddress) {
    this.activeAccountAddress = accountAddress;
  }
  getActiveAccountAddress() {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.activeAccountAddress;
    });
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter9(this, void 0, void 0, function* () {
      var _a21, _b;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_a21 = this.getSignedSessionId) === null || _a21 === void 0 ? void 0 : _a21.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      const targetWallet = yield walletClient.getWallet({
        accountAddress: expectedAddress,
        authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
        signedSessionId
      });
      if (!targetWallet) {
        throw new DynamicError("Account not found");
      }
      const isWalletActive = isSameAddress(targetWallet.accountAddress, this.activeAccountAddress || "", this.connectedChain);
      if (!isWalletActive) {
        this.activeAccountAddress = targetWallet.accountAddress;
      }
    });
  }
  internalSignMessage(message_1) {
    return __awaiter9(this, arguments, void 0, function* (message, { parentTraceId, startTime } = {}) {
      var _a21, _b, _c3;
      const traceId = parentTraceId || this.generateTraceId();
      const effectiveStartTime = startTime || Date.now();
      const walletClient = yield this.instrumentAsync({
        context: { chainName: "SVM", startTime: effectiveStartTime, traceId },
        fn: () => __awaiter9(this, void 0, void 0, function* () {
          return this.getWaasWalletClient();
        }),
        operation: "internalSignMessage",
        resource: "getWaasWalletClient"
      });
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const signedSessionId = yield (_a21 = this.getSignedSessionId) === null || _a21 === void 0 ? void 0 : _a21.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      const mfaToken = yield (_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
        mfaAction: MFAAction.WalletWaasSign
      });
      const accountAddress = this.activeAccountAddress;
      const authToken = (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this);
      const signedMessage = yield this.instrumentAsync({
        context: { chainName: "SVM", startTime: effectiveStartTime, traceId },
        fn: () => __awaiter9(this, void 0, void 0, function* () {
          return walletClient.signMessage({
            accountAddress,
            authToken,
            message,
            mfaToken,
            signedSessionId,
            traceContext: {
              startTime: effectiveStartTime,
              traceId
            }
          });
        }),
        operation: "internalSignMessage",
        resource: "walletClient.signMessage"
      });
      return signedMessage;
    });
  }
  signMessage(message) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const traceId = this.generateTraceId();
      const startTime = Date.now();
      this.instrument("[signMessage] start", {
        key: "signMessage-start",
        startTime,
        time: 0,
        traceId
      });
      const signedMessage = yield this.walletUiUtils.signMessage({
        handler: () => __awaiter9(this, void 0, void 0, function* () {
          return this.internalSignMessage(message, {
            parentTraceId: traceId,
            startTime
          });
        }),
        message,
        walletConnector: this
      });
      this.instrument("[signMessage] completed", {
        key: "signMessage-completed",
        startTime,
        time: Date.now() - startTime,
        traceId
      });
      return signedMessage;
    });
  }
  internalSignTransaction(transaction_1) {
    return __awaiter9(this, arguments, void 0, function* (transaction, { parentTraceId, startTime } = {}) {
      var _a21, _b;
      const traceId = parentTraceId || this.generateTraceId();
      const effectiveStartTime = startTime || Date.now();
      const walletClient = yield this.instrumentAsync({
        context: { chainName: "SVM", startTime: effectiveStartTime, traceId },
        fn: () => __awaiter9(this, void 0, void 0, function* () {
          return this.getWaasWalletClient();
        }),
        operation: "internalSignTransaction",
        resource: "getWaasWalletClient"
      });
      const signedSessionId = yield (_a21 = this.getSignedSessionId) === null || _a21 === void 0 ? void 0 : _a21.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const mfaToken = yield (_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
        mfaAction: MFAAction.WalletWaasSign
      });
      const messageBytes = transaction instanceof Transaction5 ? transaction.serializeMessage() : transaction.message.serialize();
      const messageToSign = Buffer.from(messageBytes).toString("hex");
      const chainId = yield this.getNetwork(true);
      const senderAddress = this.activeAccountAddress;
      const signature4 = yield this.instrumentAsync({
        context: { chainName: "SVM", startTime: effectiveStartTime, traceId },
        fn: () => __awaiter9(this, void 0, void 0, function* () {
          var _c3;
          return walletClient.signTransaction({
            authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
            chainId,
            mfaToken,
            senderAddress,
            signedSessionId,
            traceContext: {
              startTime: effectiveStartTime,
              traceId
            },
            transaction: messageToSign
          });
        }),
        operation: "internalSignTransaction",
        resource: "signTransaction"
      });
      transaction.addSignature(new PublicKey5(this.activeAccountAddress), Buffer.from(signature4, "hex"));
      try {
        transaction.serialize({
          requireAllSignatures: false,
          verifySignatures: true
        });
      } catch (err) {
        logger7.warn("[internalSignTransaction] Error signing transaction", err);
      }
      return transaction;
    });
  }
  signTransaction(transaction) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const traceId = this.generateTraceId();
      const startTime = Date.now();
      this.instrument("[signTransaction] start", {
        key: "signTransaction-start",
        startTime,
        time: 0,
        traceId
      });
      const uiTransaction = new SolanaUiTransaction({
        connection: this.getWalletClient(),
        from: this.activeAccountAddress,
        multipleTransactions: [transaction],
        onSubmit: () => __awaiter9(this, void 0, void 0, function* () {
          return this.internalSignTransaction(transaction, {
            parentTraceId: traceId,
            startTime
          });
        })
      });
      const signedTransaction = yield this.walletUiUtils.signTransaction(this, uiTransaction);
      this.instrument("[signTransaction] completed", {
        key: "signTransaction-completed",
        startTime,
        time: Date.now() - startTime,
        traceId
      });
      return signedTransaction;
    });
  }
  internalSignAllTransactions(transactions) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const signedTransactions = [];
      for (const transaction of transactions) {
        const signedTx = yield this.internalSignTransaction(transaction);
        signedTransactions.push(signedTx);
      }
      return signedTransactions;
    });
  }
  signAllTransactions(transactions) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const traceId = this.generateTraceId();
      const startTime = Date.now();
      this.instrument("[signAllTransactions] start", {
        key: "signAllTransactions-start",
        startTime,
        time: 0,
        traceId
      });
      const uiTransaction = new SolanaUiTransaction({
        connection: this.getWalletClient(),
        from: this.activeAccountAddress,
        multipleTransactions: transactions,
        onSubmit: () => __awaiter9(this, void 0, void 0, function* () {
          return this.internalSignAllTransactions(transactions);
        })
      });
      const signedTransactions = yield this.walletUiUtils.signTransaction(this, uiTransaction);
      this.instrument("[signAllTransactions] completed", {
        key: "signAllTransactions-completed",
        startTime,
        time: Date.now() - startTime,
        traceId
      });
      return signedTransactions;
    });
  }
  internalSignAndSendTransaction(transaction_1, options_1) {
    return __awaiter9(this, arguments, void 0, function* (transaction, options, { parentTraceId, startTime } = {}) {
      const traceId = parentTraceId || this.generateTraceId();
      const effectiveStartTime = startTime || Date.now();
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const connection = this.getWalletClient();
      const signedTransaction = yield this.instrumentAsync({
        context: { chainName: "SVM", startTime: effectiveStartTime, traceId },
        fn: () => __awaiter9(this, void 0, void 0, function* () {
          return this.internalSignTransaction(transaction, {
            parentTraceId: traceId,
            startTime: effectiveStartTime
          });
        }),
        operation: "internalSignAndSendTransaction",
        resource: "internalSignTransaction"
      });
      const signature4 = yield this.instrumentAsync({
        context: {
          chainName: "SVM",
          rpcUrl: connection.rpcEndpoint,
          startTime: effectiveStartTime,
          traceId
        },
        fn: () => __awaiter9(this, void 0, void 0, function* () {
          return connection.sendRawTransaction(signedTransaction.serialize({
            requireAllSignatures: false,
            verifySignatures: true
          }), options);
        }),
        operation: "internalSignAndSendTransaction",
        resource: "sendRawTransaction"
      });
      const confirmationStartTime = Date.now();
      return new Promise((resolve, reject) => {
        var _a21;
        const timeout = setTimeout(() => {
          const timeoutTotalElapsed = Date.now() - confirmationStartTime;
          this.instrument(`[internalSignAndSendTransaction] Transaction timed out - total: ${timeoutTotalElapsed}ms`, {
            key: "internalSignAndSendTransaction-transactionTimedOut",
            rpcUrl: connection.rpcEndpoint,
            time: timeoutTotalElapsed,
            traceId
          });
          reject(new Error("Transaction timed out"));
        }, 6e4);
        connection.onSignature(signature4, (result) => {
          clearTimeout(timeout);
          const confirmationEndTime = Date.now();
          const confirmationStepElapsed = confirmationEndTime - confirmationStartTime;
          const confirmationTotalElapsed = confirmationEndTime - effectiveStartTime;
          if (result.err) {
            logger7.error(`[internalSignAndSendTransaction] Transaction failed - total: ${confirmationTotalElapsed}ms, step: ${confirmationStepElapsed}ms`, {
              accountAddress: this.activeAccountAddress,
              error: result.err,
              key: "internalSignAndSendTransaction-transactionFailed",
              rpcUrl: connection.rpcEndpoint,
              stepTime: confirmationStepElapsed,
              time: confirmationTotalElapsed,
              traceId
            });
            reject(new Error(`Transaction failed: ${result.err}`));
          } else {
            this.instrument(`[internalSignAndSendTransaction] Transaction confirmed - total: ${confirmationTotalElapsed}ms, step: ${confirmationStepElapsed}ms`, {
              key: "internalSignAndSendTransaction-transactionSuccess",
              rpcUrl: connection.rpcEndpoint,
              stepTime: confirmationStepElapsed,
              time: confirmationTotalElapsed,
              traceId
            });
            resolve(signature4);
          }
        }, (_a21 = options === null || options === void 0 ? void 0 : options.preflightCommitment) !== null && _a21 !== void 0 ? _a21 : "confirmed");
      });
    });
  }
  signAndSendTransaction(transaction, options) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this.activeAccountAddress) {
        throw new Error("Active account address is required");
      }
      const traceId = this.generateTraceId();
      const startTime = Date.now();
      this.instrument("[signAndSendTransaction] start", {
        key: "signAndSendTransaction-start",
        options,
        startTime,
        time: 0,
        traceId
      });
      const uiTransaction = new SolanaUiTransaction({
        connection: this.getWalletClient(),
        from: this.activeAccountAddress,
        multipleTransactions: [transaction],
        onSubmit: () => __awaiter9(this, void 0, void 0, function* () {
          return this.internalSignAndSendTransaction(transaction, options, {
            parentTraceId: traceId,
            startTime
          });
        })
      });
      const result = yield this.walletUiUtils.sendTransaction(this, uiTransaction);
      this.instrument("[signAndSendTransaction] completed", {
        key: "signAndSendTransaction-completed",
        startTime,
        time: Date.now() - startTime,
        traceId
      });
      return result;
    });
  }
  getSigner() {
    return __awaiter9(this, void 0, void 0, function* () {
      return new DynamicWaasSVMSigner({
        walletConnector: this
      });
    });
  }
  getWalletClientByAddress({ accountAddress }) {
    this.setActiveAccountAddress(accountAddress);
    return this.getWalletClient();
  }
  // Chain-specific override for exportClientKeyshares - SVM needs to handle optional account address
  exportClientKeyshares(_a21) {
    const _super = Object.create(null, {
      exportClientKeyshares: { get: () => super.exportClientKeyshares }
    });
    return __awaiter9(this, arguments, void 0, function* ({ accountAddress, password }) {
      const targetAccountAddress = accountAddress || this.activeAccountAddress;
      if (!targetAccountAddress) {
        throw new Error("Account address is required");
      }
      const traceId = this.generateTraceId();
      const startTime = Date.now();
      this.instrument("[exportClientKeyshares] start", {
        key: "exportClientKeyshares-start",
        startTime,
        time: 0,
        traceId
      });
      const result = yield _super.exportClientKeyshares.call(this, {
        accountAddress: targetAccountAddress,
        password
      });
      this.instrument("[exportClientKeyshares] completed", {
        key: "exportClientKeyshares-completed",
        startTime,
        time: Date.now() - startTime,
        traceId
      });
      return result;
    });
  }
  createUiTransaction(from13) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from13);
      const transaction = new SolanaUiTransaction({
        connection: this.getWalletClient(),
        from: from13,
        onSubmit: (transaction2) => __awaiter9(this, void 0, void 0, function* () {
          if (!transaction2)
            return void 0;
          return this.internalSignAndSendTransaction(transaction2);
        })
      });
      return transaction;
    });
  }
  endSession() {
    const _super = Object.create(null, {
      endSession: { get: () => super.endSession }
    });
    return __awaiter9(this, void 0, void 0, function* () {
      yield _super.endSession.call(this);
    });
  }
  signMessageWithContext() {
    return __awaiter9(this, void 0, void 0, function* () {
      throw new Error("Not implemented");
    });
  }
};
Object.defineProperty(DynamicWaasSVMConnector, "key", {
  value: "dynamicwaas",
  writable: false
});

// node_modules/@dynamic-labs/waas-svm/src/DynamicWaasSvmConnectors.js
var DynamicWaasSVMConnectors = () => [DynamicWaasSVMConnector];

// node_modules/@dynamic-labs/waas-svm/src/index.js
assertPackageVersion("@dynamic-labs/waas-svm", version8);

// node_modules/@dynamic-labs/solana/src/injected/PhantomInjected/PhantomInjected.js
var PhantomInjected = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "Phantom";
    this.overrideKey = "phantom";
  }
  getAddress() {
    const _super = Object.create(null, {
      getAddress: { get: () => super.getAddress }
    });
    return __awaiter2(this, void 0, void 0, function* () {
      if (this.isInstalledOnBrowser()) {
        return _super.getAddress.call(this);
      }
      if (isMobile()) {
        handleMobileWalletRedirect({
          nativeLink: "phantom://browse",
          universalLink: "https://phantom.app/ul/browse"
        });
      }
      return void 0;
    });
  }
  canGetChainAddress() {
    var _a21, _b;
    return ((_b = (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.findProvider()) === null || _b === void 0 ? void 0 : _b.publicKey) !== null;
  }
};

// node_modules/@dynamic-labs/solana/src/phantomRedirect/PhantomRedirect/PhantomRedirect.js
var import_bs5810 = __toESM(require_bs583(), 1);
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);

// node_modules/@dynamic-labs/solana/src/phantomRedirect/buildUrl/buildUrl.js
var buildUrl = (path, params) => `https://phantom.app/ul/v1/${path}?${params.toString()}`;

// node_modules/@dynamic-labs/solana/src/phantomRedirect/clearRedirectUrlForPhantom/clearRedirectUrlForPhantom.js
var clearRedirectUrlForPhantom = (url) => {
  const phantomUrlParamsToRemove = [
    "data",
    "nonce",
    "phantom_encryption_public_key",
    "errorCode",
    "errorMessage",
    "data"
  ];
  phantomUrlParamsToRemove.forEach((param) => {
    url.searchParams.delete(param);
  });
  return url.toString();
};

// node_modules/@dynamic-labs/solana/src/phantomRedirect/decryptPayload/decryptPayload.js
var import_bs589 = __toESM(require_bs583(), 1);
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var failForMissingParam = (paramName, param) => {
  const message = `Failed to decrypt phantom redirect payload: ${paramName} was invalid (${param})`;
  logger2.error(message);
  throw new Error(message);
};
var decryptPayload = (data, nonce, sharedSecret) => {
  if (!data)
    failForMissingParam("data", data);
  if (!nonce)
    failForMissingParam("nonce", nonce);
  if (!sharedSecret)
    failForMissingParam("sharedSecret", sharedSecret);
  const decryptedData = import_tweetnacl.default.box.open.after(import_bs589.default.decode(data), import_bs589.default.decode(nonce), sharedSecret);
  if (!decryptedData) {
    throw new Error("Unable to decrypt data");
  }
  return JSON.parse(Buffer.from(decryptedData).toString("utf8"));
};

// node_modules/@dynamic-labs/solana/src/phantomRedirect/encryptPayload/encryptPayload.js
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var encryptPayload = (payload, sharedSecret) => {
  const nonce = import_tweetnacl2.default.randomBytes(24);
  const encryptedPayload = import_tweetnacl2.default.box.after(Buffer.from(JSON.stringify(payload)), nonce, sharedSecret);
  return [nonce, encryptedPayload];
};

// node_modules/@dynamic-labs/solana/src/phantomRedirect/storage/storage.js
var storage = {
  address: {
    get: () => {
      var _a21;
      const value = (_a21 = localStorage.getItem("dynamic_phantom_wallet_address")) !== null && _a21 !== void 0 ? _a21 : void 0;
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] address.get", {
        value
      });
      return value;
    },
    remove: () => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] address.remove");
      localStorage.removeItem("dynamic_phantom_wallet_address");
    },
    set: (address) => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] address.set", {
        address: address.toString()
      });
      localStorage.setItem("dynamic_phantom_wallet_address", address.toString());
    }
  },
  encryptionPublicKey: {
    get: () => {
      const rawPublicKey = localStorage.getItem("dynamic_phantom_public_key");
      if (!rawPublicKey) {
        return void 0;
      }
      return new Uint8Array(JSON.parse(rawPublicKey));
    },
    remove: () => {
      localStorage.removeItem("dynamic_phantom_public_key");
    },
    set: (publicKey5) => {
      localStorage.setItem("dynamic_phantom_public_key", JSON.stringify([...publicKey5]));
    }
  },
  encryptionSecretKey: {
    get: () => {
      const rawSecretKey = localStorage.getItem("dynamic_phantom_secret_key");
      if (!rawSecretKey) {
        return void 0;
      }
      return new Uint8Array(JSON.parse(rawSecretKey));
    },
    remove: () => {
      localStorage.removeItem("dynamic_phantom_secret_key");
    },
    set: (secretKey) => {
      localStorage.setItem("dynamic_phantom_secret_key", JSON.stringify([...secretKey]));
    }
  },
  message: {
    get: () => {
      var _a21;
      const value = (_a21 = localStorage.getItem("dynamic_phantom_message_to_sign")) !== null && _a21 !== void 0 ? _a21 : void 0;
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] message.get", {
        hasMessage: Boolean(value),
        messageLength: value === null || value === void 0 ? void 0 : value.length,
        messagePreview: value === null || value === void 0 ? void 0 : value.substring(0, 100)
      });
      return value;
    },
    remove: () => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] message.remove");
      localStorage.removeItem("dynamic_phantom_message_to_sign");
    },
    set: (message) => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] message.set", {
        messageLength: message.length,
        messagePreview: message.substring(0, 100)
      });
      localStorage.setItem("dynamic_phantom_message_to_sign", message);
    }
  },
  method: {
    get: () => {
      var _a21;
      const value = (_a21 = localStorage.getItem("dynamic_phantom_method")) !== null && _a21 !== void 0 ? _a21 : void 0;
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] method.get", {
        value
      });
      return value;
    },
    remove: () => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] method.remove");
      localStorage.removeItem("dynamic_phantom_method");
    },
    set: (method) => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] method.set", {
        method
      });
      localStorage.setItem("dynamic_phantom_method", method);
    }
  },
  requestId: {
    get: () => {
      var _a21;
      return (_a21 = localStorage.getItem("dynamic_phantom_request_id")) !== null && _a21 !== void 0 ? _a21 : void 0;
    },
    remove: () => {
      localStorage.removeItem("dynamic_phantom_request_id");
    },
    set: (requestId) => {
      localStorage.setItem("dynamic_phantom_request_id", requestId);
    }
  },
  sendOptions: {
    get: () => {
      var _a21;
      return (_a21 = localStorage.getItem("dynamic_phantom_send_options")) !== null && _a21 !== void 0 ? _a21 : void 0;
    },
    remove: () => {
      localStorage.removeItem("dynamic_phantom_send_options");
    },
    set: (options) => {
      localStorage.setItem("dynamic_phantom_send_options", options);
    }
  },
  session: {
    get: () => {
      var _a21;
      const value = (_a21 = localStorage.getItem("dynamic_phantom_session")) !== null && _a21 !== void 0 ? _a21 : void 0;
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] session.get", {
        hasSession: Boolean(value)
      });
      return value;
    },
    remove: () => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] session.remove");
      localStorage.removeItem("dynamic_phantom_session");
    },
    set: (session) => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] session.set", {
        session
      });
      localStorage.setItem("dynamic_phantom_session", session);
    }
  },
  sharedSecret: {
    get: () => {
      const rawSharedSecret = localStorage.getItem("dynamic_phantom_shared_secret");
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] sharedSecret.get", { hasSharedSecret: Boolean(rawSharedSecret) });
      if (!rawSharedSecret) {
        return void 0;
      }
      return new Uint8Array(JSON.parse(rawSharedSecret));
    },
    remove: () => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] sharedSecret.remove");
      localStorage.removeItem("dynamic_phantom_shared_secret");
    },
    set: (sharedSecret) => {
      logger2.logVerboseTroubleshootingMessage("[PhantomStorage] sharedSecret.set", {
        sharedSecretLength: sharedSecret.length
      });
      localStorage.setItem("dynamic_phantom_shared_secret", JSON.stringify([...sharedSecret]));
    }
  }
};
var clearStorage = () => {
  logger2.logVerboseTroubleshootingMessage("[PhantomStorage] clearStorage called");
  for (const key in storage) {
    storage[key].remove();
  }
};

// node_modules/@dynamic-labs/solana/src/phantomRedirect/PhantomRedirect/PhantomRedirect.js
var PhantomRedirect = class extends SolanaWalletConnector {
  constructor(props) {
    super(Object.assign({}, props));
    this.name = "Phantom";
    this.overrideKey = "phantom";
  }
  getMethod() {
    throw new Error("Method not implemented.");
  }
  /**
   * Sets up a Promise/listener pattern for native mobile redirects.
   * Returns undefined if not on native mobile.
   */
  setupNativeMobileListener({ eventName, methodName, getResult, shouldIgnoreEvent }) {
    if (!PlatformService.isNativeMobile) {
      return void 0;
    }
    const requestId = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
    storage.requestId.set(requestId);
    logger2.logVerboseTroubleshootingMessage(`[PhantomRedirect] ${methodName} - setting up listener`, { requestId });
    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (event.requestId !== requestId || (shouldIgnoreEvent === null || shouldIgnoreEvent === void 0 ? void 0 : shouldIgnoreEvent(event, requestId))) {
          logger2.logVerboseTroubleshootingMessage(`[PhantomRedirect] ${methodName} - ignoring event (requestId mismatch)`, {
            expectedRequestId: requestId,
            receivedRequestId: event.requestId
          });
          return;
        }
        logger2.logVerboseTroubleshootingMessage(`[PhantomRedirect] ${methodName} - listener received matching event`, { errorCode: event.errorCode, requestId });
        this.off(eventName, listener);
        if (event.errorCode) {
          reject(new Error(event.errorMessage || event.errorCode));
        } else {
          resolve(getResult(event));
        }
      };
      this.on(eventName, listener);
    });
  }
  /**
   * Encrypts payload, builds Phantom redirect URL, stores method, and opens URL.
   */
  openPhantomUrl({ payload, sharedSecret, encryptionPublicKey, phantomEndpoint, methodToStore }) {
    const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
    const params = new URLSearchParams({
      dapp_encryption_public_key: import_bs5810.default.encode(encryptionPublicKey),
      nonce: import_bs5810.default.encode(nonce),
      payload: import_bs5810.default.encode(encryptedPayload),
      redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl())
    });
    const url = buildUrl(phantomEndpoint, params);
    storage.method.set(methodToStore);
    logger2.debug(`[PhantomRedirect] ${methodToStore} - opening Phantom`, {
      isNativeMobile: PlatformService.isNativeMobile
    });
    PlatformService.openURL(url);
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      const address = storage.address.get();
      if (address) {
        return address;
      }
      yield this.connect();
      return void 0;
    });
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      const connectionType = StorageService.getItem(PHANTOM_REDIRECT_CONNECTION_TYPE_KEY);
      if (connectionType) {
        if (connectionType.connectorConsumed) {
          StorageService.setItem(PHANTOM_REDIRECT_CONNECTION_TYPE_KEY, void 0);
        } else {
          connectionType.connectorConsumed = true;
          StorageService.setItem(PHANTOM_REDIRECT_CONNECTION_TYPE_KEY, connectionType);
        }
      }
      const keyPair = import_tweetnacl3.default.box.keyPair();
      storage.encryptionPublicKey.set(keyPair.publicKey);
      storage.encryptionSecretKey.set(keyPair.secretKey);
      const { href } = PlatformService.getUrl();
      const isLocalHost = href.includes("localhost") || href.includes("0.0.0.0") || href.includes("127.0.0.1");
      const currentNetwork = this.getSelectedNetwork();
      let cluster = (_a21 = currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.cluster) !== null && _a21 !== void 0 ? _a21 : "mainnet-beta";
      if (cluster === "mainnet") {
        cluster = "mainnet-beta";
      }
      const params = new URLSearchParams({
        app_url: isLocalHost ? "https://demo.dynamic.xyz" : href,
        cluster,
        dapp_encryption_public_key: import_bs5810.default.encode(keyPair.publicKey),
        redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl())
      });
      const url = buildUrl("connect", params);
      PlatformService.openURL(url);
    });
  }
  getSession() {
    return __awaiter2(this, void 0, void 0, function* () {
      const { data, nonce, phantom_encryption_public_key: phantomEncryptionPublicKey, encryptionSecretKey } = this.getInputsOrThrow("getSession", ["data", "nonce", "phantom_encryption_public_key"], ["encryptionSecretKey"]);
      const sharedSecret = import_tweetnacl3.default.box.before(import_bs5810.default.decode(phantomEncryptionPublicKey), encryptionSecretKey);
      storage.sharedSecret.set(sharedSecret);
      const connectData = decryptPayload(data, nonce, sharedSecret);
      storage.session.set(connectData.session);
      storage.address.set(new PublicKey3(connectData.public_key));
      return connectData.public_key;
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger2.debug("[PhantomRedirect] signMessage called", {
        messageLength: messageToSign.length,
        messagePreview: messageToSign.substring(0, 200)
      });
      const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow("signMessage", [], ["session", "sharedSecret", "encryptionPublicKey"]);
      storage.message.set(messageToSign);
      const payload = {
        message: import_bs5810.default.encode(Buffer.from(messageToSign)),
        session
      };
      this.openPhantomUrl({
        encryptionPublicKey,
        methodToStore: "signMessage",
        payload,
        phantomEndpoint: "signMessage",
        sharedSecret
      });
      const nativePromise = this.setupNativeMobileListener({
        eventName: "signMessage",
        getResult: (event) => event.signature,
        methodName: "signMessage",
        shouldIgnoreEvent: (event) => event.message !== messageToSign
      });
      if (nativePromise) {
        return nativePromise;
      }
      logger2.debug("[PhantomRedirect] signMessage - mobile web, throwing ignore error");
      throw new Error("ignore");
    });
  }
  extractSignature() {
    var _a21;
    logger2.debug("[PhantomRedirect] extractSignature called");
    const { data, nonce, sharedSecret, message } = this.getInputsOrThrow("extractSignature", ["data", "nonce"], ["sharedSecret", "message"]);
    logger2.debug("[PhantomRedirect] extractSignature - retrieved from storage", {
      dataPresent: Boolean(data),
      message,
      messageLength: message === null || message === void 0 ? void 0 : message.length,
      noncePresent: Boolean(nonce),
      sharedSecretPresent: Boolean(sharedSecret)
    });
    const signMessageData = decryptPayload(data, nonce, sharedSecret);
    logger2.debug("[PhantomRedirect] extractSignature - decrypted payload", {
      signature: signMessageData.signature,
      signatureLength: (_a21 = signMessageData.signature) === null || _a21 === void 0 ? void 0 : _a21.length
    });
    return {
      message,
      signature: signMessageData.signature
    };
  }
  extractTransactions() {
    const { data, nonce, sharedSecret } = this.getInputsOrThrow("extractTransactions", ["data", "nonce"], ["sharedSecret"]);
    const signAllTransactionsData = decryptPayload(data, nonce, sharedSecret);
    const decodedTransactions = signAllTransactionsData.transactions.map((t) => Transaction3.from(import_bs5810.default.decode(t)));
    return decodedTransactions;
  }
  extractTransaction() {
    const { data, nonce, sharedSecret } = this.getInputsOrThrow("extractTransaction", ["data", "nonce"], ["sharedSecret"]);
    const signTransactionData = decryptPayload(data, nonce, sharedSecret);
    const transactionBytes = import_bs5810.default.decode(signTransactionData.transaction);
    try {
      return VersionedTransaction3.deserialize(transactionBytes);
    } catch (_a21) {
      return Transaction3.from(transactionBytes);
    }
  }
  /**
   * Extracts the signed transaction and sends it to the network.
   * Used for signAndSendTransaction since Phantom redirect doesn't support it natively.
   * @returns The transaction signature
   */
  extractAndSendTransaction() {
    return __awaiter2(this, void 0, void 0, function* () {
      logger2.debug("[PhantomRedirect] extractAndSendTransaction called");
      const signedTransaction = this.extractTransaction();
      const sendOptionsJson = storage.sendOptions.get();
      storage.sendOptions.remove();
      const sendOptions = sendOptionsJson ? JSON.parse(sendOptionsJson) : void 0;
      logger2.debug("[PhantomRedirect] Sending transaction to network", {
        hasSendOptions: Boolean(sendOptions),
        isVersioned: signedTransaction instanceof VersionedTransaction3
      });
      const serialized = signedTransaction.serialize();
      const signature4 = yield this.getWalletClient().sendRawTransaction(serialized, sendOptions);
      logger2.debug("[PhantomRedirect] Transaction sent successfully", {
        signature: signature4
      });
      return signature4;
    });
  }
  consumeMethod() {
    const method = storage.method.get();
    storage.method.remove();
    return method;
  }
  consumeRequestId() {
    const requestId = storage.requestId.get();
    storage.requestId.remove();
    return requestId;
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      const address = storage.address.get();
      if (!address) {
        return void 0;
      }
      return {
        addListener: () => {
          throw new Error("Not implemented");
        },
        connect: () => {
          throw new Error("Not implemented");
        },
        disconnect: () => {
          throw new Error("Not implemented");
        },
        emit: () => {
          throw new Error("Not implemented");
        },
        eventNames: () => {
          throw new Error("Not implemented");
        },
        isBackpack: false,
        isBraveWallet: false,
        isConnected: true,
        isExodus: false,
        isGlow: false,
        isMagicEden: false,
        isPhantom: true,
        isSolflare: false,
        listenerCount: () => {
          throw new Error("Not implemented");
        },
        listeners: () => {
          throw new Error("Not implemented");
        },
        off: () => {
          throw new Error("Not implemented");
        },
        on: () => {
          throw new Error("Not implemented");
        },
        once: () => {
          throw new Error("Not implemented");
        },
        providers: [],
        publicKey: new PublicKey3(address),
        removeAllListeners: () => {
          throw new Error("Not implemented");
        },
        removeListener: () => {
          throw new Error("Not implemented");
        },
        signAllTransactions: (transactions) => __awaiter2(this, void 0, void 0, function* () {
          const serializedTransactions = transactions.map((t) => import_bs5810.default.encode(t.serialize({
            requireAllSignatures: false
          })));
          const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow("signAllTransactions", [], ["session", "sharedSecret", "encryptionPublicKey"]);
          const payload = {
            session,
            transactions: serializedTransactions
          };
          this.openPhantomUrl({
            encryptionPublicKey,
            methodToStore: "signAllTransactions",
            payload,
            phantomEndpoint: "signAllTransactions",
            sharedSecret
          });
          const nativePromise = this.setupNativeMobileListener({
            eventName: "signAllTransactions",
            getResult: (event) => event.transactions || [],
            methodName: "signAllTransactions"
          });
          if (nativePromise) {
            return nativePromise;
          }
          return [];
        }),
        signAndSendTransaction: (transaction, options) => __awaiter2(this, void 0, void 0, function* () {
          const serializedTransaction = import_bs5810.default.encode(transaction.serialize({ requireAllSignatures: false }));
          const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow("signAndSendTransaction", [], ["session", "sharedSecret", "encryptionPublicKey"]);
          const payload = {
            session,
            transaction: serializedTransaction
          };
          if (options) {
            storage.sendOptions.set(JSON.stringify(options));
          }
          this.openPhantomUrl({
            encryptionPublicKey,
            methodToStore: "signAndSendTransaction",
            payload,
            phantomEndpoint: "signTransaction",
            sharedSecret
          });
          const nativePromise = this.setupNativeMobileListener({
            eventName: "signAndSendTransaction",
            getResult: (event) => ({ signature: event.signature || "" }),
            methodName: "signAndSendTransaction"
          });
          if (nativePromise) {
            return nativePromise;
          }
          return { signature: "" };
        }),
        signMessage: (message) => __awaiter2(this, void 0, void 0, function* () {
          const messageString = new TextDecoder().decode(message);
          const signature4 = yield this.signMessage(messageString);
          return {
            signature: signature4 ? import_bs5810.default.decode(signature4) : new Uint8Array(0)
          };
        }),
        signTransaction: (transaction) => __awaiter2(this, void 0, void 0, function* () {
          const serializedTransaction = import_bs5810.default.encode(transaction.serialize({
            requireAllSignatures: false
          }));
          const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow("signTransaction", [], ["session", "sharedSecret", "encryptionPublicKey"]);
          const payload = {
            session,
            transaction: serializedTransaction
          };
          this.openPhantomUrl({
            encryptionPublicKey,
            methodToStore: "signTransaction",
            payload,
            phantomEndpoint: "signTransaction",
            sharedSecret
          });
          const nativePromise = this.setupNativeMobileListener({
            eventName: "signTransaction",
            getResult: (event) => event.transaction,
            methodName: "signTransaction"
          });
          if (nativePromise) {
            return nativePromise;
          }
          return transaction;
        })
      };
    });
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      const address = storage.address.get();
      return address ? [address] : [];
    });
  }
  endSession() {
    return __awaiter2(this, void 0, void 0, function* () {
      const address = storage.address.get();
      const session = storage.session.get();
      const sharedSecret = storage.sharedSecret.get();
      const encryptionPublicKey = storage.encryptionPublicKey.get();
      clearStorage();
      if (!address || !session || !encryptionPublicKey || !sharedSecret)
        return;
      const payload = { session };
      const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
      const params = new URLSearchParams({
        dapp_encryption_public_key: import_bs5810.default.encode(encryptionPublicKey),
        nonce: import_bs5810.default.encode(nonce),
        payload: import_bs5810.default.encode(encryptedPayload),
        redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl())
      });
      const url = buildUrl("disconnect", params);
      PlatformService.openURL(url);
    });
  }
  /**
   * Helper method to get inputs from query params and localstorage
   *
   * The second argument is used to read values from the query string
   *   e.g. ['data', 'nonce'] -> params.get('data') and params.get('nonce')
   *
   * The third argument is used to read values from local storage
   *   e.g. ['address', 'message'] -> storage.address.get() and storage.message.get()
   *
   * Throws an error if any of the inputs are unable to be found in their respective locations
   */
  getInputsOrThrow(methodName, queryParams, storageParams) {
    const inputs = {};
    const queryString = PlatformService.getUrl().searchParams;
    queryParams.forEach((param) => {
      const value = queryString.get(param);
      if (!value) {
        throw new Error(`[PhantomRedirect] ${methodName} called, but required input '${param}' not found in query params`);
      }
      inputs[param] = value;
    });
    storageParams.forEach((storageParam) => {
      const value = storage[storageParam].get();
      if (!value) {
        throw new Error(`[PhantomRedirect] ${methodName} called, but required input '${storageParam}' not found in local storage`);
      }
      inputs[storageParam] = value;
    });
    return inputs;
  }
};

// node_modules/@dynamic-labs/solana/src/Phantom/Phantom.js
var Phantom = class extends SolanaWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "Phantom";
    this.overrideKey = "phantom";
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getMobileOrInstalledWallet().connect();
    });
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.getMobileOrInstalledWallet().getSigner();
    });
  }
  getMobileOrInstalledWallet() {
    const phantomInjected = new PhantomInjected(this.constructorProps);
    if (isMobile() && !phantomInjected.isInstalledOnBrowser() && this.mobileExperience === "redirect") {
      return new PhantomRedirect(this.constructorProps);
    }
    return phantomInjected;
  }
};
Object.defineProperty(Phantom, "key", {
  value: "phantom",
  writable: false
});

// node_modules/@dynamic-labs/solana/src/CoinbaseSolana/CoinbaseSolana.js
var CoinbaseSolana = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "CoinbaseSolana";
    this.overrideKey = "coinbasesolana";
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21;
      return (_a21 = this.solProviderHelper) === null || _a21 === void 0 ? void 0 : _a21.connect();
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const walletAddress = yield this.getAddress();
      if (!walletAddress) {
        return void 0;
      }
      const provider = yield this.getSigner();
      if (!provider) {
        return void 0;
      }
      const encodedMessage = new TextEncoder().encode(messageToSign);
      const signedMessage = yield provider.signMessage(encodedMessage, walletAddress);
      if (!signedMessage) {
        return void 0;
      }
      return bufferToBase64(isSignedMessage(signedMessage) ? signedMessage.signature : signedMessage);
    });
  }
};
Object.defineProperty(CoinbaseSolana, "key", {
  value: "coinbasesolana",
  writable: false
});

// node_modules/@dynamic-labs/solana/src/Solflare/Solflare.js
var Solflare = class extends InjectedWalletBase {
  constructor(props) {
    super(props);
    this.name = "Solflare";
    this.overrideKey = "solflare";
    this.walletConnectWalletBookEntry = findWalletBookWallet(props.walletBook, this.key);
  }
  getMobileOrInstalledWallet() {
    if (isMobile()) {
      return this;
    }
    return super.getMobileOrInstalledWallet();
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a21, _b;
      if (isMobile() && !this.isInstalledOnBrowser()) {
        const mobileDeepLinks = (_a21 = this.metadata.deepLinks) === null || _a21 === void 0 ? void 0 : _a21.mobile;
        handleMobileWalletRedirect({
          nativeLink: (mobileDeepLinks === null || mobileDeepLinks === void 0 ? void 0 : mobileDeepLinks.native) || "solflare://ul/v1/browse",
          universalLink: (mobileDeepLinks === null || mobileDeepLinks === void 0 ? void 0 : mobileDeepLinks.universal) || "https://solflare.com/ul/v1/browse"
        });
        return;
      }
      return (_b = this.solProviderHelper) === null || _b === void 0 ? void 0 : _b.getAddress();
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const walletAddress = yield this.getAddress();
      if (!walletAddress) {
        return void 0;
      }
      const provider = yield this.getSigner();
      if (!provider) {
        return void 0;
      }
      const encodedMessage = new TextEncoder().encode(messageToSign);
      const isSignedMessage2 = (value) => value.signature !== void 0;
      yield provider.connect();
      yield new Promise((resolve) => {
        setTimeout(resolve, 100);
      });
      const rawMessage = yield provider.signMessage(encodedMessage, "utf8");
      return isSignedMessage2(rawMessage) ? bufferToBase64(rawMessage.signature) : void 0;
    });
  }
};
Object.defineProperty(Solflare, "key", {
  value: "solflare",
  writable: false
});

// node_modules/@dynamic-labs/solana/src/utils/getConnectorConstructorInjectedWallet/getConnectorConstructorInjectedWallet.js
var getConnectorConstructorInjectedWallet = ({ key, wallet, walletBook }) => {
  const { shortName } = wallet;
  const name2 = shortName || wallet.name;
  let walletConnectWalletBookEntry = void 0;
  if (wallet.group) {
    walletConnectWalletBookEntry = Object.values(walletBook.wallets).find((entry) => {
      var _a21;
      return entry.walletConnect && entry.group === wallet.group && // Disregard if the wallet connect data does not support Solana. WC chains are prefixed with 'solana:'
      // as they follow CAIP-2 format
      ((_a21 = entry.chains) === null || _a21 === void 0 ? void 0 : _a21.some((chain6) => chain6.includes("solana:")));
    });
  }
  const InjectedWalletConstructor = class extends InjectedWalletBase {
    constructor() {
      super(...arguments);
      this.walletName = name2;
      this.name = name2;
      this.walletConnectWalletBookEntry = walletConnectWalletBookEntry;
      this.overrideKey = key;
    }
  };
  Object.defineProperty(InjectedWalletConstructor, "key", {
    value: key,
    writable: false
  });
  return InjectedWalletConstructor;
};

// node_modules/@dynamic-labs/solana/src/injected/walletStandard/createSolanaSignerFromWalletStandard/createSolanaSignerFromWalletStandard.js
var import_bs5811 = __toESM(require_bs583(), 1);
var isVersionedTransaction2 = (transaction) => !("instructions" in transaction);
var createSolanaSignerFromWalletStandard = ({ wallet, walletConnector }) => {
  const features = wallet.features;
  const hasAutoConnectedAccounts = () => {
    var _a21, _b, _c3;
    return Boolean(((_a21 = wallet.accounts) === null || _a21 === void 0 ? void 0 : _a21.length) > 0 && ((_b = wallet.accounts[0]) === null || _b === void 0 ? void 0 : _b.publicKey) && ((_c3 = wallet.accounts[0]) === null || _c3 === void 0 ? void 0 : _c3.address));
  };
  const connect = (args) => __awaiter2(void 0, void 0, void 0, function* () {
    var _a21;
    const autoConnectedAccounts = wallet.accounts;
    logger2.logVerboseTroubleshootingMessage("[SolanaWalletStandardConnector] - connect", {
      autoConnectedAccounts
    });
    if (hasAutoConnectedAccounts()) {
      return {
        address: autoConnectedAccounts[0].address,
        publicKey: autoConnectedAccounts[0].publicKey
      };
    }
    const connectMethod = (_a21 = features["standard:connect"]) === null || _a21 === void 0 ? void 0 : _a21.connect;
    if (!connectMethod) {
      logger2.error("connect - Not implemented");
      return;
    }
    const result = yield connectMethod({ silent: false });
    if (!result.accounts[0]) {
      return;
    }
    return {
      address: result.accounts[0].address,
      publicKey: result.accounts[0].publicKey
    };
  });
  const disconnect = () => __awaiter2(void 0, void 0, void 0, function* () {
    var _b;
    const disconnectMethod = (_b = features["standard:disconnect"]) === null || _b === void 0 ? void 0 : _b.disconnect;
    if (!disconnectMethod) {
      logger2.debug("disconnect - Not implemented");
      return;
    }
    yield disconnectMethod();
  });
  const getCurrentAccount = () => __awaiter2(void 0, void 0, void 0, function* () {
    const address = yield walletConnector.getAddress();
    const account = wallet.accounts.find((account2) => account2.address === address);
    if (!account) {
      throw new Error("Account not found");
    }
    return account;
  });
  const getChain = () => {
    var _a21;
    const currentNetwork = walletConnector.getSelectedNetwork();
    if (!currentNetwork) {
      throw new Error("Network not found");
    }
    const cluster = (_a21 = currentNetwork.cluster) !== null && _a21 !== void 0 ? _a21 : "mainnet";
    return `solana:${cluster}`;
  };
  const signTransaction3 = (transaction) => __awaiter2(void 0, void 0, void 0, function* () {
    const signedTransactions = yield signAllTransactions([transaction]);
    return signedTransactions[0];
  });
  const signAllTransactions = (transactions) => __awaiter2(void 0, void 0, void 0, function* () {
    const signTransactionMethod = features["solana:signTransaction"].signTransaction;
    const account = yield getCurrentAccount();
    const chain6 = getChain();
    const transactionsInput = transactions.map((transaction) => ({
      account,
      chain: chain6,
      transaction: transaction.serialize({
        requireAllSignatures: false
      })
    }));
    const signTransactionResult = yield signTransactionMethod(...transactionsInput);
    const signedTransactions = signTransactionResult.map(({ signedTransaction }, index) => {
      const inputTransaction = transactions[index];
      if (isVersionedTransaction2(inputTransaction)) {
        return VersionedTransaction3.deserialize(signedTransaction);
      }
      return Transaction3.from(signedTransaction);
    });
    return signedTransactions;
  });
  const signAndSendTransaction = (transaction) => __awaiter2(void 0, void 0, void 0, function* () {
    var _c3;
    const signAndSendTransactionMethod = (_c3 = features["solana:signAndSendTransaction"]) === null || _c3 === void 0 ? void 0 : _c3.signAndSendTransaction;
    if (!signAndSendTransactionMethod) {
      logger2.error("signAndSendTransaction - Not implemented");
      throw new Error("signAndSendTransaction - Not implemented by wallet");
    }
    const account = yield getCurrentAccount();
    const signedTransactions = yield signAndSendTransactionMethod({
      account,
      chain: getChain(),
      transaction: transaction.serialize({
        requireAllSignatures: false
      })
    });
    const [{ signature: signature4 }] = signedTransactions;
    return { signature: import_bs5811.default.encode(signature4) };
  });
  const signMessage3 = (message) => __awaiter2(void 0, void 0, void 0, function* () {
    var _d;
    const signMessageMethod = (_d = features["solana:signMessage"]) === null || _d === void 0 ? void 0 : _d.signMessage;
    if (!signMessageMethod) {
      logger2.error("signMessage - Not implemented");
      throw new Error("signMessage - Not implemented by wallet");
    }
    const account = yield getCurrentAccount();
    const messages = yield signMessageMethod({
      account,
      message
    });
    return { signature: messages[0].signature };
  });
  const on6 = (event, listener) => {
    var _a21;
    const onMethod = (_a21 = features["standard:events"]) === null || _a21 === void 0 ? void 0 : _a21.on;
    if (!onMethod) {
      logger2.error("on - Not implemented");
      return;
    }
    logger2.debug(`[SolanaWalletStandardConnector] - on: ${event}`);
    if (event !== "accountChanged") {
      logger2.debug(`on - Not implemented for event: ${event}`);
      return;
    }
    const wrappedListener = (prop) => {
      var _a22, _b;
      const publicKey5 = (_b = (_a22 = prop.accounts) === null || _a22 === void 0 ? void 0 : _a22[0]) === null || _b === void 0 ? void 0 : _b.publicKey;
      if (publicKey5) {
        listener(new TextDecoder().decode(publicKey5));
      }
    };
    return onMethod("change", wrappedListener);
  };
  return {
    addListener: () => {
      throw new Error("addListener - Not implemented");
    },
    connect,
    disconnect,
    emit: () => {
      throw new Error("emit - Not implemented");
    },
    eventNames: () => {
      logger2.error("eventNames - Not implemented");
      return [];
    },
    isBackpack: false,
    isBraveWallet: false,
    isConnected: hasAutoConnectedAccounts(),
    isExodus: false,
    isGlow: false,
    isMagicEden: false,
    isPhantom: false,
    isSolflare: false,
    listenerCount: () => {
      logger2.error("listenerCount - Not implemented");
      return 0;
    },
    listeners: () => {
      logger2.error("listeners - Not implemented");
      return [];
    },
    off: () => {
      throw new Error("off - Not implemented");
    },
    on: on6,
    once: () => {
      throw new Error("once - Not implemented");
    },
    providers: [],
    get publicKey() {
      var _a21, _b;
      if (!((_b = (_a21 = wallet.accounts) === null || _a21 === void 0 ? void 0 : _a21[0]) === null || _b === void 0 ? void 0 : _b.publicKey)) {
        return void 0;
      }
      return new PublicKey3(wallet.accounts[0].publicKey);
    },
    removeAllListeners: () => {
      throw new Error("removeAllListeners - Not implemented");
    },
    removeListener: () => {
      throw new Error("removeListener - Not implemented");
    },
    send: () => {
      throw new Error("send - Not implemented");
    },
    signAllTransactions,
    signAndSendTransaction,
    signMessage: signMessage3,
    signTransaction: signTransaction3
  };
};

// node_modules/@dynamic-labs/solana/src/injected/walletStandard/getConnectorConstructorForWalletStandardWallet/getConnectorConstructorForWalletStandardWallet.js
var getConnectorConstructorForWalletStandardWallet = (wallet, walletBookMetadata = {}, walletBookKey = void 0) => {
  const sanitizedName = sanitizeName(wallet.name);
  const ConnectorConstructor = class extends InjectedWalletBase {
    constructor(props) {
      super(Object.assign(Object.assign({}, props), { metadata: Object.assign(Object.assign({}, walletBookMetadata), { groupKey: sanitizedName, icon: wallet.icon, id: sanitizedName, name: wallet.name }) }));
      this.name = wallet.name;
      this.overrideKey = `${sanitizedName}sol`;
      this._provider = createSolanaSignerFromWalletStandard({
        wallet,
        walletConnector: this
      });
    }
    findProvider() {
      return this._provider;
    }
  };
  Object.defineProperty(ConnectorConstructor, "key", {
    value: walletBookKey !== null && walletBookKey !== void 0 ? walletBookKey : sanitizedName,
    writable: false
  });
  return ConnectorConstructor;
};

// node_modules/@dynamic-labs/solana/src/injected/walletStandard/getWalletStandardWallets/getWalletStandardWallets.js
var getWalletStandardWallets = () => {
  const { get: get9, on: on6 } = getWallets();
  return {
    on: on6,
    wallets: get9()
  };
};

// node_modules/@dynamic-labs/solana/src/injected/walletStandard/hasAllWalletStandardRequiredFeatures/hasAllWalletStandardRequiredFeatures.js
var hasAllWalletStandardRequiredFeatures = (wallet, authMode = "connect-and-sign") => {
  var _a21, _b, _c3, _d;
  const hasBasicFeatures = Boolean(((_a21 = wallet.features) === null || _a21 === void 0 ? void 0 : _a21["standard:events"]) && ((_b = wallet.features) === null || _b === void 0 ? void 0 : _b["standard:connect"]) && ((_c3 = wallet.features) === null || _c3 === void 0 ? void 0 : _c3["solana:signTransaction"]));
  const hasAuthModeFeatures = authMode === "connect-and-sign" ? Boolean((_d = wallet.features) === null || _d === void 0 ? void 0 : _d["solana:signMessage"]) : true;
  return hasBasicFeatures && hasAuthModeFeatures;
};

// node_modules/@dynamic-labs/solana/src/injected/fetchInjectedWalletConnectors.js
var removeSolanaWalletStandardListener = null;
var injectedWalletOverrides = [
  CoinbaseSolana,
  BackpackSol,
  Solflare
];
var walletsWithCustomConnectors = [
  "coinbasesolana",
  "phantom",
  "phantomledger",
  "backpacksol",
  "solflare"
];
var shouldAddWalletStandardConnector = (wallet, walletBook, authMode) => {
  var _a21;
  const { name: name2 } = wallet;
  const chain6 = "sol";
  const connectorKey = `${sanitizeName(name2)}${chain6}`;
  logger2.logVerboseTroubleshootingMessage("[SOL shouldAddWalletStandardConnector]", name2, chain6, connectorKey, wallet.features);
  const shouldHandleWalletFromWalletBook = ([key, wallet2]) => {
    var _a22, _b, _c3, _d, _e6, _f3;
    const hasMatchingKey = key === connectorKey;
    const needsCustomConnector = walletsWithCustomConnectors.includes(connectorKey);
    const hasMatchingNameAndChain = wallet2.name === name2 && ((_b = (_a22 = wallet2.injectedConfig) === null || _a22 === void 0 ? void 0 : _a22[0]) === null || _b === void 0 ? void 0 : _b.chain) === chain6;
    const isNotWalletStandard = !((_f3 = (_e6 = (_d = (_c3 = wallet2.injectedConfig) === null || _c3 === void 0 ? void 0 : _c3[0]) === null || _d === void 0 ? void 0 : _d.walletStandard) === null || _e6 === void 0 ? void 0 : _e6.features) === null || _f3 === void 0 ? void 0 : _f3.length);
    return (hasMatchingKey || needsCustomConnector || hasMatchingNameAndChain) && isNotWalletStandard;
  };
  const shouldHandleFromWalletBook = Object.entries((_a21 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a21 !== void 0 ? _a21 : {}).find(shouldHandleWalletFromWalletBook);
  const hasAllFeatures = hasAllWalletStandardRequiredFeatures(wallet, authMode);
  logger2.logVerboseTroubleshootingMessage("[SOL shouldAddWalletStandardConnector]", {
    hasAllFeatures,
    shouldAdd: !shouldHandleFromWalletBook && hasAllFeatures,
    shouldHandleFromWalletBook
  });
  return !shouldHandleFromWalletBook && hasAllFeatures;
};
var addSolanaWalletStandardListener = (walletBook, authMode) => {
  if (typeof window === "undefined") {
    return;
  }
  removeSolanaWalletStandardListener === null || removeSolanaWalletStandardListener === void 0 ? void 0 : removeSolanaWalletStandardListener();
  const { on: on6 } = getWalletStandardWallets();
  removeSolanaWalletStandardListener = on6("register", (wallet) => {
    var _a21, _b;
    if (!shouldAddWalletStandardConnector(wallet, walletBook, authMode)) {
      return;
    }
    logger2.logVerboseTroubleshootingMessage("[SOL fetchInjectedWalletConnectors] Wallet registered via wallet-standard", wallet.name);
    const walletBookWallet = findWalletBookWalletByNameAndChain(walletBook, wallet.name, "sol");
    const walletKey = walletBookWallet ? (_b = Object.entries((_a21 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a21 !== void 0 ? _a21 : {}).find(([, entry]) => entry === walletBookWallet)) === null || _b === void 0 ? void 0 : _b[0] : void 0;
    const walletBookMetadata = walletBookWallet && getWalletMetadataFromWalletBook({
      walletBook,
      walletBookWallet,
      walletKey: walletKey !== null && walletKey !== void 0 ? walletKey : `${sanitizeName(wallet.name)}sol`
    });
    const injectedConnectorConstructor = getConnectorConstructorForWalletStandardWallet(wallet, walletBookMetadata, walletKey);
    walletConnectorEvents.emit("providerInjected", {
      injectedConnectorConstructor
    });
  });
};
var fetchInjectedWalletConnectors = ({ walletBook, authMode }) => {
  var _a21;
  addSolanaWalletStandardListener(walletBook, authMode);
  const walletBookConnectors = Object.entries((_a21 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a21 !== void 0 ? _a21 : {}).filter(([key, wallet]) => {
    var _a22, _b, _c3;
    const injectedConfig = (_a22 = wallet.injectedConfig) === null || _a22 === void 0 ? void 0 : _a22.find((config) => config.chain === "sol");
    const isSolanaWallet2 = Boolean(injectedConfig);
    const shouldBeFiltered = walletsWithCustomConnectors.includes(key) || ((_c3 = (_b = injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.walletStandard) === null || _b === void 0 ? void 0 : _b.features) === null || _c3 === void 0 ? void 0 : _c3.length);
    return isSolanaWallet2 && !shouldBeFiltered;
  }).map(([key, wallet]) => getConnectorConstructorInjectedWallet({ key, wallet, walletBook }));
  const { wallets: walletStandardWallets } = getWalletStandardWallets();
  const walletStandardConnectors = walletStandardWallets.filter((wallet) => shouldAddWalletStandardConnector(wallet, walletBook, authMode)).map((wallet) => {
    var _a22, _b;
    const [walletBookKey, walletBookWallet] = (_b = Object.entries((_a22 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a22 !== void 0 ? _a22 : {}).find(([, walletBookEntry]) => {
      var _a23, _b2;
      return walletBookEntry.name === wallet.name && ((_b2 = (_a23 = walletBookEntry.injectedConfig) === null || _a23 === void 0 ? void 0 : _a23[0]) === null || _b2 === void 0 ? void 0 : _b2.chain) === "sol";
    })) !== null && _b !== void 0 ? _b : [];
    const walletBookMetadata = walletBookWallet && getWalletMetadataFromWalletBook({
      walletBook,
      walletBookWallet,
      walletKey: walletBookKey !== null && walletBookKey !== void 0 ? walletBookKey : `${sanitizeName(wallet.name)}sol`
    });
    return getConnectorConstructorForWalletStandardWallet(wallet, walletBookMetadata, walletBookKey);
  });
  logger2.logVerboseTroubleshootingMessage("[SOL fetchInjectedWalletConnectors] walletStandardConnectors", walletStandardConnectors.map((w4) => w4.name));
  return [...walletBookConnectors, ...walletStandardConnectors];
};

// node_modules/@dynamic-labs/solana/src/injected/FallbackSolanaConnector/FallbackSolanaConnector.js
var FallbackSolanaConnector = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "Fallback Connector";
    this.overrideKey = "fallbackconnector";
    this.isAvailable = false;
  }
  isInstalledOnBrowser() {
    return false;
  }
};
Object.defineProperty(FallbackSolanaConnector, "key", {
  value: "fallbackconnector",
  writable: false
});

// node_modules/@dynamic-labs/solana/src/SolanaWalletConnectors.js
var import_bs5812 = __toESM(require_bs583(), 1);

// node_modules/@dynamic-labs/solana/src/walletConnect/utils/getSolanaWalletConnectConnector/getSolanaWalletConnectConnector.js
var getSolanaWalletConnectConnector = () => {
  const SolanaWalletConnectConnectorConstructor = class extends SolanaWalletConnectConnector {
    constructor(props) {
      super(Object.assign(Object.assign({}, props), { metadata: { groupKey: "walletconnect", name: "WalletConnect" }, walletName: "WalletConnect Sol" }));
    }
  };
  Object.defineProperty(SolanaWalletConnectConnectorConstructor, "key", {
    value: "walletconnectsol",
    writable: false
  });
  return SolanaWalletConnectConnectorConstructor;
};

// node_modules/@dynamic-labs/solana/src/walletConnect/utils/addSolanaWalletConnectConnectors/addSolanaWalletConnectConnectors.js
var addSolanaWalletConnectConnectors = ({ walletBook, connectors: currentConnectors }) => {
  var _a21;
  const walletEntries = Object.entries((_a21 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a21 !== void 0 ? _a21 : {});
  const allWcConstructors = walletEntries.filter(([, wallet]) => {
    var _a22;
    return wallet.walletConnect && // Exclude wallets that don't support Solana
    ((_a22 = wallet.chains) === null || _a22 === void 0 ? void 0 : _a22.some((chain6) => chain6.includes("solana:")));
  }).map(([key, wallet]) => {
    const { shortName } = wallet;
    const name2 = shortName || wallet.name;
    const SolanaWalletConnectConnectorConstructor = class extends SolanaWalletConnectConnector {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { metadata: getWalletMetadataFromWalletBook({
          walletBook,
          walletBookWallet: wallet,
          walletKey: key
        }), overrideKey: key, walletName: name2 }));
        this.overrideKey = key;
      }
    };
    const entryKeysWithSameGroup = walletEntries.filter(([, { group }]) => group && group === wallet.group).map(([key2]) => key2);
    Object.defineProperty(SolanaWalletConnectConnectorConstructor, "key", {
      value: key,
      writable: false
    });
    Object.defineProperty(SolanaWalletConnectConnectorConstructor, "groupedKeys", {
      value: entryKeysWithSameGroup,
      writable: false
    });
    return SolanaWalletConnectConnectorConstructor;
  });
  let filteredWcConstructors = allWcConstructors;
  if (currentConnectors.length > 0) {
    filteredWcConstructors = allWcConstructors.filter((constructor) => currentConnectors.every((existingConnector) => (
      // @ts-expect-error - the key type is not defined for the constructor
      existingConnector["key"] !== constructor["key"] && // @ts-expect-error - the key type is not defined for the constructor
      !constructor["groupedKeys"].includes(existingConnector["key"])
    )));
  }
  return [...currentConnectors, ...filteredWcConstructors];
};

// node_modules/@dynamic-labs/solana/src/SolanaWalletConnectors.js
var SolanaWalletConnectors = (props) => {
  const solNetworks = props.solNetworks || [];
  const hasSolanaNetworks = solNetworks.length > 0;
  const initialConnectors = [
    ...injectedWalletOverrides,
    ...fetchInjectedWalletConnectors(props),
    ...TurnkeySolanaWalletConnectors(props),
    ...DynamicWaasSVMConnectors(),
    Phantom,
    FallbackSolanaConnector,
    ...hasSolanaNetworks ? [getSolanaWalletConnectConnector()] : []
  ];
  if (!hasSolanaNetworks) {
    return initialConnectors;
  }
  return addSolanaWalletConnectConnectors({
    connectors: initialConnectors,
    walletBook: props.walletBook
  });
};

// node_modules/@dynamic-labs/solana/src/walletConnect/SolanaWalletConnectConnectors.js
var SolanaWalletConnectConnectors = (props) => addSolanaWalletConnectConnectors({
  connectors: [],
  walletBook: props.walletBook
});

// node_modules/@dynamic-labs/solana/src/SolanaWalletConnectorsWithConfig/SolanaWalletConnectorsWithConfig.js
var SolanaWalletConnectorsWithConfig = (connectionConfig) => {
  const classWithConfig = (className) => class extends className {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...args) {
      const [opts2] = args;
      super(Object.assign(Object.assign({}, opts2), { connectionConfig }));
    }
  };
  return (props) => SolanaWalletConnectors(props).map(classWithConfig);
};

// node_modules/@dynamic-labs/solana/src/utils/isBackpackSolanaSigner.js
var isBackpackSolanaSigner = (signer) => Boolean(signer) && signer.send !== void 0;

// node_modules/@dynamic-labs/solana/src/index.js
assertPackageVersion("@dynamic-labs/solana", version);
export {
  BackpackSol as BackpackConnector,
  PhantomRedirect,
  InjectedWalletBase as SolanaInjectedConnector,
  SolanaWalletConnectConnectors,
  SolanaWalletConnector,
  SolanaWalletConnectors,
  SolanaWalletConnectorsWithConfig,
  createSolanaSignerFromWalletStandard,
  getWalletStandardWallets,
  hasAllWalletStandardRequiredFeatures,
  isBackpackSolanaSigner,
  isSignedMessage,
  isSolanaWallet
};
/*! Bundled license information:

tslib/tslib.es6.js:
tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

statuses/index.js:
statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toidentifier/index.js:
  (*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

http-errors/index.js:
http-errors/index.js:
  (*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@walletconnect/relay-auth/dist/index.es.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@walletconnect/utils/dist/index.es.js:
@walletconnect/utils/dist/index.es.js:
@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/post-quantum/utils.js:
@noble/post-quantum/_crystals.js:
@noble/post-quantum/ml-kem.js:
  (*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) *)

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.27
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.5.27
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=@dynamic-labs_solana.js.map
