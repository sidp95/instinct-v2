Object.defineProperty(exports,"__esModule",{value:!0}),exports.Ed25519=void 0;const _1=require("./index.cjs"),utils_1=require("@noble/hashes/utils"),common_1=require("./common.cjs");class Ed25519{constructor(native,url){this.NATIVE=native,this.URL=url}async initKeygen(){const keygenInitKeypair=await(await this.NATIVE).initKeygen();return new _1.Ed25519InitKeygenResult(keygenInitKeypair.pubkey,keygenInitKeypair.keypair)}async exportID(keygenResult){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare;return(await this.NATIVE).ed25519GetExportID(secretShare)}async createRoom(numParties,apiKey){return(0,common_1.sanitizeNumberOfParties)(numParties),(await this.NATIVE).createRoom(this.URL,numParties,apiKey)}async keygen(roomUuid,numParties,threshold,keygenInit,keygenIds){if((0,common_1.sanitizeNumberOfParties)(numParties,threshold),keygenIds.length!==numParties-1)throw new Error(`keygenIds length must be exactly: ${numParties-1}, it is: `+keygenIds.length);const keygenResult=await(await this.NATIVE).ed25519Keygen(roomUuid,this.URL,numParties,threshold,keygenInit.keygenSecret,keygenIds);if(!keygenResult.pubkey||!keygenResult.secret_share)throw new Error("Keygen failed, no public key or secret share was returned.");const pubkey=(0,utils_1.hexToBytes)(keygenResult.pubkey),secretShareHex=keygenResult.secret_share;return new _1.Ed25519KeygenResult(pubkey,secretShareHex)}async sign(roomUuid,keygenResult,msg,derivationPath=new Uint32Array){"string"!=typeof msg&&(msg=(0,utils_1.bytesToHex)(msg));const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,signature=await(await this.NATIVE).ed25519Sign(roomUuid,this.URL,secretShare,msg,Array.from(derivationPath));return(0,utils_1.hexToBytes)(signature)}async refresh(roomUuid,keygenResult){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,refreshedKeygenResult=await(await this.NATIVE).ed25519Refresh(roomUuid,this.URL,secretShare);if(!refreshedKeygenResult.pubkey||!refreshedKeygenResult.secret_share)throw new Error("Keygen failed, no public key or secret share was returned.");const pubkey=(0,utils_1.hexToBytes)(refreshedKeygenResult.pubkey),secretShareHex=refreshedKeygenResult.secret_share;return new _1.Ed25519KeygenResult(pubkey,secretShareHex)}async reshareNewParty(roomUuid,oldThreshold,newThreshold,keygenInit,keygenIds){const resharedKeygenResult=await(await this.NATIVE).ed25519ReshareNewParty(roomUuid,this.URL,oldThreshold,newThreshold,keygenInit.keygenSecret,keygenIds),pubkey=(0,utils_1.hexToBytes)(resharedKeygenResult.pubkey),secretShareHex=resharedKeygenResult.secret_share;return new _1.Ed25519KeygenResult(pubkey,secretShareHex)}async reshareRemainingParty(roomUuid,newThreshold,keygenResult,keygenIds){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,resharedKeygenResult=await(await this.NATIVE).ed25519ReshareRemainingParty(roomUuid,this.URL,newThreshold,secretShare,keygenIds),pubkey=(0,utils_1.hexToBytes)(resharedKeygenResult.pubkey),secretShareHex=resharedKeygenResult.secret_share;return new _1.Ed25519KeygenResult(pubkey,secretShareHex)}async derivePubkey(keygenResult,derivationPath=new Uint32Array){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,pubkey=await(await this.NATIVE).ed25519DerivePubkey(secretShare,Array.from(derivationPath));return(0,utils_1.hexToBytes)(pubkey)}async getSpub(keygenResult){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare;return(await this.NATIVE).ed25519GetSpub(secretShare)}async derivePubkeyFromSpub(spub,derivation){const pubkey=await(await this.NATIVE).ed25519DerivePubkeyFromSpub(spub,Array.from(derivation));return(0,utils_1.hexToBytes)(pubkey)}async exportFullPrivateKey(roomUuid,keygenResult,toExportID){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,exported=await(await this.NATIVE).ed25519ExportFullPrivateKey(roomUuid,this.URL,secretShare,toExportID);return exported||void 0}async derivePrivateKeyFromSpriv(spriv,derivationPath=new Uint32Array){return(await this.NATIVE).ed25519DerivePrivateKeyFromSpriv(spriv,Array.from(derivationPath))}async offlineExportFullPrivateKey(keygenResults){const secretShares=keygenResults.map(k=>{if("string"==typeof k)return k;if(k instanceof _1.Ed25519KeygenResult)return k.secretShare;throw"UnknownType"});return(await this.NATIVE).ed25519OfflineExportFullPrivateKey(secretShares)}async importPrivateKeyRecipient(roomUuid,threshold,keygenInit,keygenIds){const importKeygenResult=await(await this.NATIVE).ed25519ImportPrivateKeyRecipient(roomUuid,this.URL,threshold,keygenInit.keygenSecret,keygenIds),pubkey=(0,utils_1.hexToBytes)(importKeygenResult.pubkey),secretShareHex=importKeygenResult.secret_share;return new _1.Ed25519KeygenResult(pubkey,secretShareHex)}async importPrivateKeyImporter(roomUuid,threshold,privateKey,keygenInit,keygenIds,isPrivateKeyRaw=!1){const importKeygenResult=await(await this.NATIVE).ed25519ImportPrivateKeyImporter(roomUuid,this.URL,threshold,privateKey,keygenInit.keygenSecret,keygenIds,isPrivateKeyRaw),pubkey=(0,utils_1.hexToBytes)(importKeygenResult.pubkey),secretShareHex=importKeygenResult.secret_share;return new _1.Ed25519KeygenResult(pubkey,secretShareHex)}}exports.Ed25519=Ed25519;