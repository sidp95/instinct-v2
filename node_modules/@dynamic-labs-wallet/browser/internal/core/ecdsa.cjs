Object.defineProperty(exports,"__esModule",{value:!0}),exports.Ecdsa=void 0;const _1=require("./index.cjs"),common_1=require("./common.cjs");class Ecdsa{constructor(native,hostUrl){this.NATIVE=native,this.URL=hostUrl}async createRoom(numParties,apiKey){return(0,common_1.sanitizeNumberOfParties)(numParties),(await this.NATIVE).createRoom(this.URL,numParties,apiKey)}async initKeygen(){const keygenInitKeypair=await(await this.NATIVE).initKeygen();return new _1.EcdsaInitKeygenResult(keygenInitKeypair.pubkey,keygenInitKeypair.keypair)}async exportID(keygenResult){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare;return(await this.NATIVE).ecdsaGetExportID(secretShare)}async keygen(roomUuid,numParties,threshold,keygenInit,keygenIds){if((0,common_1.sanitizeNumberOfParties)(numParties,threshold),keygenIds.length!==numParties-1)throw new Error(`keygenIds length must be exactly: ${numParties-1}, it is: `+keygenIds.length);const keygenResult=await(await this.NATIVE).ecdsaKeygen(roomUuid,this.URL,numParties,threshold,keygenInit.keygenSecret,keygenIds),pubkey=new _1.EcdsaPublicKey(keygenResult.pubkey),secretShareHex=keygenResult.secret_share;return new _1.EcdsaKeygenResult(pubkey,secretShareHex)}async sign(roomUuid,keygenResult,msgHash,derivationPath=new Uint32Array){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,expandedSignature=await(await this.NATIVE).ecdsaSign(roomUuid,this.URL,secretShare,msgHash.toHex(),Array.from(derivationPath));return _1.EcdsaSignature.fromBuffer(expandedSignature)}async refresh(roomUuid,keygenResult){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,refreshedKeygenResult=await(await this.NATIVE).ecdsaRefresh(roomUuid,this.URL,secretShare),pubkey=new _1.EcdsaPublicKey(refreshedKeygenResult.pubkey),secretShareHex=refreshedKeygenResult.secret_share;return new _1.EcdsaKeygenResult(pubkey,secretShareHex)}async reshareNewParty(roomUuid,oldThreshold,newThreshold,keygenInit,keygenIds){const resharedKeygenResult=await(await this.NATIVE).ecdsaReshareNewParty(roomUuid,this.URL,oldThreshold,newThreshold,keygenInit.keygenSecret,keygenIds),pubkey=new _1.EcdsaPublicKey(resharedKeygenResult.pubkey),secretShareHex=resharedKeygenResult.secret_share;return new _1.EcdsaKeygenResult(pubkey,secretShareHex)}async reshareRemainingParty(roomUuid,newThreshold,keygenResult,keygenIds){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,resharedKeygenResult=await(await this.NATIVE).ecdsaReshareRemainingParty(roomUuid,this.URL,newThreshold,secretShare,keygenIds),pubkey=new _1.EcdsaPublicKey(resharedKeygenResult.pubkey),secretShareHex=resharedKeygenResult.secret_share;return new _1.EcdsaKeygenResult(pubkey,secretShareHex)}async derivePubkey(keygenResult,derivationPath=new Uint32Array){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,pubkey=await(await this.NATIVE).ecdsaDerivePubkey(secretShare,Array.from(derivationPath));return new _1.EcdsaPublicKey(pubkey)}async getXpub(keygenResult){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare;return(await this.NATIVE).ecdsaGetXpub(secretShare)}async derivePubkeyFromXpub(Xpub,derivationPath=new Uint32Array){const pubkey=await(await this.NATIVE).ecdsaDerivePubkeyFromXpub(Xpub,Array.from(derivationPath));return new _1.EcdsaPublicKey(pubkey)}async exportFullPrivateKey(roomUuid,keygenResult,toExportID){const secretShare="string"==typeof keygenResult?keygenResult:keygenResult.secretShare,exported=await(await this.NATIVE).ecdsaExportFullPrivateKey(roomUuid,this.URL,secretShare,toExportID);return exported||void 0}async derivePrivateKeyFromXpriv(xpriv,derivationPath=new Uint32Array){return(await this.NATIVE).ecdsaDerivePrivateKeyFromXpriv(xpriv,Array.from(derivationPath))}async offlineExportFullPrivateKey(keygenResults){const secretShares=keygenResults.map(k=>{if("string"==typeof k)return k;if(k instanceof _1.EcdsaKeygenResult)return k.secretShare;throw"UnknownType"});return(await this.NATIVE).ecdsaOfflineExportFullPrivateKey(secretShares)}async importPrivateKeyRecipient(roomUuid,threshold,keygenInit,keygenIds){const importKeygenResult=await(await this.NATIVE).ecdsaImportPrivateKeyRecipient(roomUuid,this.URL,threshold,keygenInit.keygenSecret,keygenIds),pubkey=new _1.EcdsaPublicKey(importKeygenResult.pubkey),secretShareHex=importKeygenResult.secret_share;return new _1.EcdsaKeygenResult(pubkey,secretShareHex)}async importPrivateKeyImporter(roomUuid,threshold,privateKey,keygenInit,keygenIds){const importKeygenResult=await(await this.NATIVE).ecdsaImportPrivateKeyImporter(roomUuid,this.URL,threshold,privateKey,keygenInit.keygenSecret,keygenIds),pubkey=new _1.EcdsaPublicKey(importKeygenResult.pubkey),secretShareHex=importKeygenResult.secret_share;return new _1.EcdsaKeygenResult(pubkey,secretShareHex)}getHostUrl(path){return path||this.URL}}exports.Ecdsa=Ecdsa;