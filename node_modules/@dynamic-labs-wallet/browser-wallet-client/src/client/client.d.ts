import type { BackupKeySharesToGoogleDriveRequest, BackupKeySharesToICloudRequest, BitcoinConfig, CreateWalletAccountRequest, CreateWalletAccountResponse, DelegateKeySharesRequest, ExportClientKeysharesRequest, GetWalletResponse, ImportPrivateKeyRequest, IsPasswordEncryptedRequest, OfflineExportPrivateKeyResponse, RefreshWalletAccountSharesRequest, RequestWithTraceContext, RequiresPasswordForOperationRequest, ReshareRequest, RevokeDelegationRequest, SignMessageRequestBrowser, SignRawMessageRequest, SignTransactionRequest, SignTypedDataRequest, UpdatePasswordRequest, VerifyPasswordRequest } from '@dynamic-labs-wallet/core';
import { AuthMode, WalletOperation } from '@dynamic-labs-wallet/core';
import { IframeManager } from './iframeManager/index.js';
export declare class DynamicWalletClient extends IframeManager {
    constructor({ environmentId, authToken, baseApiUrl, baseMPCRelayApiUrl, baseClientKeysharesRelayApiUrl, chainName, sdkVersion, debug, authMode, }: {
        environmentId: string;
        authToken: string;
        baseApiUrl: string;
        baseMPCRelayApiUrl: string;
        chainName: string;
        sdkVersion?: string;
        debug?: boolean;
        authMode?: AuthMode;
        baseClientKeysharesRelayApiUrl?: string;
    });
    private withHandler;
    getWallets(): Promise<GetWalletResponse[]>;
    getWallet({ accountAddress, walletOperation, signedSessionId, authToken, }: {
        accountAddress: string;
        walletOperation?: WalletOperation;
        signedSessionId: string;
        authToken?: string;
    }): Promise<GetWalletResponse>;
    createWalletAccount({ thresholdSignatureScheme, password, signedSessionId, authToken, traceContext, bitcoinConfig, }: RequestWithTraceContext<Omit<CreateWalletAccountRequest, 'chainName'>>): Promise<CreateWalletAccountResponse>;
    requiresPasswordForOperation({ accountAddress, walletOperation, authToken, }: Omit<RequiresPasswordForOperationRequest, 'chainName'>): Promise<boolean>;
    isPasswordEncrypted({ accountAddress, authToken, }: Omit<IsPasswordEncryptedRequest, 'chainName'>): Promise<boolean>;
    signMessage({ message, accountAddress, password, signedSessionId, authToken, mfaToken, context, traceContext, bitcoinConfig, }: RequestWithTraceContext<Omit<SignMessageRequestBrowser, 'chainName'>>): Promise<string>;
    signRawMessage({ message, accountAddress, password, signedSessionId, authToken, mfaToken, context, traceContext, bitcoinConfig, }: RequestWithTraceContext<Omit<SignRawMessageRequest, 'chainName'>>): Promise<string>;
    /**
     * Signs a transaction and returns the signature, @transaction is a string of the serialized transaction
     * EVM:
     *   transaction = serializeTransaction()
     * SOL:
     *   const messageBytes = transaction.serializeMessage();
     *   const messageToSign = Buffer.from(messageBytes).toString("hex");
     * SUI:
     *  const txBytes = await txb.build({ client });
     *  const txString = Buffer.from(txBytes).toString("hex");
     */
    signTransaction({ senderAddress, transaction, password, signedSessionId, authToken, mfaToken, chainId, traceContext, bitcoinConfig, }: RequestWithTraceContext<Omit<SignTransactionRequest, 'chainName'>>): Promise<string>;
    signTypedData({ accountAddress, typedData, password, signedSessionId, authToken, mfaToken, traceContext, }: RequestWithTraceContext<Omit<SignTypedDataRequest, 'chainName'>>): Promise<string>;
    backupKeySharesToGoogleDrive({ accountAddress, password, signedSessionId, authToken, traceContext, }: RequestWithTraceContext<Omit<BackupKeySharesToGoogleDriveRequest, 'chainName'>>): Promise<void>;
    backupKeySharesToICloud({ accountAddress, password, signedSessionId, authToken, traceContext, }: RequestWithTraceContext<Omit<BackupKeySharesToICloudRequest, 'chainName'>>): Promise<void>;
    displayICloudSignIn({ displayContainer, }: {
        displayContainer: HTMLElement;
    }): Promise<void>;
    hideICloudSignIn(): Promise<void>;
    isICloudAuthenticated(): Promise<boolean>;
    delegateKeyShares({ accountAddress, password, signedSessionId, authToken, mfaToken, traceContext, }: RequestWithTraceContext<Omit<DelegateKeySharesRequest, 'chainName'>>): Promise<void>;
    revokeDelegation({ accountAddress, password, signedSessionId, authToken, mfaToken, traceContext, }: RequestWithTraceContext<Omit<RevokeDelegationRequest, 'chainName'>>): Promise<void>;
    exportClientKeysharesFromGoogleDrive({ accountAddress, password, signedSessionId, authToken, traceContext, }: RequestWithTraceContext<{
        accountAddress: string;
        password?: string;
        signedSessionId: string;
        authToken?: string;
    }>): Promise<void>;
    refreshWalletAccountShares({ accountAddress, password, signedSessionId, authToken, mfaToken, traceContext, }: RequestWithTraceContext<Omit<RefreshWalletAccountSharesRequest, 'chainName'>>): Promise<void>;
    reshare({ accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, password, signedSessionId, authToken, mfaToken, traceContext, }: RequestWithTraceContext<Omit<ReshareRequest, 'chainName'>>): Promise<void>;
    exportPrivateKey({ accountAddress, displayContainer, password, signedSessionId, authToken, mfaToken, traceContext, bitcoinConfig, }: RequestWithTraceContext<{
        accountAddress: string;
        displayContainer: HTMLElement;
        password?: string;
        signedSessionId: string;
        authToken?: string;
        mfaToken?: string;
        bitcoinConfig?: BitcoinConfig;
    }>): Promise<void>;
    verifyPassword({ accountAddress, password, walletOperation, signedSessionId, authToken, traceContext, }: RequestWithTraceContext<Omit<VerifyPasswordRequest, 'chainName'>>): Promise<void>;
    updatePassword({ accountAddress, existingPassword, newPassword, signedSessionId, authToken, traceContext, }: RequestWithTraceContext<Omit<UpdatePasswordRequest, 'chainName'>>): Promise<void>;
    importPrivateKey({ privateKey, thresholdSignatureScheme, signedSessionId, authToken, publicAddressCheck, addressType, traceContext, legacyWalletId, }: RequestWithTraceContext<Omit<ImportPrivateKeyRequest, 'chainName'>>): Promise<CreateWalletAccountResponse>;
    exportClientKeyshares({ accountAddress, password, signedSessionId, authToken, traceContext, }: RequestWithTraceContext<Omit<ExportClientKeysharesRequest, 'chainName'>>): Promise<void>;
    /**
     * keyShares is stringified list of EcdsaKeygenResult[] and Ed25519KeygenResult[]
     */
    offlineExportPrivateKey({ keyShares, derivationPath, traceContext, }: RequestWithTraceContext<{
        keyShares: string[];
        derivationPath?: string;
    }>): Promise<OfflineExportPrivateKeyResponse>;
}
//# sourceMappingURL=client.d.ts.map