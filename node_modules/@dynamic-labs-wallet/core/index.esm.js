import { v4 } from 'uuid';
import axios from 'axios';
import { ForwardMPCClient } from '@dynamic-labs-wallet/forward-mpc-client';
import createHttpError from 'http-errors';

var ENVIRONMENT_ENUM = /*#__PURE__*/ function(ENVIRONMENT_ENUM) {
    ENVIRONMENT_ENUM["development"] = "development";
    ENVIRONMENT_ENUM["preprod"] = "preprod";
    ENVIRONMENT_ENUM["production"] = "production";
    return ENVIRONMENT_ENUM;
}({});
const DynamicRequestIdHeader = 'x-dyn-request-id';
const DynamicClientSessionSignature = 'x-dyn-client-session-signature';
const DynamicMfaTokenHeader = 'x-mfa-auth-token';
const DynamicForwardMPCHeader = 'x-forward-mpc-client';
const DynamicTraceIdHeader = 'x-dyn-trace-id';
const DynamicTraceElapsedTimeHeader = 'x-dyn-trace-elapsed-time';
/**
 * Dynamic auth base API URL to redcoast API
 * NOTE: For coookie auth, we should use the configured baseApiUrl
 */ const DYNAMIC_AUTH_PROD_BASE_API_URL = 'https://app.dynamicauth.com';
const DYNAMIC_AUTH_PREPROD_BASE_API_URL = 'https://app.dynamic-preprod.xyz';
const DYNAMIC_AUTH_DEV_BASE_API_URL = 'http://localhost:4200';
const DYNAMIC_AUTH_BASE_API_URL_MAP = {
    ["production"]: DYNAMIC_AUTH_PROD_BASE_API_URL,
    ["preprod"]: DYNAMIC_AUTH_PREPROD_BASE_API_URL,
    ["development"]: DYNAMIC_AUTH_DEV_BASE_API_URL
};
/**
 * Evervault keyshare encryption relay
 * Note: Not used for cookie auth, we use the configured baseKeyshareRelayApiUrl
 */ const DYNAMIC_KEYSHARES_RELAY_PROD_BASE_API_URL = 'https://waas-keyshares-relay.dynamicauth.com';
const DYNAMIC_KEYSHARES_RELAY_PREPROD_BASE_API_URL = 'https://waas-keyshares-relay.dynamic-preprod.xyz';
const DYNAMIC_KEYSHARES_RELAY_MAP = {
    ["production"]: DYNAMIC_KEYSHARES_RELAY_PROD_BASE_API_URL,
    ["preprod"]: DYNAMIC_KEYSHARES_RELAY_PREPROD_BASE_API_URL,
    ["development"]: DYNAMIC_KEYSHARES_RELAY_PREPROD_BASE_API_URL
};
/**
 * Dymamic MPC relay where the MPC operations are performed (NOT keyshare relay in Evervault)
 */ const MPC_RELAY_PROD_API_URL = 'relay.dynamicauth.com';
const MPC_RELAY_PREPROD_API_URL = 'relay.dynamic-preprod.xyz';
const MPC_RELAY_DEV_API_URL = 'http://localhost:4200';
const MPC_RELAY_URL_MAP = {
    ["production"]: MPC_RELAY_PROD_API_URL,
    ["preprod"]: MPC_RELAY_PREPROD_API_URL,
    ["development"]: MPC_RELAY_DEV_API_URL
};
const RELAY_APP_ID_HEADER = 'X-Evervault-App-Id';
const PROD_RELAY_APP_ID = 'app_6e12fc400995';
const PREPROD_RELAY_APP_ID = 'app_32d15525a875';
const DYNAMIC_CLIENT_RELAY_REDCOAST_APP_ID_MAP = {
    ["production"]: PROD_RELAY_APP_ID,
    ["preprod"]: PREPROD_RELAY_APP_ID,
    ["development"]: undefined
};
const RELAY_API_KEY_HEADER = 'X-Evervault-Api-Key';
// This is the API key for the relay API. Its must be public to use MTLs
const PROD_RELAY_API_KEY = 'ev:key:1:7kRuVm1sE1J5FjGz2ijufy0IkATzrBKEvde0IMLW1dt3xbFcdTdOKHO0vNnJeAjAD:YmAPOP:Jh7DdD';
const PREPROD_RELAY_API_KEY = 'ev:key:1:7j2jIPMzlcKlpDz1RTV6Vadsm8sgmj1VHZzJXqW9ie1dgmyzKmccEGI8BBWU0PaXv:XfF7Ri:ivvRp1';
const DYNAMIC_CLIENT_RELAY_REDCOAST_API_KEY_MAP = {
    ["production"]: PROD_RELAY_API_KEY,
    ["preprod"]: PREPROD_RELAY_API_KEY,
    ["development"]: undefined
};
const SOLANA_RPC_URL = 'https://api.devnet.solana.com';
const chain = {
    EVM: 'EVM',
    SVM: 'SVM',
    COSMOS: 'COSMOS',
    BTC: 'BTC',
    FLOW: 'FLOW',
    SUI: 'SUI',
    TON: 'TON'
};
var WalletOperation = /*#__PURE__*/ function(WalletOperation) {
    WalletOperation["REACH_THRESHOLD"] = "REACH_THRESHOLD";
    WalletOperation["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
    WalletOperation["SIGN_MESSAGE"] = "SIGN_MESSAGE";
    WalletOperation["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
    WalletOperation["REFRESH"] = "REFRESH";
    WalletOperation["RESHARE"] = "RESHARE";
    WalletOperation["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
    WalletOperation["NO_OPERATION"] = "NO_OPERATION";
    return WalletOperation;
}({});
var BackupLocation = /*#__PURE__*/ function(BackupLocation) {
    BackupLocation["DYNAMIC"] = "dynamic";
    BackupLocation["GOOGLE_DRIVE"] = "googleDrive";
    BackupLocation["ICLOUD"] = "iCloud";
    BackupLocation["USER"] = "user";
    BackupLocation["EXTERNAL"] = "external";
    BackupLocation["DELEGATED"] = "delegated";
    return BackupLocation;
}({});
const IFRAME_DOMAIN_MAP = {
    development: 'http://localhost:4200',
    preprod: 'https://app.dynamic-preprod.xyz',
    production: 'https://app.dynamicauth.com'
};
const chainEnumToVerifiedCredentialName = {
    BTC: 'bip122',
    EVM: 'eip155',
    FLOW: 'flow',
    SVM: 'solana'
};
const verifiedCredentialNameToChainEnum = {
    bip122: 'BTC',
    eip155: 'EVM',
    solana: 'SVM',
    sui: 'SUI',
    ton: 'TON'
};
const DELEGATED_SHARE_COUNT = 1;
const FEATURE_FLAGS = {
    ENABLE_DELEGATED_KEY_SHARES_FLAG: 'enable-delegated-key-shares',
    ENABLE_FORWARD_MPC_CLIENT_FLAG: 'enable-forward-mpc-client',
    ENABLE_ROOM_CACHE_FLAG: 'enable-mpc-room-cache'
};
const DYNAMIC_FORWARD_MPC_PROD_ENCLAVE_URL = 'wss://forward-mpc-client-prod.app-bf095f298b04.enclave.evervault.com/ws';
const DYNAMIC_FORWARD_MPC_PREPROD_ENCLAVE_URL = 'wss://forward-mpc-client-preprod.app-560a39ebfe3b.enclave.evervault.com/ws';
const DYNAMIC_FORWARD_MPC_DEV_ENCLAVE_URL = 'ws://localhost:8008/ws';
const DYNAMIC_FORWARD_MPC_ENCLAVE_URL_MAP = {
    ["production"]: DYNAMIC_FORWARD_MPC_PROD_ENCLAVE_URL,
    ["preprod"]: DYNAMIC_FORWARD_MPC_PREPROD_ENCLAVE_URL,
    ["development"]: DYNAMIC_FORWARD_MPC_DEV_ENCLAVE_URL
};
const DYNAMIC_FORWARD_MPC_ENCLAVE_ATTESTATION_CONFIG_MAP = {
    ["production"]: {
        expectedPcr8: '484fd412249304fe7659b2a9a4869504f0e4502d8abb4f88183e65416b4f62354e4eda60e80a5b2e9d730ab0d804f83e',
        strictCertValidation: true
    },
    ["preprod"]: {
        expectedPcr8: 'acc59ec98dbf7ecb43f9a6b9890866141868c079aa879e05e3675e1a10e187259a64951e72cc531541b02dbdcd780770',
        strictCertValidation: true
    },
    ["development"]: undefined
};

var SigningAlgorithm = /*#__PURE__*/ function(SigningAlgorithm) {
    SigningAlgorithm["ECDSA"] = "ECDSA";
    SigningAlgorithm["ED25519"] = "ED25519";
    SigningAlgorithm["BIP340"] = "BIP340";
    return SigningAlgorithm;
}({});
const BITCOIN_DERIVATION_PATHS = {
    NATIVE_SEGWIT: [
        84,
        0,
        0,
        0,
        0
    ],
    TAPROOT: [
        86,
        0,
        0,
        0,
        0
    ]
};
/**
 * Bitcoin address type configurations
 * Maps each address type to its derivation path and signing algorithm
 */ const BITCOIN_ADDRESS_TYPE_CONFIG = {
    taproot: {
        derivationPath: BITCOIN_DERIVATION_PATHS.TAPROOT,
        signingAlgorithm: "BIP340"
    },
    native_segwit: {
        derivationPath: BITCOIN_DERIVATION_PATHS.NATIVE_SEGWIT,
        signingAlgorithm: "ECDSA"
    }
};
const MPC_CHAIN_CONFIG = {
    EVM: {
        // Uses secp256k1 ECDSA
        derivationPath: [
            44,
            60,
            0,
            0,
            0
        ],
        signingAlgorithm: "ECDSA"
    },
    SVM: {
        // Uses Ed25519
        derivationPath: [
            44,
            501,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    COSMOS: {
        // Uses Ed25519
        derivationPath: [
            44,
            118,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    FLOW: {
        // Uses Ed25519
        derivationPath: [
            44,
            539,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    SUI: {
        // Uses Ed25519
        derivationPath: [
            44,
            784,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    TON: {
        // Uses Ed25519
        derivationPath: [
            44,
            607,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    }
};
var ThresholdSignatureScheme = /*#__PURE__*/ function(ThresholdSignatureScheme) {
    ThresholdSignatureScheme["TWO_OF_TWO"] = "TWO_OF_TWO";
    ThresholdSignatureScheme["TWO_OF_THREE"] = "TWO_OF_THREE";
    ThresholdSignatureScheme["THREE_OF_FIVE"] = "THREE_OF_FIVE";
    return ThresholdSignatureScheme;
}({});
const MPC_CONFIG = {
    ["TWO_OF_TWO"]: {
        numberOfParties: 2,
        threshold: 2,
        clientThreshold: 1,
        dynamicServerThreshold: 1
    },
    ["TWO_OF_THREE"]: {
        numberOfParties: 3,
        threshold: 2,
        clientThreshold: 2,
        dynamicServerThreshold: 1
    },
    ["THREE_OF_FIVE"]: {
        numberOfParties: 5,
        threshold: 3,
        clientThreshold: 3,
        dynamicServerThreshold: 2
    }
};
var CreateRoomPartiesOptions = /*#__PURE__*/ function(CreateRoomPartiesOptions) {
    CreateRoomPartiesOptions["THRESHOLD"] = "threshold";
    CreateRoomPartiesOptions["FULL"] = "full";
    return CreateRoomPartiesOptions;
}({});

/**
 * Get Bitcoin chain configuration based on address type
 * @param addressType - Bitcoin address type (taproot, native_segwit)
 * @returns Chain configuration with derivation path and signing algorithm
 */ const getBitcoinChainConfig = (addressType)=>{
    const normalizedAddressType = addressType.toLowerCase();
    const config = BITCOIN_ADDRESS_TYPE_CONFIG[normalizedAddressType];
    if (!config) {
        throw new Error(`Unsupported Bitcoin address type: ${addressType}. Must be one of: taproot, native_segwit`);
    }
    return config;
};
/**
 * Get MPC chain configuration
 * @param chainName - Chain name (e.g., 'BTC', 'EVM', 'SVM')
 * @param bitcoinConfig - Optional bitcoin config (for BTC)
 * @returns Chain configuration with derivation path and signing algorithm
 */ const getMPCChainConfig = (chainName, bitcoinConfig)=>{
    // Special handling for BTC - addressType is required
    if (chainName === 'BTC') {
        const { addressType } = bitcoinConfig || {};
        if (!addressType) {
            throw new Error('addressType is required for BTC. Please provide addressType (taproot or native_segwit).');
        }
        return getBitcoinChainConfig(addressType);
    }
    const chainConfig = MPC_CHAIN_CONFIG[chainName];
    if (!chainConfig) {
        throw new Error(`Chain ${chainName} not supported`);
    }
    return chainConfig;
};
const getTSSConfig = (thresholdSignatureScheme)=>{
    const { threshold, numberOfParties } = MPC_CONFIG[thresholdSignatureScheme];
    return {
        threshold,
        numberOfParties
    };
};
const getClientThreshold = (thresholdSignatureScheme)=>{
    return MPC_CONFIG[thresholdSignatureScheme].clientThreshold;
};
const getDynamicServerThreshold = (thresholdSignatureScheme)=>{
    return MPC_CONFIG[thresholdSignatureScheme].dynamicServerThreshold;
};
/**
 * Helper function to get the reshare config for client and server shares
 * @param {ThresholdSignatureScheme} oldThresholdSignatureScheme - The current threshold signature scheme
 * @param {ThresholdSignatureScheme} newThresholdSignatureScheme - The target threshold signature scheme
 * @returns {{
 *   existingClientShareCount: number,
 *   newClientShareCount: number,
 *   existingServerShareCount: number,
 *   newServerShareCount: number
 * }} The number of existing and new client and server shares needed
 */ const getReshareConfig = ({ oldThresholdSignatureScheme, newThresholdSignatureScheme })=>{
    switch(true){
        // 2-of-2 -> 2-of-2:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 0,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 2-of-3 -> 2-of-3:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 1,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 3-of-5 -> 3-of-5:
        // -- dynamic server shares: 2 existing, 0 new
        // -- client shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 2,
                existingServerShareCount: 2,
                newServerShareCount: 0
            };
        // 2-of-2 -> 2-of-3:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 1,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 2-of-2 -> 3-of-5:
        // -- dynamic server shares: 1 existing, 1 new
        // -- client shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 2,
                existingServerShareCount: 1,
                newServerShareCount: 1
            };
        // 2-of-3 -> 3-of-5:
        // -- dynamic server shares: 1 existing, 1 new
        // -- client shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 2,
                existingServerShareCount: 1,
                newServerShareCount: 1
            };
        // 2-of-3 -> 2-of-2:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 0,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 3-of-5 -> 2-of-3:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 2 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingClientShareCount: 2,
                newClientShareCount: 0,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        default:
            throw new Error(`Unsupported reshare from ${oldThresholdSignatureScheme} to ${newThresholdSignatureScheme}`);
    }
};
/**
 * Helper function to get the reshare config for client and server shares
 * @param {ThresholdSignatureScheme} oldThresholdSignatureScheme - The current threshold signature scheme
 * @param {ThresholdSignatureScheme} newThresholdSignatureScheme - The target threshold signature scheme
 * @returns {{
 *   existingServerShareCount: number,
 *   newServerhareCount: number,
 *   existingDynamicServerShareCount: number,
 *   newDynamicServerShareCount: number
 * }} The number of existing and new client and server shares needed
 */ const getServerWalletReshareConfig = ({ oldThresholdSignatureScheme, newThresholdSignatureScheme })=>{
    switch(true){
        // 2-of-2 -> 2-of-2:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 0,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 2-of-3 -> 2-of-3:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 1,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 3-of-5 -> 3-of-5:
        // -- dyanmic server shares: 2 existing, 0 new
        // -- external server shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 2,
                existingDynamicServerShareCount: 2,
                newDynamicServerShareCount: 0
            };
        // 2-of-2 -> 2-of-3:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 1,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 2-of-2 -> 3-of-5:
        // -- dyanmic server shares: 1 existing, 1 new
        // -- external server shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 2,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 1
            };
        // 2-of-3 -> 3-of-5:
        // -- dyanmic server shares: 1 existing, 1 new
        // -- external server shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 2,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 1
            };
        // 2-of-3 -> 2-of-2:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 0,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 3-of-5 -> 2-of-3:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 2 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingExternalServerShareCount: 2,
                newExternalServerShareCount: 0,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        default:
            throw new Error(`Unsupported reshare from ${oldThresholdSignatureScheme} to ${newThresholdSignatureScheme}`);
    }
};
const URL_PATTERNS = {
    [ENVIRONMENT_ENUM.development]: /^http:\/\/localhost:\d+$/,
    [ENVIRONMENT_ENUM.preprod]: /-preprod/,
    [ENVIRONMENT_ENUM.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
function getEnvironmentFromUrl(url) {
    if (!url) {
        return ENVIRONMENT_ENUM.production;
    }
    if (URL_PATTERNS[ENVIRONMENT_ENUM.development].test(url)) {
        return ENVIRONMENT_ENUM.development;
    }
    if (URL_PATTERNS[ENVIRONMENT_ENUM.preprod].test(url)) {
        return ENVIRONMENT_ENUM.preprod;
    }
    return ENVIRONMENT_ENUM.production;
}

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

var AuthMode = /*#__PURE__*/ function(AuthMode) {
    AuthMode["HEADER"] = "header";
    AuthMode["COOKIE"] = "cookie";
    return AuthMode;
}({});
var BitcoinAddressType = /*#__PURE__*/ function(BitcoinAddressType) {
    BitcoinAddressType["TAPROOT"] = "taproot";
    BitcoinAddressType["NATIVE_SEGWIT"] = "native_segwit";
    return BitcoinAddressType;
}({});
var BitcoinNetwork = /*#__PURE__*/ function(BitcoinNetwork) {
    BitcoinNetwork["MAINNET"] = "mainnet";
    BitcoinNetwork["TESTNET"] = "testnet";
    return BitcoinNetwork;
}({});
var SuccessEventType = /*#__PURE__*/ function(SuccessEventType) {
    SuccessEventType["KeygenComplete"] = "keygen_complete";
    SuccessEventType["RoomCreated"] = "room_created";
    SuccessEventType["CeremonyComplete"] = "ceremony_complete";
    return SuccessEventType;
}({});

const getElapsedTime = (startTime)=>{
    return startTime ? (Date.now() - startTime).toString() : undefined;
};
/**
 * Creates a promise that resolves when a specific event is received from an event stream.
 * Adds a timeout to prevent hanging and races the two promises.
 *
 * @template T The expected type of the response data
 * @param apiClient The axios instance to use for API calls
 * @param options The configuration options
 * @returns A promise that resolves with the event data or rejects on timeout
 */ const createEventStreamPromise = ({ apiClient, dynamicRequestId, endpoint, body, successEventType, timeoutMs = 30000, timeoutMessage, onError, onCeremonyComplete, mfaToken, forwardMPCClientEnabled, traceContext })=>{
    const headers = {
        Accept: 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
        [DynamicRequestIdHeader]: dynamicRequestId,
        [DynamicMfaTokenHeader]: mfaToken,
        [DynamicForwardMPCHeader]: forwardMPCClientEnabled,
        [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
        [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
    };
    // Create a promise that will resolve when the success event is received
    const eventPromise = new Promise((resolve, reject)=>{
        apiClient.post(endpoint, body, {
            responseType: 'stream',
            headers: _extends({}, headers),
            adapter: 'fetch'
        }).then(createSuccessErrorEventStreamHandler({
            onError,
            reject,
            resolve,
            successEventType,
            onCeremonyComplete
        })).catch(reject);
    });
    // Add a timeout to prevent hanging
    const timeoutPromise = new Promise((_, reject)=>{
        setTimeout(()=>reject(new Error(timeoutMessage)), timeoutMs);
    });
    // Return the event data as soon as it's available
    return Promise.race([
        eventPromise,
        timeoutPromise
    ]);
};
/**
 * Creates a handler function for processing server-sent events (SSE) streams.
 * This utility manages asynchronous event-based communication with the server,
 * particularly for long-running operations like wallet creation or key generation.
 *
 * @template T - The expected type of the successful response data
 * @param {function} resolve - Promise resolution function to call when the success event is received
 * @param {function} reject - Promise rejection function to call when an error occurs
 * @param {string} successEventType - The event type string that indicates a successful operation
 * @param {function} [onError] - Optional callback for error handling, allowing custom error processing
 * @returns {function} A response handler function that processes the event stream
 */ const createSuccessErrorEventStreamHandler = ({ resolve, reject, successEventType, onError, onCeremonyComplete })=>{
    return (response)=>{
        const reader = response.data.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        const processStream = async ()=>{
            try {
                const { value, done } = await reader.read();
                if (done) return;
                buffer += decoder.decode(value, {
                    stream: true
                });
                const events = parseEventStream(buffer);
                for (const event of events){
                    if (event.type === successEventType) {
                        resolve(event.data);
                    }
                    if (event.type === SuccessEventType.CeremonyComplete) {
                        const { accountAddress, walletId } = event.data;
                        onCeremonyComplete == null ? void 0 : onCeremonyComplete(accountAddress, walletId);
                    }
                    if (event.type === 'error') {
                        const error = createErrorFromEventData(event.data);
                        reject(error);
                        onError == null ? void 0 : onError(error);
                    }
                }
                processStream();
            } catch (err) {
                reject(err instanceof Error ? err : new Error(String(err)));
            }
        };
        processStream();
    };
};
/**
 * Creates an error object from event stream error data.
 *
 * @param data - The error data received from the event stream
 * @returns A standardized Error object with properties from the error data
 */ const createErrorFromEventData = (data)=>{
    const error = new Error(typeof data === 'object' && data !== null && 'error' in data ? String(data.error) : 'Unknown error');
    if (typeof data === 'object' && data !== null) {
        Object.assign(error, data);
    }
    return error;
};
/**
 * Parses a Server-Sent Events (SSE) stream into structured event objects.
 *
 * @param input - Raw string data from an event stream
 * @returns Array of parsed events with type and data properties
 */ const parseEventStream = (input)=>{
    const lines = input.split('\n');
    const events = [];
    let currentEvent = {};
    let inEvent = false;
    for (const line of lines){
        // Empty line marks the end of an event
        if (line === '') {
            if (currentEvent.type && currentEvent.data) {
                events.push({
                    type: currentEvent.type,
                    data: JSON.parse(currentEvent.data)
                });
                currentEvent = {};
                inEvent = false;
            }
            continue;
        }
        // Process event fields
        if (line.startsWith('event:')) {
            currentEvent.type = line.substring(6).trim();
            inEvent = true;
        } else if (line.startsWith('data:')) {
            currentEvent.data = line.substring(5).trim();
            inEvent = true;
        } else if (inEvent && currentEvent.data) {
            currentEvent.data += line;
        }
    }
    return events;
};

var version = "0.0.1";

class BaseClient {
    syncAuthToken(authToken) {
        if (this.authMode === AuthMode.COOKIE) {
            return;
        }
        if (!authToken) {
            throw new Error('Auth token is required for header authentication');
        }
        const authHeader = `Bearer ${authToken}`;
        this.apiClient.defaults.headers['Authorization'] = authHeader;
        this.clientRelayApiClient.defaults.headers['Authorization'] = authHeader;
        this.apiClient.defaults.headers.common['Authorization'] = authHeader;
        this.clientRelayApiClient.defaults.headers.common['Authorization'] = authHeader;
        if (this.apiClient.defaults.headers['Authorization'] !== authHeader || this.clientRelayApiClient.defaults.headers['Authorization'] !== authHeader) {
            throw new Error('Failed to sync auth token, auth header is not set to the expected auth token after sync, there is likely a race condition, contact Dynamic devs to investigate');
        }
    }
    syncBackupServiceAuthToken(backupServiceAuthToken) {
        if (this.authMode === AuthMode.HEADER) {
            return;
        }
        if (!backupServiceAuthToken) {
            throw new Error('Backup service auth token is required for cookie authentication');
        }
        this.backupServiceAuthToken = backupServiceAuthToken;
        this.clientRelayApiClient.defaults.headers['Authorization'] = `Bearer ${backupServiceAuthToken}`;
    }
    constructor({ environmentId, baseApiUrl, authToken, backupServiceAuthToken, baseClientKeysharesRelayApiUrl, authMode = AuthMode.HEADER, // Represents the version of the client SDK used by developer
    sdkVersion, forwardMPCClient }){
        const headers = {};
        // Only set Authorization header if using header auth mode and token is provided
        if (authMode === AuthMode.HEADER && authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
        }
        headers['x-dyn-wallet-sdk-version'] = version;
        headers['x-dyn-version'] = sdkVersion;
        this.environmentId = environmentId;
        this.authMode = authMode;
        const environment = getEnvironmentFromUrl(baseApiUrl);
        this.baseApiUrl = baseApiUrl != null ? baseApiUrl : DYNAMIC_AUTH_BASE_API_URL_MAP[environment];
        // Configure axios to include credentials for cookie auth
        const axiosConfig = _extends({
            baseURL: this.baseApiUrl,
            headers
        }, authMode === AuthMode.COOKIE ? {
            withCredentials: true
        } : {});
        this.apiClient = axios.create(axiosConfig);
        this.clientKeysharesRelayBaseApiUrl = baseClientKeysharesRelayApiUrl != null ? baseClientKeysharesRelayApiUrl : DYNAMIC_KEYSHARES_RELAY_MAP[environment];
        // Cookie based auth will not have an authToken
        // so we need to pass the backupServiceAuthToken to the clientRelayApiClient
        // This was requested from the backend during initWaasWalletClient
        if (authMode === AuthMode.COOKIE && backupServiceAuthToken && !authToken) {
            headers['Authorization'] = `Bearer ${backupServiceAuthToken}`;
        }
        this.clientRelayApiClient = axios.create({
            baseURL: this.clientKeysharesRelayBaseApiUrl,
            headers: _extends({}, headers, {
                [RELAY_API_KEY_HEADER]: DYNAMIC_CLIENT_RELAY_REDCOAST_API_KEY_MAP[environment],
                [RELAY_APP_ID_HEADER]: DYNAMIC_CLIENT_RELAY_REDCOAST_APP_ID_MAP[environment]
            })
        });
        // Use provided ForwardMPCClient or create a new one
        if (forwardMPCClient) {
            this.forwardMPCClient = forwardMPCClient;
        } else {
            const forwardMPCEnclaveUrl = DYNAMIC_FORWARD_MPC_ENCLAVE_URL_MAP[environment];
            const attestationConfig = DYNAMIC_FORWARD_MPC_ENCLAVE_ATTESTATION_CONFIG_MAP[environment];
            this.forwardMPCClient = new ForwardMPCClient(forwardMPCEnclaveUrl != null ? forwardMPCEnclaveUrl : '', {
                reconnectInterval: 5000,
                reconnectAttempts: 5,
                connectionTimeout: 10000,
                heartbeatInterval: 30000,
                attestationConfig
            });
        }
    }
}

class DynamicApiClient extends BaseClient {
    async getBackupRelayToken({ traceContext }) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/waas/keyShares/backup/token`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data.token;
    }
    async authenticateApiToken({ environmentId }) {
        return this.apiClient.post(`/api/v0/environments/${environmentId}/waas/authenticate`, undefined, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', '')
            }
        });
    }
    async createWalletAccount({ chainName, clientKeygenIds, dynamicRequestId, thresholdSignatureScheme, skipLock, bitcoinConfig, onError, onCeremonyComplete, traceContext }) {
        const { addressType } = bitcoinConfig || {};
        const requestBody = _extends({
            chain: chainName,
            clientKeygenIds,
            thresholdSignatureScheme
        }, skipLock ? {
            skipLock
        } : {}, addressType ? {
            addressType
        } : {});
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/create`,
            body: requestBody,
            successEventType: SuccessEventType.KeygenComplete,
            timeoutMessage: 'Wallet creation timed out',
            onError,
            onCeremonyComplete,
            traceContext
        });
    }
    async signMessage({ dynamicRequestId, walletId, message, onError, isFormatted, mfaToken, roomId, context, forwardMPCClientEnabled, traceContext, bitcoinConfig }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/signMessage`,
            body: _extends({
                message,
                isFormatted,
                context,
                roomId
            }, bitcoinConfig ? {
                bitcoinConfig
            } : {}),
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Message signing timed out',
            onError,
            mfaToken,
            forwardMPCClientEnabled,
            traceContext
        });
    }
    async refreshWalletAccountShares({ dynamicRequestId, walletId, onError, mfaToken, traceContext }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/refresh`,
            body: undefined,
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Refresh timed out',
            onError,
            mfaToken,
            traceContext
        });
    }
    async reshare({ walletId, dynamicRequestId, clientKeygenIds, oldThresholdSignatureScheme, newThresholdSignatureScheme, delegateToProjectEnvironment, revokeDelegation, mfaToken, onError, traceContext }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/reshare`,
            body: {
                clientKeygenIds,
                delegateToProjectEnvironment,
                newThresholdSignatureScheme,
                oldThresholdSignatureScheme,
                revokeDelegation
            },
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Reshare timed out',
            onError,
            mfaToken,
            traceContext
        });
    }
    async exportKey({ mfaToken, dynamicRequestId, walletId, exportId, bitcoinConfig, onError, traceContext }) {
        const { addressType } = bitcoinConfig || {};
        const requestBody = _extends({
            exportId
        }, addressType ? {
            addressType
        } : {});
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/privateKey/export`,
            body: requestBody,
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Key export timed out',
            onError,
            mfaToken,
            traceContext
        });
    }
    async getDelegatedEncryptionKey({ environmentId, traceContext }) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${environmentId}/waas/delegatedAccess/encryptionPublicKey`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async publishDelegatedKeyShare({ walletId, encryptedKeyShare, signedSessionId, requiresSignedSessionId = false, dynamicRequestId, traceContext }) {
        if (requiresSignedSessionId && !signedSessionId) {
            throw new Error('Signed session ID is required');
        }
        const apiClient = this.apiClient;
        const { data, status } = await apiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/delegatedAccess/delivery`, {
            encryptedDelegatedShare: encryptedKeyShare
        }, {
            headers: {
                [DynamicRequestIdHeader]: dynamicRequestId,
                [DynamicClientSessionSignature]: signedSessionId,
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return {
            data,
            status
        };
    }
    async storeEncryptedBackupByWallet({ walletId, encryptedKeyShares, passwordEncrypted, signedSessionId, encryptionVersion, requiresSignedSessionId = false, dynamicRequestId, traceContext }) {
        if (requiresSignedSessionId && !signedSessionId) {
            throw new Error('Signed session ID is required');
        }
        const { data } = await this.clientRelayApiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/backup`, {
            // TODO: decide on whether to store encryptedAccountCredentials or encryptedKeyShares as backup
            encryptedAccountCredentials: encryptedKeyShares,
            passwordEncrypted,
            encryptionVersion
        }, {
            headers: {
                [DynamicRequestIdHeader]: dynamicRequestId,
                [DynamicClientSessionSignature]: signedSessionId,
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async markKeySharesAsBackedUp({ walletId, locations, dynamicRequestId, traceContext }) {
        const { data } = await this.apiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/backup/locations`, {
            locations
        }, {
            headers: {
                [DynamicRequestIdHeader]: dynamicRequestId,
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async recoverEncryptedBackupByWallet({ walletId, keyShareIds, signedSessionId, mfaToken, requiresSignedSessionId = false, traceContext }) {
        if (requiresSignedSessionId && !signedSessionId) {
            throw new Error('Signed session ID is required');
        }
        // TODO: add signed messsage to body?
        const { data } = await this.clientRelayApiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/recover`, keyShareIds ? {
            keyShareIds
        } : undefined, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicClientSessionSignature]: signedSessionId,
                [DynamicMfaTokenHeader]: mfaToken,
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async getAccessToken({ oauthAccountId, traceContext }) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/oauthAccounts/${oauthAccountId}/accessToken`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data.accessToken;
    }
    // TODO: return array instead considering cases where server has multiple parties
    async importPrivateKey({ chainName, dynamicRequestId, clientKeygenIds, thresholdSignatureScheme, bitcoinConfig, onError, onCeremonyComplete, traceContext, legacyWalletId }) {
        const { addressType } = bitcoinConfig || {};
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/privateKey/import`,
            body: _extends({
                chain: chainName,
                clientKeygenIds,
                thresholdSignatureScheme
            }, addressType ? {
                addressType
            } : {}, legacyWalletId ? {
                legacyWalletId
            } : {}),
            successEventType: SuccessEventType.KeygenComplete,
            timeoutMessage: 'Key import timed out',
            onError,
            onCeremonyComplete,
            traceContext
        });
    }
    async getUser(dynamicRequestId, traceContext) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/users`, {
            headers: {
                [DynamicRequestIdHeader]: dynamicRequestId,
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async refreshUser(traceContext) {
        const { data } = await this.apiClient.post(`/api/v0/sdk/${this.environmentId}/refresh`, undefined, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async getEnvironmentSettings(traceContext) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/settings`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async getWaasWalletById({ walletId, traceContext }) {
        const { data } = await this.apiClient.get(`/api/v0/environments/${this.environmentId}/waas/${walletId}`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    /**
   * Fetch a single WaaS wallet by ID using the /sdk/{environmentId}/waas/{walletId} endpoint.
   * This endpoint returns user information with verified credentials filtered to only include the specified WaaS wallet.
   */ async getWaasWalletByAddress({ walletAddress, traceContext }) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/waas/byWalletAddress/${walletAddress}`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async delegatedSignMessage({ walletId, message, isFormatted, dynamicRequestId, onError, context, traceContext }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/environments/${this.environmentId}/waas/${walletId}/delegatedAccess/signMessage`,
            body: {
                message,
                isFormatted,
                context
            },
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Delegated sign message timed out',
            onError,
            traceContext
        });
    }
    async createRooms({ walletId, roomType, roomCount = 5, traceContext }) {
        const { data } = await this.apiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/createRooms`, {
            roomCount,
            roomType
        }, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    async createRoomsWithoutWalletId({ roomType, thresholdSignatureScheme, roomCount = 5, traceContext }) {
        const { data } = await this.apiClient.post(`/api/v0/sdk/${this.environmentId}/waas/createRooms`, {
            roomCount,
            roomType,
            thresholdSignatureScheme
        }, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicTraceIdHeader]: traceContext == null ? void 0 : traceContext.traceId,
                [DynamicTraceElapsedTimeHeader]: getElapsedTime(traceContext == null ? void 0 : traceContext.startTime)
            }
        });
        return data;
    }
    constructor({ environmentId, authToken, backupServiceAuthToken, baseApiUrl, authMode = AuthMode.HEADER, // Represents the version of the client SDK used by developer
    sdkVersion, forwardMPCClient, baseClientKeysharesRelayApiUrl }){
        super({
            environmentId,
            authToken: authToken || '',
            backupServiceAuthToken,
            baseApiUrl,
            authMode,
            sdkVersion,
            forwardMPCClient,
            baseClientKeysharesRelayApiUrl
        });
    }
}

const SDK_NAMESPACE = {
    REACT: 'WalletKit',
    CLIENT: 'ClientSDK'
};
/**
 * Parses a potentially namespaced SDK version string
 * @param sdkVersion - The SDK version string, optionally namespaced
 * @returns Parsed SDK version with namespace and version
 * @example
 * parseNamespacedVersion("WalletKit/1.0.0") // { namespace: "WalletKit", version: "1.0.0", raw: "WalletKit/1.0.0" }
 * parseNamespacedVersion("1.0.0") // { namespace: "WalletKit", version: "1.0.0", raw: "1.0.0" }
 */ function parseNamespacedVersion(sdkVersion) {
    if (!sdkVersion || sdkVersion === '') {
        return null;
    }
    // Check if the version contains a namespace
    const colonIndex = sdkVersion.indexOf('/');
    if (colonIndex !== -1) {
        const namespace = sdkVersion.substring(0, colonIndex);
        const version = sdkVersion.substring(colonIndex + 1);
        // Validate namespace
        if (!Object.values(SDK_NAMESPACE).includes(namespace)) {
            return {
                namespace: SDK_NAMESPACE.REACT,
                version,
                raw: sdkVersion
            };
        }
        return {
            namespace: namespace,
            version,
            raw: sdkVersion
        };
    }
    // No namespace found, default to react-sdk for backward compatibility
    return {
        namespace: 'WalletKit',
        version: sdkVersion,
        raw: sdkVersion
    };
}
/**
 * Formats a parsed SDK version back to string format
 * @param parsedVersion - The parsed SDK version object
 * @returns Formatted SDK version string
 */ function formatNamespacedVersion(parsedVersion) {
    return `${parsedVersion.namespace}/${parsedVersion.version}`;
}
/**
 * Gets the version string without namespace
 * @param sdkVersion - The SDK version string, optionally namespaced
 * @returns Version string without namespace
 */ function getVersionWithoutNamespace(sdkVersion) {
    const parsed = parseNamespacedVersion(sdkVersion);
    return parsed ? parsed.version : null;
}
/**
 * Gets the namespace from a potentially namespaced SDK version
 * @param sdkVersion - The SDK version string, optionally namespaced
 * @returns The namespace or default namespace
 */ function getVersionNamespace(sdkVersion) {
    const parsed = parseNamespacedVersion(sdkVersion);
    return parsed ? parsed.namespace : null;
}

const serializeMessageForForwardMPC = ({ message, isFormatted = false, chainName })=>{
    let serializedMessage = message;
    if (isFormatted && chainName === 'EVM') {
        if (typeof message === 'string') {
            // Handle hex string (with or without 0x prefix)
            const cleanHex = message.startsWith('0x') ? message.slice(2) : message;
            serializedMessage = cleanHex;
        } else if (message instanceof Uint8Array) {
            serializedMessage = Buffer.from(message).toString('hex');
        } else if (message instanceof MessageHash) {
            serializedMessage = message.toHex();
        } else {
            throw new Error('Unsupported formatted message format');
        }
    }
    return serializedMessage;
};

const handleAxiosError = (error, message, context, logger)=>{
    var _error_response, _error_response1, _error_response2;
    logger.error('[DynamicWaasWalletClient] Axios error: ', {
        message,
        error: (_error_response = error.response) == null ? void 0 : _error_response.data,
        status: (_error_response1 = error.response) == null ? void 0 : _error_response1.status,
        context
    });
    switch((_error_response2 = error.response) == null ? void 0 : _error_response2.status){
        case 400:
            throw createHttpError(400, 'Invalid request');
        case 401:
            throw createHttpError(401, 'Authorization header or cookie is required');
        case 403:
            throw createHttpError(403, 'Forbidden');
        case 422:
            throw createHttpError(422, 'Unprocessable content');
        case 500:
            throw createHttpError(500, 'Internal server error');
        default:
            throw createHttpError(500, 'Internal server error');
    }
};

export { AuthMode, BITCOIN_ADDRESS_TYPE_CONFIG, BITCOIN_DERIVATION_PATHS, BackupLocation, BitcoinAddressType, BitcoinNetwork, CreateRoomPartiesOptions, DELEGATED_SHARE_COUNT, DYNAMIC_AUTH_BASE_API_URL_MAP, DYNAMIC_AUTH_DEV_BASE_API_URL, DYNAMIC_AUTH_PREPROD_BASE_API_URL, DYNAMIC_AUTH_PROD_BASE_API_URL, DYNAMIC_CLIENT_RELAY_REDCOAST_API_KEY_MAP, DYNAMIC_CLIENT_RELAY_REDCOAST_APP_ID_MAP, DYNAMIC_FORWARD_MPC_DEV_ENCLAVE_URL, DYNAMIC_FORWARD_MPC_ENCLAVE_ATTESTATION_CONFIG_MAP, DYNAMIC_FORWARD_MPC_ENCLAVE_URL_MAP, DYNAMIC_FORWARD_MPC_PREPROD_ENCLAVE_URL, DYNAMIC_FORWARD_MPC_PROD_ENCLAVE_URL, DYNAMIC_KEYSHARES_RELAY_MAP, DYNAMIC_KEYSHARES_RELAY_PREPROD_BASE_API_URL, DYNAMIC_KEYSHARES_RELAY_PROD_BASE_API_URL, DynamicApiClient, DynamicClientSessionSignature, DynamicForwardMPCHeader, DynamicMfaTokenHeader, DynamicRequestIdHeader, DynamicTraceElapsedTimeHeader, DynamicTraceIdHeader, ENVIRONMENT_ENUM, FEATURE_FLAGS, IFRAME_DOMAIN_MAP, MPC_CHAIN_CONFIG, MPC_CONFIG, MPC_RELAY_DEV_API_URL, MPC_RELAY_PREPROD_API_URL, MPC_RELAY_PROD_API_URL, MPC_RELAY_URL_MAP, PREPROD_RELAY_API_KEY, PREPROD_RELAY_APP_ID, PROD_RELAY_API_KEY, PROD_RELAY_APP_ID, RELAY_API_KEY_HEADER, RELAY_APP_ID_HEADER, SDK_NAMESPACE, SOLANA_RPC_URL, SigningAlgorithm, SuccessEventType, ThresholdSignatureScheme, URL_PATTERNS, WalletOperation, chain, chainEnumToVerifiedCredentialName, formatNamespacedVersion, getBitcoinChainConfig, getClientThreshold, getDynamicServerThreshold, getEnvironmentFromUrl, getMPCChainConfig, getReshareConfig, getServerWalletReshareConfig, getTSSConfig, getVersionNamespace, getVersionWithoutNamespace, handleAxiosError, parseNamespacedVersion, serializeMessageForForwardMPC, verifiedCredentialNameToChainEnum };
