import type { ForwardMPCClient } from '@dynamic-labs-wallet/forward-mpc-client';
import type { SignMessageContext } from '@dynamic-labs/sdk-api-core';
import type { BackupLocation, WalletOperation } from './constants.js';
import type { ThresholdSignatureScheme } from './mpc/index.js';
export type TraceContext = {
    traceId?: string;
    startTime?: number;
};
export type RequestWithTraceContext<T> = T & {
    traceContext?: TraceContext;
};
export declare enum AuthMode {
    HEADER = "header",
    COOKIE = "cookie"
}
export declare enum BitcoinAddressType {
    TAPROOT = "taproot",
    NATIVE_SEGWIT = "native_segwit"
}
export declare enum BitcoinNetwork {
    MAINNET = "mainnet",
    TESTNET = "testnet"
}
export type BitcoinConfig = {
    addressType?: BitcoinAddressType;
    network?: BitcoinNetwork;
    tweak?: string;
};
export type InitKeygenResult = {
    keygenId: string;
    keygenSecret: string;
};
export type KeygenResult = {
    pubkey: string;
    secretShare: string;
};
export type KeygenCompleteResponse = {
    walletId: string;
    roomId: string;
    serverKeygenIds: string[];
};
export type OpenRoomResponse = {
    roomId: string;
    serverKeygenIds: string[];
};
export type ReshareResponse = {
    roomId: string;
    serverKeygenIds: string[];
    newServerKeygenIds: string[];
};
export declare enum SuccessEventType {
    KeygenComplete = "keygen_complete",
    RoomCreated = "room_created",
    CeremonyComplete = "ceremony_complete"
}
export type InitializeResult = {
    error: unknown | null;
    traceContext?: TraceContext;
};
export interface KeyShareBackupInfo {
    passwordEncrypted: boolean;
    backups: Record<BackupLocation, BackupLocationWithExternalKeyShareId[]>;
}
export interface WaasWalletProperties {
    derivationPath?: string;
    keyShares: KeyShareInfo[];
    thresholdSignatureScheme: ThresholdSignatureScheme;
}
export interface WaasWalletResponse {
    wallet: {
        accountAddress: string;
        chainName: string;
        derivationPath: string;
        thresholdSignatureScheme: string;
        walletId: string;
    };
}
export interface KeyShareInfo {
    id: string;
    backupLocation: BackupLocation;
    passwordEncrypted: boolean;
    externalKeyShareId?: string;
}
export type FeatureFlags = Record<string, boolean>;
export type ICloudConfig = {
    containerIdentifier?: string;
    apiToken?: string;
    environment?: 'development' | 'production';
};
export interface DynamicWalletClientProps {
    environmentId: string;
    authToken?: string;
    backupServiceAuthToken?: string;
    baseApiUrl?: string;
    storageKey?: string;
    debug?: boolean;
    baseMPCRelayApiUrl?: string;
    featureFlags?: FeatureFlags;
    authMode?: AuthMode;
    sdkVersion?: string;
    forwardMPCClient?: ForwardMPCClient;
    baseClientKeysharesRelayApiUrl?: string;
    iCloudConfig?: ICloudConfig;
}
export type BackupData = {
    keyShares: string[];
    metadata: {
        version: string;
        createdAt: string;
        accountAddress: string;
        thresholdSignatureScheme: ThresholdSignatureScheme;
        hasPassword: boolean;
        encryption?: EncryptionMetadata;
        shareCount: number;
    };
};
export type EncryptionMetadata = {
    algorithm: string;
    keyDerivation: string;
    iterations: number;
    hashAlgorithm: string;
    algorithmLength: number;
    memorySize?: number;
    parallelism?: number;
    hashLength?: number;
};
export type IframeRequestMessages = {
    sendAuthToken: (token?: string, authMode?: AuthMode, traceContext?: TraceContext) => Promise<void>;
    createWalletAccount: (request: RequestWithTraceContext<CreateWalletAccountRequest>) => Promise<CreateWalletAccountResponse | MessageTransportErrorResponse>;
    getWallets: (request: RequestWithTraceContext<GetWalletsRequest>) => Promise<GetWalletResponse[] | MessageTransportErrorResponse>;
    getWallet: (request: RequestWithTraceContext<GetWalletRequest>) => Promise<GetWalletResponse | MessageTransportErrorResponse>;
    signMessage: (request: RequestWithTraceContext<SignMessageRequest>) => Promise<string | MessageTransportErrorResponse>;
    signRawMessage: (request: RequestWithTraceContext<SignRawMessageRequest>) => Promise<string | MessageTransportErrorResponse>;
    signTypedData: (request: RequestWithTraceContext<SignTypedDataRequest>) => Promise<string | MessageTransportErrorResponse>;
    requiresPasswordForOperation: (request: RequestWithTraceContext<RequiresPasswordForOperationRequest>) => Promise<boolean | MessageTransportErrorResponse>;
    signTransaction: (request: RequestWithTraceContext<SignTransactionRequest>) => Promise<string | MessageTransportErrorResponse>;
    isPasswordEncrypted: (request: RequestWithTraceContext<IsPasswordEncryptedRequest>) => Promise<boolean | MessageTransportErrorResponse>;
    backupKeySharesToGoogleDrive: (request: RequestWithTraceContext<BackupKeySharesToGoogleDriveRequest>) => Promise<string[] | MessageTransportErrorResponse>;
    backupKeySharesToICloud: (request: RequestWithTraceContext<BackupKeySharesToICloudRequest>) => Promise<void | MessageTransportErrorResponse>;
    exportClientKeysharesFromGoogleDrive: (request: RequestWithTraceContext<ExportClientKeysharesFromGoogleDriveRequest>) => Promise<void | MessageTransportErrorResponse>;
    delegateKeyShares: (request: RequestWithTraceContext<DelegateKeySharesRequest>) => Promise<void | MessageTransportErrorResponse>;
    revokeDelegation: (request: RequestWithTraceContext<RevokeDelegationRequest>) => Promise<void | MessageTransportErrorResponse>;
    refreshWalletAccountShares: (request: RequestWithTraceContext<RefreshWalletAccountSharesRequest>) => Promise<void | MessageTransportErrorResponse>;
    reshare: (request: RequestWithTraceContext<ReshareRequest>) => Promise<void | MessageTransportErrorResponse>;
    exportPrivateKey: (request: RequestWithTraceContext<ExportPrivateKeyRequest>) => Promise<void | MessageTransportErrorResponse>;
    verifyPassword: (request: RequestWithTraceContext<VerifyPasswordRequest>) => Promise<void | MessageTransportErrorResponse>;
    updatePassword: (request: RequestWithTraceContext<UpdatePasswordRequest>) => Promise<void | MessageTransportErrorResponse>;
    importPrivateKey: (request: RequestWithTraceContext<ImportPrivateKeyRequest>) => Promise<CreateWalletAccountResponse | MessageTransportErrorResponse>;
    exportClientKeyshares: (request: RequestWithTraceContext<ExportClientKeysharesRequest>) => Promise<void | MessageTransportErrorResponse>;
    offlineExportPrivateKey: (request: RequestWithTraceContext<OfflineExportPrivateKeyRequest>) => Promise<OfflineExportPrivateKeyResponse | MessageTransportErrorResponse>;
    displayICloudSignIn: (request: {
        chainName: string;
    }) => Promise<void>;
    hideICloudSignIn: () => Promise<void>;
    isICloudAuthenticated: (request: {
        chainName: string;
    }) => Promise<boolean>;
    cleanup: () => Promise<void | MessageTransportErrorResponse>;
};
export type CreateWalletAccountRequest = {
    chainName: string;
    thresholdSignatureScheme: ThresholdSignatureScheme;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    bitcoinConfig?: BitcoinConfig;
};
export type CreateWalletAccountResponse = {
    chainName: string;
    accountAddress: string;
    publicKeyHex: string;
    rawPublicKey: string | Uint8Array | undefined;
};
export type GetWalletsRequest = {
    chainName: string;
    authToken?: string;
};
export type GetWalletResponse = {
    chainName: string;
    accountAddress: string;
    walletId: string;
    clientKeySharesBackupInfo: KeyShareBackupInfo;
    derivationPath: string;
    thresholdSignatureScheme: ThresholdSignatureScheme;
};
export type GetWalletRequest = {
    chainName: string;
    accountAddress: string;
    walletOperation: WalletOperation;
    shareCount?: number;
    password?: string;
    signedSessionId: string;
    authToken?: string;
};
export type SignMessageRequest = {
    chainName: string;
    message: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
    context?: string;
    bitcoinConfig?: BitcoinConfig;
};
export type SignMessageRequestBrowser = {
    chainName: string;
    message: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
    context?: SignMessageContext;
    bitcoinConfig?: BitcoinConfig;
};
export type SignRawMessageRequest = {
    chainName: string;
    message: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
    context?: SignMessageContext;
    bitcoinConfig?: BitcoinConfig;
};
export type RequiresPasswordForOperationRequest = {
    chainName: string;
    accountAddress: string;
    walletOperation?: WalletOperation;
    authToken?: string;
};
export type SignTransactionRequest = {
    chainName: string;
    senderAddress: string;
    transaction: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
    chainId?: string;
    bitcoinConfig?: BitcoinConfig;
};
export type SignTypedDataRequest = {
    chainName: string;
    accountAddress: string;
    typedData: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
};
export type IsPasswordEncryptedRequest = {
    chainName: string;
    accountAddress: string;
    authToken?: string;
};
export type BackupKeySharesToGoogleDriveRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
};
export type BackupKeySharesToICloudRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    signInButtonId?: string;
};
export type ExportClientKeysharesFromGoogleDriveRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
};
export type DelegateKeySharesRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
};
export type RevokeDelegationRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
};
export type RefreshWalletAccountSharesRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
};
export type ReshareRequest = {
    chainName: string;
    accountAddress: string;
    oldThresholdSignatureScheme: ThresholdSignatureScheme;
    newThresholdSignatureScheme: ThresholdSignatureScheme;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
};
export type ExportPrivateKeyRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    mfaToken?: string;
    bitcoinConfig?: BitcoinConfig;
};
export type VerifyPasswordRequest = {
    chainName: string;
    accountAddress: string;
    password?: string;
    walletOperation?: WalletOperation;
    signedSessionId: string;
    authToken?: string;
};
export type UpdatePasswordRequest = {
    chainName: string;
    accountAddress: string;
    existingPassword: string;
    newPassword: string;
    signedSessionId: string;
    authToken?: string;
};
export type ImportPrivateKeyRequest = {
    chainName: string;
    privateKey: string;
    thresholdSignatureScheme: ThresholdSignatureScheme;
    password?: string;
    signedSessionId: string;
    authToken?: string;
    publicAddressCheck?: string;
    addressType?: string;
    /** ID of the legacy embedded wallet being upgraded to v3 */
    legacyWalletId?: string;
};
export type ExportClientKeysharesRequest = {
    chainName: string;
    accountAddress: string;
    signedSessionId: string;
    password?: string;
    authToken?: string;
};
export type OfflineExportPrivateKeyRequest = {
    chainName: string;
    base64Args: string;
    authToken?: string;
};
export type OfflineExportPrivateKeyResponse = {
    derivedPrivateKey: string | undefined;
};
export type MessageTransportErrorResponse = {
    error: string;
};
export type BackupLocationWithExternalKeyShareId = {
    location: BackupLocation;
    externalKeyShareId?: string;
    keyShareId?: string;
    passwordEncrypted?: boolean;
};
export type EncryptedDelegatedKeyShareEnvelope = {
    alg: string;
    iv: string;
    ct: string;
    tag: string;
    ek: string;
    kid?: string;
};
//# sourceMappingURL=types.d.ts.map