"use strict";var e=require("react/jsx-runtime"),r=require("lucide-react"),t=require("react"),i=require("./index-B-V647xG.js"),o=require("./internal-context-NWsAL807.js"),a=require("./get-is-unified-wallet--p0rdEtP.js"),n=require("./ScreenLayout-DND5buhY.js");require("@privy-io/js-sdk-core"),require("uuid"),require("jose"),require("eventemitter3"),require("./useActiveWallet-Wp8zv7qb.js"),require("zustand"),require("./context-B8VkgLLk.js"),require("tinycolor2"),require("styled-components"),require("react-device-detect"),require("./prepareFundingModalData-BADfvap9.js"),require("./events-context-Di6--rDg.js"),require("viem"),require("viem/utils"),require("./getPublicClient-CGlodIp_.js"),require("./useWallets-DEyFRWD0.js"),require("@coinbase/wallet-sdk"),require("@privy-io/ethereum"),require("mipd"),require("@privy-io/popup"),require("./paths-DizMb-lU.js"),require("./usePrivy-BM1sYNel.js"),require("@scure/base"),require("@headlessui/react"),require("@walletconnect/ethereum-provider"),require("@privy-io/urls"),require("ofetch"),require("js-cookie"),require("./frame-B14fp9oC.js"),require("@privy-io/routes"),require("x402/client"),require("@privy-io/api-base"),require("viem/accounts"),require("./use-sign-with-user-signer-BcAsQTGF.js"),require("./getEmbeddedConnectedWallet-6TsVZJkD.js"),require("./ModalHeader-HFJct04e.js"),require("@heroicons/react/24/outline/ArrowLeftIcon"),require("@heroicons/react/24/outline/ArrowRightIcon"),require("@heroicons/react/24/outline/QuestionMarkCircleIcon"),require("@heroicons/react/24/outline/XMarkIcon"),require("./Screen-M6XQZTd0.js"),require("./index-ByFhjjzH.js");const s=({connectionFailed:t,onClose:i})=>t?/*#__PURE__*/e.jsx(n.ScreenLayout,{title:"Something went wrong",subtitle:"We're on it. Please try again later.",icon:r.XCircle,iconVariant:"error",primaryCta:{label:"Close",onClick:i},watermark:!0}):/*#__PURE__*/e.jsx(n.ScreenLayout,{title:"Connecting to your wallet",subtitle:"Please wait...",iconVariant:"loading",showClose:!0,onClose:i,watermark:!1}),c={component:()=>{let{authenticated:r,user:n}=a.usePrivyContext(),{client:c,closePrivyModal:l,createAnalyticsEvent:u,walletProxy:d}=o.usePrivyInternal(),{navigate:y,data:v,setModalData:q,onUserCloseViaDialogOrKeybindRef:p}=a.usePrivyModal(),h=t.useMemo((()=>Date.now()),[]),[m,w]=t.useState(!1),{onCompleteNavigateTo:b,onFailure:f,shouldForceMFA:j,entropyId:C,entropyIdVerifier:g,recoveryMethod:I,connectingWalletAddress:x,isUnifiedWallet:A=!1}=v?.connectWallet,S=e=>{m||(w(!0),f("string"==typeof e?Error(e):e))};return t.useEffect((()=>{let e;return r?d?((async()=>{let r=await c.getAccessToken();if(!r)return S("User must be authenticated and have a Privy wallet before it can be connected");try{if(!A){if(!C||!g)return S("For on-device first-class chain wallets, entropyId and entropyIdVerifier are required");await d.connect({accessToken:r,entropyId:C,entropyIdVerifier:g})}j&&await d.verifyMfa({accessToken:r});let t=(Date.now()-h)/1e3;"EmbeddedWalletKeyExportScreen"===b&&t<1?e=setTimeout((()=>{y(b,!1)}),1e3*(1-t)):y(b,!1)}catch(e){if(i.errorIndicatesRecoveryIsNeeded(e)&&"privy"===I){let e=await c.getAccessToken();if(!e)return S("User must be authenticated and have a Privy wallet before it can be recovered");try{u({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:x}});let r=await(d?.recover({accessToken:e,entropyId:C,entropyIdVerifier:g}));r?.entropyId||S(Error("Unable to recover wallet")),b?y(b):l({shouldCallAuthOnSuccess:!1}),u({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:x}}),y(b)}catch(e){S("An error has occurred, please try again.")}}else i.errorIndicatesRecoveryIsNeeded(e)&&"privy"!==I&&"privy-v2"!==I?(q({...v,recoverWallet:{entropyId:C,entropyIdVerifier:g,onCompleteNavigateTo:b,onFailure:f},recoveryOAuthStatus:{provider:I,action:"recover",isInAccountCreateFlow:!1,shouldCreateEth:!1,shouldCreateSol:!1}}),y(i.embeddedWalletRecoveryScreen(I))):S(e)}})(),()=>clearTimeout(e)):void 0:S("User must be authenticated and have a Privy wallet before it can be connected")}),[r,n,d]),p.current=()=>{S("User exited before wallet could be connected"),l({shouldCallAuthOnSuccess:!1})},/*#__PURE__*/e.jsx(s,{connectionFailed:m,onClose:()=>l({shouldCallAuthOnSuccess:!1})})}};exports.EmbeddedWalletConnectingScreen=c,exports.EmbeddedWalletConnectingView=s,exports.default=c;
