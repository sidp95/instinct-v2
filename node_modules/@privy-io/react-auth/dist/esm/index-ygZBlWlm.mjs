import{jsxs as e,jsx as t,Fragment as n}from"react/jsx-runtime";import r,{useContext as a,createContext as i,useRef as s,useState as o,useMemo as l,useEffect as c,Suspense as d,lazy as u,useCallback as h}from"react";import p,{DEFAULT_SUPPORTED_CHAIN_IDS as w,rpc as m,PrivyClientError as y,getWallet as g,updateWallet as f,generateAuthorizationSignature as v}from"@privy-io/js-sdk-core";import{v4 as A}from"uuid";import*as k from"jose";import{base64url as T}from"jose";import{u as C,a as _,g as S,i as b,b as E,c as I,d as P,e as W,f as U,h as N,j as O,P as R,M,k as x,l as F,m as D}from"./get-is-unified-wallet-CvIzjbW7.mjs";import L from"eventemitter3";import{E as j,P as z,t as q,p as H,H as V,u as B,L as K,g as $,s as G,a as Y,b as J,c as Q,i as Z,d as X,e as ee,f as te,h as ne,j as re,k as ae,R as ie,l as se,m as oe,n as le,M as ce,o as de,q as ue,S as he,r as pe,v as we,w as me,x as ye}from"./useActiveWallet-RUYo4pXO.mjs";import{u as ge,t as fe,g as ve,U as Ae}from"./useWallets-BkIu5vyx.mjs";import{P as ke,a as Te,f as Ce,b as _e,c as Se,n as be,d as Ee,u as Ie,e as Pe,g as We,I as Ue,h as Ne,i as Oe}from"./internal-context-e-Eni5bG.mjs";import{f as Re,u as Me,W as xe,i as Fe,a as De,p as Le,e as je,P as ze,b as qe,l as He}from"./prepareFundingModalData-CRrWM52E.mjs";import{createCoinbaseWalletSDK as Ve}from"@coinbase/wallet-sdk";import{toViemTransactionSerializable as Be,STRING_TO_NUMBER_TXN_TYPE as Ke}from"@privy-io/ethereum";import{P as $e,C as Ge,a as Ye,H as Je,O as Qe,S as Ze,u as Xe,b as et,c as tt,D as nt,d as rt,g as at,V as it,R as st,e as ot,f as lt,h as ct,i as dt,j as ut,I as ht,k as pt,l as wt,m as mt,W as yt}from"./context-Bu4xmqpC.mjs";import{createStore as gt}from"mipd";import{isMobile as ft,isIOS as vt,isAndroid as At,isSafari as kt}from"react-device-detect";import{toHex as Tt,isAddress as Ct,getAddress as _t,isHex as St,hashAuthorization as bt}from"viem/utils";import{trigger as Et}from"@privy-io/popup";import{u as It,p as Pt,a as Wt,b as Ut,f as Nt,c as Ot,d as Rt,e as Mt,o as xt,g as Ft,h as Dt,i as Lt,j as jt,k as zt,l as qt,m as Ht,n as Vt,q as Bt,r as Kt,s as $t,t as Gt,v as Yt,w as Jt,x as Qt,y as Zt,z as Xt,A as en,B as tn,C as nn,D as rn,E as an,F as sn,G as on,H as ln,I as cn,J as dn,K as un,L as hn,M as pn,N as wn,O as mn,P as yn,Q as gn,R as fn,S as vn,T as An,U as kn,V as Tn,W as Cn,X as _n,Y as Sn,Z as bn,_ as En,$ as In,a0 as Pn,a1 as Wn,a2 as Un,a3 as Nn,a4 as On}from"./paths-3HW55qZg.mjs";import{o as Rn,p as Mn,d as xn,r as Fn,b as Dn,s as Ln,a as jn,u as zn,c as qn,S as Hn,e as Vn,P as Bn,f as Kn}from"./usePrivy-Bn7q4pcu.mjs";import{base64 as $n}from"@scure/base";import{styled as Gn,createGlobalStyle as Yn,css as Jn}from"styled-components";import{u as Qn,a as Zn,p as Xn,e as er,P as tr}from"./events-context-CI0iqAXA.mjs";import{create as nr}from"zustand";import{Transition as rr,Dialog as ar,TransitionChild as ir,DialogPanel as sr}from"@headlessui/react";import{EthereumProvider as or,OPTIONAL_METHODS as lr,OPTIONAL_EVENTS as cr}from"@walletconnect/ethereum-provider";import{constructURL as dr}from"@privy-io/urls";import{toHex as ur,zeroAddress as hr,getAddress as pr,createWalletClient as wr,http as mr,parseSignature as yr}from"viem";import{g as gr,a as fr}from"./getPublicClient-A9RSftUZ.mjs";import{ofetch as vr}from"ofetch";import Ar from"js-cookie";import{F as kr}from"./frame-CwE9r3cT.mjs";import{MfaAuthPasskeyVerify as Tr,MfaAuthPasskeyInit as Cr,MfaAuthTotpVerify as _r,MfaAuthPasskeyEnrollment as Sr,MfaAuthTotpUnenroll as br,MfaAuthTotpEnroll as Er,MfaAuthTotpInit as Ir}from"@privy-io/routes";import{selectPaymentRequirements as Pr,createPaymentHeader as Wr}from"x402/client";import{InvalidInputError as Ur}from"@privy-io/api-base";import{toAccount as Nr}from"viem/accounts";import{u as Or}from"./use-sign-with-user-signer-eEm9Olt_.mjs";import"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";class Rr{static parse(e){try{return new Rr(e)}catch(e){return null}}static throwIfNotWellFormedJwt(e){return k.decodeJwt(e),e}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=k.decodeJwt(e)}}class Mr extends Rr{static parse(e){try{return new Mr(e)}catch(e){return null}}get appId(){return this._decoded.aid?this._decoded.aid:this.audience}}const xr=({style:n,...r})=>/*#__PURE__*/e("svg",{viewBox:"0 0 1024 1024",fill:"none",xmlns:"http://www.w3.org/2000/svg",style:{height:"28px",width:"28px",...n},...r,children:[/*#__PURE__*/t("rect",{width:"1024",height:"1024",fill:"#0052FF",rx:100,ry:100}),/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z",fill:"white"})]}),Fr="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==",Dr="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC";let Lr,jr;class zr extends j{async initialize(){await this.importPromise,await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Dr,id:"com.coinbase.wallet"}}async promptConnection(){try{await this.importPromise;let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super("base_account",e,t,n),this.connectorType="base_account",this.walletClientType="base_account",this.displayName="Base",this.setBaseAccountSdk=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.baseAccountConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},Lr?(this.proxyProvider.setWalletProvider(Lr.getProvider()),this.setBaseAccountSdk(Lr)):this.importPromise=import("@base-org/account").then((({createBaseAccountSDK:e})=>{Lr=e(this.baseAccountConfig),this.proxyProvider.setWalletProvider(Lr.getProvider()),this.setBaseAccountSdk(Lr)})).catch(console.error)}}let qr=[1,11155111,137,10,8453,84532,42161,7777777,43114,56];class Hr extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Fr,id:"com.coinbase.wallet"}}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}updateConnectionPreference(e){this.coinbaseWalletConfig={...this.coinbaseWalletConfig,preference:{...this.coinbaseWalletConfig.preference,options:e}},this.walletClientType="smartWalletOnly"===e?"coinbase_smart_wallet":"coinbase_wallet",jr=Ve({...this.coinbaseWalletConfig}),this.proxyProvider.setWalletProvider(jr.getProvider())}constructor(e,t,n,r){if(super("coinbase_wallet",e,t,n),this.connectorType="coinbase_wallet",this.displayName="Coinbase Wallet",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.coinbaseWalletConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},this.walletClientType="smartWalletOnly"===this.coinbaseWalletConfig.preference?.options?"coinbase_smart_wallet":"coinbase_wallet","coinbase_smart_wallet"===this.walletClientType&&(this.displayName="Coinbase Smart Wallet"),!jr){let e="eoaOnly"!==this.coinbaseWalletConfig.preference?.options?(this.coinbaseWalletConfig.appChainIds??[]).filter((e=>!qr.includes(e))):[];e.length>0&&!e.every((e=>w.has(e)))&&console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e.join(", ")}`),jr=Ve(this.coinbaseWalletConfig)}this.proxyProvider.setWalletProvider(jr.getProvider())}}const Vr=({...e})=>/*#__PURE__*/t("svg",{width:"15",height:"15",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg",...e,children:/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z",fill:e.color||"var(--privy-color-foreground-3)"})});class Br extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return await this.isConnected()?(await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[q(e?.chainId||"0x1")]}),this.getConnectedWallet()):null}get walletBranding(){return{name:"Privy Wallet",icon:Vr,id:"io.privy.wallet"}}disconnect(){this.connected=!1}async promptConnection(){}constructor({provider:e,chains:t,defaultChain:n,rpcConfig:r,imported:a,walletIndex:i}){super("privy",t,n,r),this.connectorType="embedded",this.proxyProvider=e,this.walletIndex=i,a&&(this.connectorType="embedded_imported"),this.subscribeListeners()}}async function Kr(){let e=Ns();return e?e.getAccessToken():Promise.resolve(Me.get($e)||Me.get(Ge)||null)}const $r=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];function Gr(e){return e?{"privy-ui":"t"}:void 0}class Yr{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new Te("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(Pt,{email:this.meta.email,code:this.meta.emailCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new Te("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(Wt,{email:this.meta.email,code:this.meta.emailCode})}catch(e){throw Ce(e)}}async sendCodeEmail({email:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Te("Auth flow has no API instance");if(e&&(this.meta.email=e),t&&(this.meta.captchaToken=t),!this.meta.email)throw new Te("Email must be set when initialzing authentication.");let r=Gr(n);try{return await this.api.post(Ut,{email:this.meta.email,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Ce(e)}}constructor({email:e,captchaToken:t,disableSignup:n}){this.meta={email:e,captchaToken:t,disableSignup:n??!1}}}class Jr extends Yr{async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode||!this.meta.oldAddress)throw new Te("Email, email code, and an old email address must be set prior to calling update.");try{return await this.api.post(It,{oldAddress:this.meta.oldAddress,newAddress:this.meta.email,code:this.meta.emailCode})}catch(e){throw Ce(e)}}constructor(e,t,n){super({email:t,captchaToken:n}),this.meta={email:t,captchaToken:n,oldAddress:e,disableSignup:!1}}}class Qr{execute(e){return null===this.promise&&(this.promise=(async()=>{try{return await this.fn(e)}finally{this.promise=null}})()),this.promise}constructor(e){this.promise=null,this.fn=e}}class Zr{get meta(){return this._meta}async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.channelToken)throw new Te("Auth flow must be initialized first");try{let e=await this.api.post(Nt,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});if(!e)throw new Te("No response from authentication");return e}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Ot,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid})}catch(e){throw Ce(e)}}async _startChannelOnce(){if(!this.api)throw new Te("Auth flow has no API instance");let e=await this.api.post(Rt,{token:this.captchaToken});ft&&!vt&&e.connect_uri&&Rn(e.connect_uri,"_blank"),this._meta={...this._meta,connectUri:e.connect_uri,channelToken:e.channel_token}}async initializeFarcasterConnect(){if(!this.api)throw new Te("Auth flow has no API instance");await this.startChannelOnce.execute()}async _pollForReady(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.channelToken)throw new Te("Auth flow must be initialized first");let e=await this.api.get(Mt,{headers:{"farcaster-channel-token":this.meta.channelToken}});return"completed"===e.state&&(this.message=e.message,this.signature=e.signature,this.fid=e.fid,!0)}constructor(e,t=!1){this._meta={disableSignup:!1},this.captchaToken=e,this.startChannelOnce=new Qr(this._startChannelOnce.bind(this)),this.pollForReady=new Qr(this._pollForReady.bind(this)),this._meta.disableSignup=t}}function Xr(){return"undefined"!=typeof window&&"chrome-extension:"===window.location.protocol&&"chrome"in window}function ea(){if(!Xr())return;let e=window.chrome;return e?.runtime?.id}function ta(){if(!Xr())return!1;let e=window.chrome;return"function"==typeof e?.identity?.launchWebAuthFlow}async function na(e){return new Promise(((t,n)=>{ta()?window.chrome.identity.launchWebAuthFlow({url:e,interactive:!0},(async e=>{try{let n=function(){if(!Xr())return;let e=window.chrome;return e?.runtime?.lastError?.message}();if(n||!e){let e=`WebAuthFlow failed: ${n||"Response URI missing"}`;throw Error(e)}let r=new URL(e),a=ea();if(!a)throw Error("Invalid extension context");if("chrome-extension:"===r.protocol){if(r.hostname!==a)throw Error("Invalid responseUri origin")}else{if("https:"!==r.protocol)throw Error("Invalid responseUri protocol");{let e=r.hostname.split(".");if(3!==e.length||"chromiumapp"!==e[1]||"org"!==e[2]||e[0]!==a)throw Error("Invalid responseUri origin")}}let i=r.searchParams.get("privy_oauth_state"),s=r.searchParams.get("privy_oauth_code");if(!i||!s)throw Error("Invalid responseUri - missing required parameters");t({privyOAuthState:i,privyOAuthCode:s})}catch(e){n(e)}})):n(Error("Chrome identity API not available"))}))}function ra(e){return crypto.getRandomValues(new Uint8Array(e))}function aa(){return T.encode(ra(36))}function ia(){return aa()}async function sa(e,t="S256"){if("S256"!=t)return e;{let t=await async function(e){let t=(new TextEncoder).encode(e);return new Uint8Array(await crypto.subtle.digest("SHA-256",t))}(e);return T.encode(t)}}class oa{addCaptchaToken(e){this.meta.captchaToken=e}isActive(){return!!(this.meta.authorizationCode&&this.meta.stateCode&&this.meta.provider)}async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Te("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");if("undefined"===this.meta.authorizationCode)throw new Te("User denied confirmation during OAuth flow");let e=function(){let e=Me.get(Ye);if(!e)throw new Te("Authentication error.");return e}();try{let t=await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});return Me.del(Ye),Me.del(Je),Me.del(Qe),t}catch(e){let t=Ce(e);if(t.privyErrorCode)throw new Te(t.message||"Invalid code during OAuth flow.",void 0,t.privyErrorCode);if("User denied confirmation during OAuth flow"===t.message)throw new Te("Invalid code during oauth flow.",void 0,_e.OAUTH_USER_DENIED);throw new Te("Invalid code during OAuth flow.",void 0,_e.UNKNOWN_AUTH_ERROR)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Te("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");if("undefined"===this.meta.authorizationCode)throw new Te("User denied confirmation during OAuth flow");let e=Me.get(Ye);if(!e)throw new Te("Authentication error.");try{let t=await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e});return Me.del(Ye),t}catch(e){throw Ce(e)}}async getAuthorizationUrl(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.provider)throw new Te("Provider must be set when initializing OAuth authentication.");let e=aa();Me.put(Ye,e);let t=ia();Me.put(Ze,t);let n=await sa(e);this.meta.withPrivyUi||Me.put(Je,!0),this.meta.disableSignup?Me.put(Qe,!0):Me.del(Qe);let r=Gr(this.meta.withPrivyUi),a=window.location.href,i=function(){let e=ea();if(e)return`https://${e}.chromiumapp.org`}();i&&(a=i);try{return await this.api.post(Dt,{provider:this.meta.provider,redirect_to:this.meta.customOAuthRedirectUrl||a,token:this.meta.captchaToken,code_challenge:n,state_code:t},{headers:{...r}})}catch(e){throw Ce(e)}}constructor(e){this.meta=e}}function la(){let e=new URLSearchParams(window.location.search),t=e.get("privy_oauth_code"),n=e.get("privy_oauth_state"),r=e.get("privy_oauth_provider");if(!t||!n||!r)return{inProgress:!1};let a=!1;try{a=!!window.opener.location.origin}catch{}return{inProgress:!0,authorizationCode:t,stateCode:n,provider:r,withPrivyUi:!Me.get(Je),popupFlow:null!==window.opener&&a,disableSignup:!!Me.get(Qe)}}function ca(){let e=new URL(window.location.href);e.searchParams.delete("privy_oauth_code"),e.searchParams.delete("privy_oauth_provider"),e.searchParams.delete("privy_oauth_state"),Me.del(Ze),window.history.replaceState({},"",e)}class da{async initRegisterFlow(e){if(!this.api)throw new Te("Auth flow has no API instance");this.authenticateForRegistration=!0,this.meta.initRegisterResponse=await this.initRegisterOnce.execute(e)}async initAuthenticationFlow(e){if(!this.api)throw new Te("Auth flow has no API instance");this.authenticateForRegistration=!1,this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute(e)}async initLinkFlow(){if(!this.api)throw new Te("Auth flow has no API instance");this.meta.initLinkResponse=await this.initLinkOnce.execute()}async register(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new Te("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Te("WebAuthn is not supported in this browser");this.meta.initRegisterResponse||(this.meta.initRegisterResponse=await this.initRegisterOnce.execute());try{let t=this.meta.initRegisterResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(Lt,{relying_party:this.meta.initRegisterResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Te("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Ce(e)}}async authenticate(){if(this.authenticateForRegistration)return this.register();let e=await import("@simplewebauthn/browser");if(!this.api)throw new Te("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Te("WebAuthn is not supported in this browser");this.meta.initAuthenticateResponse||(this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute());let t=this.meta.allowedCredentialsIds?.map((e=>({type:"public-key",id:e})))??this.meta.initAuthenticateResponse.options.allow_credentials;try{let n=await e.startAuthentication({optionsJSON:this._transformInitAuthenticateOptionsToCamelCase({...this.meta.initAuthenticateResponse.options,allow_credentials:t})});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(jt,{relying_party:this.meta.initAuthenticateResponse.relying_party,challenge:this.meta.initAuthenticateResponse.options.challenge,authenticator_response:this._transformAuthenticationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Te("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Ce(e)}}async link(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new Te("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Te("WebAuthn is not supported in this browser");this.meta.initLinkResponse||(this.meta.initLinkResponse=await this.initLinkOnce.execute());try{let t=this.meta.initLinkResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(zt,{relying_party:this.meta.initLinkResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Te("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Ce(e)}}async _initRegisterOnce(e){if(!this.api)throw new Te("Auth flow has no API instance");let t=Gr(e);return await this.api.post(qt,{token:this.meta.captchaToken},{headers:{...t}})}async _initAuthenticateOnce(e){if(!this.api)throw new Te("Auth flow has no API instance");let t=Gr(e);return await this.api.post(Ht,{token:this.meta.captchaToken},{headers:{...t}})}async _initLinkOnce(){if(!this.api)throw new Te("Auth flow has no API instance");return await this.api.post(Vt,{})}_transformInitLinkOptionsToCamelCase(e){return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params.map((e=>({type:e.type,alg:e.alg}))),timeout:e.timeout,excludeCredentials:e.exclude_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports}))),authenticatorSelection:{authenticatorAttachment:e.authenticator_selection?.authenticator_attachment,requireResidentKey:e.authenticator_selection?.require_resident_key,residentKey:e.authenticator_selection?.resident_key,userVerification:e.authenticator_selection?.user_verification},attestation:e.attestation,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props?.rk,hmacCreateSecret:e.extensions?.hmac_create_secret},hints:this.meta.hints}}_transformRegistrationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}_transformInitAuthenticateOptionsToCamelCase(e){return{rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}_transformAuthenticationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}constructor({captchaToken:e,setPasskeyAuthState:t,hints:n}){this.authenticateForRegistration=!1,this.initRegisterOnce=new Qr(this._initRegisterOnce.bind(this)),this.initAuthenticateOnce=new Qr(this._initAuthenticateOnce.bind(this)),this.initLinkOnce=new Qr(this._initLinkOnce.bind(this)),this.meta={captchaToken:e,setPasskeyAuthState:t,hints:n}}}const ua=({address:e,chainId:t,nonce:n})=>`${window.location.host} wants you to sign in with your Ethereum account:\n${e}\n\nBy signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\n\nURI: ${window.location.origin}\nVersion: 1\nChain ID: ${t}\nNonce: ${n}\nIssued At: ${(new Date).toISOString()}\nResources:\n- https://privy.io`;class ha{get meta(){return{connectorType:this.wallet?.connectorType,walletClientType:this.wallet?.walletClientType,chainId:this.wallet?.chainId,address:this.wallet?.address,disableSignup:this._meta.disableSignup}}async authenticate(){if(!this.client)throw new Te("SiweFlow has no client instance");try{if(this.preparedMessage&&this.signature)return await this.client.authenticateWithSiweInternal({message:this.preparedMessage,signature:this.signature,chainId:this.wallet?.chainId,walletClientType:this.walletClientType??this.wallet?.walletClientType,connectorType:this.connectorType??this.wallet?.connectorType,mode:this._meta.disableSignup?"no-signup":"login-or-sign-up"});if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.client)throw new Te("SiweFlow has no client instance");try{if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType})}catch(e){throw Ce(e)}}async sign(){if(!this.client)throw new Te("SiweFlow has no client instance");if(await this.buildMessage(),!this.preparedMessage)throw new Te("Could not prepare SIWE message");if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let e=await this.wallet.sign(this.preparedMessage);return{message:this.preparedMessage,signature:e}}async _getNonceOnce(){if(!this.client)throw new Te("SiweFlow has no client instance");if(!this.wallet)throw new Te("UI SiweFlow has no wallet instance");return await this.client.generateSiweNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Te("SiweFlow has no client instance");if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let e=this.wallet.address,t=this.wallet.chainId.replace("eip155:","");return this.nonce||(this.nonce=await this.getNonceOnce.execute()),this.preparedMessage=ua({address:e,chainId:t,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a){this._meta={disableSignup:!1},this.getNonceOnce=new Qr(this._getNonceOnce.bind(this)),this.wallet=t,this.captchaToken=n,this.client=e,this._meta.disableSignup=r,this.preparedMessage=a?.message,this.signature=a?.signature,this.walletClientType=a?.walletClientType,this.connectorType=a?.connectorType}}class pa{get meta(){return{connectorType:this.wallet.connectorType,walletClientType:this.wallet.walletClientType,disableSignup:this._meta.disableSignup,messageType:this._meta.messageType,address:this.wallet?.address}}set messageType(e){this._meta.messageType=e}async authenticate(){if(!this.client)throw new Te("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up",messageType:this.meta.messageType})}catch(e){throw Ce(e)}}async link(){if(!this.client)throw new Te("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,messageType:this.meta.messageType})}catch(e){throw Ce(e)}}async sign(){let e,t;if(!this.client)throw new Te("SiwsFlow has no client instance");await this.buildMessage();let n="transaction"===this.meta.messageType;if(!this.preparedMessage)throw new Te("Could not prepare SIWS message");if(!n&&!this.wallet.provider.signMessage||n&&!this.wallet.provider.signTransaction)throw new Te("Wallet does not support the necessary signing methods");if(n&&this._plugin){let n=await this.wallet.provider.signTransaction({transaction:$n.decode(this.preparedMessage)});e=$n.encode(n.signedTransaction),t=this._plugin.getSignatureFromTransaction(n.signedTransaction,this.wallet.address)}else{e=this.preparedMessage;let n=await this.wallet.provider.signMessage({message:(new TextEncoder).encode(this.preparedMessage)});t=$n.encode(n.signature)}return{message:e,signature:t}}async _getNonceOnce(){if(!this.client)throw new Te("SiwsFlow has no client instance");return await this.client.generateSiwsNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Te("SiwsFlow has no client instance");let e=this.wallet.address;return this.nonce||(this.nonce=await this.getNonceOnce.execute()),"transaction"===this.meta.messageType&&this._plugin?this.preparedMessage=this._plugin.createSiwsMemoTransaction({address:e,nonce:this.nonce}):this.preparedMessage=Mn({address:e,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a="plain",i){this._meta={disableSignup:!1,messageType:"plain"},this.getNonceOnce=new Qr(this._getNonceOnce.bind(this)),this.wallet=e,this.captchaToken=n,this.client=t,this._meta.disableSignup=r,this._meta.messageType=a,this._plugin=i}}class wa{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Te("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(Bt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Te("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(Kt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Ce(e)}}async sendSmsCode({phoneNumber:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Te("Auth flow has no API instance");if(e&&(this.meta.phoneNumber=e),t&&(this.meta.captchaToken=t),!this.meta.phoneNumber)throw new Te("phone nNumber must be set when initialzing authentication.");let r=Gr(n);try{return await this.api.post($t,{phoneNumber:this.meta.phoneNumber,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Ce(e)}}constructor({phoneNumber:e,captchaToken:t,disableSignup:n}){this.meta={phoneNumber:e,captchaToken:t,disableSignup:n??!1}}}class ma extends wa{async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode||!this.meta.oldPhoneNumber)throw new Te("Phone number, sms code, and an old phone number must be set prior to calling update.");try{return await this.api.post(Gt,{old_phone_number:this.meta.oldPhoneNumber,new_phone_number:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Ce(e)}}constructor(e,t,n){super({phoneNumber:t,captchaToken:n}),this.meta={phoneNumber:t,captchaToken:n,oldPhoneNumber:e,disableSignup:!1}}}const ya=/*#__PURE__*/i({enabled:!1,siteKey:"",provider:void 0,appId:void 0,token:void 0,error:void 0,status:"disabled",setToken:be,setError:be,setExecuting:be,waitForResult:()=>Promise.resolve(""),ref:{current:null},remove:Ee,reset:be,execute:be});class ga extends Se{constructor(e,t,n){super(e||"Captcha failed"),this.type="Captcha",t instanceof Error&&(this.cause=t),this.privyErrorCode=n}}const fa=({children:e,appId:n,captchaSiteKey:r,enabledCaptchaProvider:a})=>{let i=s(null),c=s(null),[d,u]=o(),[h,p]=o(),[w,m]=o(!1),y=l((()=>a?w||d||h?!w||d||h?d&&!h?{status:"success",token:d}:h?{status:"error",error:h}:{status:"ready"}:{status:"loading"}:{status:"ready"}:{status:"disabled"}),[a,d,h,w]),g=l((()=>a?"turnstile"===a?{remove:()=>{i.current?.remove(),m(!1),p(void 0),u(void 0)},reset:()=>{i.current?.reset(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),i.current?.execute()},waitForResult:async()=>{try{return await H((()=>i.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new ga("Captcha failed",null,_e.CAPTCHA_TIMEOUT)}}}:{remove:()=>{c.current?.removeCaptcha(),m(!1),p(void 0),u(void 0)},reset:()=>{c.current?.resetCaptcha(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),c.current?.execute()},waitForResult:async()=>{try{return await H((()=>{let e=c.current?.getResponse();if(e)return e}),{interval:200,timeout:2e4})}catch(e){throw new ga("Captcha failed",null,_e.CAPTCHA_TIMEOUT)}}}:null),[a]),f=l((()=>{if(!a||!g)return{...y,enabled:!1,siteKey:"",appId:n,setToken:be,setError:be,setExecuting:be,waitForResult:()=>Promise.resolve(void 0),remove:Ee,reset:be,execute:be,provider:void 0,ref:{current:null}};let e={...y,enabled:!0,appId:n,setToken:u,setError:p,setExecuting:m};return"turnstile"===a?{...e,provider:"turnstile",ref:i,siteKey:r.split("t:")[1]??"",...g}:{...e,provider:"hcaptcha",ref:c,siteKey:r.split("h:")[1]??"",...g}}),[y,a,g,n,r]);/*#__PURE__*/return t(ya.Provider,{value:f,children:e})},va=()=>a(ya);async function Aa(e){if(e.enabled){if("error"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);return"success"===e.status?e.token:(e.execute(),await e.waitForResult())}}class ka{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Yt,{captcha_token:this.meta.captchaToken,telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Jt,{telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData})}catch(e){throw Ce(e)}}constructor(e,t=!1){this.meta={disableSignup:!1},this.meta={captchaToken:e,disableSignup:!1},this.meta.disableSignup=t}}function Ta(e){let t={detail:"",retryable:!1};return e?.privyErrorCode===_e.LINKED_TO_ANOTHER_USER&&(t.detail="This account has already been linked to another user."),e?.privyErrorCode===_e.DISALLOWED_LOGIN_METHOD&&(t.detail="Login with Telegram not allowed."),e?.privyErrorCode===_e.INVALID_DATA&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.CANNOT_LINK_MORE_OF_TYPE&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.INVALID_CREDENTIALS&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&(t.detail="Too many requests. Please wait before trying again."),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&e.message.includes("rate limit")&&(t.detail="Request limit reached for Telegram. Please wait a moment and try again."),e instanceof ga&&(t.retryable=!0,t.detail="Something went wrong. Try again."),t}function Ca(e){return Object.fromEntries(decodeURIComponent(e).split("&").map((e=>e.split("=").map(decodeURIComponent))))}function _a(){let e=new URL(window.location.href);e.searchParams.delete("id"),e.searchParams.delete("hash"),e.searchParams.delete("auth_date"),e.searchParams.delete("first_name"),e.searchParams.delete("last_name"),e.searchParams.delete("username"),e.searchParams.delete("photo_url"),e.hash="",window.history.replaceState({},"",e)}let Sa=/*#__PURE__*/u((()=>import("./TurnstileWrapper-Co-t5mTh.mjs"))),ba=/*#__PURE__*/u((()=>import("./HCaptchaWrapper-CUi9LJsp.mjs")));const Ea=n=>{let r=va();return c((()=>r.remove),[r.remove]),r.enabled&&r.provider?/*#__PURE__*/t(d,{fallback:null,children:/*#__PURE__*/e("div",{className:"hidden h-0 w-0",children:["turnstile"===r.provider&&/*#__PURE__*/t(Sa,{...n,captchaContext:r}),"hcaptcha"===r.provider&&/*#__PURE__*/t(ba,{...n,captchaContext:r})]})}):null};var Ia=/*#__PURE__*/Object.freeze({__proto__:null,AccountNotFoundScreen:()=>import("./AccountNotFoundScreen-Q-gvf1Fn.mjs"),AffirmativeConsentScreen:()=>import("./AffirmativeConsentScreen-CLQuUvfP.mjs"),AllowlistRejectionScreen:()=>import("./AllowlistRejectionScreen-CA0r2B2G.mjs"),AuthenticateWithWalletScreen:()=>import("./AuthenticateWithWalletScreen-CJ0PGjN8.mjs"),AwaitingEvmToSolBridgingScreen:()=>import("./AwaitingEvmToSolBridgingScreen-BCl9wYAA.mjs"),AwaitingExternalEthereumTransferScreen:()=>import("./AwaitingExternalEthereumTransferScreen-PysgS8Qt.mjs"),AwaitingPasswordlessCodeScreen:()=>import("./AwaitingPasswordlessCodeScreen-BV79QlfB.mjs"),AwaitingSolToEvmBridgingScreen:()=>import("./AwaitingSolToEvmBridgingScreen-BAWOxcgh.mjs"),CaptchaScreen:()=>import("./CaptchaScreen-BpGtWd73.mjs"),CoinbaseOnrampStatusScreen:()=>import("./CoinbaseOnrampStatusScreen-0Uex7DsA.mjs"),ConnectLedgerScreen:()=>import("./ConnectLedgerScreen-CQFzXuWK.mjs"),ConnectOnlyLandingScreen:()=>import("./ConnectOnlyLandingScreen-BHXmw89v.mjs"),ConnectOnlyStatusScreen:()=>import("./ConnectOnlyStatusScreen-CrK4PC6t.mjs"),ConnectOrCreateScreen:()=>import("./ConnectOrCreateScreen-BrRb6sNR.mjs"),ConnectionStatusScreen:()=>import("./ConnectionStatusScreen-KrobwyOT.mjs"),CrossAppAuthScreen:()=>import("./CrossAppAuthScreen-BOKIMDhq.mjs"),DelegatedActionsConsentScreen:()=>import("./DelegatedActionsConsentScreen-B7RhRjIf.mjs"),DelegatedActionsRevokeScreen:()=>import("./DelegatedActionsRevokeScreen-C5V6mhCq.mjs"),EmbeddedWalletConnectingScreen:()=>import("./EmbeddedWalletConnectingScreen-C9Fw9Ret.mjs"),EmbeddedWalletCreatedScreen:()=>import("./EmbeddedWalletCreatedScreen-keGjjfu4.mjs"),EmbeddedWalletKeyExportScreen:()=>import("./EmbeddedWalletKeyExportScreen-DxbOABYY.mjs"),EmbeddedWalletOnAccountCreateScreen:()=>import("./EmbeddedWalletOnAccountCreateScreen-B7blEQwB.mjs"),EmbeddedWalletPasswordCreateScreen:()=>import("./RecoveryPasswordCreateScreen-BgT7udfA.mjs"),EmbeddedWalletPasswordUpdateScreen:()=>import("./EmbeddedWalletPasswordUpdateScreen-B25GzXZc.mjs"),EmbeddedWalletPasswordUpdateSplashScreen:()=>import("./EmbeddedWalletPasswordUpdateSplashScreen-Cu_NA9L6.mjs"),ErrorScreen:()=>import("./ErrorScreen-DLsfgpC9.mjs"),FarcasterConnectStatusScreen:()=>import("./FarcasterConnectStatusScreen-ng3F34Zy.mjs"),FarcasterSignerStatusScreen:()=>import("./FarcasterSignerStatusScreen-C19Go4EG.mjs"),FundSolWalletWithExternalSolanaWallet:()=>import("./FundSolWalletWithExternalSolanaWallet-DpBJNLZJ.mjs"),FundingAmountEditScreen:()=>import("./FundingEditAmountScreen-DVwlwSMh.mjs"),FundingMethodSelectionScreen:()=>import("./FundingMethodSelectionScreen-BEXU_dRV.mjs"),InAppBrowserLoginNotPossible:()=>import("./InAppBrowserLoginNotPossible-fdO06E7f.mjs"),InstallWalletScreen:()=>import("./InstallWalletScreen-BTCkqOY-.mjs"),LandingScreen:()=>import("./LandingScreen-BYYtxc3M.mjs"),LinkConflictScreen:()=>import("./LinkConflictScreen-CEU67LFR.mjs"),LinkEmailScreen:()=>import("./LinkEmailScreen-frIcyTMB.mjs"),LinkPasskeyScreen:()=>import("./LinkPasskeyScreen-DJveInKu.mjs"),LinkPhoneScreen:()=>import("./LinkPhoneScreen-DoNf-oO4.mjs"),LoginFailedScreen:()=>import("./LoginFailedScreen-g2jT2Kyc.mjs"),ManualTransferScreen:()=>import("./ManualTransferScreen-Cc1Y8Jih.mjs"),MfaAuthEnrollmentFlowScreen:()=>import("./MfaAuthEnrollmentFlowScreen-O3_CYjp9.mjs"),MfaAuthVerifyFlowScreen:()=>import("./MfaAuthVerifyFlowScreen-T7Rg8uvy.mjs"),MfaEnrollmentFlowScreen:()=>import("./MfaEnrollmentFlowScreen-Bz72-m4D.mjs"),MoonpayStatusScreen:()=>import("./MoonpayStatusScreen-B8KZWDvr.mjs"),OAuthStatusScreen:()=>import("./OAuthStatusScreen-BqifArEf.mjs"),PasskeySelectSignupOrLogin:()=>import("./PasskeySelectSignupOrLogin-BnluBsvm.mjs"),PasskeyStatusScreen:()=>import("./PasskeyStatusScreen-DNO05Efn.mjs"),PasswordRecoveryScreen:()=>import("./PasswordRecoveryScreen-B7NJ3m5d.mjs"),RecoveryOAuthScreen:()=>import("./RecoveryOAuthStatusScreen-C0tnlfv2.mjs"),RecoverySelectionScreen:()=>import("./RecoverySelectionScreen-ePxeHUj1.mjs"),SendTransactionScreen:()=>import("./index-DieEhruj.mjs"),SetAutomaticRecoveryScreen:()=>import("./SetAutomaticRecoveryScreen-CVl0jRLW.mjs"),SignRequestScreen:()=>import("./SignRequestScreen-DsHKzR1x.mjs"),StandardSignAndSendTransactionScreen:()=>import("./StandardSignAndSendTransactionScreen-BuT88OVq.mjs"),TelegramAuthScreen:()=>import("./TelegramAuthScreen-DQ63cPv-.mjs"),TransferFromWalletScreen:()=>import("./TransferFromWalletScreen-rtFkHQRz.mjs"),UpdateEmailScreen:()=>import("./UpdateEmailScreen-sALtnLLN.mjs"),UpdatePhoneScreen:()=>import("./UpdatePhoneScreen-DKfVISn1.mjs"),UserLimitReachedScreen:()=>import("./UserLimitReachedScreen-BoinP76r.mjs"),WalletInterstitialScreen:()=>import("./WalletInterstitialScreen-jn7VehvZ.mjs")});function Pa(e){Qn("configureMfa",e)}const Wa=nr((()=>({inProgressMfaFlow:void 0})));const Ua=Yn`
  :root {
     ${e=>Na(e.palette)}
  };
`;const Na=e=>{let t=function(e){return{"--privy-color-background":e.background,"--privy-color-background-2":e.background2,"--privy-color-background-3":e.background3,"--privy-color-foreground":e.foreground,"--privy-color-foreground-2":e.foreground2,"--privy-color-foreground-3":e.foreground3,"--privy-color-foreground-4":e.foreground4,"--privy-color-foreground-accent":e.foregroundAccent,"--privy-color-accent":e.accent,"--privy-color-accent-light":e.accentLight,"--privy-color-accent-hover":e.accentHover,"--privy-color-accent-dark":e.accentDark,"--privy-color-accent-darkest":e.accentDarkest,"--privy-color-success":e.success,"--privy-color-success-dark":e.successDark,"--privy-color-success-light":e.successLight,"--privy-color-success-bg":e.successBg,"--privy-color-error":e.error,"--privy-color-error-light":e.errorLight,"--privy-color-error-bg":e.errorBg,"--privy-color-error-bg-hover":e.errorBgHover,"--privy-color-warn":e.warn,"--privy-color-warn-light":e.warnLight,"--privy-color-warn-bg":e.warnBg,"--privy-color-warning-dark":e.warningDark,"--privy-color-error-dark":e.errorDark,"--privy-color-info-bg":e.infoBg,"--privy-color-info-bg-hover":e.infoBgHover,"--privy-color-border-default":e.borderDefault,"--privy-color-border-hover":e.borderHover,"--privy-color-border-focus":e.borderFocus,"--privy-color-border-error":e.borderError,"--privy-color-border-success":e.borderSuccess,"--privy-color-border-warning":e.borderWarning,"--privy-color-border-info":e.borderInfo,"--privy-color-border-interactive":e.borderInteractive,"--privy-color-border-interactive-hover":e.borderInteractiveHover,"--privy-color-background-hover":e.backgroundHover,"--privy-color-background-clicked":e.backgroundClicked,"--privy-color-background-disabled":e.backgroundDisabled,"--privy-color-background-interactive":e.backgroundInteractive,"--privy-color-background-interactive-hover":e.backgroundInteractiveHover,"--privy-color-background-interactive-clicked":e.backgroundInteractiveClicked,"--privy-color-background-interactive-disabled":e.backgroundInteractiveDisabled,"--privy-color-foreground-hover":e.foregroundHover,"--privy-color-foreground-clicked":e.foregroundClicked,"--privy-color-foreground-disabled":e.foregroundDisabled,"--privy-color-foreground-interactive":e.foregroundInteractive,"--privy-color-foreground-interactive-hover":e.foregroundInteractiveHover,"--privy-link-navigation-color":e.linkNavigationColor,"--privy-link-navigation-decoration":e.linkNavigationDecoration,"--privy-accent-has-good-contrast":e.accentHasGoodContrast,"--privy-color-icon-default":e.iconDefault,"--privy-color-icon-muted":e.iconMuted,"--privy-color-icon-subtle":e.iconSubtle,"--privy-color-icon-inverse":e.iconInverse,"--privy-color-icon-success":e.iconSuccess,"--privy-color-icon-warning":e.iconWarning,"--privy-color-icon-error":e.iconError,"--privy-color-icon-interactive":e.iconInteractive,"--privy-color-icon-default-hover":e.iconDefaultHover,"--privy-color-icon-muted-hover":e.iconMutedHover,"--privy-color-icon-subtle-hover":e.iconSubtleHover,"--privy-color-icon-default-clicked":e.iconDefaultClicked,"--privy-color-icon-muted-clicked":e.iconMutedClicked,"--privy-color-icon-subtle-clicked":e.iconSubtleClicked,"--privy-color-icon-default-disabled":e.iconDefaultDisabled,"--privy-color-icon-muted-disabled":e.iconMutedDisabled,"--privy-color-icon-subtle-disabled":e.iconSubtleDisabled,"--privy-color-icon-error-hover":e.iconErrorHover,"--privy-color-icon-interactive-hover":e.iconInteractiveHover,"--privy-color-icon-error-clicked":e.iconErrorClicked,"--privy-color-icon-interactive-clicked":e.iconInteractiveClicked,"--privy-color-icon-muted-disabled-alt":e.iconMutedDisabledAlt,"--privy-color-icon-subtle-disabled-alt":e.iconSubtleDisabledAlt,"--privy-border-radius-xs":"6px","--privy-border-radius-sm":"8px","--privy-border-radius-md":"12px","--privy-border-radius-mdlg":"16px","--privy-border-radius-lg":"24px","--privy-border-radius-full":"9999px","--privy-height-modal-full":"620px","--privy-height-modal-compact":"480px"}}(e);return Jn`
    ${Object.entries(t).map((([e,t])=>`${e}: ${t};`)).join("\n")}
  `},Oa=Gn.div`
  // css normalize only the privy application to avoid conflicts
  // with consuming application
  ${"\n  *,\n  ::before,\n  ::after {\n    box-sizing: border-box;\n    border-width: 0;\n    border-style: solid;\n  }\n\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  font-feature-settings: normal;\n\n  margin: 0;\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    text-decoration: underline dotted;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n    display: inline;\n  }\n\n  a {\n    color: inherit;\n    text-decoration: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: 100%;\n    font-weight: inherit;\n    line-height: inherit;\n    color: inherit;\n    margin: 0;\n    padding: 0;\n  }\n\n  button,\n  select {\n    text-transform: none;\n  }\n\n  button,\n  [type='button'],\n  [type='reset'],\n  [type='submit'] {\n    -webkit-appearance: button;\n    background-color: transparent;\n    background-image: none;\n  }\n\n  ::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n\n  :-moz-focusring {\n    outline: 1px dotted ButtonText;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [type='search'] {\n    -webkit-appearance: textfield;\n    outline-offset: -2px;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-file-upload-button {\n    -webkit-appearance: button;\n    font: inherit;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  blockquote,\n  dl,\n  dd,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  hr,\n  figure,\n  p,\n  pre {\n    margin: 0;\n  }\n\n  fieldset {\n    margin: 0;\n    padding: 0;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  input::placeholder,\n  textarea::placeholder {\n    opacity: 1;\n    color: #9ca3af;\n  }\n\n  button,\n  [role='button'] {\n    cursor: pointer;\n  }\n\n  :disabled {\n    cursor: default;\n  }\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block;\n  }\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  [hidden] {\n    display: none;\n  }\n"}

  // Privy styles
  color: var(--privy-color-foreground-2);

  h3 {
    font-size: 16px;
    line-height: 24px;
    font-weight: 500;
    color: var(--privy-color-foreground-2);
  }

  h4 {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: var(--privy-color-foreground);
  }

  p {
    font-size: 13px;
    line-height: 20px;
    color: var(--privy-color-foreground-2);
  }

  button:focus,
  input:focus,
  optgroup:focus,
  select:focus,
  textarea:focus {
    outline: none;
    border-color: var(--privy-color-accent-light);
    box-shadow: 0 0 0 3px var(--privy-color-border-focus);
  }

  .mobile-only {
    @media (min-width: 441px) {
      display: none;
    }
  }

  /* Animations */

  @keyframes fadein {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
`,Ra=({children:n,open:a,onClick:i,...s})=>/*#__PURE__*/t(rr,{show:a,as:r.Fragment,children:/*#__PURE__*/e(ar,{onClose:i,...s,as:xa,children:[/*#__PURE__*/t(ir,{as:r.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/t(Ma,{id:"privy-dialog-backdrop","aria-hidden":"true"})}),/*#__PURE__*/t(Fa,{children:/*#__PURE__*/t(ir,{as:r.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/t(sr,{as:Da,children:n})})})]})});let Ma=Gn.div`
  position: fixed;
  inset: 0;

  transition: backdrop-filter 100ms ease;
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);

  &.entering,
  &.leaving {
    backdrop-filter: unset;
    -webkit-backdrop-filter: unset;
  }
`,xa=Gn.div`
  position: relative;
  z-index: 999999;
`,Fa=Gn.div`
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  min-height: 100vh;
`;const Da=Gn.div`
  // reset some default dialog styles
  padding: 0;
  background: transparent;
  border: none;
  width: 100%;
  pointer-events: auto;

  outline: none;
  display: block;

  /*
   * Normally it is bad to mix media queries like this We are doing
   * this here specifically for animations to avoid weird jank.
   */
  /* Mobile animation is a bottom drawer */
  @media (max-width: 440px) {
    opacity: 1;
    transform: translate3d(0, 0, 0);
    transition: transform 200ms ease-in;
    position: fixed;
    bottom: 0;

    &.entering,
    &.leaving {
      opacity: 0;
      transform: translate3d(0, 100%, 0);
      transition:
        transform 150ms ease-in 0ms,
        opacity 0ms ease 150ms;
    }
  }

  /* Tablet/Desktop animation is a fade in */
  @media (min-width: 441px) {
    opacity: 1;
    transition: opacity 100ms ease-in;

    &.entering,
    &.leaving {
      opacity: 0;
      transition-delay: 5ms;
    }

    margin: auto;
    width: 360px;
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`;Gn.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
`;const La=()=>{let{ready:e}=C(),{currentScreen:t}=_(),[n,r]=o(null),[a,i]=o(!1),l=function(e){let[t,n]=o(!1),r=s(null),a=s(null),i=s(null);return c((()=>{if(r.current&&(clearTimeout(r.current),r.current=null),a.current&&(clearTimeout(a.current),a.current=null),e)i.current=Date.now(),r.current=setTimeout((()=>{n(!0)}),150);else if(null!==i.current){let e=Date.now()-i.current;if(e>=150){let t=Math.max(0,400-(e-150));a.current=setTimeout((()=>{n(!1),i.current=null}),t)}else r.current&&(clearTimeout(r.current),r.current=null),n(!1),i.current=null}return()=>{r.current&&clearTimeout(r.current),a.current&&clearTimeout(a.current)}}),[e]),t}(a);return c((()=>{if(!t)return r(null),void i(!1);i(!0),Ia[t]().then((n=>{(!t||e||n.default.isShownBeforeReady)&&(r((()=>n.default.component)),i(!1))})).catch((()=>{r(null),i(!1)}))}),[t,e]),{component:n,isLoading:l}};let ja=/*#__PURE__*/u((()=>import("./MfaVerifyFlowScreen-C_vKdC1M.mjs"))),za=/*#__PURE__*/u((()=>(e=>Ia[e]().then((e=>({default:e.default.component}))))("MfaAuthVerifyFlowScreen"))),qa=()=>/*#__PURE__*/t(Ga,{children:/*#__PURE__*/t(K,{})}),Ha=()=>{let{currentScreen:r}=_(),a=Wa((e=>e.inProgressMfaFlow)),i=()=>Wa.setState({inProgressMfaFlow:void 0}),{component:s,isLoading:l}=La();return function(){let{isModalOpen:e}=C(),{headless:t}=Xe(),{currentScreen:n}=_(),{status:r,execute:a,reset:i,enabled:s}=va(),[l,d]=o(!1);c((()=>{!e&&s&&i()}),[e,s,i]),c((()=>{n?Ia[n]().then((e=>{d(!!e.default.isCaptchaRequired)})).catch((()=>{d(!1)})):d(!1)}),[n]),c((()=>{e&&l&&!t&&"ready"===r&&s&&a()}),[e,l,t,r,s,a])}(),r||"txn"!==a?l?/*#__PURE__*/t(qa,{}):s?
/*#__PURE__*/e(n,{children:[/*#__PURE__*/t(V,{$if:!!a,children:/*#__PURE__*/t(d,{children:/*#__PURE__*/t(s,{})})}),/*#__PURE__*/e(d,{children:["txn"===a&&/*#__PURE__*/t(ja,{onClose:i}),"auth"===a&&/*#__PURE__*/t(za,{})]})]}):null:/*#__PURE__*/t(d,{children:/*#__PURE__*/t(ja,{onClose:i})})},Va=()=>{let e=s(null);/*#__PURE__*/return t($a,{style:{height:B(e)},id:"privy-modal-content",children:/*#__PURE__*/t("div",{ref:e,children:/*#__PURE__*/t(Ha,{})})})};const Ba=({open:e})=>{let n=Xe(),{gracefulClosePrivyModal:r}=(()=>{let{closePrivyModal:e}=Ie(),{onUserCloseViaDialogOrKeybindRef:t}=_();return{gracefulClosePrivyModal:h((()=>{if(!t?.current)return e({shouldCallAuthOnSuccess:!1});t.current()}),[e])}})(),a=Wa((e=>e.inProgressMfaFlow));return Pa({onMfaRequired:()=>{n.mfa.noPromptOnMfaRequired||Wa.setState({inProgressMfaFlow:"txn"})}}),n.render.standalone?/*#__PURE__*/t(Oa,{children:/*#__PURE__*/t(Ka,{id:"privy-modal-content",children:/*#__PURE__*/t(Ha,{})})}):/*#__PURE__*/t(Ra,{open:!(!e&&!a),id:"privy-dialog","aria-label":"log in or sign up","aria-labelledby":"privy-dialog-title",onClick:()=>r(),children:/*#__PURE__*/t(Oa,{children:/*#__PURE__*/t(Va,{})})})};let Ka=Gn.div`
  display: flex;
  flex-direction: column;
  text-align: center;
  font-size: 14px;
  line-height: 20px;
  width: 100%;
  background: var(--privy-color-background);
  padding: 0 16px;
`,$a=Gn(Ka)`
  transition: height 150ms ease-out;
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none;

  // Ensure the modal gets pinned to the top if it ever gets too tall
  max-height: calc(100svh - 32px);

  border-radius: var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;
  box-shadow: 0px 0px 36px rgba(55, 65, 81, 0.15);

  @media (min-width: 441px) {
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`,Ga=Gn.div`
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  padding: 2rem;
`;function Ya(e){let n=s(null),r=s();return c((()=>{r.current?.remove(),r.current=function({botUsername:e,scriptHost:t}){let n=document.createElement("script"),{origin:r}=new URL(t);return n.async=!0,n.src=`${r}/js/telegram-login.js`,n.setAttribute("data-telegram-login",e),n.setAttribute("data-request-access","write"),n.setAttribute("data-lang","en"),n}(e),n.current?.after(r.current)}),[e]),/*#__PURE__*/t("div",{ref:n,hidden:!0})}const Ja=()=>{let{ready:e}=ge(),{client:t}=Ie();return c((()=>{let n=()=>{if(!t.connectors||!e)return;let n=t.connectors.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id})));Me.put(et,n)};return t.connectors?.on("walletsUpdated",n),()=>{t.connectors?.off("walletsUpdated",n)}}),[e,t.connectors]),null};class Qa extends j{async initialize(){let e=await this.createProvider();this.provider=e,this.proxyProvider.setWalletProvider(e),this.subscribeListeners(),e.session&&(this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown"),this.connected=!0,await this.syncAccounts()),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),this.getConnectedWallet()}async isConnected(){return!!this.walletProvider?.connected}get walletBranding(){let e=this.walletProvider?.session?.peer.metadata.icons?.[0];return{name:G(this.walletProvider?.session?.peer.metadata.name||"")||"WalletConnect",icon:"string"==typeof e?e:xe,id:this.walletProvider?.session?.peer.metadata.name.toLowerCase()||"wallet_connect_v2"}}async resetConnection(e){this.walletProvider&&this.walletProvider.connected&&(await this.walletProvider.disconnect(),this.walletProvider.signer.session=void 0,this.walletClientType=e,this.redirectUri=void 0,this.fallbackUniversalRedirectUri=void 0,xn(),this.onDisconnect())}async promptConnection(){if(this.provider)return new Promise(((e,t)=>{(async()=>{let t="",n=await Promise.race([this.walletProvider?.enable(),this.proxyProvider.walletTimeout()]);if(n?.length&&(t=n[0]),!t||""===t)throw new ke("Unable to retrieve address");this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown",this.proxyProvider.rpcTimeoutDuration=Q(this.rpcConfig,this.walletClientType)),this.connected=!0,await this.syncAccounts(n),e()})().catch((e=>{t(e?Re(e):new ke("Unknown error during connection"))}))}))}disconnect(){this.walletProvider?.disconnect().then((()=>this.onDisconnect())).catch((()=>console.warn("Unable to disconnect WalletConnect provider")))}get walletProvider(){return this.proxyProvider.walletProvider}setWalletProvider(e){this.proxyProvider.setWalletProvider(e)}async createProvider(){let e={};for(let t of this.chains){let n=Y(t.id,this.chains,this.rpcConfig,this.privyAppId);n&&(e[t.id]=n)}let t=this.shouldEnforceDefaultChainOnConnect?[this.defaultChain.id]:[],n=this.chains.map((e=>e.id)),r=await or.init({projectId:this.walletConnectCloudProjectId,chains:t,optionalChains:n,optionalEvents:cr,optionalMethods:lr,rpcMap:e,showQrModal:!1,metadata:{description:this.privyAppName,name:this.privyAppName,url:window.location.origin,icons:[]}});return r.on("display_uri",(e=>{if(r.signer.abortPairingAttempt(),Fn(),!this.showPrivyQrModal)throw new ke("WalletConnect modal not available - Privy handles wallet connections through its own UI");if(ft&&this.walletEntry){let{redirect:t,href:n}=Dn(e,this.walletEntry);Rn(t,"_self"),Ln({href:n,name:this.walletEntry.metadata?.shortName||this.walletEntry.name});let r=jn(e,this.walletEntry);return this.redirectUri=t,this.fallbackUniversalRedirectUri=r?.redirect,this.showPrivyQrModal({native:t,universal:t})}if(this.redirectUri=void 0,this.walletEntry){let t=jn(e,this.walletEntry);this.fallbackUniversalRedirectUri=t?.redirect}this.showPrivyQrModal({native:e,universal:void 0})})),r.on("connect",(()=>{r.session?.peer.metadata.url&&(this.walletEntry=$(r.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown")})),r}async enableProvider(){return this.walletProvider?.connected?Promise.resolve(this.walletProvider.accounts):await(this.walletProvider?.enable())}setWalletEntry(e,t){this.walletEntry=e,this.showPrivyQrModal=t}constructor({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,shouldEnforceDefaultChainOnConnect:a,privyAppId:i,privyAppName:s,walletClientType:o}){super(o||"unknown",n,r,t),this.connectorType="wallet_connect_v2",this.privyAppId=i,this.privyAppName=s,this.walletConnectCloudProjectId=e,this.rpcConfig=t,this.shouldEnforceDefaultChainOnConnect=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),o&&(this.walletEntry=J(o),this.walletClientType=o)}}const Za=["error","invalid_request_arguments","wallet_not_on_device","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","mfa_verification_max_attempts_reached","mfa_timeout","twilio_verification_failed"];class Xa extends Error{constructor(e,t){super(t),this.type=e}}function ei(e){let t=e.type;return"string"==typeof t&&Za.includes(t)}function ti(e){return ei(e)&&"wallet_not_on_device"===e.type}function ni(e){return ei(e)&&("invalid_recovery_pin"===e.type||"invalid_request_arguments"===e.type)}function ri(e){return!!ei(e)&&"mfa_timeout"===e.type}function ai(e){return!!ei(e)&&"missing_or_invalid_mfa"===e.type}function ii(e){return!!ei(e)&&"mfa_verification_max_attempts_reached"===e.type}function si(e){return!(!ei(e)||!e.message.includes("code 429"))}function oi(e){return!!function(e){let t=e.type;return"string"==typeof t&&"client_error"===t}(e)&&"MFA canceled"===e.message}async function li(e,t,n,r,a,i=!1){let s=i,o=async o=>{if(s&&t&&t.length>0){o===(i?0:1)?a("configureMfa","onMfaRequired",{mfaMethods:t}):r.current?.reject(new Xa("missing_or_invalid_mfa","MFA verification failed, retry."));let s=await new Promise(((e,t)=>{n.current={resolve:e,reject:t},setTimeout((()=>{let e=new Xa("mfa_timeout","Timed out waiting for MFA code");r.current?.reject(e),t(e)}),3e5)}));return await e(s)}return await e()},l=null;for(let e=0;e<4;e++)try{l=await o(e),r.current?.resolve(void 0);break}catch(e){if("missing_or_invalid_mfa"!==e.type)throw r.current?.resolve(void 0),e;s=!0}if(null===l){let e=new Xa("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw r.current?.reject(e),e}return l}var ci;let di=(ci=0,()=>"id-"+ci++);function ui(e){return void 0!==e.error}let hi=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let n=this.callbacks[t];if(!n)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case"privy:iframe:ready":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:import":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":case"privy:auth:unlink-passkey":case"privy:farcaster:init-signer":case"privy:farcaster:sign":case"privy:solana-wallet:create":case"privy:delegated-actions:consent":return n;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}},pi=new Map,wi=(e,t)=>"bigint"==typeof t?t.toString():t;function mi(e,t,n,r){let a=n.contentWindow;if(!a)throw Error("iframe not initialized");let i=((e,t)=>`${e}${JSON.stringify(t,wi)}`)(e,t);if("privy:wallet:create"===e){let e=pi.get(i);if(e)return e}let s=new Promise(((n,i)=>{let s=di();hi.enqueue(s,{resolve:n,reject:i}),a.postMessage({id:s,event:e,data:t},r)})).finally((()=>{pi.delete(i)}));return pi.set(i,s),s}function yi(e){let n=tt(),r=s(null),a=s(e.mfaMethods),i=Zn(),[l,d]=o(!1);return c((()=>{a.current=e.mfaMethods}),[e.mfaMethods]),c((()=>{if(!l)return;let t=r.current;if(!t)return;function n(t){var n;t&&t.origin===e.origin&&"string"==typeof(n=t.data).event&&/^privy:.+/.test(n.event)&&function(e){switch(e.event){case"privy:iframe:ready":let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data);case"privy:user-signer:sign":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:add":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:set-recovery":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:connect":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:recover":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:rpc":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallet:create":let n=hi.dequeue(e.event,e.id);return ui(e)?n.reject(new Xa(e.error.type,e.error.message)):n.resolve(e.data);case"privy:wallets:import":let r=hi.dequeue(e.event,e.id);return ui(e)?r.reject(new Xa(e.error.type,e.error.message)):r.resolve(e.data);case"privy:mfa:verify":let a=hi.dequeue(e.event,e.id);return ui(e)?a.reject(new Xa(e.error.type,e.error.message)):a.resolve(e.data);case"privy:mfa:init-enrollment":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:submit-enrollment":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:unenroll":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:clear":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:auth:unlink-passkey":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:solana-wallet:create":let i=hi.dequeue(e.event,e.id);return ui(e)?i.reject(new Xa(e.error.type,e.error.message)):i.resolve(e.data);case"privy:farcaster:init-signer":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:farcaster:sign":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:delegated-actions:consent":{let t=hi.dequeue(e.event,e.id);return ui(e)?t.reject(new Xa(e.error.type,e.error.message)):t.resolve(e.data)}default:console.warn("Unsupported wallet proxy method:",e)}}(t.data)}let s={signWithUserSigner:n=>li((r=>mi("privy:user-signer:sign",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),addWallet:n=>li((r=>mi("privy:wallets:add",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),setRecovery:n=>li((r=>mi("privy:wallets:set-recovery",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),connect:n=>li((r=>mi("privy:wallets:connect",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),recover:n=>li((r=>mi("privy:wallets:recover",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!n.recoveryAccessToken&&!n.recoveryPassword&&!n.recoverySecretOverride),rpc:n=>li((r=>mi("privy:wallets:rpc",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),create:n=>mi("privy:wallet:create",n,t,e.origin),importWallet:n=>mi("privy:wallets:import",n,t,e.origin),createSolana:n=>li((r=>mi("privy:solana-wallet:create",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),createDelegatedAction:n=>mi("privy:delegated-actions:consent",n,t,e.origin),verifyMfa:n=>li((r=>mi("privy:mfa:verify",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!0),initEnrollMfa:n=>li((r=>mi("privy:mfa:init-enrollment",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),submitEnrollMfa:n=>li((r=>mi("privy:mfa:submit-enrollment",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),unenrollMfa:n=>li((r=>mi("privy:mfa:unenroll",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),clearMfa:n=>mi("privy:mfa:clear",n,t,e.origin),unlinkPasskeyAccount:n=>li((r=>mi("privy:auth:unlink-passkey",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),initFarcasterSigner:n=>mi("privy:farcaster:init-signer",n,t,e.origin),signFarcasterMessage:n=>mi("privy:farcaster:sign",n,t,e.origin)};window.addEventListener("message",n);let o=new AbortController;return Z((()=>mi("privy:iframe:ready",{},t,e.origin)),{abortSignal:o.signal}).then((()=>e.onLoad(s)),((...t)=>{console.warn("Privy iframe failed to load: ",...t),e.onLoadFailed()})),()=>{window.removeEventListener("message",n),o.abort()}}),[l]),n?
/*#__PURE__*/t("iframe",{ref:r,width:"0",height:"0",style:{display:"none",height:"0px",width:"0px"},onLoad:()=>d(!0),src:dr({origin:e.origin,path:`/apps/${e.appId}/embedded-wallets`,query:{caid:e.clientAnalyticsId,client_id:e.appClientId}})}):null}const gi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!n)throw new Te("Address to delegate is not associated with current user.");if(!Fe(n))throw new Te(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:n.address,chainType:n.chainType,walletIndex:n.walletIndex??0}},fi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!n)throw new Te("Address to delegate is not associated with current user.");let r=n.imported?n:S(t);if(!r)throw new Te("Unable to determine root address for delegated address.");if(!Fe(r))throw new Te(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:r.address,chainType:r.chainType,imported:r.imported}},vi=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated));const Ai="popup-privy-oauth",ki="PRIVY_OAUTH_USE_BROADCAST_CHANNEL";class Ti{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw Ce(e)}}constructor(e){this.meta=e}}async function Ci({api:e,requesterAppId:t,providerAppId:n}){let r=(await e.get(`/api/v1/apps/${t}/cross-app/connections`)).connections.find((e=>e.provider_app_id===n));if(!r)throw new Te("Invalid connected app");return{name:r.provider_app_name,logoUrl:r.provider_app_icon_url||void 0,apiUrl:r.provider_app_custom_api_url,readOnly:r.read_only,customAuthAuthorizeUrl:r.provider_app_custom_auth_authorize_url,customAuthTransactUrl:r.provider_app_custom_auth_transact_url}}const _i=async({user:e,address:t,client:n,request:r,requesterAppId:a,reconnect:i})=>{n.createAnalyticsEvent({eventName:"cross_app_request_started",payload:{address:t,method:r.method}});let s=e?.linkedAccounts.find((e=>"cross_app"===e.type&&(e.embeddedWallets.some((e=>e.address===t))||e.smartWallets.some((e=>e.address===t)))));if(!e||!s)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Cannot request a signature with this wallet address",address:t}}),new Te("Cannot request a signature with this wallet address");let o=n.getProviderAccessToken(s.providerApp.id),l=await Ci({api:n.api,requesterAppId:a,providerAppId:s.providerApp.id});if(!o){if(l.readOnly)throw console.error("cannot transact against a read-only provider app"),new Te("Cannot transact against a read-only provider app");await i({appId:s.providerApp.id,action:"link"})&&(o=n.getProviderAccessToken(s.providerApp.id))}if(!o)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Transactions require a valid token",address:t}}),new Te("Transactions require a valid token");let c=new URL(l.customAuthTransactUrl||`${l.apiUrl}/oauth/transact`);c.searchParams.set("token",o||""),c.searchParams.set("request",Si(r));let d=Et({location:c.href});if(!d)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Missing token",address:t}}),new Te("Failed to initialize signature request");return new Promise(((e,a)=>{let i=setTimeout((()=>{c(),a(new Te("Request timeout")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Request timeout",address:t}})}),12e4),o=setInterval((()=>{d.closed&&(c(),a(new Te("User rejected request")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"User rejected request",address:t}}))}),300),l=i=>{i.data&&("set"===i.data.token?.action&&void 0!==i.data.token?.value?n.storeProviderAccessToken(s.providerApp.id,i.data.token.value):"clear"===i.data.token?.action&&n.storeProviderAccessToken(s.providerApp.id,null),"PRIVY_CROSS_APP_ACTION_RESPONSE"===i.data.type&&i.data.result&&(c(),e(i.data.result),n.createAnalyticsEvent({eventName:"cross_app_request_success",payload:{address:t,method:r.method}})),"PRIVY_CROSS_APP_ACTION_ERROR"===i.data.type&&i.data.error&&(c(),a(i.data.error),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:i.data.error,address:t}})))};window.addEventListener("message",l);let c=()=>{d.close(),clearInterval(o),clearTimeout(i),window.removeEventListener("message",l)}}))};let Si=e=>JSON.stringify({content:{request:{request:bi(e,ur)}},timestamp:Date.now(),callbackUrl:window.origin});const bi=(e,t)=>"bigint"==typeof e?t(e):Array.isArray(e)?e.map((e=>bi(e,t))):e&&"object"==typeof e?Object.fromEntries(Object.entries(e).map((([e,n])=>[e,bi(n,t)]))):e;function Ei({isCreatingWallet:e,skipSplashScreen:t}){return e?"EmbeddedWalletPasswordCreateScreen":t?"EmbeddedWalletPasswordUpdateScreen":"EmbeddedWalletPasswordUpdateSplashScreen"}function Ii({walletAction:e,availableRecoveryMethods:t,legacySetWalletPasswordFlow:n,isResettingPassword:r,showAutomaticRecovery:a}){return a?"SetAutomaticRecoveryScreen":n||1===t.length?Ei({isCreatingWallet:"create"===e,skipSplashScreen:r}):"RecoverySelectionScreen"}function Pi(e){switch(e){case"user-passcode":return"PasswordRecoveryScreen";case"google-drive":case"icloud":return"RecoveryOAuthScreen";default:throw Error("Recovery method not supported")}}function Wi(e,t){if(e.onComplete)switch(t){case"external":e.fundingResult?e.onComplete({...e.fundingResult,fundingMethod:t}):e.onComplete({status:"cancelled",address:e.address,fundingMethod:t,amount:e.amount});break;case null:e.onComplete({status:"cancelled",address:e.address,fundingMethod:void 0,amount:e.amount});break;default:e.onComplete({status:"completed",address:e.address,fundingMethod:t,amount:e.amount})}}function Ui(e,t,n,r,a,i,s){return{...e,funding:e?.funding?{...e.funding,fundingResult:{status:t,address:e.funding.address,fundingMethod:void 0,transactionHash:n,amount:e.funding.amount,assetType:a?i?.symbol||"ETH":s.nativeCurrency.symbol||"ETH",metadata:{walletClientType:r}}}:void 0,solanaFundingData:e?.solanaFundingData,sendTransaction:e?.sendTransaction}}const Ni=new Map([["FundingMethodSelectionScreen",null],["TransferFromWalletScreen","external"],["FundingAmountEditScreen","external"],["ConnectOnlyLandingScreen","external"],["ConnectOnlyStatusScreen","external"],["AwaitingExternalEthereumTransferScreen","external"],["AwaitingEvmToSolBridgingScreen","external"],["AwaitingSolToEvmBridgingScreen","external"],["ManualTransferScreen","manual"],["MoonpayStatusScreen","moonpay"]]);function Oi(e){let t=e.toLowerCase();return!!window?.webkit?.messageHandlers?.ReactNativeWebView||!!window?.ReactNativeWebView||["fbav","fban","instagram","snapchat","linkedinapp"].some((e=>t.includes(e)))}async function Ri({rpc:e,address:t}){return(await e.getBalance(t,{commitment:"confirmed"}).send()).value??0n}let Mi={apple_oauth:"apple",custom_auth:"custom",discord_oauth:"discord",email:"email",farcaster:"farcaster",github_oauth:"github",google_oauth:"google",instagram_oauth:"instagram",linkedin_oauth:"linkedin",passkey:"passkey",phone:"sms",spotify_oauth:"spotify",telegram:"telegram",tiktok_oauth:"tiktok",line_oauth:"line",twitch_oauth:"twitch",twitter_oauth:"twitter",wallet:"siwe",smart_wallet:"siwe",cross_app:"privy:"};const xi=e=>{if(b(e))return{displayName:e.replace("custom:",""),loginMethod:"custom"};let t=Mi[e];return"wallet"===e||"phone"===e?{displayName:e,loginMethod:t}:{displayName:t,loginMethod:t}},Fi=(e,t)=>!E(e)&&("all-users"===t||"users-without-wallets"===t&&!Di(e).length);let Di=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"ethereum"===e.chainType));const Li=(e,t)=>!I(e)&&("all-users"===t||"users-without-wallets"===t&&!ji(e).length);let ji=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"solana"===e.chainType));async function zi(e,t,n,r){let a=Be(e),{chain:i,...s}=await(async()=>r?await r():await t.prepareTransactionRequest({...a,account:{address:n,type:"json-rpc"}}))();return{...s,type:Ke[s.type]}}const qi=()=>{let e=Xe(),{user:t}=C(),{client:n,refreshSessionAndUser:r,walletProxy:a}=Ie();return{migrate:h((async()=>{if("legacy-embedded-wallets-only"===e.embeddedWallets.mode)return{success:!0,migrated:!1};if(!t)throw new Te("User must be authenticated before migrating wallets",_e.MUST_BE_AUTHENTICATED);if(!a)throw new Te("Cannot connect to wallet proxy");let i=await n.getAccessToken();if(!i)throw new Te("User must be authenticated before migrating wallets",_e.MUST_BE_AUTHENTICATED);let s=t.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&Fe(e)&&!P(e)));if(0===s.length)return{success:!0,migrated:!1};let o=s.filter((e=>e.imported)),l=s.filter((e=>!e.imported));if(l.length>0){let e=l.find((e=>"ethereum"===e.chainType&&0===e.walletIndex))??l.find((e=>"solana"===e.chainType&&0===e.walletIndex))??null;if(!e)throw new Te("Primary wallet not found");let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(r){if(!ti(r)||"privy"!==e.recoveryMethod)throw r;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!1},delegatedWallets:l.map((e=>({address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0})))})}for(let e of o){let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(o){if(!ti(o)||"privy"!==e.recoveryMethod)throw o;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!0},delegatedWallets:[{address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}]})}return await r(),{success:!0,migrated:!0}}),[e.embeddedWallets.mode,t,a,n,r])}},Hi=({disabled:e})=>{let{migrate:t}=qi(),{user:n}=C(),{walletProxy:r}=Ie(),a=s(!1);return c((()=>{!e&&!a.current&&n&&r&&(a.current=!0,t().catch((e=>{console.debug("Unable to migrate wallets: ",e)})).finally((()=>{a.current=!1})))}),[n,r,e,t]),null},Vi=e=>({id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}),Bi=nr((()=>({ethereum:[]}))),Ki=()=>Bi.getState().ethereum;class $i{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Qt,{token:this.meta.token})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Zt,{token:this.meta.token})}catch(e){throw Ce(e)}}constructor(e){this.meta={token:e}}}function Gi({subscribe:e,getExternalJwt:t,enabled:n=!0,onAuthenticated:r,onUnauthenticated:a,onError:i}){let{client:l,onCustomAuthAuthenticated:d}=Ie(),{logout:u,authenticated:h,ready:p}=zn();if(!l)throw new Te("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");let[w,m]=o({status:"initial"}),y=s(),g=s(!1),f=s(t);c((()=>{f.current=t}),[t]);let v=s(r);c((()=>{v.current=r}),[r]);let A=s(a);c((()=>{A.current=a}),[a]);let k=s(i);return c((()=>{k.current=i}),[i]),c((()=>{if(!n||!p)return;let t=async()=>{if(!g.current){g.current=!0;try{m({status:"loading"});let e=await f.current();if(void 0!==y.current&&y.current===e)return void m({status:"done"});if(!e)return h&&(await u(),A.current?.()),y.current=e,void m({status:"done"});l.startAuthFlow(new $i(e));let{user:t,isNewUser:n=!1}=await l.authenticate();if(!t)throw new Te("Failed to sync with custom auth provider");v.current?.({user:t,isNewUser:n}),d(t,n),y.current=e,m({status:"done"})}catch(e){if(console.warn(e),await u().catch((()=>{})),A.current?.(),e instanceof Pe&&e.privyErrorCode===_e.LINKED_TO_ANOTHER_USER)return m({status:"initial"}),void setTimeout((()=>{t()}),0);k.current?.(e),m({status:"error",error:e})}finally{g.current=!1}}};return t(),e(t)}),[e,l,d,h,u,n,p]),n?{state:w}:{state:{status:"not-enabled"}}}let Yi=nr((()=>({jwtAuthFlowState:{status:"not-enabled"}})));function Ji({customAuth:e}){let{jwtAuthFlowState:t}=function({customAuth:e}){let t=Zn(),n=s(),r=h((e=>(n.current=e,()=>{n.current=void 0})),[]),a=e?.getCustomAccessToken??(()=>Promise.resolve(void 0)),{state:i}=Gi({enabled:!0===e?.enabled,subscribe:r,getExternalJwt:a,onAuthenticated:({user:e,isNewUser:n})=>{t("login","onComplete",{user:e,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),t("customAuth","onAuthenticated",{user:e})},onUnauthenticated:()=>{t("customAuth","onUnauthenticated")},onError:e=>{t("login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR)}});return c((()=>{(async()=>{e&&!e.isLoading&&n.current?.()})()}),[e?.enabled,e?.getCustomAccessToken,e?.isLoading]),{jwtAuthFlowState:i}}({customAuth:e});return c((()=>{Yi.setState({jwtAuthFlowState:t})}),[t]),null}const Qi=/*#__PURE__*/i(!1);let Zi,Xi,es,ts,ns;const rs=n=>{let r=n.client,a=n.privy,i=qn(),d=Xe();X(ee(d?.appearance.walletList??[]));let[u,p]=o(!1),w=Wa((e=>e.inProgressMfaFlow)),[y,g]=o(!1),[f,v]=o(null),A=Bi((e=>e.ethereum)),[k,T]=o(void 0),[C,_]=o(!1),[b,I]=o(null),[F,D]=o(!1),[L,j]=o({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:be}),[z,q]=o({status:"initial"}),[H,B]=o({status:"initial"}),[K,$]=o({status:"initial"}),[G,Y]=o({status:"initial"}),[J,Q]=o({status:"initial"}),[Z,ce]=o({status:"initial"}),[de,ue]=o(null),he=tt(),[pe,we]=o({}),[me,ye]=o(null),ge=s(null),[fe,Ee]=o(!1),[Ie,Pe]=o(!1),Ne=s(null),Oe=s(null),Re=s(Xn),[xe,He]=o(!1),[Ve,Be]=o(!1),Ke=h((e=>{Be(e),!e&&b&&Ia[b]().then((e=>{e.default.isUnauthenticatedScreem&&I(null)}))}),[b]);r.onStoreCustomerAccessToken=e=>{e&&er(Re,"accessToken","onAccessTokenGranted",{accessToken:e})},r.onDeleteCustomerAccessToken=()=>{v(null),Ke(!1),er(Re,"accessToken","onAccessTokenRemoved")};let $e=s(null),Ge=s(null),Ye=s(!1),et=({showWalletUIs:e})=>Ye.current?Ye.current:void 0!==e?!e:!d.embeddedWallets.showWalletUIs,it=e=>{I(e),setTimeout((()=>{p(!0)}),15)};c((()=>{if(!f)return void r.connectors?.removeEmbeddedWalletConnectors();let e=E(f),t=W(f),i=U(f);e&&t.length||r.connectors?.removeEmbeddedWalletConnectors(),i.length||r.connectors?.removeImportedWalletConnectors(),r.connectors?de?(e&&r.connectors.addEmbeddedWalletConnectors({walletProxy:de,user:f,embeddedWallets:t,defaultChain:d.defaultChain,appId:n.appId,privyClient:a}),i.forEach((e=>r.connectors?.addImportedWalletConnector(de,e.address,d.defaultChain,n.appId)))):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[de,f]),c((()=>{de&&ge.current?.(de)}),[de]);let st=h(((e,t)=>{v(e),_(t),Ke(!0),Pe(!0)}),[]);c((()=>{Ie&&de&&f&&(async()=>{let e=Fi(f,d.embeddedWallets.ethereum.createOnLogin),t=Li(f,d.embeddedWallets.solana.createOnLogin),n=await Kr();if(n){if(e&&t){let e=await de.create({accessToken:n});return await de.createSolana({accessToken:n,ethereumAddress:e?.address}),void Pe(!1)}if(t)return await de.createSolana({accessToken:n,ethereumAddress:E(f)?.address}),await Nt.refreshSessionAndUser(),void Pe(!1);if(e)return await de.create({accessToken:n}),void Pe(!1)}})().catch(console.error)}),[Ie&&de&&f]),c((()=>{if(d.externalWallets.solana.connectors)return d.externalWallets.solana.connectors.onMount(),()=>d.externalWallets.solana.connectors?.onUnmount()}),[d.externalWallets.solana.connectors]),c((()=>{!y&&he&&async function(){let e,t=ot(),n=lt(),a=gt();r.initializeConnectorManager({walletConnectCloudProjectId:d.walletConnectCloudProjectId,rpcConfig:d.rpcConfig,chains:d.chains,defaultChain:d.defaultChain,store:a,walletList:d.appearance.walletList,shouldEnforceDefaultChainOnConnect:d.shouldEnforceDefaultChainOnConnect,externalWalletConfig:d.externalWallets,appName:d.name??"Privy",walletChainType:d.appearance.walletChainType,setBaseAccountSdk:T}),r.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=r.connectors.walletConnectors.length,n=r.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);n===t?He(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:n,expected:t}),He(!0)}),1500)})),r.connectors?.initialize().then((()=>{pt()}));let i=await r.getAuthenticatedUser(),s=!!i;d.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await r.logout(),Nt.setReadyToTrue(!0),er(Re,"logout","onSuccess")):(d.customAuth?.enabled||(Ke(!!i),i&&er(Re,"login","onComplete",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),v(i)),t?Ge.current=s?"link":"login":n&&!s?(Ge.current="login",we({telegramAuthModalData:{seamlessAuth:!0}}),it("TelegramAuthScreen")):Nt.setReadyToTrue(!!i))}()}),[r,me,y,he]),c((()=>{if(y){if(!f||!f.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void Ee(!!de);if([...A].some((e=>"privy"===e.walletClientType)))return void Ee(!0);Ee(!!de)}}),[y,f,A,de]),c((()=>{r.connectors?.setWalletList(d.appearance.walletList)}),[d.appearance.walletList.join()]);let ot=()=>{let e=la();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&e.provider.startsWith("privy:")&&!e.popupFlow&&(new BroadcastChannel(Ai).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(r.startAuthFlow(new oa({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl})),it("OAuthStatusScreen"),!0))},lt=()=>{let e=function(){let e;return(e=function(){let e=new URLSearchParams(window.location.search),t=Number(e.get("id")||""),n=e.get("hash"),r=Number(e.get("auth_date")||""),a=e.get("first_name");if(t&&a&&r&&n)return Object.fromEntries(e.entries())}())?(_a(),{flowType:"login-url",authData:e}):(e=function(){let e=window.location.hash;if(!e||!e.startsWith("#tgWebAppData"))return;let t=Ca(e.replace("#tgWebAppData=","")),{user:n,auth_date:r,hash:a}=t;return n&&r&&a?t:void 0}())?(_a(),{flowType:"web-app",authData:e}):void 0}();if(!e||!d.loginMethods.telegram||!d.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new ka;return r.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},ct=async(e,t,n,a)=>{if("solana_adapter"!==e)dt(await(r.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:t}))||null,t,n,a);else{let e=r.connectors?.findSolanaWalletConnector(t);if(!e)return;dt(e,t,n,a)}};async function dt(e,t,n,r){if(!e)return j({status:"disconnected",connectedWallet:null,connectError:new ke("Unable to connect to wallet."),connector:null,connectRetry:be}),r?.(null,n);j({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:be}),e instanceof Qa&&t&&await e.resetConnection(t),j({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>dt(e,t,n,r)});try{let t=await e.connect({showPrompt:!0});if((!t||te(t))&&d.shouldEnforceDefaultChainOnConnect&&!d.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){j((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:be})));try{await(t?.switchChain(d.defaultChain.id)),t&&(t.chainId=ne(Tt(d.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${d.defaultChain.id}`)}}return j((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:be}))),t&&er(Re,"connectWallet","onSuccess",{wallet:t}),r?.(t,n)}catch(e){return e instanceof Se?(console.warn(e.cause?e.cause:e.message),er(Re,"connectWallet","onError",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),er(Re,"connectWallet","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR)),j((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),r?.(null,n)}}let ut=async(e,t,n)=>{if(null===e||!te(e))return;let a=new ha(r,e,t,n);r.startAuthFlow(a)},ht=async(e,t,n,a="plain")=>{let s=i(Vn);if("transaction"===a&&!s)throw new Te("useSolanaLedger plugin hook must be mounted");if(null===e||!se(e))return;let o=new pa(e,r,t,n,a,s);r.startAuthFlow(o)},pt=async()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),n=e.get("privy_wallet_client"),a="true"===e.get("privy_connect_only");if(!t||!n)return;let i=le({connectorType:t,walletClientType:n});if(!i||!i.isInstalled)return it("LoginFailedScreen");if(!r.connectors)throw new Te("Connector not initialized");await it(a?"ConnectOnlyStatusScreen":"ConnectionStatusScreen");let s=new URL(window.location.href);s.searchParams.delete("privy_connector"),s.searchParams.delete("privy_wallet_client"),s.searchParams.delete("privy_connect_only"),window.history.pushState({},"",s),ct(t,n,void 0,a?void 0:"solana_adapter"===t?ht:ut)};c((()=>{y&&Ve&&null===f&&r.getAuthenticatedUser().then(v)}),[y,Ve,f,r]);let wt=e=>{if(!Ve)throw er(Re,"linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Te("User must be authenticated before linking an account.")},mt=e=>{if(!Ve||!f)return!1;if("privy"===e.walletClientType)return!0;for(let t of f.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},yt=()=>{Bi.setState((e=>{let t=r.connectors?.wallets.filter(te).map((e=>({...e,linked:mt(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Te("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Te("Cannot link or login with embedded wallet");(async e=>{let t;if(!r.connectors)throw new Te("Connector not initialized");t="ethereum"===e.type?r.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:r.connectors.findSolanaWalletConnector(e.walletClientType)||null,j((n=>({...n,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:be}))),d.captcha.enabledProvider&&!Ve?(we({captchaModalData:{callback:t=>te(e)?ut(e,t):ht(e,t),userIntentRequired:!1,onSuccessNavigateTo:"ConnectionStatusScreen",onErrorNavigateTo:"ErrorScreen"}}),await it("CaptchaScreen")):(te(e)?await ut(e):await ht(e),await it("ConnectionStatusScreen"))})(e)},fund:async t=>{await Nt.fundWallet(e.address,t)},unlink:async()=>{if(!Ve)throw new Te("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Te("Cannot unlink an embedded wallet");v(await r.unlinkEthereumWallet(e.address))}})))||[];return re(e.ethereum,t)?{}:{ethereum:t}}))};c((()=>{yt()}),[f?.linkedAccounts,Ve,y]),c((()=>{if(y){if(!r.connectors)throw new Te("Connector not initialized");yt(),r.connectors.on("walletsUpdated",yt)}}),[y]),c((()=>{[...d.loginMethodsAndOrder?.primary??[],...d.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>r.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!r]);let ft=({transaction:e,sponsor:t,uiOptions:i,fundWalletConfig:s,address:o,signOnly:l})=>new Promise((async(c,u)=>{let{requesterAppId:h}=i||{},p=l?"signTransaction":"sendTransaction",w=o?N(f,o):E(f);if(!w&&o){let n=x(Ki(),o);if(n){if(t)throw new Te("Cannot sponsor transactions for externally connected wallet.");try{let t=await n.getEthereumProvider(),r={...e,from:o,chainId:e.chainId||Number(n.chainId.replace("eip155:","")),value:void 0!==e.value?Tt(e.value):void 0},a=await t.request({method:"sendTransaction"===p?"eth_sendTransaction":"eth_signTransaction",params:[r]});return er(Re,p,"onSuccess",{hash:a}),void c({hash:a})}catch(e){return er(Re,p,"onError",_e.TRANSACTION_FAILURE),void u(e??new ze("Unable to "+p+e))}}}if(!w)return er(Re,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(new Te("No embedded or connected wallet found for address."));if(!Ve||!f)return er(Re,p,"onError",_e.MUST_BE_AUTHENTICATED),void u(Error("User must be authenticated before signing with a Privy wallet"));let y=w.address,g=w.walletIndex??0,{entropyId:v,entropyIdVerifier:A}=ve(f,w),k=Ot.wallets.find((e=>"privy"===e.walletClientType&&_t(e.address)===_t(y)));if(!k)return er(Re,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error("Must have a Privy wallet before signing"));let T=await k.getEthereumProvider(),C=await T.request({method:"eth_chainId"}),_=e.chainId?Number(e.chainId):qe(C);(e=>{if(!d.chains.map((e=>e.id)).includes(e))throw new ke(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,_e.UNSUPPORTED_CHAIN_ID)})(_);let S={...e,from:e.from??y,chainId:_},b=await Kr();if(!b||!de)return er(Re,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error("Must have valid access token and Privy wallet to send transaction"));let I=gr(S.chainId,d.chains,d.rpcConfig,{appId:n.appId}),W=P(w),U=async({transactionRequest:e})=>{try{let n;if(!await Nt.recoverEmbeddedWallet({address:y}))throw er(Re,p,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(Error("Unable to connect to wallet")),Error("Unable to connect to wallet");if(t){let t=await(async({transactionRequest:e})=>{if(!W)throw new Te("Sponsoring is only supported for wallets on the TEE stack");if(l)throw new Te("Cannot sponsor a sign transaction request");let t=e=>null==e?void 0:Tt(e),n=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:b,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_sendTransaction",caip2:ne(Tt(e.chainId)),sponsor:!0,params:{transaction:{from:e.from,to:e.to,chain_id:t(e.chainId),data:St(e.data)?e.data?e.data:Tt(Uint8Array.from(e.data)):void 0,value:t(e.value)}},wallet_id:w.id});if(n.data&&"hash"in n.data)return n.data.hash;throw new ze("Unable to sign transaction")})({transactionRequest:e});return er(Re,"sendTransaction","onSuccess",{hash:t}),t}if(W){let t=e=>null==e?void 0:Tt(e),r=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:b,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_signTransaction",params:{transaction:{from:e.from,to:e.to,nonce:t(e.nonce),chain_id:t(e.chainId),data:St(e.data)?e.data?e.data:Tt(Uint8Array.from(e.data)):void 0,value:t(e.value),type:e.type,gas_limit:t(e.gasLimit??e.gas),gas_price:t(e.gasPrice??e.gas),max_fee_per_gas:t(e.maxFeePerGas),max_priority_fee_per_gas:t(e.maxPriorityFeePerGas)}},wallet_id:w.id});if(!r.data||!("signed_transaction"in r.data))throw new ze("Unable to sign transaction");n=r.data.signed_transaction}else n=await async function({accessToken:e,entropyId:t,entropyIdVerifier:n,transactingWalletIndex:r,walletProxy:a,transactionRequest:i,requesterAppId:s}){return(await a.rpc({entropyId:t,entropyIdVerifier:n,hdWalletIndex:r??0,chainType:"ethereum",accessToken:e,requesterAppId:s,request:{method:"eth_signTransaction",params:[i]}})).response.data}({accessToken:b,entropyId:v,entropyIdVerifier:A,transactingWalletIndex:g,walletProxy:de,transactionRequest:e,requesterAppId:h});if(l)return er(Re,"signTransaction","onSuccess",{signature:n}),n;{let e=await I.sendRawTransaction({serializedTransaction:n});return er(Re,"sendTransaction","onSuccess",{hash:e}),e}}catch(e){throw er(Re,p,"onError",_e.TRANSACTION_FAILURE),e}};if(et({showWalletUIs:i?.showWalletUIs})){let e=l||t?S:await zi(S,I,S.from);try{let t=await U({transactionRequest:e});l?er(Re,"signTransaction","onSuccess",{signature:t}):er(Re,"sendTransaction","onSuccess",{hash:t}),c({hash:t})}catch(e){er(Re,p,"onError",_e.TRANSACTION_FAILURE),u(e)}}else{let e={connectingWalletAddress:y,recoveryMethod:w.recoveryMethod,entropyId:v,entropyIdVerifier:A,onCompleteNavigateTo:"SendTransactionScreen",isUnifiedWallet:W,onFailure:e=>{er(Re,p,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(e)}},n=(e=>!!e.fundingConfig&&De(e.fundingConfig.options).length>=1)(d)?Le({address:y,appConfig:d,fundWalletConfig:s,methodScreen:"FundingMethodSelectionScreen",chainIdOverride:S.chainId,comingFromSendTransactionScreen:!0}):void 0;we({connectWallet:e,sendTransaction:{transactionRequest:S,transactingWalletIndex:g,transactingWalletAddress:y,entropyId:v,entropyIdVerifier:A,signOnly:l,scanTransaction:async()=>{let e=await zi(S,I,S.from);return await r.scanTransaction({metadata:{domain:d.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:e.from,to:e.to,value:e.value?.toString(),gas:e.gas?.toString(),gasPrice:e.gasPrice?.toString(),nonce:e.nonce?.toString(),data:e.data}]}})},getIsSponsored:async()=>!!t,onConfirm:({transactionRequest:e})=>U({transactionRequest:e}),onSuccess:e=>{l?er(Re,"signTransaction","onSuccess",{signature:e.hash}):er(Re,"sendTransaction","onSuccess",{hash:e.hash}),c(e)},onFailure:e=>{er(Re,p,"onError",_e.TRANSACTION_FAILURE),u(e)},uiOptions:i||{},fundWalletConfig:s,requesterAppId:h},funding:n}),it("EmbeddedWalletConnectingScreen")}}));function vt(){return new Promise((async(e,t)=>{let n=await Kr();if(!n||!de)throw Error("Must have valid access token to enroll in MFA");try{await de.verifyMfa({accessToken:n}),e()}catch(e){t(e)}}))}let kt=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],bt=e=>{let t=f?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:n,loginMethod:r}=xi(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw er(Re,"linkAccount","onError",_e.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new Te(`User already has an account of type ${n} linked.`)};async function It({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){I(null);let n=t?"setWalletPassword":"setWalletRecovery";if(!Ve||!f)throw er(Re,n,"onError",_e.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=S(f);if(!r||!de)throw er(Re,n,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");let a=P(r);if(a)throw er(Re,n,"onError",_e.UNSUPPORTED_WALLET_TYPE),new Te("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");try{await vt()}catch(e){throw er(Re,n,"onError",_e.MISSING_MFA_CREDENTIALS),e}return new Promise(((i,s)=>{let o="user-passcode"===r.recoveryMethod,l=Ii({walletAction:"update",availableRecoveryMethods:d.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:o,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:u}=ve(f),h={recoveryMethod:r.recoveryMethod,connectingWalletAddress:r.address,onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,isUnifiedWallet:a,entropyIdVerifier:u,onFailure:e=>{er(Re,n,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}};we({setWalletPassword:{onSuccess:e=>{er(Re,n,"onSuccess",{method:"user-passcode",wallet:e}),i(e)},onFailure:e=>{er(Re,n,"onError",_e.USER_EXITED_SET_PASSWORD_FLOW),s(e)},callAuthOnSuccessOnClose:!1},recoverWallet:{entropyId:c,entropyIdVerifier:u,onFailure:s},connectWallet:h,recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:o,shouldCreateEth:!1,shouldCreateSol:!1}}),it("EmbeddedWalletConnectingScreen")}))}async function Pt({appId:e,action:t,disableSignup:n}){let a=await Kr();if("link"===t&&!a)throw er(Re,"linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Te("User must be authenticated before linking an account.");if("login"===t&&a)throw er(Re,"login","onError",_e.UNKNOWN_AUTH_ERROR),new Te("Attempted to log in, but user is already logged in. Use a `link` helper instead.");$e.current=`privy:${e}`,Ge.current=t;let i=Et();return r.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(a,s)=>{let{name:o,logoUrl:l}=await Ci({api:r.api,providerAppId:e,requesterAppId:d.id});we({crossAppAuth:{appId:e,name:o,logoUrl:l,action:t,popup:i,disableSignup:n,onSuccess:a,onError:s}}),it("CrossAppAuthScreen")}))}let Wt={ready:y,authenticated:Ve,user:f,walletConnectors:r.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),we({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,walletChainType:e?.walletChainType,description:e?.description,hideHeader:e?.hideHeader}}),it("ConnectOnlyLandingScreen")},linkWallet:e=>(e&&"target"in e&&e&&(e=void 0),wt("siwe"),$e.current="siwe",Ge.current="link",we({...pe,externalConnectWallet:{...pe.externalConnectWallet,walletList:e?.walletList,walletChainType:e?.walletChainType,description:e?.description||`Link a wallet to your ${d?.name} account`}}),it("AuthenticateWithWalletScreen")),startCrossAppAuthFlow:Pt,linkEmail:()=>{wt("email"),bt("email"),$e.current="email",Ge.current="link",it("LinkEmailScreen")},linkPhone:()=>{wt("sms"),bt("phone"),$e.current="sms",Ge.current="link",it("LinkPhoneScreen")},linkGoogle:async()=>{wt("google"),bt("google_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("google")},linkTwitter:async()=>{wt("twitter"),bt("twitter_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("twitter")},linkTwitch:async()=>{wt("twitch"),bt("twitch_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("twitch")},linkDiscord:async()=>{wt("discord"),bt("discord_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("discord")},linkGithub:async()=>{wt("github"),bt("github_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("github")},linkSpotify:async()=>{wt("spotify"),bt("spotify_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("spotify")},linkInstagram:async()=>{wt("instagram"),bt("instagram_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("instagram")},linkTiktok:async()=>{wt("tiktok"),bt("tiktok_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("tiktok")},linkLine:async()=>{wt("line"),bt("line_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("line")},linkLinkedIn:async()=>{wt("linkedin"),bt("linkedin_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("linkedin")},linkApple:async()=>{wt("apple"),bt("apple_oauth"),Ge.current="link",await Nt.initLoginWithOAuth("apple")},linkPasskey:async()=>{wt("passkey"),bt("passkey"),await Nt.initLinkWithPasskey(),it("LinkPasskeyScreen")},linkTelegram:async e=>{if(wt("telegram"),bt("telegram"),Ge.current="link",$e.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let t=new ka;r.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=Ca(e.launchParams.initDataRaw),we({telegramAuthModalData:{seamlessAuth:!0}}),it("TelegramAuthScreen")}else er(Re,"linkAccount","onError",_e.INVALID_DATA,{linkMethod:"telegram"});else await Nt.initLoginWithTelegram();it("TelegramAuthScreen")},linkFarcaster:async()=>{wt("farcaster"),bt("farcaster"),await Nt.initLoginWithFarcaster(),Ge.current="link",$e.current="farcaster",it("FarcasterConnectStatusScreen")},updateEmail:()=>{if(wt("email"),!f?.email)throw new Te("User does not have an email linked to their account.");Ge.current="update",$e.current="email",it("UpdateEmailScreen")},updatePhone:()=>{if(wt("sms"),!f?.phone)throw new Te("User does not have a phone number linked to their account.");Ge.current="update",$e.current="sms",it("UpdatePhoneScreen")},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!y){let e=await new Promise((e=>{ye((t=>e.bind(t)))}));if(ye(null),e)return void console.warn(t)}!f||f.isGuest?(Ge.current="login",we({login:e}),it("LandingScreen")):console.warn(t)},connectOrCreateWallet:async()=>{y||(await new Promise((e=>{ye((()=>e))})),ye(null)),Ve?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Ge.current="connect-or-create",it("ConnectOrCreateScreen"))},logout:async()=>{if(Ge.current=null,$e.current=null,f&&r.clearProviderAcccessTokens(f),I(null),await r.logout(),f&&de)try{await de.clearMfa({userId:f.id})}catch(e){}v(null),Ke(!1),B({status:"initial"}),$({status:"initial"}),q({status:"initial"}),Y({status:"initial"}),Q({status:"initial"}),ce({status:"initial"}),er(Re,"logout","onSuccess"),p(!1),Me.del(rt),Me.del(at(d.id))},getAccessToken:h((async()=>{let e=await r.getCustomerAccessToken();return e&&!Ve&&Ke(!0),e}),[r,Ve]),unlinkWallet:async e=>{let t;return v(t=e.startsWith("0x")?await r.unlinkEthereumWallet(e):await r.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await r.unlinkEmail(e);return v(t),t},unlinkPhone:async e=>{let t=await r.unlinkPhone(e);return v(t),t},unlinkGoogle:async e=>{let t=await r.unlinkOAuth("google",e);return v(t),t},unlinkTwitter:async e=>{let t=await r.unlinkOAuth("twitter",e);return v(t),t},unlinkTwitch:async e=>{let t=await r.unlinkOAuth("twitch",e);return v(t),t},unlinkDiscord:async e=>{let t=await r.unlinkOAuth("discord",e);return v(t),t},unlinkGithub:async e=>{let t=await r.unlinkOAuth("github",e);return v(t),t},unlinkSpotify:async e=>{let t=await r.unlinkOAuth("spotify",e);return v(t),t},unlinkInstagram:async e=>{let t=await r.unlinkOAuth("instagram",e);return v(t),t},unlinkTiktok:async e=>{let t=await r.unlinkOAuth("tiktok",e);return v(t),t},unlinkLine:async e=>{let t=await r.unlinkOAuth("line",e);return v(t),t},unlinkLinkedIn:async e=>{let t=await r.unlinkOAuth("linkedin",e);return v(t),t},unlinkApple:async e=>{let t=await r.unlinkOAuth("apple",e);return v(t),t},unlinkFarcaster:async e=>{let t=await r.unlinkFarcaster(e);return v(t),t},unlinkTelegram:async e=>{let t=await r.unlinkTelegram(e);return v(t),t},unlinkPasskey:async e=>{let t=await Kr();if(!t)throw Error("Must have valid access token to enroll in MFA");if(!de)throw Error("Wallet proxy not initialized.");let n=d.passkeys.shouldUnenrollMfaOnUnlink;await de.unlinkPasskeyAccount({credentialId:e,accessToken:t,removeAsMfa:n});let a=await r.getAuthenticatedUser();return v(a),a},unlinkCrossAppAccount:async({subject:e})=>{let t=f?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Te("Invalid subject");r.storeProviderAccessToken(t.id,null);let n=await r.unlinkOAuth(`privy:${t.id}`,e);return v(n),n},setWalletRecovery:async e=>It({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>It({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=e.message,l=t?.address?N(f,t.address):E(f);if(!l&&void 0!==t?.address){let e=x(Ki(),t.address);if(e)try{let t=await e.getEthereumProvider(),r=await t.request({method:"personal_sign",params:[o,e.address]});return er(Re,"signMessage","onSuccess",{signature:r}),void n({signature:r})}catch(e){return er(Re,"signMessage","onError",_e.UNABLE_TO_SIGN),void i(e??new ze("Unable to sign message"))}}if(!l)throw new Te("No embedded or connected wallet found for address.");if(!Ve||!f)return er(Re,"signMessage","onError",_e.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let c=l.address,d=l.walletIndex??0,{entropyId:u,entropyIdVerifier:h}=ve(f,l),p=P(l);if("string"!=typeof o||o.length<1)return er(Re,"signMessage","onError",_e.INVALID_MESSAGE),void i(Error("Message must be a non-empty string"));let w=async()=>{let t;if(!Ve)throw Error("User must be authenticated before signing with a Privy wallet");let n=await Kr();if(!de||!n||!await Nt.recoverEmbeddedWallet({address:c}))throw Error("Unable to connect to wallet");if(r.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:c,requesterAppId:s}}),p){let r=St(e.message,{strict:!0}),i=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:n,requesterAppId:s,message:e})),{chain_type:"ethereum",method:"personal_sign",params:r?{message:o.slice(2),encoding:"hex"}:{message:o,encoding:"utf-8"},wallet_id:l.id});if(!i.data||!("signature"in i.data))throw new ze("Unable to sign message");t=i.data.signature}else{let{response:e}=await de.rpc({accessToken:n,entropyId:u,entropyIdVerifier:h,chainType:"ethereum",hdWalletIndex:d,requesterAppId:s,request:{method:"personal_sign",params:[o,c]}});t=e.data}return r.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:c,requesterAppId:s}}),t};if(et({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();er(Re,"signMessage","onSuccess",{signature:e}),n({signature:e})}catch(e){er(Re,"signMessage","onError",_e.UNABLE_TO_SIGN),i(e??new ze("Unable to sign message"))}else we({signMessage:{method:"personal_sign",data:o,confirmAndSign:w,onSuccess:e=>{er(Re,"signMessage","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{er(Re,"signMessage","onError",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:c,entropyId:u,entropyIdVerifier:h,onCompleteNavigateTo:"SignRequestScreen",isUnifiedWallet:p,onFailure:e=>{er(Re,"signMessage","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),it("EmbeddedWalletConnectingScreen")})),signTypedData:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=t?.address?N(f,t.address):E(f);if(!o&&t?.address){let r=x(Ki(),t.address);if(r)try{let t=await r.getEthereumProvider(),a=oe(e),i=await t.request({method:"eth_signTypedData_v4",params:[r.address,a]});return er(Re,"signTypedData","onSuccess",{signature:i}),void n({signature:i})}catch(e){return er(Re,"signTypedData","onError",_e.UNABLE_TO_SIGN),void i(e??new ze("Unable to sign typed data "+e))}}if(!o)throw new Te("No embedded or connected wallet found for address.");if(!Ve||!f)return er(Re,"signTypedData","onError",_e.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let l=o.address,c=o.walletIndex??0,{entropyId:d,entropyIdVerifier:u}=ve(f,o),h=P(o),p=oe(e),w=async()=>{let e;if(!Ve)throw Error("User must be authenticated before signing with a Privy wallet");let t=await Kr();if(!de||!t||!await Nt.recoverEmbeddedWallet({address:l}))throw Error("Unable to connect to wallet");if(r.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:l,requesterAppId:s}}),h){let{domain:n,types:r,primaryType:i,message:l}=p,c=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:t,requesterAppId:s,message:e})),{chain_type:"ethereum",method:"eth_signTypedData_v4",params:{typed_data:{domain:n,types:r,primary_type:i,message:l}},wallet_id:o.id});if(!c.data||!("signature"in c.data))throw new ze("Unable to sign message");e=c.data.signature}else{let{response:n}=await de.rpc({accessToken:t,entropyId:d,entropyIdVerifier:u,chainType:"ethereum",hdWalletIndex:c,requesterAppId:s,request:{method:"eth_signTypedData_v4",params:[l,p]}});e=n.data}return r.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:l,requesterAppId:s}}),e};if(et({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();er(Re,"signTypedData","onSuccess",{signature:e}),n({signature:e})}catch(e){er(Re,"signTypedData","onError",_e.UNABLE_TO_SIGN),i(e??new ze("Unable to sign message"))}else we({signMessage:{method:"eth_signTypedData_v4",data:p,confirmAndSign:w,onSuccess:e=>{er(Re,"signTypedData","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{er(Re,"signTypedData","onError",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,entropyId:d,isUnifiedWallet:h,entropyIdVerifier:u,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{er(Re,"signMessage","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),it("EmbeddedWalletConnectingScreen")})),sendTransaction:async(e,t)=>await ft({transaction:e,sponsor:t?.sponsor,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await ft({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,a)=>{if(!Ve||!f)return void a(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let i=e?.address?N(f,e.address):E(f);if(!i)return void a(new Te("User must have an embedded wallet."));let s=i.address,{entropyId:o,entropyIdVerifier:l}=ve(f,i),c=P(i);if(!s)return void a(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));if(!Ct(s))return void a(Error("Must provide a valid Ethereum address."));let d={recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,isUnifiedWallet:c,entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:"EmbeddedWalletKeyExportScreen",onFailure:a,shouldForceMFA:!0};we(pe),await Kr()&&de?de?Fe(i)?(we({keyExport:{appId:n.appId,appClientId:n.clientId,origin:r.apiUrl,address:i.address,entropyId:o,entropyIdVerifier:l,hdWalletIndex:i.walletIndex,chainType:i.chainType,walletId:i.id,isUnifiedWallet:c,imported:i.imported,onSuccess:t,onFailure:a},connectWallet:d}),it("EmbeddedWalletConnectingScreen")):a(Error(`Export is not supported for ${i.chainType} wallets`)):a(Error("Must have a Privy wallet before exporting")):a(Error("Must have valid access token to enroll in MFA"))})),promptMfa:vt,async init(e){switch(e){case"sms":return void await r.initMfaSmsVerification();case"passkey":return await r.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Te("Invalid MFA code");Ne.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{Oe.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Te("Invalid authenticator response");let n=await import("@simplewebauthn/browser"),r=Vi(await n.startAuthentication({optionsJSON:t}));Ne.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{Oe.current={resolve:e,reject:t}}));break;default:throw Ne.current?.reject(new Te("Unsupported MFA method")),new Te(`Unsupported MFA method: ${e}`)}},cancel(){Ne.current?.reject(new Te("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Kr();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,n)=>{if(!e)return Nt.closePrivyModal(),void t();d.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),we({mfaEnrollmentFlow:{mfaMethods:d.mfa.methods,shouldUnlinkOnUnenrollMfa:d.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:n}}),it("MfaEnrollmentFlowScreen")})),async initEnrollmentWithTotp(){let e=await Kr();if(!e||!de)throw Error("Must have valid access token to enroll in MFA");let t=await de.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Kr();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Kr();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},t={}){let n=await Kr();if(!n||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"passkey",accessToken:n,credentialIds:e,removeForLogin:t.removeForLogin}),v(await r.getAuthenticatedUser())},async unenroll(e,t={}){let n=await Kr();if(!n||!de)throw Error("Must have valid access token to remove MFA");"passkey"===e?await de.submitEnrollMfa({method:"passkey",accessToken:n,credentialIds:[],removeForLogin:t.removeForLogin}):await de.unenrollMfa({method:e,accessToken:n}),v(await r.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Kr(),t=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!de||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(P(t))throw new Te("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Nt.recoverEmbeddedWallet({address:t.address}))throw Error("Unable to connect to wallet");let n=await de.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===n.status&&v(await r.getAuthenticatedUser()||f||null),we({farcasterSigner:n}),it("FarcasterSignerStatusScreen")},getFarcasterSignerPublicKey:async()=>{let e,t=await Kr(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(P(n))throw new Te("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Nt.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!f.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=f.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Kr(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(P(n))throw new Te("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Nt.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!f.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let r=await import("@simplewebauthn/browser"),a=await de.signFarcasterMessage({address:n.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(f.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(a.signature))},signMessageWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return _i({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletMessage":"personal_sign",params:[e,t],chainId:n},reconnect:Pt})},signTypedDataWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),i=oe(e);return _i({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,i],chainId:n},reconnect:Pt})},sendTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return _i({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e],chainId:e.chainId},reconnect:Pt})},signTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return _i({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?"privy_signSmartWalletTx":"eth_signTransaction",params:[e],chainId:e.chainId},reconnect:Pt})},isModalOpen:u||!!w,mfaMethods:d.mfa.methods};Zi=Wt.signMessage,Xi=Wt.signTypedData,ts=async(e,t)=>await ft({transaction:e,...t,signOnly:!1}),es=async(e,t)=>({signature:(await ft({transaction:e,...t,signOnly:!0})).hash});let Ut=async e=>{let t,n,a;D(!0),Q({status:"loading"}),r.startAuthFlow(new oa({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl}));let i=Me.get(Ze),s=e.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:i??"",returnedStateCode:s??""}}),D(!1),new Te("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{({user:t,oAuthTokens:a}=await r.link()),$e.current=e.provider;let n=kt(t);t&&n&&er(Re,"linkAccount","onSuccess",{user:t,linkMethod:$e.current,linkedAccount:n})}catch(t){throw D(!1),er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:n,oAuthTokens:a}=await r.authenticate()),$e.current=e.provider;let i=kt(t);t&&i&&void 0!==n&&er(Re,"login","onComplete",{user:t,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:$e.current,loginAccount:i})}catch(e){throw D(!1),Q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}return v(t),_(n||!1),Ke(!0),D(!1),Q({status:"done"}),a&&t&&er(Re,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:t}),t??void 0},Nt={privy:a,setAuthenticated:Ke,setUser:v,setIsNewUser:_,isNewUserThisSession:C,pendingTransaction:null,walletConnectionStatus:L,setWalletConnectionStatus:j,connectors:r.connectors?.walletConnectors??[],rpcConfig:d.rpcConfig,chains:d.chains,appId:n.appId,showFiatPrices:"native-token"!==d.embeddedWallets.priceDisplay.primary,clientAnalyticsId:r.clientAnalyticsId,onCustomAuthAuthenticated:st,hideWalletUIs:Ye,isHeadlessSigning:h(et,[d.embeddedWallets.showWalletUIs]),emailOtpState:H,setEmailOtpState:B,smsOtpState:K,setSmsOtpState:$,oAuthState:J,setOAuthState:Q,telegramAuthState:Z,setTelegramAuthState:ce,siweState:G,setSiweState:Y,isHeadlessOAuthLoading:F,baseAccountSdk:k,setBaseAccountSdk:T,nativeTokenSymbolForChainId:e=>d.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(de)return de;let t=new Promise((e=>{ge.current=e})),n=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,n]);return ge.current=null,r},getAuthFlow:()=>r.authFlow,getAuthMeta:()=>r.authFlow?.meta,client:r,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=y&&Ve&&f;if(a&&$e.current&&(t=kt(f)),"login"===Ge.current)e.shouldCallAuthOnSuccess&&a&&$e.current?er(Re,"login","onComplete",{user:f,isNewUser:C,wasAlreadyAuthenticated:!1,loginMethod:$e.current,loginAccount:t??null}):er(Re,"login","onError",_e.USER_EXITED_AUTH_FLOW);else if("link"===Ge.current&&t)e.isSuccess&&a&&$e.current?er(Re,"linkAccount","onSuccess",{user:f,linkMethod:$e.current,linkedAccount:t}):$e.current&&er(Re,"linkAccount","onError",_e.USER_EXITED_LINK_FLOW,{linkMethod:$e.current});else if("update"===Ge.current&&t)e.isSuccess&&a&&$e.current?er(Re,"update","onSuccess",{user:f,updateMethod:$e.current,updatedAccount:t}):$e.current&&er(Re,"update","onError",_e.USER_EXITED_UPDATE_FLOW,{linkMethod:$e.current});else if("connect-or-create"===Ge.current){let e=Ki();e[0]?er(Re,"connectOrCreateWallet","onSuccess",{wallet:e[0]}):er(Re,"connectOrCreateWallet","onError",_e.USER_EXITED_AUTH_FLOW)}let s=b&&Ni.has(b),o="ErrorScreen"===b&&pe.errorModalData&&Ni.has(pe.errorModalData.previousScreen);if((s||o)&&pe.funding){let e,t=Ni.get(b)??null;if(o&&pe.funding?.onError){let e=pe.errorModalData?.error,t=e?.privyErrorCode||_e.UNKNOWN_FUNDING_ERROR,n=new Te(e?.message||"Funding failed",e,t);pe.funding?.onError?.(n)}if("solana"===pe.funding.chainType){let n=d.solanaRpcs[pe.funding.chain];if(!n)return console.warn("Unable to load solana rpc, skipping balance"),er(Re,"fundSolanaWallet","onUserExited",{address:pe.funding.address,fundingMethod:t,chain:pe.funding.chain,balance:e}),p(!1),void Wi(pe.funding,t);if(i(Hn))try{e=await Ri({rpc:n.rpc,address:pe.funding.address})}catch{console.error("Unable to pull wallet balance")}else console.warn("Unable to load solana plugin, skipping balance");er(Re,"fundSolanaWallet","onUserExited",{address:pe.funding.address,fundingMethod:t,chain:pe.funding.chain,balance:e})}else{let r=gr(pe.funding.chain.id,d.chains,d.rpcConfig,{appId:n.appId});try{e=await r.getBalance({address:pe.funding.address})}catch{console.error("Unable to pull wallet balance")}er(Re,"fundWallet","onUserExited",{address:pe.funding.address,chain:pe.funding.chain,fundingMethod:t,balance:e}),Wi(pe.funding,t)}}we((e=>({...e,externalConnectWallet:{}}))),Ge.current=null,$e.current=null,_(!1),p(!1),j({status:"disconnected",connectedWallet:null,connector:null,connectError:null,connectRetry:()=>{}}),setTimeout((()=>{r.authFlow=void 0}),200)},openPrivyModal:it,connectWallet:dt,initLoginWithWallet:async(e,t,n,r)=>{te(e)?($e.current="siwe",ut(e,t,n)):($e.current="siws",ht(e,t,n,r))},loginWithWallet:async()=>{let e,t,n;if(!y)throw new We;if(r.authFlow instanceof ha?e="siwe":r.authFlow instanceof pa&&(e="siws"),!e)throw new Te("Must initialize SIWE/SIWS flow first.");if(null!==await r.getAccessToken())try{({user:t}=await r.link()),$e.current=e}catch(t){throw er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:n}=await r.authenticate()),$e.current=e}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR),e}v(t||f||null),_(n||!1),Ke(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:n})=>new Promise((async(r,a)=>{let i=await Kr();if(!Ve||!f||!i)throw new Te("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Te("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let s=Nt.walletProxy??await Nt.initializeWalletProxy(15e3);if(!s)throw new Te("Wallet proxy not initialized.");if((({address:e,user:t})=>!!vi(t).find((t=>t.address===e)))({address:e,user:f}))return r();let o=N(f,e);if(!o)throw new Te("Address to delegate is not associated with current user.");if(P(o))throw new Te("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let l=gi({address:e,user:f}),c=fi({address:e,user:f}),d=async()=>{await s.createDelegatedAction({accessToken:i,rootWallet:c,delegatedWallets:[l]}),await Nt.refreshSessionAndUser()};if(await Nt.recoverEmbeddedWallet({address:e}),n)we({delegatedActions:{consent:{address:e,onDelegate:d,onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),it("DelegatedActionsConsentScreen");else try{await d(),r()}catch(e){a(e)}})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,n)=>{if(!Ve||!f)throw new Te("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");let a=vi(f);if(0===a.length)throw new Te("User has no delegated wallets to revoke.");if(a.some(P))throw new Te("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let i=async()=>{await r.revokeDelegatedWallet(),await Nt.refreshSessionAndUser()};if(e)we({delegatedActions:{revoke:{onRevoke:i,onSuccess:async()=>{t()},onError:async e=>{n(e)}}}}),it("DelegatedActionsRevokeScreen");else try{await i(),t()}catch(e){n(e)}})),initLoginWithFarcaster:async(e,t)=>{let n=new Zr(e,t);r.startAuthFlow(n);try{$e.current="farcaster",await n.initializeFarcasterConnect()}catch(e){throw"login"===Ge.current?er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!y)throw new We;if(!(r.authFlow instanceof Zr))throw new Te("Must initialize Farcaster flow first.");if(null!==await r.getAccessToken())try{({user:e}=await r.link()),$e.current="farcaster"}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await r.authenticate()),$e.current="farcaster"}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e||null),_(t||!1),Ke(!0)},async crossAppAuthFlow({appId:e,popup:t,action:n,disableSignup:a}){let i=`privy:${e}`;$e.current=i;let{url:s,stateCode:o,codeVerifier:l}=await async function({api:e,appId:t}){let n=aa(),r=ia(),a=await sa(n);try{let{url:i}=await e.post(Dt,{provider:`privy:${t}`,redirect_to:window.location.href,code_challenge:a,state_code:r});return{url:i,stateCode:r,codeVerifier:n}}catch(e){throw Ce(e)}}({api:r.api,appId:e});if(!s)throw r.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Te("No authorization URL returned for cross-app auth.");try{let c=await async function({url:e,popup:t}){return t.location=e,new Promise(((e,n)=>{let r,a=setTimeout((()=>{n(new Te("Authorization request timed out after 2 minutes.")),i()}),12e4);function i(){t?.close(),window.removeEventListener("message",o)}let s=setInterval((()=>{t?.closed&&!r&&(i(),clearInterval(s),clearTimeout(a),n(new Te("User rejected request")))}),300);function o(t){t.data&&("PRIVY_OAUTH_RESPONSE"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(clearTimeout(a),e(t.data),i()),"PRIVY_OAUTH_ERROR"===t.data.type&&(clearTimeout(a),n(new Te(t.data.error)),i()),t.data.type===ki&&((r=new BroadcastChannel(Ai)).onmessage=o))}window.addEventListener("message",o)}))}({url:s,popup:t,provider:i}),d=c.stateCode,u=c.authorizationCode;if(d!==o)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:i,storedStateCode:o??"",returnedStateCode:d??""}}),new Te("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);let h=await async function({appId:e,stateCode:t,codeVerifier:n,authorizationCode:r,action:a,client:i,disableSignup:s}){if(!r||!t)throw new Te("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if("undefined"===r)throw new Te("User denied confirmation during cross-app auth flow");try{let o=new Ti({authorizationCode:r,stateCode:t,codeVerifier:n,provider:`privy:${e}`,disableSignup:!!s});i.startAuthFlow(o);let l="link"===a?await i.link():await i.authenticate(),c=l.oAuthTokens?.accessToken;return console.debug(),c}catch(e){let t=Ce(e);if(t.privyErrorCode===_e.ACCOUNT_TRANSFER_REQUIRED)throw t;if(t.privyErrorCode)throw new Te(t.message||"Invalid code during cross-app auth flow.",void 0,t.privyErrorCode);if("User denied confirmation during cross-app auth flow"===t.message)throw new Te("Invalid code during cross-app auth flow.",void 0,_e.OAUTH_USER_DENIED);throw new Te("Invalid code during cross-app auth flow.",void 0,_e.UNKNOWN_AUTH_ERROR)}}({appId:e,codeVerifier:l,stateCode:d,authorizationCode:u,action:n,client:r,disableSignup:a});h&&r.storeProviderAccessToken(e,h);let p=await Nt.refreshSessionAndUser();if(!p)throw new Te("Unable to update user");return r.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),p}catch(e){throw r.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:i}}),e}},async initLoginWithOAuth(e,t,n){if($e.current=e,!je())return void it("InAppBrowserLoginNotPossible");if("google"===e&&!d.allowOAuthInEmbeddedBrowsers&&Oi(window.navigator.userAgent))return void it("InAppBrowserLoginNotPossible");"twitter"===e&&window.opener&&window.opener.postMessage({type:ki},"*"),Me.del(Je),Me.del(Qe);let a=new oa({provider:e,disableSignup:!!n,withPrivyUi:!0,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),r.startAuthFlow(a);let i=await r.authFlow.getAuthorizationUrl();if(i&&i.url)if("twitter"===e&&At&&(i.url=i.url.replace("x.com","twitter.com")),"chrome-extension:"===window.location.protocol&&ta())try{let{privyOAuthCode:e,privyOAuthState:t}=await na(i.url);it("OAuthStatusScreen"),a.meta.stateCode=t,a.meta.authorizationCode=e}catch(e){throw console.error("OAuth in chrome extension flow failed:",e),e}else window.location.assign(i.url)},async initLoginWithTelegram(e,t){if(!y)throw new We;$e.current="telegram";let n=new ka(e,t);r.startAuthFlow(n),ce({status:"loading"}),n.meta.telegramWebAppData=void 0,n.meta.telegramAuthResult=await new Promise(((e,t)=>d.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:d.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(n=>n?e(n):("link"===Ge.current?er(Re,"linkAccount","onError",_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}):"login"===Ge.current?er(Re,"login","onError",_e.INVALID_CREDENTIALS):"update"===Ge.current&&er(Re,"login","onError",_e.FAILED_TO_UPDATE_ACCOUNT),t(new Te("Telegram auth failed or was canceled by the client"))))):t(new Te("Telegram was not initialized")):t(new Te("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,n;if(!(r.authFlow instanceof ka))throw new Te("Must initialize Telegram flow before calling loginWithTelegram");r.authFlow.meta.captchaToken||=e?.captchaToken;let a=await Kr(),i=e?.intent||Ge.current;if("login"===i)try{let e=await r.authenticate();t=e.user,n=e.isNewUser,$e.current="telegram"}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}else{if("link"!==i)throw new Te("Unknown auth intent");try{t=(await r.link()).user,$e.current="telegram"}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}v(t),_(n||!1),Ke(!0),ce({status:"done"});let s=t?.linkedAccounts.find((({type:e})=>"telegram"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:s}},async loginWithOAuth(e){let t,n,a;if(!(r.authFlow instanceof oa))throw new Te("Must initialize OAuth flow before calling loginWithOAuth");let i=Me.get(Ze),s=r.authFlow.meta.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:i??"",returnedStateCode:s??""}}),new Te("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{let n=await r.link();t=n.user,a=n.oAuthTokens,$e.current=e}catch(t){throw er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let i=await r.authenticate();t=i.user,n=i.isNewUser,a=i.oAuthTokens,$e.current=e}catch(t){throw"login"===Ge.current?er(Re,"login","onError",t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return v(t),_(n||!1),Ke(!0),a&&t&&er(Re,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:t}),a},passkeyAuthState:z,setPasskeyAuthState:q,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new da({captchaToken:e,setPasskeyAuthState:q,hints:d.passkeys.registration?.hints});r.startAuthFlow(n),Ge.current="login";try{$e.current="passkey",q({status:"generating-challenge"}),await n.initRegisterFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Te("Must initialize Passkey flow first.");if("passkey"!==$e.current){let e=new Te("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let n=await Kr();try{$e.current="passkey",q({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await r.authenticate())}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e),_(t||!1),Ke(!0),q({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!n,loginAccount:a}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new da({captchaToken:e,setPasskeyAuthState:q,hints:void 0});r.startAuthFlow(n),Ge.current="login";try{$e.current="passkey",q({status:"generating-challenge"}),await n.initAuthenticationFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(e){let t,n;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Te("Must initialize Passkey flow first.");if(e?.credentialIds&&(r.authFlow.meta.allowedCredentialsIds=e.credentialIds),"passkey"!==$e.current){let e=new Te("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let a=await Kr();try{$e.current="passkey",q({status:"awaiting-passkey"}),({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(t),_(n||!1),Ke(!0),q({status:"done"});let i=t?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:i}},async initLinkWithPasskey(e){let t=new da({captchaToken:e,hints:d.passkeys.registration?.hints});r.startAuthFlow(t),Ge.current="link",$e.current="passkey",q({status:"generating-challenge"});try{await t.initLinkFlow(),q({status:"awaiting-passkey"})}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),q({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Te("Must initialize Passkey flow first.");if("passkey"!==$e.current)throw new Te("Must init login with Passkey flow first.");try{$e.current="passkey",({user:e}=await r.link())}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return v(e||f||null),q({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,n){if(!je())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&!d.allowOAuthInEmbeddedBrowsers&&Oi(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new oa({provider:e,withPrivyUi:!1,disableSignup:n??!1,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),Q({status:"loading"});let i=await r.startAuthFlow(a).getAuthorizationUrl();if(i?.url)if("chrome-extension:"===window.location.protocol&&ta())try{let{privyOAuthCode:e,privyOAuthState:t}=await na(i.url);a.meta.stateCode=t,a.meta.authorizationCode=e,await Ut(a.meta)}catch(e){throw Q({status:"error",error:e}),e}else window.location.assign(i.url)},loginWithHeadlessOAuth:Ut,initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{let i=new Yr({email:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{$e.current="email",B({status:"sending-code"});let e=await i.sendCodeEmail({withPrivyUi:a});if(e?.ssoRedirectUrl)return window.location.href=e.ssoRedirectUrl,void await ae(1e4);B({status:"awaiting-code-input"})}catch(e){throw B({status:"error",error:e}),"login"===Ge.current?er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async({oldAddress:e,newAddress:t,captchaToken:n})=>{let a=new Jr(e,t,n);r.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){throw er(Re,"update","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:$e.current}),e}},initUpdatePhone:async(e,t,n)=>{let a=new ma(e,t,n);r.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){er(Re,"update","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:$e.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{$({status:"sending-code"});let i=new wa({phoneNumber:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{$e.current="sms",await i.sendSmsCode({withPrivyUi:a}),$({status:"awaiting-code-input"})}catch(e){throw $({status:"error",error:e}),"login"===Ge.current?er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(r.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(r.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,n;function a(e){r.authFlow instanceof Yr?B(e):r.authFlow instanceof wa&&$(e)}if(a({status:"submitting-code"}),!y){let e=new We;throw a({status:"error",error:e}),e}if(r.authFlow instanceof Yr)r.authFlow.meta.emailCode=e.trim();else{if(!(r.authFlow instanceof wa)){let e=new Te("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}r.authFlow.meta.smsCode=e.trim()}let i=await Kr();if("link"===Ge.current)try{({user:t}=await r.link())}catch(e){throw a({status:"error",error:e}),er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:$e.current}),e}else if("update"===Ge.current)try{({user:t}=await r.link())}catch(e){throw a({status:"error",error:e}),er(Re,"update","onError",e.privyErrorCode||_e.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:$e.current}),e}else try{({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw a({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}let s=t||f;v(s||null),_(n||!1),Ke(!0),a({status:"done"});let o=null;return r.authFlow instanceof Yr?o=s?.linkedAccounts.find((({type:e})=>"email"===e))||null:r.authFlow instanceof wa&&(o=s?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:s,isNewUser:n||!1,wasAlreadyAuthenticated:!!i,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:n})=>{Ge.current=Ve?"link":"login",$e.current="siwe",Y({status:"generating-message"});let a=await r.generateSiweNonce({address:e,captchaToken:n});return Y({status:"awaiting-signature"}),ua({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let n=await r.generateSiweNonce({address:e});return ua({address:e,chainId:t.replace("eip155:",""),nonce:n})},linkSmartWallet:async({message:e,signature:t,smartWalletType:n,smartWalletVersion:a})=>{let i;i=await r.linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:a}),v((i=await Nt.refreshSessionAndUser()??i)||f||null)},loginWithSiwe:async({message:e,signature:t,captchaToken:n,disableSignup:a,walletClientType:i,connectorType:s})=>{let o,l=null;try{if(f)throw Error("User already authenticated");let c=new ha(r,void 0,n,a,{message:e,signature:t,walletClientType:i,connectorType:s});r.startAuthFlow(c),$e.current="siwe",Ge.current="login",Y({status:"submitting-signature"});let d=await r.authenticate();if(({user:l,isNewUser:o}=d),!l)throw Error("Authentication failed - no user returned")}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),Y({status:"error",error:e}),e}return v(l),_(o||!1),Ke(!0),Y({status:"done"}),Ge.current=null,$e.current=null,{user:l,isNewUser:o||!1}},linkWithSiwe:async({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i})=>{let s;wt("siwe");let o=null;try{Y({status:"submitting-signature"}),s=await r.linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i}),s=await Nt.refreshSessionAndUser()??s,Y({status:"done"}),(o=kt(s)||null)&&er(Re,"linkAccount","onSuccess",{user:s,linkMethod:"siwe",linkedAccount:o})}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Ge.current=null,$e.current=null,Y({status:"error",error:e}),e}let l=s||f;return v(l||null),Ge.current=null,$e.current=null,{user:l,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await r.getAuthenticatedUser();return Ke(!!e),v(e),e},walletProxy:de,createAnalyticsEvent:({eventName:e,payload:t,timestamp:n})=>r.createAnalyticsEvent({eventName:e,payload:t,timestamp:n}),acceptTerms:async()=>{let e=await r.acceptTerms();return v(e),e},getUsdTokenPrice:e=>r.getUsdTokenPrice(e),getUsdPriceForSol:()=>r.getUsdPriceForSol(),getSplTokenMetadata:e=>r.getSplTokenMetadata(e),recoverEmbeddedWallet:async e=>new Promise((async(t,n)=>{if(!f)return void t(!0);let a=e?.address?N(f,e.address):S(f)||U(f).at(0)||O(f).at(0);if(!a||P(a))return void t(!0);let i=await Kr();if(!i||!de||!a)return void n(Error("Must have valid access token and Privy wallet to recover wallet"));let{entropyId:s,entropyIdVerifier:o}=ve(f,a);try{await de.connect({accessToken:i,entropyId:s,entropyIdVerifier:o}),t(!0)}catch(e){if(ti(e)&&"privy"===a.recoveryMethod){let e;r.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}});try{e=await de.recover({entropyId:s,entropyIdVerifier:o,accessToken:i})}catch(e){return void n(e)}e.entropyId||n(Error("Unable to recover wallet")),r.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)}else ti(e)&&"privy"!==a.recoveryMethod&&"privy-v2"!==a.recoveryMethod?(we({recoverWallet:{entropyId:s,entropyIdVerifier:o,onFailure:n,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover",shouldCreateEth:!1,shouldCreateSol:!1}}),it(Pi(a.recoveryMethod))):n(e)}})),setReadyToTrue:e=>{g(!0),me?.(e)},updateWallets:()=>yt(),fundWallet:async(e,t)=>{let n="FundingMethodSelectionScreen";return new Promise(((r,a)=>{we({funding:{...Le({address:e,appConfig:d,fundWalletConfig:t,methodScreen:n,onComplete:r,onError:a})}}),it(n)}))},openModal:it,requestFarcasterSignerStatus:async e=>{let t=await Kr(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await r.requestFarcasterSignerStatus(e);return"approved"===a.status&&v(await r.getAuthenticatedUser()||f||null),a},connectCoinbaseSmartWallet:async()=>{d.externalWallets.coinbaseWallet.config.preference={...d.externalWallets.coinbaseWallet.config.preference,options:"smartWalletOnly"};let e=r.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||r.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),dt(e);await ct("coinbase_wallet","coinbase_smart_wallet")},connectBaseAccount:async()=>{let e=r.connectors?.findWalletConnector("base_account","base_account");if(e)return dt(e);await ct("base_account","base_account")},initiateAccountTransfer:async({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l})=>{let c=await r.sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l});return v(c),c},inProgressAuthFlowRef:Ge,inProgressLoginOrLinkMethodRef:$e};ns=Nt.recoverEmbeddedWallet,Nt.recoverEmbeddedWallet;let Ot=l((()=>({wallets:A,ready:fe&&xe})),[A,fe,xe]),Rt=r.authFlow instanceof ka,{siteKey:Mt,enabledProvider:xt}=d.captcha,Ft=!d.headless&&xt&&!Ve&&(y||Rt);/*#__PURE__*/return t(Qi.Provider,{value:!0,children:/*#__PURE__*/t(R.Provider,{value:Wt,children:/*#__PURE__*/t(tr.Provider,{value:Re,children:/*#__PURE__*/t(Ae.Provider,{value:Ot,children:/*#__PURE__*/t(fa,{appId:d.id,captchaSiteKey:Mt,enabledCaptchaProvider:xt,children:/*#__PURE__*/e(Ue.Provider,{value:Nt,children:[/*#__PURE__*/t(ie,{children:/*#__PURE__*/e(M,{data:pe,setModalData:we,setInitialScreen:I,initialScreen:b,authenticated:Ve,open:u,children:[n.children,/*#__PURE__*/t(Ji,{customAuth:d.customAuth}),Ft&&/*#__PURE__*/t(Ea,{delayedExecution:!1}),/*#__PURE__*/t(Ja,{}),/*#__PURE__*/t(Hi,{disabled:d.embeddedWallets.disableAutomaticMigration}),/*#__PURE__*/t(Ua,{palette:d.appearance.palette||{}}),!d.render.standalone&&/*#__PURE__*/t(Ba,{open:u})]})}),/*#__PURE__*/t(yi,{appId:n.appId,appClientId:n.clientId,clientAnalyticsId:r.clientAnalyticsId,origin:r.apiUrl,mfaMethods:f?.mfaMethods,mfaPromise:Ne,mfaSubmitPromise:Oe,onLoad:ue,onLoadFailed:()=>null}),d.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/t(V,{$if:!0,children:/*#__PURE__*/t(Ya,{scriptHost:n.apiUrl||nt,botUsername:d.loginConfig.telegramAuthConfiguration.botName})})]})})})})})})},as=e=>ns(e);class is extends Error{constructor(e,t,n){super(e),this.code=t,this.data=n}}class ss extends L{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new is(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Kr()||!this.address)throw new is("Disconnected",4900);let{hash:n}=await((e,t)=>ts(e,t))(t,{address:this.address});return n}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new is(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Kr()||!this.address)throw new is("Disconnected",4900);let{signature:n}=await((e,t)=>es(e,t))(t,{address:this.address});return n}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new is(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new is(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=gr(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],n=e.params[1],{signature:r}=await((e,t)=>Zi(e,t))({message:t},{address:n});return r}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],n="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:r}=await((e,t)=>Xi(e,t))(oe(n),{address:t});return r}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:q(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...Be(t)})}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return q(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!(e=>$r.includes(e))(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await Kr();if(await as({address:this.address}),!t||!this.address)throw new is("Disconnected",4900);try{let n={method:e.method,params:e.params},r=this.walletAccount;return r&&P(r)?this.handleWalletApiRequest(n,r,t):(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:n})).response.data}catch(e){throw console.error(e),new is("Disconnected",4900)}}}async handleWalletApiRequest(e,t,n){let r=this.privyClient;if(!r)throw new is("Disconnected",4900);if("secp256k1_sign"===e.method){let a=await m(r,(async({message:e})=>this.walletProxy.signWithUserSigner({accessToken:n,message:e})),{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:e.params[0]}});if("secp256k1_sign"!==a.method)throw new is(`Invalid params for ${e.method}`,4200);return a.data.signature}throw new is(`Method not supported: ${e.method}`,4200)}constructor({walletProxy:e,address:t,entropyId:n,entropyIdVerifier:r,rpcConfig:a,chains:i,appId:s,chainId:o=1,walletIndex:l,privyClient:c,walletAccount:d}){super(),this.walletProxy=e,this.address=t,this.entropyId=n,this.entropyIdVerifier=r,this.chainId=o,this.rpcConfig=a,this.chains=i,this.publicClient=gr(o,this.chains,a,{appId:s}),this.rpcTimeoutDuration=Q(a,"privy"),this.appId=s,this.walletIndex=l,this.privyClient=c,this.walletAccount=d}}const os=({style:e,...n})=>/*#__PURE__*/t("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",stroke:"currentColor",strokeWidth:1.5,viewBox:"0 0 24 24",style:{...e},...n,children:/*#__PURE__*/t("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"})}),ls=({style:n,...r})=>/*#__PURE__*/e("svg",{xmlns:"http://www.w3.org/2000/svg",width:"108",height:"108",viewBox:"0 0 108 108",fill:"none",style:{height:"28px",width:"28px",...n},...r,children:[/*#__PURE__*/t("rect",{width:"108",height:"108",rx:"23",fill:"#AB9FF2"}),/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z",fill:"#FFFDF8"})]});function cs(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var ds=0;class us extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a||"unknown",e,t,n),this.connectorType="injected",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=r;let i=r.provider;this.proxyProvider.setWalletProvider(i)}}var hs="__private_"+ds+++"__walletBranding";class ps extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return cs(this,hs)[hs]??{name:"Browser Extension",icon:os,id:"extension"}}disconnect(){console.warn("Programmatic disconnect with browser wallets is not yet supported.")}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a??"unknown",e,t,n),Object.defineProperty(this,hs,{writable:!0,value:void 0}),this.connectorType="injected",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(r),"metamask"===a?cs(this,hs)[hs]={name:"MetaMask",icon:ce,id:"io.metamask"}:"phantom"===a&&(cs(this,hs)[hs]={name:"Phantom",icon:ls,id:"phantom"})}}class ws extends us{disconnect(){console.warn("MetaMask does not support programmatic disconnect.")}async promptConnection(){try{ft||await this.proxyProvider.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}}class ms extends L{get wallets(){let e=new Set;return this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let n=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(n)&&(e.add(n),!0)}))}async initialize(e){if(this.initialized&&!e||(e&&this.removeAllConnectors(),this.externalWalletConfig.disableAllExternalWallets))return;let t=de({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:n})=>{this.createEthereumWalletConnector({connectorType:"injected",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:n}})}))}));for(let e of(this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector({connectorType:"coinbase_wallet",walletClientType:"coinbase_wallet"}),this.walletList.includes("base_account")&&this.createEthereumWalletConnector({connectorType:"base_account",walletClientType:"base_account"}),Object.values(ue)))!e.isInstalled&&this.walletList.includes(e.client)&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&e.chainTypes.includes("ethereum")&&this.createEthereumWalletConnector({connectorType:"null",walletClientType:e.client,walletConfig:e}),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&e.chainTypes.includes("solana")&&this.addSolanaWalletConnector(new he({id:e.client,name:e.name})));this.externalWalletConfig.walletConnect.enabled&&(this.walletList.includes("wallet_connect_qr")||ee(this.walletList))&&"solana-only"!==this.walletChainType&&this.createEthereumWalletConnector({connectorType:"wallet_connect_v2",walletClientType:"unknown"});let n=this.walletList.includes("wallet_connect_qr_solana")||ee(this.walletList)&&"ethereum-only"!==this.walletChainType,r=this.externalWalletConfig.solana.connectors?.get()||[],a=async e=>{if(!n)return;let t=e.find((e=>"walletconnect_solana"===e.walletBranding?.id));t&&t.wallet&&await t.wallet.initialize({walletConnectCloudProjectId:this.walletConnectCloudProjectId,privyAppName:this.privyAppName})};a(r),r.filter((e=>n||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{a(e),e?.filter((e=>n||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector)})),await t,this.initialized=!0}findWalletConnector(e,t,n){return"wallet_connect_v2"===e?this.walletConnectors.filter(pe).find((t=>t.connectorType===e&&(!n||t.wallets.some((e=>e.address===n)))))??null:this.walletConnectors.filter(pe).find((r=>r.connectorType===e&&r.walletClientType===t&&(!n||r.wallets.some((e=>e.address===n)))))??null}findSolanaWalletConnector(e){return this.walletConnectors.filter(we).find((t=>"unknown"===t.walletClientType?t.walletBranding.id===e:t.walletClientType===e))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}findImportedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded_imported"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&("solana"===e.type&&"unknown"===t.walletClientType&&"unknown"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType)));t&&(e.connectedAt=t.connectedAt)})),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&this.emit("walletsUpdated")}addEmbeddedWalletConnectors({walletProxy:e,user:t,embeddedWallets:n,defaultChain:r,appId:a,privyClient:i}){let{entropyId:s,entropyIdVerifier:o}=ve(t);for(let t of n){let n=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===t.walletIndex));if(n&&pe(n))n.proxyProvider.walletProxy=e;else{let n=new Br({provider:new ss({walletProxy:e,address:t.address,entropyId:s,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id,walletIndex:t.walletIndex,privyClient:i,walletAccount:t}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:t.walletIndex});this.addWalletConnector(n)}}}addImportedWalletConnector(e,t,n,r){let a=this.findWalletConnector("embedded_imported","privy",t);if(a&&pe(a))a.proxyProvider.walletProxy=e;else{let a=new Br({provider:new ss({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:n.id}),chains:this.chains,walletIndex:0,defaultChain:n,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(a)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.storedConnections=He(),this.emit("walletsUpdated")}removeImportedWalletConnectors(){let e=this.findImportedWalletConnectors();e.length&&(e.forEach((e=>{let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1)})),this.storedConnections=He(),this.emit("walletsUpdated"))}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:n,walletConfig:r}){let a=this.findWalletConnector(e,t);if(a&&pe(a))return a instanceof Qa&&a.resetConnection(t),a;let i=(()=>"injected"!==e?"coinbase_wallet"===e?new Hr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.coinbaseWallet.config):"base_account"===e?new zr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.baseAccount.config,this.setBaseAccountSdk):"null"!==e?new Qa({walletConnectCloudProjectId:this.walletConnectCloudProjectId,rpcConfig:this.rpcConfig,chains:this.chains,defaultChain:this.defaultChain,shouldEnforceDefaultChainOnConnect:this.shouldEnforceDefaultChainOnConnect,privyAppId:this.privyAppId,privyAppName:this.privyAppName,walletClientType:t}):r?new me({id:r.client,name:r.name,defaultChain:this.defaultChain,walletClientType:r.client}):null:"metamask"===t&&n?.eip6963InjectedProvider?new ws(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,"metamask"):"metamask"===t&&n?.legacyInjectedProvider?new ps(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"metamask"):"phantom"===t&&n?.legacyInjectedProvider?new ps(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"phantom"):n?.legacyInjectedProvider&&"unknown_browser_extension"===t?new ps(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider):n?.eip6963InjectedProvider?new us(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,t):void 0)();return i&&this.addWalletConnector(i),i||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,n,r,a,i,s,o,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{let t=this.findSolanaWalletConnector(e.walletClientType);if(!t||"null"===t.connectorType){if("null"===t?.connectorType){let e=this.walletConnectors.indexOf(t);this.walletConnectors.splice(e,1)}this.addWalletConnector(e)}},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=n,this.chains=r,this.defaultChain=a,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=s,this.shouldEnforceDefaultChainOnConnect=o,this.externalWalletConfig=l,this.privyAppName=c,this.walletChainType=u||"ethereum-only",this.setBaseAccountSdk=d,this.storedConnections=He()}}const ys=nr((()=>({identityToken:null})));function gs(){let{identityToken:e}=ys();return{identityToken:e}}let fs=[Xt,en,tn];class vs{async get(e,t){try{return await this.baseFetch(e,t)}catch(e){throw Ce(e)}}async post(e,t,n){try{return await this.baseFetch(e,{method:"POST",...t?{body:t}:{},...n})}catch(e){throw Ce(e)}}async delete(e,t){try{return await this.baseFetch(e,{method:"DELETE",...t})}catch(e){throw Ce(e)}}constructor({appId:e,appClientId:t,client:n,defaults:r}){this.appId=e,this.appClientId=t,this.clientAnalyticsId=n.clientAnalyticsId,this.sdkVersion=it,this.client=n,this.defaults=r,this.fallbackApiUrl=n.fallbackApiUrl,this.baseFetch=vr.create({baseURL:this.defaults.baseURL,timeout:this.defaults.timeout,retry:3,retryDelay:500,retryStatusCodes:[408,409,425,500,502,503,504],credentials:"include",onRequest:async({request:e,options:t})=>{let n=new Headers(t.headers);n.set("privy-app-id",this.appId),this.appClientId&&n.set("privy-client-id",this.appClientId),n.set("privy-ca-id",this.clientAnalyticsId||""),n.set("privy-client",`react-auth:${this.sdkVersion}`);let r=fs.includes(e.toString());if(!n.has("authorization")){let e=await this.client.getAccessToken({disableAutoRefresh:r});null!==e&&n.set("authorization",`Bearer ${e}`)}t.headers=n,t.retryDelay&&"number"==typeof t.retryDelay&&(t.retryDelay=3*t.retryDelay)},onRequestError:({error:e})=>{if(e instanceof DOMException&&"AbortError"===e.name)throw new Ne}})}}const As=e=>({rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification});class ks{getOrCreateGuestCredential(e){let t=at(e);if(je()){if(Me.get(t))return Me.get(t);{let e=T.encode(ra(32));return Me.put(t,e),e}}return T.encode(ra(32))}async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(nn,{guest_credential:this.meta.guestCredential})}catch(e){throw Ce(e)}}async link(){throw Error("Linking is not supported for the guest flow")}constructor(e){this.meta={guestCredential:this.getOrCreateGuestCredential(e)}}}function Ts(){return!(kt&&window.location.origin.startsWith("http://localhost"))}var Cs,_s=((Cs={}).PRIVY="privy_access_token",Cs.CUSTOMER="customer_access_token",Cs);class Ss{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return"privy_access_token"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(Ge)}get privyAccessToken(){return this._getToken($e)}_getToken(e){try{let t=Me.get(e);return"string"==typeof t?Rr.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=Me.get(st);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=Me.get(ot(e));if("string"!=typeof t)return null;{let n=new Rr(t);return n.isExpired()?(Me.del(ot(e)),null):n.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let e=Ar.get(lt);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e="privy_access_token"){let t="string"==typeof this.getToken(e),n="string"==typeof this.refreshToken&&this.refreshToken!==ct;return this.mightHaveServerCookies||t&&n}hasActiveAccessToken(e){let t=Rr.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){"string"==typeof t?Me.put(ot(e),t):Me.del(ot(e))}updateIdentityToken(e){"string"==typeof e?this.storeIdentityToken(e):this.clearIdentityToken()}async _authenticate(e){try{let t=await e.authenticate(),{user:n,is_new_user:r,oauth_tokens:a}=t;this.handleTokenResponse(t);let i=a?{provider:a.provider,accessToken:a.access_token,accessTokenExpiresInSeconds:a.access_token_expires_in_seconds,refreshToken:a.refresh_token,refreshTokenExpiresInSeconds:a.refresh_token_expires_in_seconds,scopes:a.scopes}:void 0;return this._trackAuthenticateEvents(e,r),{user:F(n),isNewUser:r,oAuthTokens:i}}catch(e){throw console.warn("Error authenticating session"),Oe(e)}}_trackAuthenticateEvents(e,t){let n=function(e){return e instanceof Yr?"email":e instanceof wa?"sms":e instanceof ha?"siwe":e instanceof ks?"guest":e instanceof $i?"custom_auth":e instanceof oa?e.meta.provider:null}(e);n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate",payload:{method:n,isNewUser:t}}),"siwe"===n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate_siwe",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),n=t.oauth_tokens,r=n?{provider:n.provider,accessToken:n.access_token,accessTokenExpiresInSeconds:n.access_token_expires_in_seconds,refreshToken:n.refresh_token,refreshTokenExpiresInSeconds:n.refresh_token_expires_in_seconds,scopes:n.scopes}:void 0;return{user:F(t),oAuthTokens:r}}catch(e){throw console.warn("Error linking account"),Oe(e)}}async _refresh(){if(!this.api)throw new Te("Session has no API instance");if(!this.client)throw new Te("Session has no PrivyClient instance");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let n;if(!(e&&t||this.mightHaveServerCookies))return null;{let r={};e&&(r.authorization=`Bearer ${e}`),n=await this.api.post(Xt,t?{refresh_token:t}:{},{headers:r})}return this.handleTokenResponse(n),F(n.user)}catch(e){if(e instanceof Pe&&e.privyErrorCode===_e.MISSING_OR_INVALID_TOKEN)return console.warn("Unable to refresh tokens - token is missing or no longer valid"),this.destroyLocalState(),null;throw Oe(e)}}handleTokenResponse(e){e.session_update_action&&"set"!==e.session_update_action?"clear"===e.session_update_action?this.destroyLocalState():"ignore"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await(this.api?.post(en,{refresh_token:this.refreshToken}))}catch(e){console.warn("Error destroying session")}this.destroyLocalState()}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken()}storeCustomerAccessToken(e){if("string"==typeof e){let t=Me.get(Ge);if(Me.put(Ge,e),!this.client?.useServerCookies){let t=Rr.parse(e)?.expiration;Ar.set(dt,e,{sameSite:"Strict",secure:Ts(),expires:t?new Date(1e3*t):void 0})}t!==e&&this.client?.onStoreCustomerAccessToken?.(e)}else Me.del(Ge),Ar.remove(dt),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(e){"string"==typeof e?(Me.put(st,e),this.client?.useServerCookies||Ar.set(lt,"t",{sameSite:"Strict",secure:Ts(),expires:30})):(Me.del(st),Ar.remove(ut),Ar.remove(lt))}storePrivyAccessToken(e){"string"==typeof e?Me.put($e,e):Me.del($e)}storeIdentityToken(e){if(ys.setState({identityToken:e}),this.client?.useServerCookies)return;Me.put(ht,e);let t=Rr.parse(e)?.expiration;Ar.set(pt,e,{sameSite:"Strict",secure:Ts(),expires:t?new Date(1e3*t):void 0})}clearIdentityToken(){Me.del(ht),ys.setState({identityToken:null}),Ar.remove(pt)}constructor(){this.authenticateOnce=new Qr((async e=>this._authenticate(e))),this.linkOnce=new Qr((async e=>this._link(e))),this.refreshOnce=new Qr(this._refresh.bind(this)),this.destroyOnce=new Qr(this._destroy.bind(this))}}let bs,Es;var Is=0,Ps="__private_"+Is+++"__getOrGenerateClientAnalyticsId";class Ws{getAppId(){return this.appId}initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,store:a,walletList:i,shouldEnforceDefaultChainOnConnect:s,externalWalletConfig:o,appName:l,walletChainType:c,setBaseAccountSdk:d}){this.connectors||(this.connectors=new ms(this.appId,e,t,n,r,a,i,s,o,l,d,c))}generateApi(){let e=new vs({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Te("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Te("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(rn,{action:"verify"})}catch(e){throw Ce(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(an,{});return As(e.options)}catch(e){throw Ce(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(sn,{});return F(e)}catch(e){throw Oe(e)}}async unlinkEmail(e){try{let t=await this.api.post(on,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkPhone(e){try{let t=await this.api.post(ln,{phoneNumber:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(cn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(dn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkOAuth(e,t){try{let n=await this.api.post(un,{provider:e,subject:t});return await this.getAuthenticatedUser()??F(n)}catch(e){throw Oe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(hn,{fid:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(pn,{telegram_user_id:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async revokeDelegatedWallet(){try{await this.api.post(wn,{})}catch(e){throw Oe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:n,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(tn,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:n?n.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){console.log("Unable to submit event. This is not an issue.")}}async signMoonpayOnRampUrl(e){try{return this.api.post(mn,e)}catch(e){throw Oe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(yn,e)}catch(e){throw Oe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${gn}?partnerUserId=${e}`)}catch(e){throw Oe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(_s.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(_s.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?Mr.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(n){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(fn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i}){return await this.api.post(vn,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){return await this.api.post(An,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a})}async linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:r}){try{let a=await this.api.post(kn,{message:e,signature:t,smart_wallet_type:n,smart_wallet_version:r});return F(a)}catch(e){throw Oe(e)}}async linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a});return F(i)}catch(e){throw Oe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(Tn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){return await this.api.post(Cn,{message:e,signature:t,walletClientType:n,connectorType:r,mode:a,message_type:i})}async authenticateWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){let s=await this.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i});this.session.handleTokenResponse(s);let o=F(s.user);if(!o)throw Error("Authentication failed - no user returned");return{user:o,isNewUser:s.is_new_user||!1}}async sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:r,telegramAuthResult:a,telegramWebAppData:i,farcasterEmbeddedAddress:s,oAuthUserInfo:o}){try{let l,c;switch(n){case"email":l=Wn,c={nonce:e,email:t};break;case"sms":l=Pn,c={nonce:e,phoneNumber:t};break;case"siwe":if(l=In,!r)throw Error("Wallet parameters must be defined");c={nonce:e,address:t,...r};break;case"farcaster":l=En,c={nonce:e,farcaster_id:t,farcaster_embedded_address:s};break;case"telegram":l=bn,c={nonce:e,telegram_auth_result:a,telegram_web_app_data:i};break;case"siws":l=Sn,c={nonce:e,address:t,...r};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:l=_n,c={nonce:e,userInfo:o}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??F(d)}catch(e){throw Oe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){return await this.api.post(Un,{message:e,signature:t,walletClientType:n,connectorType:r,message_type:a})}async linkWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){try{let i=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a});return F(i)}catch(e){throw Oe(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(Nn);return this.session.updateIdentityToken(e.identity_token),F(e.user)}catch(e){throw Oe(e)}}async scanTransaction(e){try{return await this.api.post(On,e)}catch(e){throw Oe(e)}}constructor({apiUrl:e=nt,appId:t,appClientId:n,timeout:r=wt}){Object.defineProperty(this,Ps,{value:Us}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==nt&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=n,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Ps)[Ps](),bs||(bs=new Ss),this.session=bs,this.api=this.generateApi(),this.session.client=this}}function Us(){if("undefined"==typeof window)return null;try{let e=Me.get(rt);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=A();try{return Me.put(rt,e),e}catch(t){return e}}function Ns(){if(!Es)throw new Te("No global PrivyClient instance found. Please ensure you have initialized the PrivyProvider.");return Es}async function Os(){return await(Es?.updateUserAndIdToken()),Es?.useServerCookies?ys.getState().identityToken:Promise.resolve(Me.get(ht)||null)}const Rs=({config:e,...n})=>{(()=>{if(a(Qi))throw new Te("Multiple PrivyProvider instances found","Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.")})(),function(){if("undefined"==typeof window)return;let e=["localhost","127.0.0.1"].includes(window.location.hostname),t="https:"===window.location.protocol||"chrome-extension:"===window.location.protocol;if(!e&&!t)throw new Te("Embedded wallet is only available over HTTPS")}(),function(e){if("string"!=typeof e||25!==e.length)throw new Te("Cannot initialize the Privy provider with an invalid Privy app ID")}(n.appId),function(e){Es||(Es=new Ws({appId:e.appId,appClientId:e.clientId,apiUrl:e.apiUrl}))}(n);let r=l((()=>new p({appId:n.appId,clientId:n.clientId,storage:Me,baseUrl:n.apiUrl,sdkVersion:"react-auth:3.11.0"})),[]),i=Ns(),s=Object.assign({},e);/*#__PURE__*/return t(mt,{client:r,legacyClient:i,appClientId:n.clientId,clientConfig:s,children:/*#__PURE__*/t(Bn,{children:/*#__PURE__*/t(rs,{...n,client:i,privy:r})})})},Ms=()=>{let{user:e}=C(),{walletProxy:t}=Ie();return{recover:h((async n=>{if(!t)throw Error("Wallet proxy is not ready");let r=await Kr();if(!e||!r)throw new Te("User must be logged in before attempting to modify the recovery method.");let{entropyId:a,entropyIdVerifier:i}=ve(e);try{await t.recover({entropyId:a,entropyIdVerifier:i,accessToken:r,...n})}catch{throw new Te("Unable to recover wallets")}}),[t,e])}};function xs(){let{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}=a(R);return{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}}function Fs(){let{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenroll:o,enrollInMfa:l}=a(R);return{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenrollWithSms:()=>o("sms"),unenrollWithTotp:()=>o("totp"),unenrollWithPasskey:e=>o("passkey",e),showMfaEnrollmentModal:()=>l(!0),closeMfaEnrollmentModal:()=>l(!1)}}function Ds(){let e=Ns();return e?e.getCustomerAccessToken():Promise.resolve(Me.get(Ge)||null)}const Ls=()=>{let{client:e,setAuthenticated:t,setUser:n}=Ie();return l((()=>({init:async()=>{if(!e)throw new Te("Must initialize Privy client first.");let t=new kr;return e.startAuthFlow(t),await t.init()},login:async({fid:r,message:a,signature:i})=>{if(!e)throw new Te("Must initialize Privy client first.");if(!(e.authFlow instanceof kr))throw new Te("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:a,signature:i,fid:r});let{user:s}=await e.authenticate();if(!s)throw new Te("Failed to login with Farcaster V2");return n(s),t(!0),{user:s}}})),[e,n,t])},js=()=>l((()=>({getAccessTokenForProvider:({appId:e})=>{try{let t=Me.get(ot(e));if("string"!=typeof t)return{token:null};{let n=new Rr(t);return n.isExpired()?(Me.del(ot(e)),{token:null}):{token:n.value}}}catch(e){return console.error(e),{token:null}}}})),[]),zs=e=>{Qn("login",e);let t=va(),n=tt(),{ready:r,user:a}=C(),{initLoginWithHeadlessOAuth:i,loginWithHeadlessOAuth:s,oAuthState:o,setOAuthState:l,isHeadlessOAuthLoading:d}=Ie(),u=h((async e=>{try{if(t.enabled&&"success"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return await i(e.provider,t.token,e.disableSignup)}catch(e){throw l({status:"error",error:e}),e}}),[i,t]),p=h((async()=>{let e=la();try{if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");let t=e.provider;if(b(t)){if(a&&a.linkedAccounts.some((e=>e.type===t)))return console.warn("User is already logged in with this OAuth provider"),a}else if(a&&t in a&&a[t])return console.warn("User is already logged in with this OAuth provider"),a;if(e.popupFlow)return}catch(e){throw l({status:"error",error:e}),e}try{return await s(e)}catch(e){throw l({status:"error",error:e}),e}finally{ca()}}),[s]);return c((()=>{let e=la();r&&n&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&p().catch((()=>{}))}),[r,n]),{initOAuth:u,loading:d,state:o}},qs=e=>{let t=va(),{emailOtpState:n,setEmailOtpState:r,initLoginWithEmail:a,loginWithCode:i}=Ie();return{sendCode:h((async({email:n,disableSignup:i})=>{try{if(!n)throw Error("Email required to send OTP code");let e=await Aa(t);return await a({email:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),loginWithCode:h((async({code:t})=>{try{let{user:n,isNewUser:r,wasAlreadyAuthenticated:a,linkedAccount:s}=await i(t);e?.onComplete?.({user:n,isNewUser:r,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:s})}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[i]),state:n}},Hs=e=>{let t=va(),{initSignupWithPasskey:n,signupWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{signupWithPasskey:h((async()=>{try{let a=await Aa(t);await n({captchaToken:a,withPrivyUi:!1});let{user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginAccount:l}=await r();e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:"passkey",loginAccount:l})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[r,t]),state:a}},Vs=e=>{let t=va(),{initLoginWithPasskey:n,loginWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{loginWithPasskey:h((async a=>{try{let i=await Aa(t);await n({captchaToken:i,withPrivyUi:!1});let{user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginAccount:c}=await r(a);e?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(a){throw i({status:"error",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[r,t]),state:a}},Bs=e=>{let{initLinkWithPasskey:t,linkWithPasskey:n,passkeyAuthState:r,setPasskeyAuthState:a}=Ie();return{linkWithPasskey:h((async()=>{try{await t();let r=await n();if(!r)throw Error("Error, user not found");let a=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:a})}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[n]),state:r}},Ks=e=>{let t=va(),{smsOtpState:n,setSmsOtpState:r,initLoginWithSms:a,loginWithCode:i}=Ie();return{sendCode:h((async({phoneNumber:n,disableSignup:i})=>{try{if(!n)throw Error("SMS required to send OTP code");let e=await Aa(t);return await a({phoneNumber:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),loginWithCode:h((async({code:t})=>{try{let{user:n,isNewUser:r,wasAlreadyAuthenticated:a,linkedAccount:s}=await i(t);e?.onComplete?.({user:n,isNewUser:r,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:s})}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[i]),state:n}},$s=e=>{let{connectOrCreateWallet:t}=C();return Qn("connectOrCreateWallet",e),{connectOrCreateWallet:t}},Gs=e=>{let t=va(),{siweState:n,setSiweState:r,linkWithSiwe:a,generateSiweMessage:i}=Ie();return{generateSiweMessage:h((async({address:t,chainId:n})=>{try{if(!t||!n)throw Error("wallet address and chainId required to generate nonce");return await i({address:t,chainId:n}).then((e=>e))}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[i]),linkWithSiwe:h((async({signature:n,message:i,chainId:s,walletClientType:o,connectorType:l})=>{try{if(t.enabled&&"success"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,linkedAccount:c}=await a({message:i,signature:n,chainId:s,walletClientType:o,connectorType:l});c&&e?.onSuccess?.({user:r,linkMethod:"siwe",linkedAccount:c})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),n}}),[a,t.status]),state:n}},Ys=e=>{let t=va(),{siweState:n,setSiweState:r,client:a,generateSiweMessage:i,loginWithSiwe:s}=Ie();return{generateSiweNonce:h((async n=>{try{let e=await Aa(t);r({status:"generating-message"});let i=await a.generateSiweNonce({address:n?.address,captchaToken:e});return r({status:"awaiting-signature"}),i}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),generateSiweMessage:h((async({address:n,chainId:a})=>{try{let e=await Aa(t);return await i({address:n,chainId:a,captchaToken:e})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t]),loginWithSiwe:h((async({message:n,signature:a,disableSignup:i,walletClientType:o,connectorType:l})=>{try{let r=await Aa(t),{user:c,isNewUser:d}=await s({message:n,signature:a,captchaToken:r,disableSignup:i,walletClientType:o,connectorType:l});return e?.onComplete?.({user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),c}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[s,t]),state:n}},Js=()=>{let e=va(),{client:t,setAuthenticated:n,setUser:r,setIsNewUser:a}=Ie(),{authenticated:i}=zn();return{generateSiwsMessage:h((async({address:n})=>{let r=await Aa(e),a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),loginWithSiws:h((async({message:e,signature:s,disableSignup:o,walletClientType:l,connectorType:c})=>{if(i)throw Error("User already authenticated");let{user:d,isNewUser:u}=await t.authenticateWithSiws({message:e,signature:s,walletClientType:l,connectorType:c,mode:o?"no-signup":"login-or-sign-up",messageType:"plain"});if(!d)throw Error("Authentication failed - no user returned");return r(d),a(u||!1),n(!0),d}),[i,t,n,r,a])}},Qs=()=>{let e=va(),{client:t,setUser:n,refreshSessionAndUser:r}=Ie(),{authenticated:a}=zn();return{generateSiwsMessage:h((async({address:n})=>{let r=await Aa(e),a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),linkWithSiws:h((async({signature:i,message:s,walletClientType:o,connectorType:l})=>{if(!a)throw Error("User must be authenticated before linking");await Aa(e);let c=await t.linkWithSiws({message:s,signature:i,walletClientType:o,connectorType:l,messageType:"plain"}),d=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(c=await r()??c)||null;return n(c||null),{user:c,linkedAccount:d}}),[a,e,t,r,n])}};function Zs(){let{signTransaction:e}=a(R);return{signTransaction:e}}function Xs(e){let{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkTelegram:y,linkFarcaster:g,linkPasskey:f}=a(R);return Qn("linkAccount",e),{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkFarcaster:g,linkTelegram:y,linkPasskey:f}}function eo(e){let{updateEmail:t,updatePhone:n}=a(R);return Qn("update",e),{updateEmail:t,updatePhone:n}}const to=e=>{let{user:t}=C(),{loginWithCode:n,emailOtpState:r,setEmailOtpState:a,client:i,inProgressAuthFlowRef:s,inProgressLoginOrLinkMethodRef:o}=Ie();return{state:r,sendCode:h((async({newEmailAddress:n})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new Jr(t.email.address,n);i.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(n){a({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:h((async({code:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");s.current="update",o.current="email";let{user:a,linkedAccount:i}=await n(r);return e?.onSuccess?.({user:a,updateMethod:"email",updatedAccount:i}),{user:a}}catch(r){a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},no=()=>{let{connectCoinbaseSmartWallet:e}=Ie();return{connectCoinbaseSmartWallet:e}},ro=()=>{let{connectBaseAccount:e}=Ie();return{connectBaseAccount:e}},ao=()=>{let{baseAccountSdk:e}=Ie();return{baseAccountSdk:e}},io=()=>{let{setModalData:e}=_(),{openModal:t,privy:n,closePrivyModal:r}=Ie(),{user:a}=C();return l((()=>({verify:async({standalone:i=!0}={standalone:!0})=>new Promise(((s,o)=>a?0===a.mfaMethods.length?s():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!0}):Wa.setState({inProgressMfaFlow:void 0}),s()},onFailure:async e=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!1}):Wa.setState({inProgressMfaFlow:void 0}),o(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await n.fetchPrivyRoute(_r,{body:{code:e}})},generateOptions:async()=>As((await n.fetchPrivyRoute(Cr,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),r=await t.startAuthentication({optionsJSON:e});await n.fetchPrivyRoute(Tr,{body:{authenticator_response:Vi(r)}})}}}))),void(i?t("MfaAuthVerifyFlowScreen"):Wa.setState({inProgressMfaFlow:"auth"}))):o(Error("Must be logged in to verify MFA"))))})),[n,e,t,r])},so=()=>{let e=Xe(),{setModalData:t}=_(),{verify:n}=io(),{openModal:r,privy:a,closePrivyModal:i,refreshSessionAndUser:s,setUser:o}=Ie();return l((()=>({enroll:async l=>new Promise(((c,d)=>{t({mfaEnroll:{onSuccess:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!0}),c(e)},onFailure:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(e)},onBack:l?.onBack?async()=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(Error("User canceled MFA enrollment flow.")),l.onBack?.()}:void 0,verify:()=>n({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await a.fetchPrivyRoute(Ir,{body:{}}),enrollTotp:async e=>{await a.fetchPrivyRoute(Er,{body:{code:e}});let t=await s();return o(t),t},unenrollTotp:async()=>{await a.fetchPrivyRoute(br,{body:{}});let e=await s();return o(e),e},enrollPasskey:async e=>{await a.fetchPrivyRoute(Sr,{body:{credential_ids:e,remove_for_login:!0}});let t=await s();return o(t),t}}}),r("MfaAuthEnrollmentFlowScreen")}))})),[a,t,r,i])},oo=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:n,signTypedDataWithCrossAppWallet:r,sendTransactionWithCrossAppWallet:a,signTransactionWithCrossAppWallet:i}=C();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:n,signTypedData:r,sendTransaction:a,signTransaction:i}};function lo(e){let{sendTransaction:t}=a(R);return Qn("sendTransaction",e),{sendTransaction:t}}function co(){let e=Xe(),t=Zn(),{client:n,setUser:r,setAuthenticated:a,setIsNewUser:i,initializeWalletProxy:s}=Ie(),{create:o}=Kn();return{createGuestAccount:async()=>{if(!e.id||!n)throw Error("SDK not yet ready");n.startAuthFlow(new ks(e.id));try{let l=await n.authenticate(),c=l.user,d=l.isNewUser??!1;if(!c)throw new Te("Unable to authenticate guest account");let u=await n.getAccessToken(),h=await s(yt);if(u&&h)try{let t=Fi(c,e.embeddedWallets.ethereum.createOnLogin),n=Li(c,e.embeddedWallets.solana.createOnLogin);t&&n?(c=(await o({chainType:"ethereum",latestUser:c})).user,c=(await o({chainType:"solana",latestUser:c})).user):n?c=(await o({chainType:"solana",latestUser:c})).user:t?c=(await o({chainType:"ethereum",latestUser:c})).user:r(c)}catch(e){r(c),console.warn("Unable to create embedded wallet for guest account")}return i(d),a(!0),t("login","onComplete",{user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),c}catch(e){throw t("login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}}}}function uo(e){let{setWalletRecovery:t}=a(R);return Qn("setWalletRecovery",e),{setWalletRecovery:t}}function ho(e){let{signMessage:t}=a(R);return Qn("signMessage",e),{signMessage:t}}const po=()=>{let{ready:e,wallets:t}=ge(),{user:n}=C(),{rpcConfig:r,chains:a,appId:i}=Ie();return{signAuthorization:h((async(s,o)=>{let l;if(!n)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=o?.address??E(n)?.address??hr,d=t.find((e=>pr(e.address)===pr(c)));if(!d)throw Error("Signing wallet not found.");let u=s.chainId??Number(d.chainId.split(":")[1]);if(0===u)l={chainId:0,address:s.contractAddress,nonce:s.nonce??0};else{let e=a.find((e=>e.id===u));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=wr({account:c,chain:e,transport:mr(fr(e,r,i))});l=await t.prepareAuthorization({...s})}let h=await d.getEthereumProvider(),p=await h.request({method:"secp256k1_sign",params:[bt(l)]});return{...l,...yr(p)}}),[e,t,n,a])}};function wo(e){let{signTypedData:t}=a(R);return Qn("signTypedData",e),{signTypedData:t}}const mo=async({wallet:e})=>{let t=await e.getEthereumProvider();return Nr({address:e.address,sign:async({hash:n})=>{if("privy"!==e.walletClientType)throw new y({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[n]})},signMessage:async({message:n})=>await t.request({method:"personal_sign",params:[n,e.address]}),signTypedData:async n=>await t.request({method:"eth_signTypedData_v4",params:[e.address,n]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})},yo=()=>{let{wallets:e}=ge();return l((()=>({wrapFetchWithPayment:({walletAddress:t,fetch:n,maxValue:r=BigInt(1e5),paymentRequirementsSelector:a=Pr,config:i})=>{let s=t||e[0]?.address;if(!s)throw new Ur("No wallet available for payment");let o=e.find((e=>D(e.address,s)));if(!o)throw new Ur(`Wallet ${s} not found in connected wallets`);return async(e,t)=>{let s=await n(e,t);if(402!==s.status)return s;if(t?.__is402Retry)throw Error("Payment already attempted for this request");let{x402Version:l,accepts:c}=await s.json(),d=a(c,void 0,"exact");if(BigInt(d.maxAmountRequired)>r)throw new Ur("Payment amount exceeds maximum allowed");let u=await mo({wallet:o}),h=await Wr(u,l,d,i),p={...t,headers:{...t?.headers||{},"X-PAYMENT":h,"Access-Control-Expose-Headers":"X-PAYMENT-RESPONSE"},__is402Retry:!0};return await n(e,p)}}})),[e])},go=()=>{let{isModalOpen:e}=a(R);return{isOpen:e}};function fo(e){let{getAccessToken:t}=a(R);return Qn("accessToken",e),{getAccessToken:t}}function vo(e){let{authenticated:t,user:n}=C(),{initLoginWithOAuth:r}=Ie(),a=Zn();return Qn("oAuthAuthorization",e),{reauthorize:e=>Ao(t,n,r,a,e.provider)}}let Ao=async(e,t,n,r,a)=>{if(!e)throw r("linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:a}),new Te("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(a))))throw new Te(`OAuth account of type ${a} not linked to the account.`);await n(a)};function ko(e){let{client:t}=Ie(),[n,r]=o({status:"initial"});return{linkWithCustomJwt:h((async n=>{try{r({status:"initial"}),t.startAuthFlow(new $i(n)),r({status:"loading"});let{user:a}=await t.link();if(!a)throw Error("Error, user not found");let i=a.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return r({status:"done"}),e?.onSuccess?.({user:a,linkMethod:"custom",linkedAccount:i}),{user:a}}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),n}}),[t.startAuthFlow,t.link]),state:n}}const To=e=>{let t=Yi((e=>e.jwtAuthFlowState));return Qn("customAuth",e),{status:t}};function Co({isAuthenticated:e,isLoading:t,...n}){let r=s();c((()=>{t||r.current?.()}),[e,t]);let a=h((e=>(r.current=e,()=>{r.current=void 0})),[]);return Gi({...n,subscribe:a})}function _o(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}=C();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}}const So=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},bo=()=>{let{user:e}=C(),t=Ie(),{signWithUserSigner:n}=Or(),r=async({wallet:r,additional_signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Te("User must be authenticated and have an embedded wallet to delegate actions.");if(!r.id)throw new Te("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new Te("Wallet proxy not initialized.");await f(t.privy,{wallet_id:r.id},n,{additional_signers:a})};return{addSessionSignersInternal:async({address:n,signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Te("User must be authenticated and have an embedded wallet to add a session signer.");let s=t.walletProxy??await t.initializeWalletProxy(15e3);if(!s)throw new Te("Wallet proxy not initialized.");let o=N(e,n);if(!o)throw new Te("Address to add signers too is not associated with current user.");if(P(o)){if(0===a.length)throw new Te("Must specify at least one signer to add.");let e=[...(await g(t.privy,{wallet_id:o.id})).additional_signers,...ye(a)];await r({wallet:o,additional_signers:e})}else{if(o.delegated)return{user:e};if(a.length>0)throw new Te("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let r=gi({address:n,user:e}),l=fi({address:n,user:e});await t.recoverEmbeddedWallet({address:n}),await s.createDelegatedAction({accessToken:i,rootWallet:l,delegatedWallets:[r]})}let l=await t.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}},removeSessionSignersInternal:async({address:n})=>{let a=await t.client.getAccessToken();if(!e||!a)throw new Te("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new Te("Wallet proxy not initialized.");let i=N(e,n);if(!i)throw new Te("Address to remove signers from is not associated with current user.");P(i)?await r({wallet:i,additional_signers:[]}):await t.client.revokeDelegatedWallet();let s=await t.refreshSessionAndUser();if(!s)throw Error("Could not refresh user");return{user:s}}}},Eo=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=bo();return{addSessionSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSessionSigners:async({address:e})=>t({address:e})}},Io=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=bo();return{addSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSigners:async({address:e})=>t({address:e})}},Po=()=>{let{signWithUserSigner:e}=Or();return l((()=>({async generateAuthorizationSignature(t){let{targetAppId:n,...r}=t,{signature:a}=await v((async({message:t})=>e({message:t,targetAppId:n})),r);return{signature:a}}})),[e])},Wo=()=>{let{setUser:e,client:t}=a(Ue),{user:n}=a(R);return{user:n,refreshUser:h((async()=>{let n=await(t?.updateUserAndIdToken());return e(n??null),n}),[t,e])}},Uo=e=>{let t=va(),{initLoginWithTelegram:n,loginWithTelegram:r,telegramAuthState:a,setTelegramAuthState:i}=Ie();return{login:h((async a=>{try{if(t.enabled&&"success"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);await n(t.token,a?.disableSignup);let{user:i,isNewUser:s,loginAccount:o,wasAlreadyAuthenticated:l}=await r({intent:"login"});e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:l,loginMethod:"telegram",loginAccount:o})}catch(a){throw i({status:"error",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[n,r,t]),state:a}},No=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},Oo=Ba;export{$s as $,Fr as A,os as B,ga as C,Dr as D,Ii as E,ls as F,xr as G,Rs as H,Ea as I,ms as J,Ms as K,Ws as L,Os as M,Ds as N,Ls as O,Xa as P,gs as Q,Qr as R,pa as S,js as T,zs as U,qs as V,Qa as W,Hs as X,Vs as Y,Bs as Z,Ks as _,va as a,Gs as a0,Ys as a1,Js as a2,Qs as a3,Zs as a4,Pa as a5,Xs as a6,eo as a7,to as a8,no as a9,No as aA,Oo as aB,Ba as aC,mo as aD,qi as aE,ro as aa,ao as ab,io as ac,so as ad,oo as ae,lo as af,co as ag,uo as ah,ho as ai,po as aj,wo as ak,yo as al,go as am,fo as an,vo as ao,ko as ap,To as aq,Gi as ar,Co as as,_o as at,So as au,Eo as av,Io as aw,Po as ax,Wo as ay,Uo as az,ha as b,Pi as c,Fs as d,ti as e,si as f,ai as g,ri as h,oi as i,ii as j,Li as k,ca as l,Ta as m,ni as n,aa as o,zi as p,ia as q,sa as r,Fi as s,xi as t,xs as u,Ei as v,Ri as w,Ui as x,Vr as y,Oi as z};
