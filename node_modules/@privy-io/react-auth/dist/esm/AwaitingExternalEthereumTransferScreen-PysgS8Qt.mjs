import{jsxs as e,Fragment as t,jsx as i}from"react/jsx-runtime";import r from"@heroicons/react/24/outline/CheckCircleIcon";import{useState as a,useEffect as n}from"react";import{parseEther as o,createWalletClient as s,custom as d,publicActions as c,createPublicClient as l,http as m,encodeFunctionData as u,formatUnits as p}from"viem";import{addToDefaultChains as h}from"@privy-io/js-sdk-core";import{b as f,c as g,R as v}from"./Layouts-BlFm53ED.mjs";import{B as y}from"./ModalHeader-D5psNgrf.mjs";import{C}from"./ScreenHeader-CHmc4-Lu.mjs";import{t as I}from"./FundWalletMethodHeader-CI5afzwL.mjs";import{N as j}from"./index-Dq_xe9dz.mjs";import{u as T,t as w}from"./context-Bu4xmqpC.mjs";import{u as b,a as E,b as S}from"./internal-context-e-Eni5bG.mjs";import{Q as N,D as A}from"./useActiveWallet-RUYo4pXO.mjs";import{a as x}from"./get-is-unified-wallet-CvIzjbW7.mjs";import{u as k}from"./useGetTokenPrice-C1-pGMgN.mjs";import{u as B}from"./useWallets-BkIu5vyx.mjs";import{E as F}from"./transfer-CMPmjPsM.mjs";import{f as M}from"./formatErc20TokenAmount-BuPk9xcy.mjs";import{c as P,a as U,g as W,s as L}from"./ethers-TpFbevgv.mjs";import{O as H}from"./analytics-mkkvFRju.mjs";import{t as $,g as q,c as D,u as R}from"./reservoir-kvLjIrEo.mjs";import{x as _}from"./index-ygZBlWlm.mjs";import{g as Q,B as O}from"./BridgeNetworkSelectionView-T2-4Tr4k.mjs";import{g as V}from"./getErc20Balance-CaKjNAs9.mjs";import{a as G}from"./getPublicClient-A9RSftUZ.mjs";import{T as z}from"./TransferOrBridgeLoadingScreen-BZTN__SI.mjs";import"styled-components";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"tinycolor2";import"ofetch";import"zustand";import"react-device-detect";import"./prepareFundingModalData-CRrWM52E.mjs";import"eventemitter3";import"./events-context-CI0iqAXA.mjs";import"viem/utils";import"./useGetSolPrice-Cfm8o9C5.mjs";import"uuid";import"jose";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"mipd";import"@privy-io/popup";import"./paths-3HW55qZg.mjs";import"./usePrivy-Bn7q4pcu.mjs";import"@scure/base";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"@privy-io/urls";import"js-cookie";import"./frame-CwE9r3cT.mjs";import"@privy-io/routes";import"x402/client";import"@privy-io/api-base";import"viem/accounts";import"./use-sign-with-user-signer-eEm9Olt_.mjs";import"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";import"./Row-C9vrS4Zi.mjs";import"./ErrorMessage-D8VaAP5m.mjs";import"./Value-tcJV9e0L.mjs";import"./LoadingSkeleton-U6-3yFwI.mjs";import"./Subtitle-CV-2yKE4.mjs";import"./Title-BnzYV3Is.mjs";import"@heroicons/react/24/outline/WalletIcon";import"./getChainName-DjpPdUSc.mjs";import"./Chip-D2-wZOHJ.mjs";import"./NetworkIcon-B48ilzF8.mjs";import"@heroicons/react/24/outline/GlobeAltIcon";import"./shared-FM0rljBt.mjs";import"@heroicons/react/24/outline/ChevronDownIcon";import"./styles-CaJCyFB5.mjs";import"./LinkPasskeyScreen-DJveInKu.mjs";import"lucide-react";import"./TodoList-CgrU7uwu.mjs";import"./ScreenLayout-DIdy7nhJ.mjs";import"./Screen-q8npRQhQ.mjs";import"./InjectedWalletIcon-DLcYOGDj.mjs";import"./Address-BGlhcEcA.mjs";const J={component:()=>{let{rpcConfig:J,appId:X,closePrivyModal:Y,createAnalyticsEvent:K}=b(),{navigate:Z,setModalData:ee,data:te}=x(),ie=T(),{wallets:re}=B(),[ae,ne]=a(!1),[oe,se]=a(0n),[de,ce]=a(!1),[le,me]=a(null),[ue,pe]=a(null),[he,fe]=a([]),[ge,ve]=a(0),[ye,Ce]=a(!1),[Ie,je]=a(!1),[Te,we]=a(!1),[be,Ee]=a(!1),[Se,Ne]=a(),[Ae,xe]=a();if(!te?.funding||"ethereum"!==te.funding.chainType)throw Error("Invalid funding data");let{erc20ContractInfo:ke,chain:Be,connectedWallet:Fe}=te.funding,Me=te.funding.address,Pe=te.funding.erc20Address,[Ue,We]=a(te.funding.amount);n((()=>{Pe&&!ke&&me(Error("Unable to fetch token details"))}),[]);let Le=!!Pe&&!!ke,He=Le?BigInt(parseFloat(Ue)*10**ke.decimals):o(Ue),$e=("ethereum"===Fe?.type?Fe:void 0)??re[0],qe=N($e?.walletClientType||"unknown"),De=qe?.name||"wallet",[Re,_e]=a(null);n((()=>{(async()=>{if(!$e)return;let e=await $e.getEthereumProvider();_e(s({account:$e.address,transport:d(e)}).extend(c))})().catch(console.error)}),[$e]);let[Qe,Oe]=a(0n);n((()=>{l({chain:Be,transport:m(G(Be,J,X))}).getBalance({address:Me}).then(Oe).catch(console.error)}),[]);let[Ve,Ge]=a(0n);n((()=>{Le&&V({chain:Be,address:Me,appId:X,rpcConfig:J,erc20Address:Pe}).then((e=>Ge(e.balance))).catch(console.error)}),[]);let{tokenPrice:ze}=k(Be.id),[Je,Xe]=a({to:Me,chain:Be,value:He,data:void 0});n((()=>{(async()=>{let e,t;if(!Re||!$e||ye||Te)return;Ce(!0);let i=l({chain:Je.chain,transport:m(G(Je.chain,J,X))});if(Le&&!Je.data)return await i.simulateContract({address:Pe,chain:Je.chain,abi:F,functionName:"transfer",args:[Me,He],account:$e.address}).catch((e=>{console.warn("Simulated token transfer failed with error, fetching bridge options.",e)}))?(Ce(!1),void Xe({to:Pe,chain:Je.chain,data:u({abi:F,functionName:"transfer",args:[Me,He]}),value:"0x0"})):(Ce(!1),void ce(!0));try{e=await i.prepareTransactionRequest({account:$e.address,to:Je.to,chain:Je.chain,data:Je.data,value:BigInt(Je.value??0)})}catch(e){if(console.error(e),he.length>1)pe(e.shortMessage??"Something went wrong");else if(Ie&&0===he.length)return void me(new E(`Wallet ${A($e.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE))}if(!e)return Ce(!1),void ce(!0);Ce(!1),we(!0),ne(!0),se(e.gas);try{await Re.switchChain({id:Je.chain.id})}catch(e){await Re.addChain({chain:Je.chain}),await Re.switchChain({id:Je.chain.id})}try{t=await Re.sendTransaction(e)}catch(e){if(console.error(e),"TransactionExecutionError"===e.name)if(he.length<1){let t=e.shortMessage;(e.shortMessage.includes("rejected the request")||e.details.includes("rejected the request"))&&(t="User rejected the request."),me(new E(t,void 0,S.TRANSACTION_FAILURE))}else pe(e.shortMessage??"Something went wrong")}if(t)return await Re.waitForTransactionReceipt({hash:t}),we(!1),Ie?(Ne(t),void xe("pending")):(Ee(!0),ee(_(te,"completed",t,$e?.walletClientType,Le,ke,Be)),void K({eventName:H,payload:{provider:"external",status:"success",txHash:t,address:$e.address,chainId:Je.chain.id,chainType:"ethereum",value:Je.value?p(BigInt(Je.value),ke?.decimals??18):void 0,token:ke?.symbol??Pe??"ETH",destinationAddress:Me,destinationChainId:Be.id,destinationChainType:"ethereum",destinationValue:He?p(He,ke?.decimals??18):void 0,destinationToken:ke?.symbol??Pe??Be.nativeCurrency.name}}));we(!1)})().catch(console.error)}),[Re,Je]),n((()=>{(async()=>{if(!de||!Re||!$e)return;let e=h(ie.chains).filter((e=>e.id!==Be.id&&!!e.testnet==!!Be.testnet));Le&&e.unshift(Be);let t=await Q({chains:e,address:$e.address,appId:X,rpcConfig:J,includeUsdc:te.funding?.isUSDC}),i=Le?t.filter((e=>e.balance>0n)):t.filter((e=>e.balance>He)),r=Le&&t.every((e=>0n===e.balance));if(i.length<1)return void me(new E(r?`Wallet ${A($e.address)} doesn't have enough funds to cover gas fees. Top up your wallet and try again.`:`Wallet ${A($e.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE));i.sort(((e,t)=>Number(Le?(t.erc20Balance??0n)-(e.erc20Balance??0n):t.balance-e.balance)));let a=i.flatMap((e=>{let t=[{...e,isErc20Quote:!1,isTestnet:!!Be.testnet,input:$({appId:X,amount:He.toString(),user:$e.address,recipient:Me,destinationChainId:Be.id,destinationCurrency:Pe,originChainId:e.chain.id})}];return Le&&Pe&&(e.erc20Balance??0n)>=He&&t.push({...e,isErc20Quote:!0,isTestnet:!!Be.testnet,input:$({appId:X,amount:He.toString(),user:$e.address,recipient:Me,destinationChainId:Be.id,destinationCurrency:Pe,originChainId:e.chain.id,originCurrency:e.erc20Address})}),t})),n=(await Promise.allSettled(a.map((async e=>({...e,quote:await q(e)}))))).filter((e=>"fulfilled"===e.status)).map((e=>e.value));if(n.length<1)return void me(new E(`Wallet ${A($e.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE));let o=n.map((e=>({bridgeTx:D(e.quote),balance:e.balance,chain:e.chain,erc20Balance:e.erc20Balance,isErc20Quote:e.isErc20Quote}))).filter((e=>!!e.bridgeTx));if(o.length>1)return void fe(o);let s=o[0];s?(je(!0),Xe({data:s.bridgeTx.data,to:s.bridgeTx.to,value:s.bridgeTx.value,chain:s.chain})):me(new E(`Wallet ${A($e.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE))})().catch(console.error)}),[de]),R({transactionHash:Se,isTestnet:!!Be.testnet,bridgingStatus:Ae,setBridgingStatus:xe,onSuccess({transactionHash:e}){je(!1),Ee(!0),ee(_(te,"completed",e,$e?.walletClientType,Le,ke,Be)),K({eventName:H,payload:{provider:"external",status:"success",txHash:e,address:$e?.address,chainId:Je.chain.id,chainType:"ethereum",value:Je.value?p(BigInt(Je.value),ke?.decimals??18):void 0,token:ke?.symbol??Pe??"ETH",destinationAddress:Me,destinationChainId:Be.id,destinationChainType:"ethereum",destinationValue:He?p(He,ke?.decimals??18):void 0,destinationToken:ke?.symbol??Pe??Be.nativeCurrency.name}})},onFailure({error:e}){je(!1),me(e)}}),n((()=>{le&&(ee({funding:te?.funding,solanaFundingData:te?.solanaFundingData,sendTransaction:te?.sendTransaction,errorModalData:{error:le,previousScreen:"TransferFromWalletScreen"}}),Z("ErrorScreen",!1))}),[le]);let Ye=!Le&&ze?P(Ue??"0",ze):void 0,Ke=Le?oe:L([oe,He]),Ze=Ke&&ze?U(Ke,ze):void 0,et=Ke?W(Ke,te?.funding?.erc20Address?te?.funding?.erc20ContractInfo?.symbol||"ETH":te?.funding?.chain.nativeCurrency.symbol||"ETH"):void 0,tt=oe&&ze?U(oe,ze):void 0,it=oe?W(oe,Be?.nativeCurrency?.symbol||"ETH"):void 0;if(n((()=>{if(!be)return;let e=setTimeout(Y,w);return()=>clearTimeout(e)}),[be]),be/*#__PURE__*/)return e(t,{children:[/*#__PURE__*/i(I,{}),/*#__PURE__*/i(f,{}),/*#__PURE__*/e(g,{children:[/*#__PURE__*/i(r,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),/*#__PURE__*/i(C,{title:"Success!",description:`Youâ€™ve successfully added ${Ue} ${Le?ke.symbol:Be.nativeCurrency.symbol} to your ${ie.name} wallet. It may take a minute before the funds are available to use.`})]}),/*#__PURE__*/i(v,{}),/*#__PURE__*/i(y,{})]});let rt=Le?`${M({amount:Ve,decimals:ke.decimals})}  ${ke.symbol}`:W(Qe,Be.nativeCurrency.symbol,3,!0),at=he[ge];return he.length>1&&at?/*#__PURE__*/i(O,{displayName:De,configuredFundingChain:Be,erc20ContractInfo:ke,formattedBalance:rt,fundingAmount:Ue,fundingCurrency:Le?ke.symbol:Be.nativeCurrency.symbol,fundingAmountInUsd:Ye,options:he,selectedOption:at,isPreparing:ye,isSubmitting:Te,addressToFund:Me,fundingWalletAddress:$e?.address||"",errorMessage:ue,onSubmit:()=>{te.funding?.amount!==Ue?async function(){if($e&&at)try{let e=await q({isTestnet:!!Be.testnet,input:$({appId:X,amount:He.toString(),user:$e.address,recipient:Me,destinationChainId:Be.id,destinationCurrency:Pe,originChainId:at.chain.id})}),t=D(e);if(!t)throw Error("Invalid transaction request");je(!0),Xe({data:t.data,to:t.to,value:t.value,chain:at.chain})}catch(e){console.error(e),me(new E("Unable to fetch quotes for bridging",e,S.INSUFFICIENT_BALANCE))}}().catch(console.error):Xe({to:at.bridgeTx.to,data:at.bridgeTx.data,value:at.bridgeTx.value,chain:at.chain})},onSelect:e=>{e!==ge&&(pe(null),ve(e))},onAmountChange:We}):ae&&oe&&$e&&te?.funding?/*#__PURE__*/i(z,{walletClientType:$e?.walletClientType||"unknown",displayName:De,addressToFund:Me,isBridging:Ie,isErc20Flow:Le,totalPriceInUsd:Ze,totalPriceInNativeCurrency:et,gasPriceInUsd:tt,gasPriceInNativeCurrency:it,chainId:Be.id,chainName:Be.name}):
/*#__PURE__*/e(t,{children:[/*#__PURE__*/i(I,{}),/*#__PURE__*/i(j,{}),/*#__PURE__*/i("div",{style:{marginTop:"1rem"}}),/*#__PURE__*/i(y,{})]})}};export{J as AwaitingExternalEthereumTransferScreen,J as default};
