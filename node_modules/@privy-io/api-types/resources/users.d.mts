import { APIResource } from "../core/resource.mjs";
import * as UsersAPI from "./users.mjs";
import * as ClientAuthAPI from "./client-auth.mjs";
import * as WalletsAPI from "./wallets/wallets.mjs";
import { APIPromise } from "../core/api-promise.mjs";
import { Cursor, type CursorParams, PagePromise } from "../core/pagination.mjs";
import { RequestOptions } from "../internal/request-options.mjs";
export declare class Users extends APIResource {
    /**
     * Create a new user with linked accounts. Optionally pre-generate embedded wallets
     * for the user.
     *
     * @example
     * ```ts
     * const user = await client.users.create({
     *   linked_accounts: [
     *     { address: 'tom.bombadill@privy.io', type: 'email' },
     *   ],
     * });
     * ```
     */
    create(body: UserCreateParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Get all users in your app.
     *
     * @example
     * ```ts
     * // Automatically fetches more pages as needed.
     * for await (const user of client.users.list()) {
     *   // ...
     * }
     * ```
     */
    list(query?: UserListParams | null | undefined, options?: RequestOptions): PagePromise<UsersCursor, User>;
    /**
     * Delete a user by user ID.
     *
     * @example
     * ```ts
     * await client.users.delete('user_id');
     * ```
     */
    delete(userID: string, options?: RequestOptions): APIPromise<void>;
    /**
     * Get a user by user ID.
     *
     * @example
     * ```ts
     * const user = await client.users._get('user_id');
     * ```
     */
    _get(userID: string, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their custom auth ID.
     *
     * @example
     * ```ts
     * const user = await client.users.getByCustomAuthID({
     *   custom_user_id: 'custom_user_id',
     * });
     * ```
     */
    getByCustomAuthID(body: UserGetByCustomAuthIDParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Discord username.
     *
     * @example
     * ```ts
     * const user = await client.users.getByDiscordUsername({
     *   username: 'username',
     * });
     * ```
     */
    getByDiscordUsername(body: UserGetByDiscordUsernameParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their email address.
     *
     * @example
     * ```ts
     * const user = await client.users.getByEmailAddress({
     *   address: 'dev@stainless.com',
     * });
     * ```
     */
    getByEmailAddress(body: UserGetByEmailAddressParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Farcaster ID.
     *
     * @example
     * ```ts
     * const user = await client.users.getByFarcasterID({
     *   fid: 0,
     * });
     * ```
     */
    getByFarcasterID(body: UserGetByFarcasterIDParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Github username.
     *
     * @example
     * ```ts
     * const user = await client.users.getByGitHubUsername({
     *   username: 'username',
     * });
     * ```
     */
    getByGitHubUsername(body: UserGetByGitHubUsernameParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their phone number.
     *
     * @example
     * ```ts
     * const user = await client.users.getByPhoneNumber({
     *   number: 'number',
     * });
     * ```
     */
    getByPhoneNumber(body: UserGetByPhoneNumberParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their smart wallet address.
     *
     * @example
     * ```ts
     * const user = await client.users.getBySmartWalletAddress({
     *   address: 'address',
     * });
     * ```
     */
    getBySmartWalletAddress(body: UserGetBySmartWalletAddressParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Telegram user ID.
     *
     * @example
     * ```ts
     * const user = await client.users.getByTelegramUserID({
     *   telegram_user_id: 'telegram_user_id',
     * });
     * ```
     */
    getByTelegramUserID(body: UserGetByTelegramUserIDParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Telegram username.
     *
     * @example
     * ```ts
     * const user = await client.users.getByTelegramUsername({
     *   username: 'username',
     * });
     * ```
     */
    getByTelegramUsername(body: UserGetByTelegramUsernameParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Twitter subject.
     *
     * @example
     * ```ts
     * const user = await client.users.getByTwitterSubject({
     *   subject: 'subject',
     * });
     * ```
     */
    getByTwitterSubject(body: UserGetByTwitterSubjectParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their Twitter username.
     *
     * @example
     * ```ts
     * const user = await client.users.getByTwitterUsername({
     *   username: 'username',
     * });
     * ```
     */
    getByTwitterUsername(body: UserGetByTwitterUsernameParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Looks up a user by their wallet address.
     *
     * @example
     * ```ts
     * const user = await client.users.getByWalletAddress({
     *   address: 'address',
     * });
     * ```
     */
    getByWalletAddress(body: UserGetByWalletAddressParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Creates an embedded wallet for an existing user.
     *
     * @example
     * ```ts
     * const user = await client.users.pregenerateWallets(
     *   'user_id',
     *   { wallets: [{ chain_type: 'ethereum' }] },
     * );
     * ```
     */
    pregenerateWallets(userID: string, body: UserPregenerateWalletsParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Search users by search term, emails, phone numbers, or wallet addresses.
     *
     * @example
     * ```ts
     * const user = await client.users.search({
     *   searchTerm: 'searchTerm',
     * });
     * ```
     */
    search(body: UserSearchParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Adds custom metadata to a user by user ID.
     *
     * @example
     * ```ts
     * const user = await client.users.setCustomMetadata(
     *   'user_id',
     *   { custom_metadata: { key: 'value' } },
     * );
     * ```
     */
    setCustomMetadata(userID: string, body: UserSetCustomMetadataParams, options?: RequestOptions): APIPromise<User>;
    /**
     * Unlinks a user linked account.
     *
     * @example
     * ```ts
     * const user = await client.users.unlinkLinkedAccount(
     *   'user_id',
     *   { handle: 'test@test.com', type: 'email' },
     * );
     * ```
     */
    unlinkLinkedAccount(userID: string, body: UserUnlinkLinkedAccountParams, options?: RequestOptions): APIPromise<User>;
}
export type UsersCursor = Cursor<User>;
/**
 * The authenticated user.
 */
export interface AuthenticatedUser {
    token: string | null;
    privy_access_token: string | null;
    refresh_token: string | null;
    /**
     * Instructs the client on how to handle tokens received
     */
    session_update_action: 'set' | 'ignore' | 'clear';
    user: User;
    identity_token?: string;
    is_new_user?: boolean;
    /**
     * OAuth tokens associated with the user.
     */
    oauth_tokens?: AuthenticatedUser.OAuthTokens;
}
export declare namespace AuthenticatedUser {
    /**
     * OAuth tokens associated with the user.
     */
    interface OAuthTokens {
        access_token: string;
        provider: string;
        access_token_expires_in_seconds?: number;
        refresh_token?: string;
        refresh_token_expires_in_seconds?: number;
        scopes?: Array<string>;
    }
}
/**
 * A linked account for the user.
 */
export type LinkedAccount = LinkedAccount.LinkedAccountEmail | LinkedAccount.LinkedAccountPhone | LinkedAccount.LinkedAccountCrossApp | LinkedAccount.LinkedAccountAuthorizationKey | LinkedAccount.LinkedAccountCustomJwt | LinkedAccount.LinkedAccountAppleOAuth | LinkedAccount.LinkedAccountDiscordOAuth | LinkedAccount.LinkedAccountGitHubOAuth | LinkedAccount.LinkedAccountGoogleOAuth | LinkedAccount.LinkedAccountInstagramOAuth | LinkedAccount.LinkedAccountLinkedInOAuth | LinkedAccount.LinkedAccountSpotifyOAuth | LinkedAccount.LinkedAccountTiktokOAuth | LinkedAccount.LinkedAccountLineOAuth | LinkedAccount.LinkedAccountTwitchOAuth | LinkedAccount.LinkedAccountTwitterOAuth | LinkedAccountSmartWallet | LinkedAccount.LinkedAccountPasskey | LinkedAccount.LinkedAccountFarcaster | LinkedAccount.LinkedAccountTelegram | LinkedAccount.LinkedAccountEthereum | LinkedAccountEthereumEmbeddedWallet | LinkedAccount.LinkedAccountSolana | LinkedAccountSolanaEmbeddedWallet | LinkedAccountBitcoinSegwitEmbeddedWallet | LinkedAccountBitcoinTaprootEmbeddedWallet | LinkedAccountCurveSigningEmbeddedWallet | LinkedAccount.LinkedAccountCustomOAuth;
export declare namespace LinkedAccount {
    interface LinkedAccountEmail {
        address: string;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        type: 'email';
        verified_at: number;
    }
    interface LinkedAccountPhone {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        phoneNumber: string;
        type: 'phone';
        verified_at: number;
        number?: string;
    }
    interface LinkedAccountCrossApp {
        embedded_wallets: Array<LinkedAccountCrossApp.EmbeddedWallet>;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        provider_app_id: string;
        smart_wallets: Array<LinkedAccountCrossApp.SmartWallet>;
        subject: string;
        type: 'cross_app';
        verified_at: number;
    }
    namespace LinkedAccountCrossApp {
        interface EmbeddedWallet {
            address: string;
        }
        interface SmartWallet {
            address: string;
        }
    }
    interface LinkedAccountAuthorizationKey {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        public_key: string;
        type: 'authorization_key';
        verified_at: number;
    }
    interface LinkedAccountCustomJwt {
        custom_user_id: string;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        type: 'custom_auth';
        verified_at: number;
    }
    interface LinkedAccountAppleOAuth {
        email: string | null;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        subject: string;
        type: 'apple_oauth';
        verified_at: number;
    }
    interface LinkedAccountDiscordOAuth {
        email: string | null;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        subject: string;
        type: 'discord_oauth';
        username: string | null;
        verified_at: number;
    }
    interface LinkedAccountGitHubOAuth {
        email: string | null;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        name: string | null;
        subject: string;
        type: 'github_oauth';
        username: string | null;
        verified_at: number;
    }
    interface LinkedAccountGoogleOAuth {
        email: string;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        name: string | null;
        subject: string;
        type: 'google_oauth';
        verified_at: number;
    }
    interface LinkedAccountInstagramOAuth {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        subject: string;
        type: 'instagram_oauth';
        username: string | null;
        verified_at: number;
    }
    interface LinkedAccountLinkedInOAuth {
        email: string | null;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        subject: string;
        type: 'linkedin_oauth';
        verified_at: number;
        name?: string;
        vanity_name?: string;
    }
    interface LinkedAccountSpotifyOAuth {
        email: string | null;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        name: string | null;
        subject: string;
        type: 'spotify_oauth';
        verified_at: number;
    }
    interface LinkedAccountTiktokOAuth {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        name: string | null;
        subject: string;
        type: 'tiktok_oauth';
        username: string | null;
        verified_at: number;
    }
    interface LinkedAccountLineOAuth {
        email: string | null;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        name: string | null;
        profile_picture_url: string | null;
        subject: string;
        type: 'line_oauth';
        verified_at: number;
    }
    interface LinkedAccountTwitchOAuth {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        subject: string;
        type: 'twitch_oauth';
        username: string | null;
        verified_at: number;
    }
    interface LinkedAccountTwitterOAuth {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        name: string | null;
        profile_picture_url: string | null;
        subject: string;
        type: 'twitter_oauth';
        username: string | null;
        verified_at: number;
    }
    interface LinkedAccountPasskey {
        credential_id: string;
        enrolled_in_mfa: boolean;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        type: 'passkey';
        verified_at: number;
        authenticator_name?: string;
        created_with_browser?: string;
        created_with_device?: string;
        created_with_os?: string;
        public_key?: string;
    }
    interface LinkedAccountFarcaster {
        fid: number;
        first_verified_at: number | null;
        latest_verified_at: number | null;
        owner_address: string;
        type: 'farcaster';
        verified_at: number;
        bio?: string;
        display_name?: string;
        homepage_url?: string;
        profile_picture?: string;
        profile_picture_url?: string;
        signer_public_key?: string;
        username?: string;
    }
    interface LinkedAccountTelegram {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        telegram_user_id: string;
        telegramUserId: string;
        type: 'telegram';
        verified_at: number;
        first_name?: string | null;
        firstName?: string | null;
        last_name?: string | null;
        photo_url?: string | null;
        username?: string | null;
    }
    interface LinkedAccountEthereum {
        address: string;
        chain_type: 'ethereum';
        first_verified_at: number | null;
        latest_verified_at: number | null;
        type: 'wallet';
        verified_at: number;
        wallet_client: 'unknown';
        chain_id?: string;
        connector_type?: string;
        wallet_client_type?: string;
    }
    interface LinkedAccountSolana {
        address: string;
        chain_type: 'solana';
        first_verified_at: number | null;
        latest_verified_at: number | null;
        type: 'wallet';
        verified_at: number;
        wallet_client: 'unknown';
        connector_type?: string;
        wallet_client_type?: string;
    }
    interface LinkedAccountCustomOAuth {
        first_verified_at: number | null;
        latest_verified_at: number | null;
        subject: string;
        /**
         * The ID of a custom OAuth provider, set up for this app. Must start with
         * "custom:".
         */
        type: ClientAuthAPI.CustomOAuthProviderID;
        verified_at: number;
        email?: string;
        name?: string;
        profile_picture_url?: string;
        username?: string;
    }
}
export interface User {
    id: string;
    /**
     * Unix timestamp of when the user was created in milliseconds.
     */
    created_at: number;
    /**
     * Indicates if the user has accepted the terms of service.
     */
    has_accepted_terms: boolean;
    /**
     * Indicates if the user is a guest account user.
     */
    is_guest: boolean;
    linked_accounts: Array<LinkedAccount>;
    mfa_methods: Array<User.PasskeyMfaMethod | User.SMSMfaMethod | User.TotpMfaMethod>;
    /**
     * Custom metadata associated with the user.
     */
    custom_metadata?: {
        [key: string]: string | number | boolean;
    };
}
export declare namespace User {
    interface PasskeyMfaMethod {
        type: 'passkey';
        verified_at: number;
    }
    interface SMSMfaMethod {
        type: 'sms';
        verified_at: number;
    }
    interface TotpMfaMethod {
        type: 'totp';
        verified_at: number;
    }
}
/**
 * The user object along their identity token.
 */
export interface UserWithIdentityToken {
    user: User;
    identity_token?: string;
}
export interface LinkedAccountEthereumEmbeddedWallet {
    id: string | null;
    address: string;
    chain_id: string;
    chain_type: 'ethereum';
    connector_type: 'embedded';
    delegated: boolean;
    first_verified_at: number | null;
    imported: boolean;
    latest_verified_at: number | null;
    recovery_method: 'privy' | 'user-passcode' | 'google-drive' | 'icloud' | 'recovery-encryption-key' | 'privy-v2';
    type: 'wallet';
    verified_at: number;
    wallet_client: 'privy';
    wallet_client_type: 'privy';
    wallet_index: number;
}
export interface LinkedAccountSolanaEmbeddedWallet {
    id: string | null;
    address: string;
    chain_id: string;
    chain_type: 'solana';
    connector_type: 'embedded';
    delegated: boolean;
    first_verified_at: number | null;
    imported: boolean;
    latest_verified_at: number | null;
    public_key: string;
    recovery_method: 'privy' | 'user-passcode' | 'google-drive' | 'icloud' | 'recovery-encryption-key' | 'privy-v2';
    type: 'wallet';
    verified_at: number;
    wallet_client: 'privy';
    wallet_client_type: 'privy';
    wallet_index: number;
}
export interface LinkedAccountBitcoinSegwitEmbeddedWallet {
    id: string | null;
    address: string;
    chain_id: string;
    chain_type: 'bitcoin-segwit';
    connector_type: 'embedded';
    delegated: boolean;
    first_verified_at: number | null;
    imported: boolean;
    latest_verified_at: number | null;
    public_key: string;
    recovery_method: 'privy' | 'user-passcode' | 'google-drive' | 'icloud' | 'recovery-encryption-key' | 'privy-v2';
    type: 'wallet';
    verified_at: number;
    wallet_client: 'privy';
    wallet_client_type: 'privy';
    wallet_index: number;
}
export interface LinkedAccountBitcoinTaprootEmbeddedWallet {
    id: string | null;
    address: string;
    chain_id: string;
    chain_type: 'bitcoin-taproot';
    connector_type: 'embedded';
    delegated: boolean;
    first_verified_at: number | null;
    imported: boolean;
    latest_verified_at: number | null;
    public_key: string;
    recovery_method: 'privy' | 'user-passcode' | 'google-drive' | 'icloud' | 'recovery-encryption-key' | 'privy-v2';
    type: 'wallet';
    verified_at: number;
    wallet_client: 'privy';
    wallet_client_type: 'privy';
    wallet_index: number;
}
export interface LinkedAccountCurveSigningEmbeddedWallet {
    id: string | null;
    address: string;
    chain_id: string;
    /**
     * The wallet chain types that support curve-based signing.
     */
    chain_type: WalletsAPI.CurveSigningChainType;
    connector_type: 'embedded';
    delegated: boolean;
    first_verified_at: number | null;
    imported: boolean;
    latest_verified_at: number | null;
    public_key: string;
    recovery_method: 'privy' | 'user-passcode' | 'google-drive' | 'icloud' | 'recovery-encryption-key' | 'privy-v2';
    type: 'wallet';
    verified_at: number;
    wallet_client: 'privy';
    wallet_client_type: 'privy';
    wallet_index: number;
}
export type LinkedAccountEmbeddedWallet = LinkedAccountEthereumEmbeddedWallet | LinkedAccountSolanaEmbeddedWallet | LinkedAccountBitcoinSegwitEmbeddedWallet | LinkedAccountBitcoinTaprootEmbeddedWallet | LinkedAccountCurveSigningEmbeddedWallet;
export type LinkedAccountEmbeddedWalletWithID = LinkedAccountEmbeddedWalletWithID.LinkedAccountEthereumEmbeddedWallet | LinkedAccountEmbeddedWalletWithID.LinkedAccountSolanaEmbeddedWallet | LinkedAccountEmbeddedWalletWithID.LinkedAccountBitcoinSegwitEmbeddedWallet | LinkedAccountEmbeddedWalletWithID.LinkedAccountBitcoinTaprootEmbeddedWallet | LinkedAccountEmbeddedWalletWithID.LinkedAccountCurveSigningEmbeddedWallet;
export declare namespace LinkedAccountEmbeddedWalletWithID {
    interface LinkedAccountEthereumEmbeddedWallet extends Omit<UsersAPI.LinkedAccountEthereumEmbeddedWallet, 'id' | 'recovery_method'> {
        id: string;
        recovery_method: 'privy-v2';
    }
    interface LinkedAccountSolanaEmbeddedWallet extends Omit<UsersAPI.LinkedAccountSolanaEmbeddedWallet, 'id' | 'recovery_method'> {
        id: string;
        recovery_method: 'privy-v2';
    }
    interface LinkedAccountBitcoinSegwitEmbeddedWallet extends Omit<UsersAPI.LinkedAccountBitcoinSegwitEmbeddedWallet, 'id' | 'recovery_method'> {
        id: string;
        recovery_method: 'privy-v2';
    }
    interface LinkedAccountBitcoinTaprootEmbeddedWallet extends Omit<UsersAPI.LinkedAccountBitcoinTaprootEmbeddedWallet, 'id' | 'recovery_method'> {
        id: string;
        recovery_method: 'privy-v2';
    }
    interface LinkedAccountCurveSigningEmbeddedWallet extends Omit<UsersAPI.LinkedAccountCurveSigningEmbeddedWallet, 'id' | 'recovery_method'> {
        id: string;
        recovery_method: 'privy-v2';
    }
}
export type SmartWalletType = 'safe' | 'kernel' | 'light_account' | 'biconomy' | 'coinbase_smart_wallet' | 'thirdweb';
export interface LinkedAccountSmartWallet {
    address: string;
    first_verified_at: number | null;
    latest_verified_at: number | null;
    smart_wallet_type: SmartWalletType;
    type: 'smart_wallet';
    verified_at: number;
    smart_wallet_version?: string;
}
export interface UserCreateParams {
    linked_accounts: Array<UserCreateParams.LinkedAccountWalletInput | UserCreateParams.LinkedAccountEmailInput | UserCreateParams.LinkedAccountPhoneInput | UserCreateParams.LinkedAccountGoogleInput | UserCreateParams.LinkedAccountTwitterInput | UserCreateParams.LinkedAccountDiscordInput | UserCreateParams.LinkedAccountGitHubInput | UserCreateParams.LinkedAccountSpotifyInput | UserCreateParams.LinkedAccountInstagramInput | UserCreateParams.LinkedAccountTiktokInput | UserCreateParams.LinkedAccountLineInput | UserCreateParams.LinkedAccountTwitchInput | UserCreateParams.LinkedAccountAppleInput | UserCreateParams.LinkedAccountLinkedInInput | UserCreateParams.LinkedAccountFarcasterInput | UserCreateParams.LinkedAccountTelegramInput | UserCreateParams.LinkedAccountCustomJwtInput>;
    /**
     * Custom metadata associated with the user.
     */
    custom_metadata?: {
        [key: string]: string | number | boolean;
    };
    /**
     * Wallets to create for the user.
     */
    wallets?: Array<UserCreateParams.Wallet>;
}
export declare namespace UserCreateParams {
    interface LinkedAccountWalletInput {
        address: string;
        chain_type: 'ethereum' | 'solana';
        type: 'wallet';
    }
    interface LinkedAccountEmailInput {
        address: string;
        type: 'email';
    }
    interface LinkedAccountPhoneInput {
        number: string;
        type: 'phone';
    }
    interface LinkedAccountGoogleInput {
        email: string;
        name: string;
        subject: string;
        type: 'google_oauth';
    }
    interface LinkedAccountTwitterInput {
        name: string;
        subject: string;
        type: 'twitter_oauth';
        username: string;
        profile_picture_url?: string;
    }
    interface LinkedAccountDiscordInput {
        subject: string;
        type: 'discord_oauth';
        username: string;
        email?: string;
    }
    interface LinkedAccountGitHubInput {
        subject: string;
        type: 'github_oauth';
        username: string;
        email?: string;
        name?: string;
    }
    interface LinkedAccountSpotifyInput {
        subject: string;
        type: 'spotify_oauth';
        email?: string;
        name?: string;
    }
    interface LinkedAccountInstagramInput {
        subject: string;
        type: 'instagram_oauth';
        username: string;
    }
    interface LinkedAccountTiktokInput {
        name: string | null;
        subject: string;
        type: 'tiktok_oauth';
        username: string;
    }
    interface LinkedAccountLineInput {
        subject: string;
        type: 'line_oauth';
        email?: string;
        name?: string;
        profile_picture_url?: string;
    }
    interface LinkedAccountTwitchInput {
        subject: string;
        type: 'twitch_oauth';
        username?: string;
    }
    interface LinkedAccountAppleInput {
        subject: string;
        type: 'apple_oauth';
        email?: string;
    }
    interface LinkedAccountLinkedInInput {
        subject: string;
        type: 'linkedin_oauth';
        email?: string;
        name?: string;
        vanityName?: string;
    }
    interface LinkedAccountFarcasterInput {
        fid: number;
        owner_address: string;
        type: 'farcaster';
        bio?: string;
        display_name?: string;
        homepage_url?: string;
        profile_picture_url?: string;
        username?: string;
    }
    interface LinkedAccountTelegramInput {
        telegram_user_id: string;
        type: 'telegram';
        first_name?: string;
        last_name?: string;
        photo_url?: string;
        username?: string;
    }
    interface LinkedAccountCustomJwtInput {
        custom_user_id: string;
        type: 'custom_auth';
    }
    interface Wallet {
        /**
         * The wallet chain types.
         */
        chain_type: WalletsAPI.WalletChainType;
        /**
         * Additional signers for the wallet.
         */
        additional_signers?: Array<Wallet.AdditionalSigner>;
        /**
         * Create a smart wallet with this wallet as the signer. Only supported for wallets
         * with `chain_type: "ethereum"`.
         */
        create_smart_wallet?: boolean;
        /**
         * Policy IDs to enforce on the wallet. Currently, only one policy is supported per
         * wallet.
         */
        policy_ids?: Array<string>;
    }
    namespace Wallet {
        interface AdditionalSigner {
            /**
             * The key quorum ID for the signer.
             */
            signer_id: string;
            /**
             * The array of policy IDs that will be applied to wallet requests. If specified,
             * this will override the base policy IDs set on the wallet. Currently, only one
             * policy is supported per signer.
             */
            override_policy_ids?: Array<string>;
        }
    }
}
export interface UserListParams extends CursorParams {
}
export interface UserGetByCustomAuthIDParams {
    custom_user_id: string;
}
export interface UserGetByDiscordUsernameParams {
    username: string;
}
export interface UserGetByEmailAddressParams {
    address: string;
}
export interface UserGetByFarcasterIDParams {
    fid: number;
}
export interface UserGetByGitHubUsernameParams {
    username: string;
}
export interface UserGetByPhoneNumberParams {
    number: string;
}
export interface UserGetBySmartWalletAddressParams {
    address: string;
}
export interface UserGetByTelegramUserIDParams {
    telegram_user_id: string;
}
export interface UserGetByTelegramUsernameParams {
    username: string;
}
export interface UserGetByTwitterSubjectParams {
    subject: string;
}
export interface UserGetByTwitterUsernameParams {
    username: string;
}
export interface UserGetByWalletAddressParams {
    address: string;
}
export interface UserPregenerateWalletsParams {
    wallets: Array<UserPregenerateWalletsParams.Wallet>;
}
export declare namespace UserPregenerateWalletsParams {
    interface Wallet {
        /**
         * The wallet chain types.
         */
        chain_type: WalletsAPI.WalletChainType;
        additional_signers?: Array<Wallet.AdditionalSigner>;
        create_smart_wallet?: boolean;
        policy_ids?: Array<string>;
    }
    namespace Wallet {
        interface AdditionalSigner {
            signer_id: string;
            override_policy_ids?: Array<string>;
        }
    }
}
export type UserSearchParams = UserSearchParams.Variant0 | UserSearchParams.Variant1;
export declare namespace UserSearchParams {
    interface Variant0 {
        searchTerm: string;
    }
    interface Variant1 {
        emails: Array<string>;
        phoneNumbers: Array<string>;
        walletAddresses: Array<string>;
    }
}
export interface UserSetCustomMetadataParams {
    /**
     * Custom metadata associated with the user.
     */
    custom_metadata: {
        [key: string]: string | number | boolean;
    };
}
export interface UserUnlinkLinkedAccountParams {
    handle: string;
    type: 'email' | 'wallet' | 'smart_wallet' | 'farcaster' | 'passkey' | 'phone' | 'google_oauth' | 'discord_oauth' | 'twitter_oauth' | 'github_oauth' | 'linkedin_oauth' | 'apple_oauth' | 'spotify_oauth' | 'instagram_oauth' | 'tiktok_oauth' | 'line_oauth' | 'twitch_oauth' | 'custom_auth' | 'telegram' | 'cross_app' | 'guest' | (string & {});
    provider?: string;
}
export declare namespace Users {
    export { type AuthenticatedUser as AuthenticatedUser, type LinkedAccount as LinkedAccount, type User as User, type UserWithIdentityToken as UserWithIdentityToken, type LinkedAccountEthereumEmbeddedWallet as LinkedAccountEthereumEmbeddedWallet, type LinkedAccountSolanaEmbeddedWallet as LinkedAccountSolanaEmbeddedWallet, type LinkedAccountBitcoinSegwitEmbeddedWallet as LinkedAccountBitcoinSegwitEmbeddedWallet, type LinkedAccountBitcoinTaprootEmbeddedWallet as LinkedAccountBitcoinTaprootEmbeddedWallet, type LinkedAccountCurveSigningEmbeddedWallet as LinkedAccountCurveSigningEmbeddedWallet, type LinkedAccountEmbeddedWallet as LinkedAccountEmbeddedWallet, type LinkedAccountEmbeddedWalletWithID as LinkedAccountEmbeddedWalletWithID, type SmartWalletType as SmartWalletType, type LinkedAccountSmartWallet as LinkedAccountSmartWallet, type UsersCursor as UsersCursor, type UserCreateParams as UserCreateParams, type UserListParams as UserListParams, type UserGetByCustomAuthIDParams as UserGetByCustomAuthIDParams, type UserGetByDiscordUsernameParams as UserGetByDiscordUsernameParams, type UserGetByEmailAddressParams as UserGetByEmailAddressParams, type UserGetByFarcasterIDParams as UserGetByFarcasterIDParams, type UserGetByGitHubUsernameParams as UserGetByGitHubUsernameParams, type UserGetByPhoneNumberParams as UserGetByPhoneNumberParams, type UserGetBySmartWalletAddressParams as UserGetBySmartWalletAddressParams, type UserGetByTelegramUserIDParams as UserGetByTelegramUserIDParams, type UserGetByTelegramUsernameParams as UserGetByTelegramUsernameParams, type UserGetByTwitterSubjectParams as UserGetByTwitterSubjectParams, type UserGetByTwitterUsernameParams as UserGetByTwitterUsernameParams, type UserGetByWalletAddressParams as UserGetByWalletAddressParams, type UserPregenerateWalletsParams as UserPregenerateWalletsParams, type UserSearchParams as UserSearchParams, type UserSetCustomMetadataParams as UserSetCustomMetadataParams, type UserUnlinkLinkedAccountParams as UserUnlinkLinkedAccountParams, };
}
//# sourceMappingURL=users.d.mts.map