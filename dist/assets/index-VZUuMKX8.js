function d(e){const t=new Uint8Array(e);let n="";for(const r of t)n+=String.fromCharCode(r);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function R(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,a=t.padEnd(t.length+n,"="),r=atob(a),o=new ArrayBuffer(r.length),l=new Uint8Array(o);for(let s=0;s<r.length;s++)l[s]=r.charCodeAt(s);return o}function w(){return I.stubThis((globalThis==null?void 0:globalThis.PublicKeyCredential)!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const I={stubThis:e=>e};function y(e){const{id:t}=e;return{...e,id:R(t),transports:e.transports}}function O(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class i extends Error{constructor({message:t,code:n,cause:a,name:r}){super(t,{cause:a}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=r??a.name,this.code=n}}function T({error:e,options:t}){var a,r,o;const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((a=n.authenticatorSelection)==null?void 0:a.requireResidentKey)===!0)return new i({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&((r=n.authenticatorSelection)==null?void 0:r.userVerification)==="required")return new i({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(((o=n.authenticatorSelection)==null?void 0:o.userVerification)==="required")return new i({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new i({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(s=>s.type==="public-key").length===0?new i({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new i({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const l=globalThis.location.hostname;if(O(l)){if(n.rp.id!==l)return new i({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new i({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class P{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const _=new P,C=["cross-platform","platform"];function S(e){if(e&&!(C.indexOf(e)<0))return e}async function v(e){var p;!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:n=!1}=e;if(!w())throw new Error("WebAuthn is not supported in this browser");const a={...t,challenge:R(t.challenge),user:{...t.user,id:R(t.user.id)},excludeCredentials:(p=t.excludeCredentials)==null?void 0:p.map(y)},r={};n&&(r.mediation="conditional"),r.publicKey=a,r.signal=_.createNewAbortSignal();let o;try{o=await navigator.credentials.create(r)}catch(c){throw T({error:c,options:r})}if(!o)throw new Error("Registration was not completed");const{id:l,rawId:s,response:u,type:A}=o;let h;typeof u.getTransports=="function"&&(h=u.getTransports());let g;if(typeof u.getPublicKeyAlgorithm=="function")try{g=u.getPublicKeyAlgorithm()}catch(c){E("getPublicKeyAlgorithm()",c)}let f;if(typeof u.getPublicKey=="function")try{const c=u.getPublicKey();c!==null&&(f=d(c))}catch(c){E("getPublicKey()",c)}let b;if(typeof u.getAuthenticatorData=="function")try{b=d(u.getAuthenticatorData())}catch(c){E("getAuthenticatorData()",c)}return{id:l,rawId:d(s),response:{attestationObject:d(u.attestationObject),clientDataJSON:d(u.clientDataJSON),transports:h,publicKeyAlgorithm:g,publicKey:f,authenticatorData:b},type:A,clientExtensionResults:o.getClientExtensionResults(),authenticatorAttachment:S(o.authenticatorAttachment)}}function E(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function N(){if(!w())return m.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return(e==null?void 0:e.isConditionalMediationAvailable)===void 0?m.stubThis(new Promise(t=>t(!1))):m.stubThis(e.isConditionalMediationAvailable())}const m={stubThis:e=>e};function D({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const a=globalThis.location.hostname;if(O(a)){if(n.rpId!==a)return new i({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function K(e){var b,p;!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:n=!1,verifyBrowserAutofillInput:a=!0}=e;if(!w())throw new Error("WebAuthn is not supported in this browser");let r;((b=t.allowCredentials)==null?void 0:b.length)!==0&&(r=(p=t.allowCredentials)==null?void 0:p.map(y));const o={...t,challenge:R(t.challenge),allowCredentials:r},l={};if(n){if(!await N())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&a)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');l.mediation="conditional",o.allowCredentials=[]}l.publicKey=o,l.signal=_.createNewAbortSignal();let s;try{s=await navigator.credentials.get(l)}catch(c){throw D({error:c,options:l})}if(!s)throw new Error("Authentication was not completed");const{id:u,rawId:A,response:h,type:g}=s;let f;return h.userHandle&&(f=d(h.userHandle)),{id:u,rawId:d(A),response:{authenticatorData:d(h.authenticatorData),clientDataJSON:d(h.clientDataJSON),signature:d(h.signature),userHandle:f},type:g,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:S(s.authenticatorAttachment)}}function U(){return w()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}export{_ as WebAuthnAbortService,i as WebAuthnError,m as _browserSupportsWebAuthnAutofillInternals,I as _browserSupportsWebAuthnInternals,R as base64URLStringToBuffer,w as browserSupportsWebAuthn,N as browserSupportsWebAuthnAutofill,d as bufferToBase64URLString,U as platformAuthenticatorIsAvailable,K as startAuthentication,v as startRegistration};
