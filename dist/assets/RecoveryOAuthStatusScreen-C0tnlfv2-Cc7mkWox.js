import{dA as Y,d5 as G,d7 as X,d8 as ue,df as c,db as E,dX as q,dZ as he,d9 as _,dL as pe,dw as ve,d4 as i,ei as we,em as ye,en as me,eo as fe,ep as _e,eq as Ee,er as ae,es as Ae}from"./index-BZUZJG0z.js";import{T as ge,m as Q,b as Ce}from"./ModalHeader-D5psNgrf-BlEKM6aB.js";import{o as J}from"./ScreenHeader-CHmc4-Lu-D968ig42.js";import{t as Re}from"./use-create-wallet-without-fallback-BLN3_KXw-CjXTjOU0.js";import{d as Te,e as be,o as Z}from"./styles-BsotlekN-BRoDfy88.js";async function ee({url:v,popup:s,provider:w}){return s.location=v,new Promise(((o,n)=>{function l(){s==null||s.close(),window.removeEventListener("message",u)}function u(a){a.data&&(a.data.type==="PRIVY_OAUTH_RESPONSE"&&a.data.stateCode&&a.data.authorizationCode&&(o(a.data),l()),a.origin==="https://cdn.apple-cloudkit.com"&&a.data.ckSession&&(o({type:"PRIVY_OAUTH_RESPONSE",ckWebAuthToken:a.data.ckSession}),l()),a.data.type==="PRIVY_OAUTH_ERROR"&&(n(a.data.error),l()))}window.addEventListener("message",u)}))}async function xe({api:v,provider:s,stateCode:w,codeVerifier:o,authorizationCode:n}){if(!n||!w)throw new c("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if(n==="undefined")throw new c("User denied confirmation during OAuth flow");try{return(await v.post(Ae,{authorization_code:n,state_code:w,code_verifier:o,provider:s})).access_token}catch(l){let u=ae(l);throw u.privyErrorCode?new c(u.message||"Invalid code during OAuth flow.",void 0,u.privyErrorCode):u.message==="User denied confirmation during OAuth flow"?new c("Invalid code during oauth flow.",void 0,E.OAUTH_USER_DENIED):new c("Invalid code during OAuth flow.",void 0,E.UNKNOWN_AUTH_ERROR)}}async function te({api:v,provider:s}){let w=ye(),o=me(),n=await fe(w);try{return s==="icloud"?{url:(await v.post(_e,{client_type:"web"})).url}:{url:(await v.post(Ee,{redirect_to:window.location.href,code_challenge:n,state_code:o})).url,codeVerifier:w,stateCode:o,provider:s}}catch(l){throw ae(l)}}let re={"google-drive":{name:"Google Drive",component:be},icloud:{name:"iCloud",component:Te}};const Ie={component:()=>{var P;let{logout:v}=Y(),{navigate:s,setModalData:w,data:o}=G(),{closePrivyModal:n,createAnalyticsEvent:l}=X(),{execute:u}=(()=>{let{client:t,walletProxy:y,refreshSessionAndUser:N}=X(),{data:h}=G(),{user:g}=Y(),C=ue(),{create:b}=Re();return{execute:async({provider:r,action:le,popup:V,shouldCreateEth:L,shouldCreateSol:F})=>{var B,z;let R,m;if(!t)throw new c("Missing client");function H(e){if(!e&&t)throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:r}}),new c("Recovery OAuth failed")}switch(r){case"google-drive":{let e,p,{url:x,codeVerifier:O,stateCode:K}=await te({api:t.api,provider:r});H(x);try{let S=await ee({url:x,popup:V,provider:r});if(e=S.stateCode,p=S.authorizationCode,e!==K)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:K??"",returnedStateCode:e??""}}),new c("Unexpected auth flow. This may be a phishing attempt.",void 0,E.OAUTH_UNEXPECTED)}catch(S){throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:S.toString(),provider:r}}),new c("Recovery OAuth failed")}[R,m]=await Promise.all([t.getAccessToken(),xe({api:t.api,provider:r,codeVerifier:O,stateCode:e,authorizationCode:p})]);break}case"icloud":{let{url:e}=await te({api:t.api,provider:r});H(e);let{ckWebAuthToken:p}=await ee({url:e,popup:V,provider:r});m=p,R=await t.getAccessToken()}}if(!y)throw new c("Cannot connect to wallet proxy");if(!R)throw new c("Unable to authorize user");switch(le){case"recover":{let e=(B=h==null?void 0:h.recoverWallet)==null?void 0:B.entropyId,p=(z=h==null?void 0:h.recoverWallet)==null?void 0:z.entropyIdVerifier;if(!e||!p)throw new c("Recovery OAuth failed");t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:e,recoveryMethod:r}}),await y.recover({accessToken:R,entropyId:e,entropyIdVerifier:p,recoveryAccessToken:m}),t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:e,recoveryMethod:r}});break}case"create-wallet":{let e;if(t.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),L&&F)e=await b({recoveryMethod:r,recoveryAccessToken:m,chainType:"ethereum",walletIndex:0,latestUser:g}),e=await b({chainType:"solana",walletIndex:0,latestUser:e.user});else if(F)e=await b({recoveryMethod:r,recoveryAccessToken:m,chainType:"solana",walletIndex:0,latestUser:g});else{if(!L)throw Error("Invalid args to create wallet");e=await b({recoveryMethod:r,recoveryAccessToken:m,chainType:"ethereum",walletIndex:0,latestUser:g})}if(!e)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:e.account.address}}),C("createWallet","onSuccess",{wallet:e.account});break}case"set-recovery":{let e=q(g);if(!e)throw C("setWalletRecovery","onError",E.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}});let{entropyId:p,entropyIdVerifier:x}=he(g);await y.setRecovery({accessToken:R,entropyId:p,entropyIdVerifier:x,recoveryMethod:r,recoveryAccessToken:m});let O=q(await N());if(!O)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}}),C("setWalletRecovery","onSuccess",{method:r,wallet:O});break}default:throw new c("Unsupported recovery action")}}}})(),[a,U]=_.useState(!1),{provider:A,action:f,isInAccountCreateFlow:I,shouldCreateEth:oe,shouldCreateSol:ie}=o==null?void 0:o.recoveryOAuthStatus,[d,M]=_.useState(void 0),[ce,se]=_.useState(f==="create-wallet");if(A==="user-passcode")throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");let W=re[A].name,$=re[A].component,D=(P=o==null?void 0:o.recoverWallet)==null?void 0:P.onCompleteNavigateTo,k=new pe((async(t="create-wallet")=>(se(!0),new Promise(((y,N)=>{setTimeout((async()=>{try{let h=window.open();await u({provider:A,action:t,popup:h,shouldCreateEth:oe,shouldCreateSol:ie}),U(!0),y()}catch{M({message:`${t==="recover"?"Recovery":"Back up"} with ${W} unsuccessful`,detail:f==="recover"?`Please verify that you are selecting the ${W} account associated with your backup.`:"",retryable:!0}),N()}}),0)})))));_.useEffect((()=>{f!=="recover"&&k.execute(I?"create-wallet":"set-recovery")}),[]),_.useEffect((()=>{if(!a)return;let t=setTimeout((()=>{I?(w({createWallet:{onSuccess:()=>{},onFailure:y=>{l({eventName:"embedded_wallet_creation_failure_logout",payload:{error:y,screen:"RecoveryOAuthScreen"}}),v()},callAuthOnSuccessOnClose:!0,shouldCreateEth:!1,shouldCreateSol:!1}}),s("EmbeddedWalletCreatedScreen")):n({shouldCallAuthOnSuccess:!1})}),ve);return()=>clearTimeout(t)}),[a]);let j=_.useCallback((async()=>{await k.execute("recover"),D?s(D):U(!0)}),[]),T=A==="google-drive"?"Google Drive":"Apple iCloud",de=a&&`Successfully ${f==="recover"?"recovered":"backed up"} with ${T}.`||d&&d.message||`${f==="recover"?"Recovering":"Backing up"} with ${T}...`,ne=d?d.detail:"";return i.jsxs(i.Fragment,{children:[i.jsx(ge,{}),ce?i.jsx(i.Fragment,{children:i.jsxs(Z,{children:[i.jsx(J,{title:de,icon:i.jsx($,{style:{width:"38px",height:"38px"}}),description:ne}),d&&(d!=null&&d.retryable)?i.jsx(Q,{onClick:()=>{we(),M(void 0),f==="create-wallet"?k.execute("create-wallet"):j()},disabled:!a&&!(d!=null&&d.retryable),children:"Try again"}):null]})}):i.jsxs(Z,{children:[i.jsx(J,{title:"Confirm it's really you",icon:i.jsx($,{style:{height:42,width:48}}),description:`To confirm your identity, please log in to ${T} where your account is backed up.`}),i.jsxs(Q,{onClick:j,children:["Confirm with ",T]})]}),i.jsx(Ce,{})]})}};export{Ie as RecoveryOAuthScreen,Ie as default};
