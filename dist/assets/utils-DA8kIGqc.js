import{a as h,h as y,D as B}from"./index-CNyPs5_N.js";/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function w(t){if(t.length%2!=0)throw new Error("Hex string length must be multiple of 2");const e=new Uint8Array(t.length/2);for(let n=0;n<t.length;n+=2)e[n/2]=parseInt(t.substring(n,n+2),16);return e}function b(t){let e="";for(let n=0;n<t.length;n++){const r=t[n].toString(16);e+=r.length>1?r:"0"+r}return e}function c(t,e){return btoa(m(t)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function m(t){let e="";for(let n=0;n<t.length;n+=1)e+=String.fromCharCode(t[n]);return e}/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts
 * - The implementation of integerToByteArray has been modified to augment the resulting byte array to a certain length.
 * - The implementation of PointDecode has been modified to decode both compressed and uncompressed points by checking for correct format
 * - Method isP256CurvePoint added to check whether an uncompressed point is valid
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function l(){return BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951")}function d(){return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b")}function a(t){return BigInt("0x"+b(t))}function u(t,e){const n=t.toString(16),r=e*2;let o="";if(r<n.length)throw new Error(`cannot pack integer with ${n.length} hex chars into ${e} bytes`);return o="0".repeat(r-n.length),w(o+n)}function g(t,e){const n=BigInt(1)<<BigInt(e);return(t&n)!==BigInt(0)}function I(t,e,n){if(e===BigInt(0))return BigInt(1);let r=t;const o=e.toString(2);for(let i=1;i<o.length;++i)r=r*r%n,o[i]==="1"&&(r=r*t%n);return r}function p(t,e){if(e<=BigInt(0))throw new Error("p must be positive");const n=t%e;if(g(e,0)&&g(e,1)){const r=e+BigInt(1)>>BigInt(2),o=I(n,r,e);if(o*o%e!==n)throw new Error("could not find a modular square root");return o}throw new Error("unsupported modulus value")}function E(t,e){const n=l(),r=n-BigInt(3),o=d(),i=((t*t+r)*t+o)%n;let s=p(i,n);return e!==g(s,0)&&(s=(n-s)%n),s}function x(t,e){const n=l(),r=n-BigInt(3),o=d(),i=((t*t+r)*t+o)%n;return e**BigInt(2)%n===i}function v(t){const e=S(),n=e+1,r=2*e+1;if(t.length!==n&&t.length!==r)throw new Error("Invalid length: point is not in compressed or uncompressed format");if((t[0]===2||t[0]===3)&&t.length==n){const o=t[0]===3,i=a(t.subarray(1,t.length)),s=l();if(i<BigInt(0)||i>=s)throw new Error("x is out of range");const f=E(i,o);return{kty:"EC",crv:"P-256",x:c(u(i,32)),y:c(u(f,32)),ext:!0}}else if(t[0]===4&&t.length==r){const o=a(t.subarray(1,e+1)),i=a(t.subarray(e+1,2*e+1)),s=l();if(o<BigInt(0)||o>=s||i<BigInt(0)||i>=s||!x(o,i))throw new Error("invalid uncompressed x and y coordinates");return{kty:"EC",crv:"P-256",x:c(u(o,32)),y:c(u(i,32)),ext:!0}}throw new Error("invalid format")}function S(){return 32}function H(t){const{uncompressedPrivateKeyHex:e,compressedPublicKeyHex:n}=t;let r;try{r=v(h(n))}catch{throw new Error("unable to load API key: invalid public key. Did you switch your public and private key by accident? Is your public key a valid, compressed P-256 public key?")}return r.d=y(e,B),r}export{H as c};
